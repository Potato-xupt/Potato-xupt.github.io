<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Potato Blog</title>
  
  <subtitle>李土豆的Blog</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-09-30T13:23:19.072Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Potato</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>查询性能优化</title>
    <link href="http://yoursite.com/posts/39035/"/>
    <id>http://yoursite.com/posts/39035/</id>
    <published>2019-09-26T13:10:55.000Z</published>
    <updated>2019-09-30T13:23:19.072Z</updated>
    
    <content type="html"><![CDATA[<h1 id="为什么查询速度会慢"><a href="#为什么查询速度会慢" class="headerlink" title="为什么查询速度会慢"></a>为什么查询速度会慢</h1><p>在尝试编写快速的查询之前，需要清楚的一点就是，真正重要的是响应时间。如果把查询看作是一个任务，那么它由一系列子任务组成，每个字任务都会消耗一定的时间。如果要优化查询，实际上要优化其子任务，要么消除其中一些子任务，要么减少子任务的执行次数，要么让子任务运行的更快。</p><p>通常来说，<strong>查询的生命周期大致可按照顺序来看：从客户端，到服务器，然后在服务器上进行解析，生成执行计划，执行，并返回结果给客户端。</strong>其中“执行”可以认为是整个生命周期中最重要的阶段，这其中包括了大量为了检索数据到存储引擎的调用以及调用后的数据处理，包括排序、分组等。 对于一个查询的全部生命周期，上面列的并不完整，这里只是想说明，了解查询的生命周期，清楚查询的时间消耗情况对于优化查询有很大的意义。</p><h1 id="慢查询基础：优化数据访问"><a href="#慢查询基础：优化数据访问" class="headerlink" title="慢查询基础：优化数据访问"></a>慢查询基础：优化数据访问</h1><p>查询性能低下最基本的原因是访问的数据太多，大部分性能低下的查询都可以通过减少访问的数据量的方式进行优化。对于低效的查询，通过下面两个步骤来分析总是很有效的：</p><ul><li>确认应用程序是否在检索大量超过需要的数据。这通常意味着访问了太多的行，但有时候也有可能是访问了太多的列。</li><li>确认MySQL服务器是否在分析大量超过需要的数据行。</li></ul><h2 id="是否向数据库请求了不需要的数据"><a href="#是否向数据库请求了不需要的数据" class="headerlink" title="是否向数据库请求了不需要的数据"></a>是否向数据库请求了不需要的数据</h2><p>有些查询会请求超过实际需要的数据，然后这些多余的数据会被应用程序丢弃，这会给MySQL服务器带来额外的负担，并增加网络开销，另外也会消耗应用服务器的CPU和内存资源。下面是一些典型的案例：</p><ul><li><strong>查询不需要的记录：</strong>一个常见的错误是常常会误以为MySQL会只返回需要的数据，实际上MySQL确实先返回全部结果集再进行计算。最简单有效的解决方法就是在这样的查询后面加上LIMIT。</li><li><strong>多表关联时返回全部列：</strong>例如你想查询所有在电影Academy Dinosaur中出现的演员，千万不要下面这种写法编写查询：<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> actor</span><br><span class="line"><span class="keyword">INNER</span> <span class="keyword">JOIN</span> film_actor <span class="keyword">USING</span>(actor_id)</span><br><span class="line"><span class="keyword">INNER</span> <span class="keyword">JOIN</span> film <span class="keyword">USING</span>(film_id)</span><br><span class="line"><span class="keyword">WHERE</span> fime.title = <span class="string">'Academy Dinosaur'</span>;</span><br></pre></td></tr></table></figure></li></ul><p><strong>这将返回这三个表的全部数据列。</strong>正确的方式应该是像下面这样只取需要的列：<code>SELECT actor.* FROM actor...</code>。</p><ul><li><strong>总是取出全部列：</strong>每次看到SELECT * 的时候都需要用怀疑的眼光审视，是不是真的需要返回全部的列？这无疑会增加额外的消耗。但是如果这种有点浪费数据库资源的方式可以简化开发，因为提高相同代码片段的复用性，如果清楚这样做的性能影响，那么这种做法也是值得考虑的。如果应用程序使用了某种缓存机制也可以，获取并缓存所有的列的查询，相比多个独立的只获取部分列的查询可能就更有好处。</li><li><strong>重复查询相同的数据：</strong>如果不断地重复执行相同的查询，然后每次都返回相同的数据，这样是完全没有必要的。比较好的方案是，当初次查询的时候将这个数据缓存起来，需要的时候从缓存中取出，这样的性能显然会更好。</li></ul><h2 id="MySQL是否在扫描额外的记录"><a href="#MySQL是否在扫描额外的记录" class="headerlink" title="MySQL是否在扫描额外的记录"></a>MySQL是否在扫描额外的记录</h2><p>在确定查询只返回需要的数据以后，接下来该看看查询为了返回结果是否扫描了过多的数据。对于MySQL，最简单的衡量查询开销的三个指标如下：</p><blockquote><ul><li>响应时间</li><li>扫描的行数</li><li>返回的行数</li></ul></blockquote><h3 id="响应时间"><a href="#响应时间" class="headerlink" title="响应时间"></a>响应时间</h3><p>响应时间只是一个表面上的值，但是响应时间仍然是最重要的指标。响应时间是两个部分之和：<strong>服务时间</strong>和<strong>排队时间</strong>。<strong>服务时间是指数据库处理这个查询真正花了多长时间；排队时间是指服务器因为等待某些资源而没有真正执行查询的时间，一般最常见和重要的是I/O等待和锁等待。</strong></p><p>当你看到一个查询的响应时间的时候，首先需要问问自己，这个响应时间是否是一个合理的值。实际上可以使用“快速上限估计”法来估算查询的响应时间，概括地说，了解这个查询需要哪些索引以及它的执行计划是什么，然后计算大概需要多少个顺序和随机I/O，再用其乘以在具体硬件条件下一次I/O的消耗时间，最后把这些消耗都加起来，就可以获得一个大概参考值来判断当前响应时间是不是一个合理的值。</p><h3 id="扫描的行数和返回的行数"><a href="#扫描的行数和返回的行数" class="headerlink" title="扫描的行数和返回的行数"></a>扫描的行数和返回的行数</h3><p>分析查询时，查看该查询扫描的行数是非常有效的，这在一定程度上能说明该查询找到需要的数据和效率高不高。并不是所有的行的访问代价都是相同的，较短的行的访问速度更快，内存中的行比磁盘中的行的访问速度要快得多。</p><p>理想情况下扫描的行数和返回的行数应该是相同的，但实际中这种情况并不多，扫描的行数对返回的行数的比率通常很小，一般在1：1和10：1之间，不过有时候这个值也可能非常大。</p><h3 id="扫描的行数和访问类型"><a href="#扫描的行数和访问类型" class="headerlink" title="扫描的行数和访问类型"></a>扫描的行数和访问类型</h3><p>在评估查询开销的时候，需要考虑一下从表中找到某一行数据的成本。MySQL的好几种访问类型，有些方式可能需要扫描很多行才能返回一行，也有些方式可能无需扫描就能返回结果。</p><p>在EXPLAIN语句中的type列反应了访问类型，访问类型有很多种，<strong>从全表扫描到索引扫描、范围扫描、唯一索引查询、常数索引等，这里列的这些，速度是从慢到快，扫描的行数也是从多到少的。</strong></p><p><strong>如果查询没有办法找到合适的访问类型，那么解决的最好办法通常就是增加一个合适的索引</strong>，索引让MySQL以最高效、扫描行数最少的访问找到需要的记录。</p><p>一般MySQL能够使用如下三种方式应用WHERE条件，<strong>从好到坏依次为</strong>：</p><ul><li><strong>在索引中使用WHERE条件来过滤不匹配的记录。这是在存储引擎层完成的。</strong></li><li><strong>使用索引覆盖扫描（在Extra中出现了Using index）来返回记录，</strong>直接从索引中过滤不需要的记录并返回命中的结果。这是在MySQL服务层完成的，但无须再回表查询记录。</li><li>从数据表中返回数据，然后过滤不满足条件的记录（在Extra列中出现Using Where）。这在MySQL服务器层完成，MySQL需要先从数据表读出记录然后过滤。</li></ul><p>好的索引很重要，可以让查询使用合适的访问类型，尽可能的只扫描需要的数据行，但也不是说增加索引就能让扫描的行数等于返回的行数。如果发现查询需要扫描大量的数据但只返回少数的行，那么通常可以尝试下面的技巧去优化：</p><ul><li><strong>使用索引覆盖扫描</strong>，把所有需要用的列都放到索引中，这样存储引擎就无须回表获取对应行就可以返回结果了。</li><li><strong>改变库表结构</strong>，例如使用单独的汇总表。</li><li><strong>重写这个复杂的查询</strong>，让MySQL优化器能以更优化的方式执行这个查询。</li></ul><h1 id="重构查询的方式"><a href="#重构查询的方式" class="headerlink" title="重构查询的方式"></a>重构查询的方式</h1><p>在优化有问题的查询时，目标应该是找到一个更优的方法获得实际需要的结果，而不一定总是需要从MySQL获取一模一样的结果集，有时可以将查询转换一种写法让其返回一样的结果，但是性能更好。</p><h2 id="一个复杂查询还是多个简单查询"><a href="#一个复杂查询还是多个简单查询" class="headerlink" title="一个复杂查询还是多个简单查询"></a>一个复杂查询还是多个简单查询</h2><p>在传统实现中，总是强调需要数据库层完成尽可能多的工作，这样做的逻辑在于以前总是认为网络通信、查询解析和优化时是一件代价很高的事情。但是这样的想法对于MySQL并不适用，MySQL从设计上让连接和断开连接都很轻量级，在返回一个小的查询结果方面很高效。</p><p>MySQL内部每秒能扫描内存中上百万行数据，相比之下，MySQL响应数据给客户端就慢得多了。在其他条件都相同的时候，使用尽可能少的查询当然是最好的。但是有时候将一个大查询分解为多个小查询是很有必要的。</p><h2 id="切分查询"><a href="#切分查询" class="headerlink" title="切分查询"></a>切分查询</h2><p>有时候对于一个大查询我们需要“分而治之”，将大查询切分成小查询，每个查询功能完全一样，只完成一小部分，每次只返回一小部分查询结果。</p><p>例如在删除旧的数据时，定期清除大量数据时，如果用一个大的语句一次性完成的话，则可能需要一次锁住很多数据，占满整个事务日志，耗尽系统资源、阻塞很多小的但是重要的查询。将一个大的DELETE语句切分成多个较小的查询可以尽可能小的影响MySQL性能，同时还可以减少MySQL复制的延迟。例如我们可以每次只删除一部分数据，每次删除数据后都暂停一会在做下一次删除，这样也<strong>可以将服务器上原本一次性的压力分散到一个很长的时间段中，就可以大大降低对服务器的影响，还可以大大减少删除时锁的持有时间。</strong></p><h2 id="分解关联查询"><a href="#分解关联查询" class="headerlink" title="分解关联查询"></a>分解关联查询</h2><p>很多高性能的应用都会对关联查询进行分解，简单地，可以对每一个表进行一次单表查询，然后将结果在应用程序中进行关联。例如下面这个查询：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> tag </span><br><span class="line"><span class="keyword">JOIN</span> tag_post <span class="keyword">ON</span> tag_post.tag_id = tag.id</span><br><span class="line"><span class="keyword">JOIN</span> post <span class="keyword">ON</span> tag_post.post_id = post.id</span><br><span class="line"><span class="keyword">WHERE</span> tag.tag = <span class="string">'mysql'</span>;</span><br></pre></td></tr></table></figure><p>可以分解成下面这些语句来代替：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> tag <span class="keyword">WHERE</span> tag = <span class="string">'mysql'</span>;</span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> tag_post <span class="keyword">WHERE</span> tag_id = <span class="number">1234</span>;</span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> post <span class="keyword">WHERE</span> post.id <span class="keyword">in</span>(<span class="number">123</span>,<span class="number">456</span>,<span class="number">567</span>,<span class="number">9098</span>,<span class="number">8904</span>);</span><br></pre></td></tr></table></figure><p>用分解关联查询有如下优势：</p><ul><li><strong>让缓存的效率更高。</strong>许多应用程序可以方便地缓存单表查询对应的结果对象，对MySQL的查询缓存来说，如果关联中的某个表发生了变化，那么就无法使用查询缓存了，而拆分后，如果某个表很少改变，那么基于该表的查询就可以重复利用查询缓存结果了。</li><li><strong>将查询分解后，执行单个查询可以减少锁的竞争。</strong></li><li><strong>在应用层做关联，可以更容易对数据库进行拆分，更容易做到高性能和可扩展。</strong></li><li><strong>查询本身效率也可能会有所提升</strong>，例如用IN()代替关联查询，可以让MySQL按照ID顺序进行查询，这可能比随机的关联更高效。</li><li><strong>可以减少冗余记录的查询。</strong>在应用层做关联查询，意味着对于某条记录应用只需要查询一次，而在数据库中做关联查询，则可能需要重复地访问一部分数据，所以这样的重构还可能会减少网络和内存的消耗。</li><li>更进一步，<strong>这样相对于在应用中实现了哈希关联，而不是使用MySQL的嵌套循环关联。</strong></li></ul><p>在很多场景下，通过重构查询将关联放在应用程序中将会更加高效，比如：当应用能够方便的缓存单个查询的结果的时候、当可以将数据分不到不同的MySQL服务器上的时候、当能够使用IN（）的方式代替关联查询的时候、当查询中使用同一个数据表的时候。</p><h1 id="查询执行的基础"><a href="#查询执行的基础" class="headerlink" title="查询执行的基础"></a>查询执行的基础</h1><p>下图可以看出当向MySQL发送一个请求的时候，MySQL到底做了些什么：<img src="/posts/39035/SQLRunProcess.png" alt></p><ol><li>客户端先发送一条查询给服务器。</li><li>服务器先检查缓存，<strong>如果命中缓存，则立刻返回存储在缓存中的结果。</strong>否则进入下一阶段。</li><li><strong>服务端进行SQL解析、预处理，再由优化器生成对应的执行计划。</strong></li><li><strong>MySQL根据优化器生成的执行计划，调用存储引擎的API来执行查询。</strong></li><li>将结果返回给客户端。</li></ol><h2 id="MySQL客户端-服务器通信协议"><a href="#MySQL客户端-服务器通信协议" class="headerlink" title="MySQL客户端/服务器通信协议"></a>MySQL客户端/服务器通信协议</h2><p>MySQL客户端和服务器之间的通信协议是<strong>半双工</strong>的，这意味着，在任何一个时刻，要么是由服务器向客户端发送数据，要么是由客户端向服务器发送数据，这两个动作不能同时发生。所以，<strong>无法也无需将一个消息切成小块独立来发送。</strong>这种协议虽然让MySQL通信简单快速，但是一个明显的限制就是<strong>没法进行流量控制</strong>，一旦一端开始发送消息，另一端要接收完整个消息才能响应它。即一旦客户端发送了请求，它能做的事情就只是等待结果了。</p><p>相反的，一般服务器相应给客户的数据很多，由多个数据包组成。当服务器开始响应客户端请求时，客户端必须完整地接收整个返回结果，而不能简单地只取几条结果。这也是在必要时侯一定要在查询中加上LIMIT限制的原因。</p><p>多数连接MySQL的库函数都可以获得全部结果集并缓存到内存里，还可以逐行获取需要的数据。默认一般是获得全部结果集并缓存到内存中。MySQL通常需要等所有的数据都已经发送给客户端才能释放这条查询所占用的资源，所以接受全部结果并缓存通常可以减少服务器的压力，早点释放相应的资源。</p><h3 id="查询状态"><a href="#查询状态" class="headerlink" title="查询状态"></a>查询状态</h3><p>对于一个MySQL连接，或者说一个线程，任何一个时刻都有一个状态，该状态标识了MySQL当前正在做什么。最简单的查看方式是使用SHOW FULL PROCESSLIST命令，在一个查询生命周期中的状态有这么几种：</p><ul><li><strong>Sleep</strong>：线程正在等待客户端发送新的请求。</li><li><strong>Query</strong>：线程正在执行查询或者正在将结果发送给客户端。</li><li><strong>Locked</strong>：在MySQL服务层，该线程正在等待表锁。<strong>在存储引擎级别实现的锁，例如InnoDB的行锁并不会体现在线程装态中。</strong>对于MyISAM来说这是一个比较典型的状态，但在其他没有行锁的引擎中也会经常出现。</li><li><strong>Analyzing and statistics</strong>：线程正在收集存储引擎的统计信息，并生成查询的执行计划。</li><li><strong>Copying to tmp table [on disk]</strong>：线程正在执行查询，并且将其结果集都复制到一个临时表中，<strong>这种状态一般要么是在做GROUP BY操作，要么是文件排序操作，或者UNION操作。</strong>如果这个状态后面还有“on disk”标记，那么表示MySQL正在将一个内存临时表放在磁盘上。</li><li><strong>Sorting result</strong>：线程正在对结果集进行排序。</li><li><strong>Sending data</strong>：这种情况下线程可能在多个状态之间传送数据，或者在生成结果集，或者在向客户端返回数据。</li></ul><h2 id="查询缓存"><a href="#查询缓存" class="headerlink" title="查询缓存"></a>查询缓存</h2><p><strong>在解析一个查询语句之前，如果查询缓存是打开的，那么MySQL会优先检查这个查询是否命中查询缓存的数据。这个查询时通过一个对大小写敏感的哈希查找实现的。</strong></p><p><strong>如果当前查询恰好命中查询缓存，那么在返回查询结果之前MySQL会检查一次用户权限。</strong>这仍然是无须解析查询SQL语句的。如果没有权限问题，MySQL会直接从缓存中拿到结果并返回给客户端。这总情况下，查询不会解析，不用生成执行计划，不会被执行。</p><h2 id="查询优化处理"><a href="#查询优化处理" class="headerlink" title="查询优化处理"></a>查询优化处理</h2><p><strong>查询的生命周期的下一步是将一个SQL转换成一个执行计划，MySQL再按照这个执行计划和存储引擎进行交互。这包括多个子阶段：解析SQL、预处理、优化SQL执行计划。这个过程中出现任何错误都可能终止查询。</strong></p><h3 id="语法解析器和预处理"><a href="#语法解析器和预处理" class="headerlink" title="语法解析器和预处理"></a>语法解析器和预处理</h3><p><strong>首先MySQL通过关键字将SQL语句进行解析，并生成一颗对应的“解析树”。MySQL解析器将使用MySQL语法规则验证和查询解析。</strong>例如验证是否使用错误的关键字，关键字顺序是否正确等。</p><p><strong>预处理器则根据一些MySQL规则进一步检查树是否合法。</strong>例如检查数据表和列是否存在、名字和别名是否有歧义等待。</p><p><strong>下一步预处理器会验证权限。</strong>这通常很快，除非服务器上有非常多的权限配置。</p><h3 id="查询优化器"><a href="#查询优化器" class="headerlink" title="查询优化器"></a>查询优化器</h3><p><strong>在语法树被验证合法以后，将由优化器将其转化成执行计划。一条查询可以有很多种执行方式，最后都返回相同的结果。优化器的作用就是找到这其中最好的执行计划。</strong></p><p><strong>MySQL使用基于成本的优化器，它将尝试预测一个查询使用某种执行计划时的成本，并选择其中成本最小的一个。</strong>当然优化器并不能完全保证所选择的执行计划是最优的，有很多种原因会导致MySQL优化器选择错误的执行计划：</p><ul><li><strong>统计信息不准确。</strong>MySQL依赖存储引擎提供的统计信息来评估成本，但有的存储引擎提供的信息是不准确的，例如<strong>InnoBD因为其MVCC的架构，并不能维护一个数据表的精确统计信息。</strong></li><li><strong>执行计划的成本估算不等同于实际执行的成本。</strong>例如MySQL层面并不知道哪些页面在内存中，哪些在磁盘上，所以执行的I/O时间也无从得知。<strong>所以我们看到的执行成本来选择执行计划并不是完美的模型。</strong></li><li><strong>MySQL从不考虑其他并发执行的查询。</strong></li><li><strong>MySQL也并不完全是基于成本的优化，优势也会基于一些固定的规则。</strong>例如，如果存在MATCH()子句，则在全文索引的时候就使用全文索引。即使有时候使用别的索引和WHERE条件可以远比这种方式要快。</li><li><strong>MySQL不会考虑不受其控制的操作的成本。</strong>例如执行存储过程或用户自定义函数的成本。</li><li><strong>优化器有时候无法去估算所有可能的执行计划，</strong>所以可能错过实际上最优的执行计划。</li></ul><p>MySQL的查询优化器使用了很多优化策略生成一个最优的执行计划。优化策略可以简单的分为两种：<strong>静态优化和动态优化。</strong></p><blockquote><ul><li><strong>静态优化可以直接对解析树进行分析，并完成优化。</strong>例如优化器可以通过一些简单的代数变换将WHERE条件转换成另一种等价形式。静态优化不依赖于特别的数值，如WHERE条件中带入的一些常数等。<strong>静态优化在第一次完成之后一直有效，</strong>即使使用了不同的参数重复查询也不会发生变化，可以认为这是一种“编译时优化”。</li><li><strong>动态优化和查询的上下文有关，也可能和很多其他因素有关。</strong>例如WHERE条件的中的取值、索引中条目对应的数据行数等。这<strong>需要在每次查询的时候都重新评估</strong>，可以认为这是“运行时优化”。</li></ul></blockquote><p>MySQL对查询的静态优化只需要做一次，但对查询的动态优化规则在每次运行时都需要重新评估，有时甚至在查询的执行过程中也会重新优化。</p><p>下面是一些MySQL能够处理的优化类型：</p><ul><li><strong>重新定义关联表的顺序：**</strong>数据表的关联并不总是按照在查询中指定的顺序进行。**决定关联的顺序是优化器很重要的一部分功能。</li><li><strong>将外连接转化成内连接：</strong>并不是所有的OUTER JOIN语句都必须以外连接的方式执行。例如WHERE条件、库表结构都可能会让外连接等价于一个内连接，MySQL可以自动识别这一点并重写查询，让其调整关联顺序。</li><li><strong>使用等价变换规则：**</strong>MySQL可以使用一些等价变换来简化并规范表达式。**它可以合并和减少一些比较，还可以移除一些恒成立和一些恒不成立的判断。</li><li><strong>优化COUNT(*)、MIN()和MAX()：</strong>索引和列是否可为空通常可以帮助MySQL优化这类表达式。例如，<strong>要找到某一列的最小值，只需要查询对应的B-Tree索引最左端的记录，MySQL可以直接获取索引的第一行记录。</strong>如果MySQL使用了这种类型的优化，那么在EXPLAIN中就可以看到“Select tables optimized away”，从字面意思可以看出来，他表示优化器已经从执行计划中移除了该表，并以一个常数代替。</li><li><strong>预估并转化为常数表达式：**</strong>当MySQL检测到一个表达式可以转化为常数的时候，就会一直把该表达式作为常数进行优化处理。**</li><li><strong>索引覆盖扫描：</strong>当索引中的列包含所有查询中需要使用的列的时候，MySQL就可以使用索引返回需要的数据，而无需查询对应的数据行。</li><li><strong>子查询优化：</strong>MySQL在某些情况下可以将子查询转换一种效率更高的形式，从而减少多个查询多次对数据进行访问。</li><li><strong>提前终止查询：**</strong>在发现已经满足查询需求的时候，MySQL总是能够立刻终止查询。**例如当使用了LIMIT的时候、发现了一个不成立的条件等。</li><li><strong>等值传播：</strong>如果两个列的值通过等式关联，那么MySQL能够把其中一个列的WHERE条件传递到另一个列上。</li><li><strong>列表IN()的比较：</strong>在很多数据库系统中，IN()完全等同于多个OR条件的子句，因为这二者完全等价。但是在MySQL中这点是不成立的，<strong>MySQL将IN()列表中的数据先进行排序，然后通过二分查找的方式来确定列表中的值是否满足条件，这是一个O(log n)复杂度的操作</strong>，等价的变换成OR查询的复杂度为O(n)，对IN()列表中有大量取值的时候，MySQL的处理将会更快。</li></ul><h3 id="数据和索引的统计信息"><a href="#数据和索引的统计信息" class="headerlink" title="数据和索引的统计信息"></a>数据和索引的统计信息</h3><p><strong>MySQL服务层没有任何统计信息，所以MySQL查询优化器在生成查询的计划时，需要向存储引擎获取相应的统计信息。存储引擎则提供给优化器对应的统计信息，</strong>包括：每个表或者索引有多少个页面、每个表的每个索引的基数是多少、数据行和索引长度、索引的分布信息等。优化器根据这些信息来选择一个最优的执行计划。</p><h3 id="MySQL如何执行关联查询"><a href="#MySQL如何执行关联查询" class="headerlink" title="MySQL如何执行关联查询"></a>MySQL如何执行关联查询</h3><p>MySQL认为任何一个查询都是一次“关联”，并不仅仅是一个查询需要到两个表匹配才叫关联，所以在MySQL中，每一次查询，每一个片段都可能是关联。</p><p>举一个UNION查询的例子，<strong>对于UNION查询，MySQL先将一系列的单个查询结果放在一个临时表中，然后再重新读出临时表数据来完成UNION查询，所以读取结果临时也是一次关联。</strong></p><p>当前MySQL关联执行的策略很简单：<strong>MySQL对任何关联都执行嵌套循环关联操作，即MySQL先在一个表中循环取出单条数据，然后再嵌套循环到下一个表中寻找匹配的行，依次下去，直到找到所有表中匹配的行为止。然后根据各个表匹配的行，返回查询中需要的各个列。MySQL会先尝试在最后一个关联表中找到所有匹配的行，如果最后一个关联表无法找到更多的行以后，MySQL返回到上一层关联表，看是否能找到更多的匹配记录，依次类推迭代执行。</strong></p><p>从本质上来说，MySQL对所有的类型的查询都以同样的方式运行。例如，MySQL在FROM子句中遇到子查询时，先执行子查询并将其结果放在一个临时表中，然后将这个临时表当作一个普通表对待（正如其名“派生表”）。MySQL在执行UNION查询时也是用类似的临时表。<strong>在遇到右外连接的时候，MySQL将其改写成等价的左外连接。</strong>但是全外连接无法通过嵌套循环和回溯的方式完成，这大概也是MySQL并不支持全外连接的原因。</p><h3 id="执行计划"><a href="#执行计划" class="headerlink" title="执行计划"></a>执行计划</h3><p>和很多其他关系数据库不同，MySQL并不会生成查询字节码来执行查询，<strong>MySQL生成查询一棵指令树，然后通过存储引擎执行完成这棵指令树并返回结果。</strong>MySQL总是从一个表开始一直嵌套循环、回溯完成所有表关联。所以MySQL的执行计划总是如下图所示，是一棵左侧深度优先的树：<img src="/posts/39035/findTree.png" alt></p><h3 id="关联查询优化器"><a href="#关联查询优化器" class="headerlink" title="关联查询优化器"></a>关联查询优化器</h3><p>MySQL优化器最重要的一部分就是关联查询优化，他决定了多个表关联时的顺序。通常多表关联的时候，可以有多种不同的关联顺序来获得相同的执行顺序，关联查询优化器则通过评估不同顺序时的成本来选择一个代价最小的关联顺序。</p><p>关联优化器会尝试再所有的关联顺序中选择一个成本最小的来生成执行计划，<strong>尽量保证每次关联查询后，能排除掉更多的无用数据。</strong>如果可能，优化器会遍历每一个表然后逐个做嵌套循环计算每一棵可能的执行计划树的成本，最后返回一个最优的执行计划。</p><p>不过糟糕的是，如果有超过n个表的关联，那么需要检查n的阶乘种关联计划。我们称之为所有可能的执行计划的“搜索空间”，搜索空间的增长速度非常快，例如若10个表的关联，那么共有3628800种不同的关联顺序。</p><h3 id="排序优化"><a href="#排序优化" class="headerlink" title="排序优化"></a>排序优化</h3><p><strong>无论如何排序都是一个成本很高的操作，所以从性能考虑，应尽可能避免排序或者尽可能对大量数据进行排序。</strong></p><p>当不能使用索引生成排序结果的时候，MySQL需要自己进行排序，<strong>如果数据量小则在内存中进行，如果数据量大则需要使用磁盘，不过MySQL将这个过程统一称为文件排序（filesort）。</strong></p><p><strong>如果需要排序的数据量小于“排序缓冲区”，MySQL使用内存进行“快速排序”操作。如果内存不够排序，那么MySQL会先将数据分块，对每个独立的块使用“快速排序”进行排序，并将各个块的排序结果存放在磁盘上，然后将各个排好序的块进行合并，最后返回排序结果。</strong></p><p>MySQL有两种排序算法：</p><blockquote><ul><li><strong>两次传输排序（旧版本使用）：**</strong>读取行指针和需要排序的字段，对其进行排序，然后再根据排序结果读取所需要的数据行。** <strong>这需要进行两次数据传输</strong>，即需要从数据表中读取两次数据，第二次读取数据的时候，因为是读取排序列进行排序后的所有记录，这<strong>会产生大量的随机I/O，所以两次数据传输的成本非常高。</strong></li><li><strong>单次传输排序（新版本使用）：**</strong>先读取所需要的所有列，然后再根据给定列进行排序，最后直接返回排序结果。<strong>因为不需要从数据表中读取两次数据，</strong>对于I/O密集型的应用，这样做的效率高了很多。<strong>但是</strong>缺点是如果需要返回的列非常多、非常大，会额外占用大量的空间，**而这些列对排序操作本身来说是没有任何作用的。</li></ul></blockquote><p><strong>MySQL在进行文件排序的时候需要使用的临时存储空间可能会比想象的要大很多，原因在于MySQL在排序时，对每一个排序记录都会分配一个足够长的定长空间来存放。这个定长空间必须足够长以容纳其中最长的字符串，</strong>如果使用UTF-8字符集，那么MySQL将会为每个字符预留三个字节。因此排序消耗的临时空间可能会比磁盘上的原表要大很多倍。</p><p>在关联查询的时候如果需要排序，MySQL会分两种情况来处理这样的文件排序。<strong>如ORDER BY子句中所有的列都来自关联的第一个表，那么MySQL在关联处理第一个表的时候就进行文件排序，</strong>这种情况MySQL在EXPLAIN结果中的Extra字段会有“Using filesort”。<strong>除此之外所有情况，MySQL都会先将关联的结果存放到一个临时表中，然后在所有的关联都结束后，再进行文件排序，</strong>这种情况MySQL在EXPLAIN结果中的Extra字段会有“Using temporary；Using filesort”。<strong>如果查询中有LIMIT的话，LIMIT也会在排序之后应用。</strong></p><p>MySQL5.6后，当只需要返回部分排序结果的时候，例如使用了LIMIT子句，MySQL不再对所有的结果进行排序，而是根据实际情况，选择抛弃不满足条件的结果，然后再进行排序。</p><h2 id="查询执行引擎"><a href="#查询执行引擎" class="headerlink" title="查询执行引擎"></a>查询执行引擎</h2><p>在解析和优化阶段，MySQL将生成查询对应的执行计划，MySQL的查询执行引擎则根据这个执行计划来完成整个查询。这里执行计划是一个数据结构，而不是和很多其他关系型数据库那样会生成对应的字节码。</p><p><strong>MySQL只是简单的根据执行计划给出的指令逐行执行，在根据执行计划逐步执行的过程中，有大量的操作需要通过调用存储引擎实现的接口来完成。</strong></p><h2 id="返回结果给客户端"><a href="#返回结果给客户端" class="headerlink" title="返回结果给客户端"></a>返回结果给客户端</h2><p>查询执行的最后一个阶段是将结果返回给客户端。即使查询不需要返回结果集给客户端，MySQL仍然会返回这个查询的一些信息，如该查询影响到的行数。</p><p><strong>如果查询可以被缓存，那么MySQL在这个阶段也会将结果存放到查询缓存中。</strong></p><p>MySQL将结果集返回给客户端是一个增量、逐步返回的过程，<strong>一旦服务器处理完最后一个关联表，开始生成第一条结果时，MySQL就可以开始向客户端逐步返回结果集了。</strong></p><p><strong>这样处理有两个好处：服务器无须存储太多的结果，也就不会因为要返回太多的结果而消耗太多内存。另外这样的处理也让MySQL客户端第一时间获得返回的结果。</strong></p>]]></content>
    
    <summary type="html">
    
      如何设计最优的库表结构、如何建立最好的索引，这些对于高性能来说是必不可少的东西。但是这些还不够，还需要合理的设计查询。深刻地理解MySQL如何真正地执行查询，并明白高效和低效的原因何在，这样才能充分发挥MySQL的优势，并避开它的弱点。
    
    </summary>
    
      <category term="MySQL数据库" scheme="http://yoursite.com/categories/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
  </entry>
  
  <entry>
    <title>创建高性能索引</title>
    <link href="http://yoursite.com/posts/28327/"/>
    <id>http://yoursite.com/posts/28327/</id>
    <published>2019-09-18T11:58:01.000Z</published>
    <updated>2019-09-26T11:54:57.160Z</updated>
    
    <content type="html"><![CDATA[<p>索引（也叫做“键（key）”）是存储引擎用于快速找到记录的一种数据结构。索引对于良好的性能非常关键，尤其是当表中的数据量越来越大时，索引对性能的影响越发重要。其外索引优化也很重要，索引优化应该是对查询性能优化最有效的手段了，索引能轻易将查询性能提高几个数量级。</p><h1 id="索引基础"><a href="#索引基础" class="headerlink" title="索引基础"></a>索引基础</h1><p>要理解MySQL中索引时如何工作的，最简单的方法就是去看看一本书的“索引”部分：如果想在一本书中找到某个特定主题，一般会先看书的“索引”，找到对应的页码。</p><p>在MySQL中，存储引擎用类似的方法使用索引，<strong>其先在索引中找到对应值，然后根据匹配的索引记录找到对应的数据行。也就是说，MySQL先在索引上按值进行查找，然后返回所有包含该值的数据行。</strong></p><p>索引可以包含一个或多个列的值。如果索引包含多个列，那么列的顺序也十分重要，因为<strong>MySQL只能高效的使用索引的最左前缀列。</strong></p><h2 id="索引的类型"><a href="#索引的类型" class="headerlink" title="索引的类型"></a>索引的类型</h2><p>在MySQL中，<strong>索引是在存储引擎层</strong>而不是服务层<strong>实现的</strong>。索引不同存储引擎的索引的工作方式不一样，也不是所有的存储引擎都支持所有类型的索引。下面是MySQL支持的索引类型，以及它们的优点和缺点。</p><h3 id="B-Tree索引"><a href="#B-Tree索引" class="headerlink" title="B-Tree索引"></a>B-Tree索引</h3><p>如果没有特别说明索引类型，默认是B-Tree索引，它使用B-Tree数据结构来存储数据，大多数MySQL引擎都支持这种索引（Archive除外）。不过底层的存储引擎也可能使用不同的数据结构，例如<strong>InnoDB则使用的是B+Tree。</strong></p><p>存储引擎以不用的方式使用B-Tree索引，性能也各有不同，各有优势。例如：<strong>MyISAM使用前缀压缩技术使得索引更小，但InnoDB则按照原数据格式进行存储。再如MyISAM索引通过数据的物理位置引用被索引的行，而InnoDB则根据主键引用被索引的行。</strong></p><p><strong>B-Tree通常意味着所有的值都是按顺序存储的，并且每一个叶子页到根的距离相同。</strong>下图展示B-Tree索引的抽象表示：<br><img src="/posts/28327/B-Tree%E7%BB%93%E6%9E%84.png" alt></p><p><strong>B-Tree索引能加快访问数据的速度，因为存储引擎不再需要进行全表扫描来获取需要的数据，取而代之的是从索引的根节点开始进行搜索。根节点的槽中存放了指向子节点的指针，存储引擎根据这些指针向下层查找。通过比较节点页的值和要查找的值可以找到合适的指针进入下层子节点，这些指针实际上定义了子节点中值的上限和下限。最终存储引擎要么是找到对应的值，要么该记录不存在。</strong>叶子节点比较特别，它们的指针指向的是被索引的数据，而不是其他的节点页。</p><p><strong>B-Tree对索引列是顺序组织存储的，所以很适合查找范围数据。</strong>例如，在一个基于文本域的索引树上，按字母顺序传递连续的值进行查找是非常合适的，所以像“找出所有以I到K开头的名字”这样的查找效率会非常高。</p><p>建立如下表：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">CREATE TABLE <span class="title">people</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">last_name varchar(<span class="number">50</span>)</span> not <span class="keyword">null</span>,</span></span><br><span class="line"><span class="function">first_name <span class="title">varchar</span><span class="params">(<span class="number">50</span>)</span> not <span class="keyword">null</span>,</span></span><br><span class="line"><span class="function">dob date not <span class="keyword">null</span>,</span></span><br><span class="line"><span class="function">gender <span class="title">enum</span><span class="params">(<span class="string">'m'</span>,<span class="string">'f'</span>)</span> not <span class="keyword">null</span>,</span></span><br><span class="line"><span class="function"><span class="title">key</span><span class="params">(last_name,first_name,dob)</span></span></span><br><span class="line"><span class="function">)</span>;</span><br></pre></td></tr></table></figure><p><img src="/posts/28327/B-Tree%E8%A1%A8%E4%BE%8B%E5%AD%90.png" alt><br><strong>索引对多个值进行排序的依据是CREATE TABLE语句中定义索引时列的顺序。</strong>例如上图中，最后两个条目中，两个人的姓和名都一样，则根据他们的出生日期来排序。</p><p>可以使用B-Tree索引的查询类型。<strong>B-Tree索引适用于全键值、键值范围或前缀查询。其中键前缀查找只适用于根据最左前缀的查找。</strong>故所述的索引对如下类型的查询有效：</p><ul><li><strong>全值匹配</strong>：<strong>全值匹配指的是和索引中的所有列进行匹配。</strong>例如上图中，索引可用于查找姓名为Cuba Allen、同时出生于1960-01-01的人。</li><li><strong>匹配最左前缀</strong>：索引可用于查询所有姓为Allen的人，<strong>即只使用索引的第一列。</strong></li><li><strong>匹配列前缀</strong>：也可以<strong>只匹配某一列的值的开头部分。</strong>例如可以查找所有以J开头的性的人，这里也只使用了索引的第一列。</li><li><strong>匹配范围值</strong>：例如索引可用于查找姓在Allen和Barrymore之间的人，这里也只使用了索引的第一列。</li><li><strong>精确匹配某一列并范围匹配另外一列</strong>：例如可以查找所有姓为Allen，并且名字是字母K开头的人。即第一列全匹配，第二列范围匹配。</li><li><strong>只访问索引的查询</strong>：B-Tree通常可以支持“只访问索引的查询”，<strong>即查询只需要访问索引，而无须访问数据行。</strong></li></ul><p>因为索引树中的节点是有序的，所以除了按值查找之外，<strong>索引还可以用于查询中的ORDER BY操作</strong>。一般来说，如果B-Tree可以按照这种方式用于排序。</p><p>但是B-Tree索引也有一些限制：</p><ul><li><strong>如果不是按照索引的最左列开始查找，则无法使用索引。</strong>即最左列不能跳过，例如上面例子中的索引无法用于查找名字为Bill的人，也无法查找某个特定生日的人，因为这两列都不是最左数据列。</li><li><strong>不能跳过索引中的列。</strong>也就是说不能查找姓名为Smith并且某个特定日期出生的人。如果不指定名，则MySQL只能使用索引的第一列。</li><li><strong>如果查询中有某个列的范围查找，则其右边所有列都无法使用索引优化查找。</strong></li></ul><p>总而言之这些限制都和索引列的顺序有关。在优化性能的时候，可能需要使用相同的列但顺序不同的索引来满足不同类型的查询需求。</p><h3 id="哈希索引"><a href="#哈希索引" class="headerlink" title="哈希索引"></a>哈希索引</h3><p><strong>哈希索引基于哈希表实现，只有精确匹配索引所有列的查询才有效。</strong>对于每一行数据，存储引擎哦都会对所有的索引列计算一个哈希码，哈希码是一个较小的值，并且不同键值的行计算出来的哈希码也不一样。<strong>哈希索引将所有的哈希码存储在索引中，同时在哈希表中保存指向每个数据行的指针。</strong></p><p>假设有如下表：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> testhash (  </span><br><span class="line">    fname <span class="built_in">VARCHAR</span>(<span class="number">50</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">    lname <span class="built_in">VARCHAR</span>(<span class="number">50</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">    <span class="keyword">KEY</span> <span class="keyword">USING</span> <span class="keyword">HASH</span>(fname)</span><br><span class="line">)<span class="keyword">ENGINE</span>= <span class="keyword">MEMORY</span>;</span><br></pre></td></tr></table></figure><p>表中包含数据：<img src="/posts/28327/hashdata.png" alt><br>假设索引使用假想的哈希函数f()，它返回下面的值（以下为实例数据）：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">f('Arjen') = 2323</span><br><span class="line">f('Baron') = 7437</span><br><span class="line">f('Peter') = 8784</span><br><span class="line">f('Vadim') = 2458</span><br></pre></td></tr></table></figure><p>则哈希索引的数据结构如下：<img src="/posts/28327/hashdata2.png" alt><br><strong>注意，每个槽的编号是顺序的，但是数据行不是。</strong></p><p>因为索引自身只需存储对应的哈希值，所以索引的结构十分紧凑，这也让哈希索引查找到速度非常快。但是哈希索引也有它的限制：</p><ul><li><strong>哈希索引只包含哈希值和行指针，而不存储字段值，所以不能使用索引中的值来避免读取行。</strong>不过访问内存中的行的速度很快，所以大部分情况下这一点对性能的影响并不明显。</li><li>哈希索引值并不是按照索引值顺序存储的，所以也就<strong>无法用于排序。</strong></li><li><strong>哈希索引也不支持部分索引列匹配查找，因为哈希索引始终是使用索引列的全部内存容来计算哈希值的。</strong></li><li><strong>哈希索引只支持等值比较查询</strong>，包括=、IN()、&lt;=&gt;，也不支持任何范围查询。</li><li>访问哈希索引的数据非常快，除非有很多哈希冲突。当出现哈希冲突的时候，存储引擎会遍历链表中所有的行指针，逐行进行比较查找。</li><li>如果哈希冲突很多的话，一些索引维护操作的代价也会很高，冲突越多，代价越高。</li></ul><p>因为这些限制，哈希索引只适用于某些特定的场合，而一旦适合哈希索引，则它带来的性能提升将非常明显。</p><p>InnoDB引擎有一个特殊的功能叫做“<strong>自适应哈希索引</strong>”。当InnoDB注意到某些索引值被使用的非常频繁时，它会在内存中基于B-Tree所以之上再创建一个哈希索引。这是一个完全自动的、内部的行为，用户无法控制或者配置，但是可以关闭。</p><p><strong>自定义哈希索引时，记住不要使用SHA1()和MD5()作为哈希函数</strong>，因为这两个函数计算出来的哈希值时非常长的字符出阿奴，会浪费大量空间，比较时也会更慢。使用简单哈希函数导致的冲突在一个可以接受的范围，同时又能提供更好的性能。<strong>自定义哈希函数要返回整数，而不是字符串，一个简单的方法可以使用MD5()函数返回值的一部分来作为哈希函数。</strong></p><p><strong>当使用哈希索引进行查找的时候，要避免冲突问题，必须在WHERE条件中带入哈希值和对应列值。</strong>例如<code>SELECT * FROM words WHERE crc = CRC32(&#39;gnu&#39;) AND word = &#39;gnu&#39;;</code>。如果只是统计记录数（不精确的），则可以不带入列值。</p><h3 id="其他索引"><a href="#其他索引" class="headerlink" title="其他索引"></a>其他索引</h3><ul><li><strong>空间数据索引（R-Tree）</strong>：MyISAM表支持空间索引，可以用作地理数据存储。不同于B-Tree索引，这类索引无须前缀查询。<strong>空间索引会从所有维度来索引数据。查询时，可以有效地使用任意维度来组合查询。</strong></li><li><strong>全文索引</strong>：<strong>全文索引是一种特殊类型的索引，它查找的时文本中的关键字，而不是直接比较索引中的值。</strong>全文索引更类似于搜索引擎做的事情。<strong>在相同的列上同时创建全文索引和基于值的B-Tree索引不会有冲突</strong>，全文索引适用于MATCH AGAINST操作，而不是普通的WHERE条件操作。</li></ul><h1 id="索引的优点"><a href="#索引的优点" class="headerlink" title="索引的优点"></a>索引的优点</h1><p>索引可以让服务器快速地定位到表的指定位置，但这不是索引的唯一作用，因为根据创建索引的数据结构不同，索引也有一些其他的附加作用。</p><p>最常见的B-Tree索引，按照顺序存储数据，所以MySQL可以用来做ORDER BY和GROUP BY操作；因为数据是有序的，所以B-Tree也就会将相关的列值都存储在一起；因为索引中存储了实际的列值，所以某些查询只使用索引就能完成全部查询。所以总结下来索引有如下三个优点：</p><ul><li><strong>索引大大减少了服务器需要描述的数据量</strong></li><li><strong>索引可以帮助服务器避免排序和临时表</strong></li><li><strong>索引可以将随机I/O变为顺序I/O</strong></li></ul><p>有一个简单评价一个索引是否适合某个查询的方法叫做“三星系统”：<strong>索引将相关的记录放在一起则获得一星；如果索引中的数据顺序和查找中的排列顺序一致则获得二星；如果索引的列包含了查询中需要的全部列则获得三星。</strong></p><h1 id="高性能的索引策略"><a href="#高性能的索引策略" class="headerlink" title="高性能的索引策略"></a>高性能的索引策略</h1><h2 id="独立的列"><a href="#独立的列" class="headerlink" title="独立的列"></a>独立的列</h2><p>如果查询时不当的使用索引，或使得MySQL无法使用已有的索引。<strong>如果查询中的列不是独立的，则MySQL就不会使用索引。“独立的列”是指索引列不能是表达式的一部分，也不能是函数的参数。</strong><br>例如：<code>SELECT actor_id FROM sakila.actor WHERE actor_id+1 = 5;</code>和<code>SELECT ... WHERE TO_DAYS(CURRENT_DATE) - TO_DAYS(data_col) &lt;= 10;</code></p><p>所以我们应该养成简化WHERE条件的习惯，<strong>始终将索引列单独放在符号的一侧。</strong></p><h2 id="前缀索引和索引选择性"><a href="#前缀索引和索引选择性" class="headerlink" title="前缀索引和索引选择性"></a>前缀索引和索引选择性</h2><p>通常可以索引开始的部分字符，这样可以大大节约索引空间，从而提高索引效率。但是这样也会降低索引的选择性。<strong>索引的选择性是指：不重复的索引值（也称为基数）和数据表的记录总数（#T）的比值，范围从 1/#T 到 1 之间。</strong>索引的选择性越高则查询效率越高，因为选择性高的索引可以让MySQL在查找时过滤掉更多的行，唯一索引的选择性是1，即选择性最好，性能也最好。</p><p>对于BLOB、TEXT或者很长的VARCHAR类型的列，必须使用前缀索引，因为MySQL不允许索引这些列的完整长度。</p><p>诀窍在于要选择足够长的前缀以保证较高的选择性，同时又不能太长，以便节约空间。</p><p>为了决定前缀的合适长度，需要找到最常见的值的列表，然后和最常见的前缀列表进行比较，<strong>适当增加前缀长度，直到这个前缀的选择性接近完整列的选择性。</strong>另外一个方法就是计算完整列的选择性，并使前缀的选择性接近于完整列的选择性，计算方法如下：<code>SELECT COUNT(DISTINCT city)/COUNT(*) FROM city_demo</code>。通常来说，如果前缀的选择性能够接近<strong>0.031</strong>，基本上就可用了。</p><p><strong>前缀索引是一种能使索引更小、更快的有效办法，但另一方面也有其缺点：MySQL无法使用前缀索引做ORDER BY和GROUP BY，也无法使用前缀索引做覆盖扫描。</strong></p><h2 id="多列索引"><a href="#多列索引" class="headerlink" title="多列索引"></a>多列索引</h2><p>很多人对多列索引的理解一个常见的错误就是：为每个列创建独立的索引，或者按照错误的顺序创建多列索引。在多个列上建立独立的单独索引大部分情况下并不能提高MySQL的查询性能。</p><p>MySQL5.0和最新版本引入了一种叫“<strong>索引合并</strong>”的策略，一定程度上可以使用表上的多个单列索引来定位指定的行。这种算法有三个变种：OR条件的联合（union），AND条件的相交，组合前两种情况的联合及相交。</p><p><strong>索引合并策略有时候是一种优化的结果，但实际上更多时候说明了表上的索引建的很差。</strong>如果使用EXPLAIN语句中看到有索引合并，应该好好检查一下查询和表的结构，有无优化的余地。</p><h2 id="选择合适的索引列顺序"><a href="#选择合适的索引列顺序" class="headerlink" title="选择合适的索引列顺序"></a>选择合适的索引列顺序</h2><p>正确的索引顺序依赖于使用该索引的查询，并且同时需要考虑如何更好地满足排序和分组的需要。</p><p>在一个多列的B-Tree索引中，<strong>索引列的顺序意味着索引首先按照最左列进行排序，其次是第二列，等等。所以索引可以按照升序或者降序进行扫描，以满足精确符合列顺序的ORDER BY、GROUP BY和DISTINCT等子句的查询需求。所以多列索引的列顺序至关重要。</strong></p><p><strong>对于如何选择索引的列顺序有一个经验法则：将选择性最高的列放在索引最前列。</strong>但不需要考虑排序和分组时，将选择性最高的列放在前面通常是很好的。这时候索引的作用只是用于优化WHERE条件的查找。</p><h2 id="聚簇索引"><a href="#聚簇索引" class="headerlink" title="聚簇索引"></a>聚簇索引</h2><p>聚簇索引并不是一种单独的索引类型，而是一种数据存储方式，具体的细节依赖于其实现方式，<strong>InnoDB的聚簇索引实际上在同一个结构中保存了B-Tree索引的数据行。**</strong>当表有聚簇索引时，它的数据行实际上存放在索引的叶子页中。<strong>“聚簇”表示数据行和相邻的键值紧凑的存储在一起。因为无法同时把数据行存放在两个不同的地方，所以</strong>一个表只能有一个聚簇索引。**</p><p>下图展示聚簇索引中的记录是如何存放的：<img src="/posts/28327/%E8%81%9A%E7%B0%87%E7%B4%A2%E5%BC%95.png" alt>注意到，叶子页中包含了行的全部数据，但是节点页只包含了索引列。<strong>InnoDB通过主键聚集数据，也就是说上图中的“被索引的列”就是主键列。</strong>如果没有定义主键，InnoDB会选择一个唯一非空索引代替。如果没有这样的索引，InnoDB会隐式定义一个主键来作为聚簇索引。下面讨论一些聚簇索引的优缺点。</p><p><strong>优点：</strong></p><blockquote><ul><li><strong>可以把相关的数据保存在一起。</strong></li><li><strong>数据访问更快。</strong>聚簇索引将索引和数据保存在同一个B-Tree中，因此从聚簇索引中获取数据通常比在非聚簇索引中查找更快。</li><li><strong>使用覆盖索引扫描的查询可以直接使用页节点的主键值。</strong></li></ul></blockquote><p><strong>缺点：</strong></p><blockquote><ul><li><strong>聚簇索引最大限度的提高了I/O密集型应用的性能</strong>，但如果全部数据都放在内存中，那么访问的顺序就没有关系了，因此也就无法体现出什么优势了。</li><li><strong>插入速度严重依赖于插入顺序。</strong>按照主键的顺序插入是数据加载到InnoDB表中最快速度的方式；但如果不是按照主键顺序加载数据，那么在加载完成后最好<strong>使用OPTIMIZE TABLE命令重新组织一下表。</strong></li><li><strong>更新聚簇索引列的代价很高，因为会强制InnoDB将每个被更新的行移动到新的位置。</strong></li><li><strong>基于聚簇索引的表在插入新行，或者主键被更新导致需要移动行的时候，可能面临“页分裂”的问题，页分裂会导致表占用更多的磁盘空间</strong>。当行的主键值要求必须将这一行插入到某个已满的页中时，存储引擎会将该页分裂成两个页面来容纳改行，这就是一次页分裂操作。</li><li><strong>聚簇索引可能导致全表扫描变慢，尤其是行比较稀疏，或者由于页分裂导致数据存储不连续的时候。</strong></li><li><strong>二级索引（非聚簇索引）可能比想象的要更大，因为在二级索引的叶子节点包含了引用行的主键列。</strong></li><li><strong>二级索引访问需要两次索引查找，而不是一次。</strong>导致这个问题的原因在于二级索引中保存的“行指针”的实质。<strong>二级索引叶子节点保存的不是指向行的物理位置的指针，而是行的主键值。</strong>这意味着<strong>通过二级索引查找行，存储引擎需要找到二级索引的叶子节点获得对应的主键值，然后根据这个值去聚簇索引中查找到对应的行。</strong>对于InnoDB自适应哈希索引可以减少这样的重复工作。</li></ul></blockquote><p>在InnoDB和MyISAM中，对于聚簇索引和非聚簇索引的实现有区别，所以就以下表为例对比二者的区别：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> layout_test(</span><br><span class="line">col1 <span class="built_in">int</span> <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">col2 <span class="built_in">int</span> <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">PRIMARY <span class="keyword">KEY</span>(col1),</span><br><span class="line"><span class="keyword">KEY</span>(col2)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>假设该表的主键取值为1<del>10000，并且数据在磁盘上的存储方式已经最优，但行的顺序是随机的；列col2的值是从1</del>100之间随机复制，可能有很多重复值。</p><h3 id="MyISAM的数据分布"><a href="#MyISAM的数据分布" class="headerlink" title="MyISAM的数据分布"></a>MyISAM的数据分布</h3><p>MyISAM的数据分布非常简单，<strong>它按照数据插入的顺序存储在磁盘上</strong>，如图所示：<img src="/posts/28327/MyISAM%E8%81%9A%E7%B0%87%E7%B4%A2%E5%BC%95%E6%95%B0%E6%8D%AE%E5%88%86%E5%B8%83.png" alt>在行的旁边显示了行号，从0开始递增。因为行是定长的，索引MyISAM可以从表的开头跳过所需的字节知道需要的行。这种分布方式很容易创建索引，如图：<img src="/posts/28327/TIM%E6%88%AA%E5%9B%BE20190923193723.png" alt></p><p><strong>MyISAM中主键索引和其他索引在结构上没什么不同</strong>，因此列col2的索引分布和col1一样。<strong>主键索引就是一个名为PRIMARY的唯一非空索引。</strong></p><h3 id="InnoDB的数据分布"><a href="#InnoDB的数据分布" class="headerlink" title="InnoDB的数据分布"></a>InnoDB的数据分布</h3><p><img src="/posts/28327/InnoDB%E8%81%9A%E7%B0%87%E7%B4%A2%E5%BC%95%E4%B8%BB%E9%94%AE%E5%88%86%E5%B8%83.png" alt><br>可以看到该图显示了整张表，而不只有索引，因为在InnoDB中，聚簇索引就是表，所以不需要像MyISAM那样需要独立的行存储。<strong>聚簇索引的每一个叶子节点都包含了主键值、事务ID、用于事务和MVCC的回滚指针以及所有的剩余列。</strong></p><p>还有一点与MyISAM不同的是，InnoDB的二级索引和聚簇索引很不相同。<strong>InnoDB二级索引的叶子节点中存储的不是“行指针”，而是主键值，并以此作为指向行的“指针”。这样的好处就是减少了当出现行移动或者数据页分裂时二级索引的维护工作，因此InnoDB在移动行时无需更新二级索引的这个“指针”。</strong>下图是InnoDB中的二级索引分布：<img src="/posts/28327/InnoDB%E4%BA%8C%E7%BA%A7%E7%B4%A2%E5%BC%95%E5%88%86%E5%B8%83.png" alt></p><p>聚簇和非聚簇对比如图：<img src="/posts/28327/%E8%81%9A%E7%B0%87%E9%9D%9E%E8%81%9A%E7%B0%87%E5%AF%B9%E6%AF%94.png" alt></p><h3 id="在InnoDB表中按主键顺序插入行"><a href="#在InnoDB表中按主键顺序插入行" class="headerlink" title="在InnoDB表中按主键顺序插入行"></a>在InnoDB表中按主键顺序插入行</h3><p>如果正在使用的InnoDB表没有什么数据需要聚集，那么可以定义一个与数据无关的代理键作为主键，<strong>最简单方法就是使用AUTO_INCREMENT自增列，这样可以保证数据行是按顺序写入，对于根据主键做关联的性能也会更好。</strong>最好避免随机的聚簇索引，下面对比以自增的整数ID作为主键和以随机字符串UUID作为主键的情况。<img src="/posts/28327/InnoDB%E6%8F%92%E5%85%A5.png" alt><strong>可以注意到UUID主键插入不仅花费时间更长，而且索引占用的空间也更大。这一方面是由于主键字段更长，另一方面毫无疑问是因为页分裂和碎片导致的。</strong><br><img src="/posts/28327/%E5%90%91%E8%81%9A%E7%B0%87%E7%B4%A2%E5%BC%95%E6%8F%92%E5%85%A5%E9%A1%BA%E5%BA%8F%E7%9A%84%E7%B4%A2%E5%BC%95%E5%80%BC.png" alt>如图所示，因为主键的值是顺序的，所以InnoDB把每一条记录都存储在上一条记录的后面。当达到页的最大填充因子时（InnoDB默认的最大填充因子是页大小的15/19，留出部分空间用于以后修改），下一条记录就会写入新的页中。一旦数据按照这种顺序的方式加载，主键页就会近似于被顺序的记录填满，这也正是所期望的结果。</p><p><img src="/posts/28327/%E5%90%91%E8%81%9A%E7%B0%87%E7%B4%A2%E5%BC%95%E6%8F%92%E5%85%A5%E6%97%A0%E5%BA%8F%E5%80%BC.png" alt><br>但是对比使用UUID聚簇索引的表插入数据，<strong>因为新行的主键值不一定比之前的插入大，所以InnoDB无法简单的总是把新行插入到索引的最后，而是需要为新的行寻找合适的位置————通常是已有数据的中间位置————并且分配空间。这会增加很多的额外工作，并导致数据分布不够优化，</strong>下面是总结的一些缺点：</p><blockquote><ul><li>写入到目标页可能已经刷到磁盘上并从缓存中移除，或者是还没有被加载到缓存中，InnoDB再插入之前不得不先找到并从磁盘读取目标页到内存中，这将<strong>导致大量的随机I/O。</strong></li><li><strong>因为写入是乱序的，InnoDB不得不频繁的做分页操作，以便为新的行分配空间。页分裂会导致移动大量数据，一次插入最少需要修改三个页面而不是一个页面。</strong></li><li>由于频繁的页分裂，页会变得稀疏并被不规则地填充，所以<strong>最终数据会有碎片。</strong></li></ul></blockquote><p>所以总结结论就是，<strong>使用InnoDB时应该尽可能的按主键顺序插入数据，并且尽可能地使用单调增加的聚簇键的值来插入新行。</strong></p><h2 id="索引覆盖"><a href="#索引覆盖" class="headerlink" title="索引覆盖"></a>索引覆盖</h2><p>索引确实是一种查找数据的高效方式，但是MySQL也可以使用索引来直接获取列的数据，这样就不再需要读取数据行。<strong>如果一个索引包含（或者说覆盖）所有需要的字段的值，我们就称之为“索引覆盖”。</strong>索引覆盖是非常有效的工具，能够极大地提高性能，如果查询只需要扫描索引而无需回表，会带来多少好处：</p><ul><li><strong>索引条目通常远小于数据行的大小，所以如果只需要读取索引，那MySQL就会极大的减少数据访问量。</strong>这对缓存的负载非常重要，因为这种情况下响应时间大部分花费在数据拷贝上。</li><li><strong>因为索引是按照列值的顺序存储的，所以对于I/O密集型的范围查找会比随机从磁盘读取每一行的I/O要少得多。</strong>对于MyISAM甚至可以通过OPTIMIZE命令使得索引完全顺序排列，这让简单的范围查询能完全顺序的索引访问。</li><li>一些存储引擎存储引擎入MyISAM在内存中只缓存索引，数据则依赖于操作系统来缓存，因此访问数据需要一次系统调用，所以这里<strong>减少了因调用系统导致的开销。</strong></li><li>由于InnoDB二级索引在叶子节点中保存了行的主键值，所以<strong>如果二级主键能够覆盖查询，则可以避免主键索引的二次查询。</strong></li></ul><p>不是所有类型的索引都可为成为覆盖索引，覆盖索引必须存储索引列的值，而哈希索引、空间索引和全文索引等都不存储索引列的值，所以<strong>MySQL只能使用B-Tree索引做覆盖索引。</strong>另外也不是所有的索引都支持覆盖索引。</p><p>当发起一个被索引覆盖的查询（也叫做索引覆盖查询）时，<strong>在EXPLAIN的Extra列可以看到“Using index”的信息。</strong>索引覆盖查询还有很多陷阱可能导致无法实现优化。<strong>MySQL查询优化器会在执行查询前判断是否有一个索引能进行覆盖。加入索引覆盖了WHERE条件中的字段，但是不是整个查询涉及的字段。如果条件为假，MySQL5.5及更早总是会回表获取数据行，尽管并不需要这一行且最终会被过滤掉。</strong></p><p>如下例子：<img src="/posts/28327/beforesql.png" alt><br>这里索引无法覆盖该查询，有两个原因：</p><blockquote><ul><li>没有任何索引能够覆盖这个查询，因为查询从表中选择了所有的列，而每一任何索引覆盖了所有列。</li><li>MySQL不能在索引中执行LIKE操作。这是底层存储引擎API的限制，MySQL5.5及更早版本只允许在索引中做简单比较操作。<strong>MySQL能在索引中做最左前缀匹配的LIKE比较，因为该操作可以转换为简单的比较操作，但是如果时通配符开头的LIKE查询，存储器引擎就无法做比较匹配。</strong></li></ul></blockquote><p>也有办法解决上面说的问题，需重写查询并巧妙的设计索引。先将索引拓展至覆盖三个数据列，然后按如下方式重写查询：<br><img src="/posts/28327/aftersql.png" alt><br><strong>这种方式叫做“延迟关联”，因为延迟了对列的访问。</strong>在查询的第一阶段MySQL可以使用覆盖索引，在FROM子句的子查询中找到匹配的prod_id，然后根据这些prod_id值在外层查询匹配获取需要的所有列值。虽无法完全使用覆盖查询，但总比不使用覆盖查询好。</p><p><strong>这样的优化效果取决于WHERE条件匹配返回的数据行。</strong><img src="/posts/28327/%E8%A6%86%E7%9B%96%E6%B5%8B%E8%AF%95.png" alt><br>在示例3中，因为索引过滤时符合第一个条件的结果集已经很小，所以子查询带来的成本反而比从表中直接提取完整行更高。</p><p>可以考虑更进一步优化InnoDB：InnoDB的二级索引的叶子节点都包含了主键的值，这意味着InnoDB的二级索引可以有效地利用这些“额外”的主键列来覆盖查询。</p><h2 id="使用索引扫描扫描来做排序"><a href="#使用索引扫描扫描来做排序" class="headerlink" title="使用索引扫描扫描来做排序"></a>使用索引扫描扫描来做排序</h2><p>MySQL有两种方式可以生成有序的结果：通过<strong>排序操作</strong>或者<strong>按索引顺序扫描</strong>。如果EXPLAIN出来的type列的值为“index”，则说明MySQL使用了索引扫描来做排序。扫描索引本身是很快的，但是如果索引不能覆盖所需的全部列，那就不得不每扫描一条索引记录都回表查询一次对应的行，这基本上都是随机I/O，因此按索引顺序读取数据的速度通常要比顺序地全表扫描。</p><p>MySQL可以使用同一个索引既满足排序又用于查找行，因此，如果可能，设计索引时应该尽可能地满足这两种任务。<strong>只有当索引的列顺序和ORDER BY子句的顺序完全一致，并且所有列的排序方向都一样时，MySQL才能使用索引来对结果做排序。**</strong>如果查询时需要关联多张表，则只有当ORDER BY子句引用的字段全部为第一个表时，才能使用索引来做排序<strong>，，ORDER BY子句和查找型查询的限制是一样的：</strong>需要满足索引的最左前缀的要求；否则MySQL都需要执行排序操作，而无法利用索引排序。<strong>有一种情况下ORDER BY子句可以不满足索引的最左前缀的要求：</strong>前导列为常量的时候。**如果WHERE子句或者JOIN子句种对这些列指定了常量，就可以弥补索引的不足。例如有如下表：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">(retal_date,inventory_id,customer_id):</span><br><span class="line"><span class="function">CREATE TABLE <span class="title">retal</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">...</span></span></span><br><span class="line"><span class="function"><span class="params">PRIMARY KEY (retal_id)</span>,</span></span><br><span class="line"><span class="function">UNIQUE KEY <span class="title">retal_date</span><span class="params">(retal_date,inventory_id,customer_id)</span>,</span></span><br><span class="line"><span class="function">KEY <span class="title">idx_fk_inverntory_id</span><span class="params">(inventory_id)</span>,</span></span><br><span class="line"><span class="function">KEY <span class="title">idx_fk_customer_id</span><span class="params">(customer_id)</span>,</span></span><br><span class="line"><span class="function">KEY <span class="title">idx_fk_staff_id</span><span class="params">(staff_id)</span>,</span></span><br><span class="line"><span class="function">...</span></span><br><span class="line"><span class="function">)</span>;</span><br></pre></td></tr></table></figure><p>MySQL可以在使用retal_date索引为下面的查询做排序，从EXPLAIN中可以看到没有出现文件排序（filesort）操作：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">EXPLAIN</span> <span class="keyword">SELECT</span> retal_id,staff_id <span class="keyword">FROM</span> sakila.rental</span><br><span class="line"><span class="keyword">WHERE</span> retal_date = <span class="string">'2005-05-25'</span></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> inventory_id,customer_id\G</span><br></pre></td></tr></table></figure><p>即使ORDER BY子句不满足索引的最左前缀要求，也可以用于查询查询排序，这是因为<strong>索引的第一列被指定为一个常数。</strong>还有更多可以使用索引做排序的查询示例。下面这个查询可以利用查询排序，是因为<strong>查询为索引的第一列提供了常量条件，而使用第二列进行排序，将两列组合在一起，就形成了索引的最左前缀</strong>：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">...WHERE retal_date = '2005-05-25' ORDER BY inventory_id DESC;</span><br></pre></td></tr></table></figure><p>下面这个查询也可以，<strong>因为ORDER BY使用的两列就是索引的最左前缀：</strong></p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">...WHERE retal_date &gt; '2005-05-25' ORDER BY retal_date,inventory_id;</span><br></pre></td></tr></table></figure><p>下面是一些不能使用索引做排序的查询：</p><ul><li>查询使用两种不同的排序方向，但是索引列都是正序排序的。</li><li>查询的ORDER BY子句中引用了一个不在索引中的列。</li><li>查询的WHERE 和ORDER BY中的列无法组合成索引的最左前缀。</li><li>查询在索引列的第一列上使范围条件，MySQL无法使用索引的其余列。</li><li>在某一列上有多个等于条件，对于排序来说，这也是一种范围查询。</li></ul><p>使用索引做排序的一个最重要的用法是当查询同时有ORDER BY和LIMIT子句的时候。</p><h2 id="压缩（前缀压缩）索引"><a href="#压缩（前缀压缩）索引" class="headerlink" title="压缩（前缀压缩）索引"></a>压缩（前缀压缩）索引</h2><p>MyISAM使用前缀压缩来减少索引的大小，从而让更多的索引可以放入内存中，这在某些情况下能极大的提高性能。<strong>默认只压缩字符串，也可以设置对整数压缩。</strong>MyISAM压缩每个索引块的方法是：<strong>先完全保存索引块中的第一个值，然后将其他值和第一个值进行比较得到相同前缀的字节数和剩余的不同后缀部分，把这部分存储起来即可。</strong>例如索引块中的第一个值是“perform”，第二个值是“performance”，那么这个值的前缀压缩后存储的是类似“7.ance”这样的形式，同样MyISAM对行指针也采用类似的前缀压缩方式。</p><p>压缩块使用更少的空间，代价是某些操作可能更慢。因为<strong>每个值的压缩前缀都依赖前面的值，所以MyISAM查找时无法在索引块使用二分查找而只能从头开始扫描</strong>。正序的扫描速度还不错，但是倒序就不是很好了。对于CPU密集型应用，因为扫描需要随机查找，压缩索引使得MyISAM在索引查找上要慢好几倍；但如果是I/O密集型应用，对某些查询带来的好处会比成本多很多。</p><h2 id="冗余和重复索引"><a href="#冗余和重复索引" class="headerlink" title="冗余和重复索引"></a>冗余和重复索引</h2><p>MySQL允许在相同列上创建多个索引，MySQL需要单独与维护重复的索引，并且优化器在优化查询的时候也需要逐个地进行考虑，这会影响性能。</p><p><strong>重复索引是指在相同的列上按照相同的顺序创建的相同类型的索引。</strong>应该避免这样创建重复索引。</p><p><strong>冗余索引和重复索引有一些不同。如果创建了索引（A，B），在创建索引（A）就是冗余索引，因为这是前一个索引的前缀索引。因此索引（A，B）也可以当作索引（A）来使用。但是如果再创建索引（B，A）则不是冗余索引，因为B不是索引（A，B）的最左前缀列。</strong></p><p>冗余索引通常发生在为表添加新索引的时候。例如，可能会增加一个新的索引（A,B）而不是扩展已有的索引（A），还有一种情况是将一个索引扩展为（A，ID），其中ID是主键，对于InnoDB来说主键列已经包含在二级索引中了，所以这也是冗余的。大多数情况下都不需要冗余索引，<strong>应该尽量扩展已有的索引而不是创建新索引。</strong>但也有时候出于性能方面考虑需要冗余索引，因为扩展已有的索引会太大导致影响性能。</p><p>有多个索引的缺点是索引成本更高，表中的索引越多插入速度会越慢，一般来说，增加新索引将导致INSERT、UPDATE、DELETE等操作速度变慢。解决冗余索引和重复索引的方法很简单，删除这些索引就可以。</p><h2 id="未使用的索引"><a href="#未使用的索引" class="headerlink" title="未使用的索引"></a>未使用的索引</h2><p>除了冗余索引和重复索引，可能还会有一些服务器永远不用的索引，这样的索引完全是累赘，建议考虑删除。</p><h2 id="索引和锁"><a href="#索引和锁" class="headerlink" title="索引和锁"></a>索引和锁</h2><p><strong>索引可以让查询锁定更少的行。</strong>InnoDB只有在访问行的时候才会对其进行加锁，而索引能够减少InnoDB访问的行数，从而减少锁的行数，但这只有当InnoDB在存储引擎层能够过滤掉索引不需要的行时才有效。</p><p>关于InnoDB、索引和锁有一些细节很少有人知道：<strong>InnoDB在二级索引上使用共享（读）锁，但访问主键索引需要排他（写）锁。这消除使用覆盖索引的可能性，并且使得SELECT FOR UPDATE比LOCK IN SHARE MODE或非锁定查询要慢的多。</strong></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>在MySQL中，大多数情况下都会使用B-Tree索引。其他类型的索引大多只适用于特殊的目的。如果在合适的场景中，将大大提高查询的响应时间。在选择索引和编写利用这些索引的查询时有如下三个原则始终需要记住：</p><ul><li><strong>单行访问是很慢的。</strong>特别是在机械硬盘存储中，如果服务器从存储中读取一个数据块只是为了获取其中一行，那么就浪费了很多工作。最好读取的块中能包含尽可能多所需要的行。使用索引可以创建位置引用以提升效率。</li><li><strong>按顺序访问范围数据是很快的，</strong>这有两个原因：<strong>第一，I/O不需要多次磁盘寻道，所以比随机I/O要快很多；第二，如果服务器能够按需要顺序读取数据，那么就不再需要额外的排序操作，并且GROUP BY查询也无须再做排序和将行按组进行聚合计算了。</strong></li><li><strong>索引覆盖查询是很快的。</strong>如果一个索引包含了查询的所有列，那么存储引擎就不需要再回表查找行，这避免了大量的单行访问。</li></ul>]]></content>
    
    <summary type="html">
    
      索引（也叫做“键（key）”）是存储引擎用于快速找到记录的一种数据结构。这里介绍了索引的基础知识、基本功能和优化，还讨论索引其它一些方面有用的属性。
    
    </summary>
    
      <category term="MySQL数据库" scheme="http://yoursite.com/categories/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
  </entry>
  
  <entry>
    <title>Schema与数据类型优化</title>
    <link href="http://yoursite.com/posts/64582/"/>
    <id>http://yoursite.com/posts/64582/</id>
    <published>2019-09-15T07:26:55.000Z</published>
    <updated>2019-09-18T11:59:17.260Z</updated>
    
    <content type="html"><![CDATA[<h1 id="选择优化的数据类型"><a href="#选择优化的数据类型" class="headerlink" title="选择优化的数据类型"></a>选择优化的数据类型</h1><p>MySQL支持的数据类型非常多，选择正确的数据类型对于获得高性能至关重要。不管存储哪种类型的数据库，下面几个简单的原则都有助于做出更好的选择：</p><ul><li><strong>更小的通常更好</strong>：<strong>一般情况下，应该尽量使用可以正确存储数据的最小数据类型。更小的数据类型通常更快，占用更少的磁盘、内存和CPU缓存，处理时需要的CPU周期更少。</strong>但是要在保证没有低估需要存储的值的范围的前提下，如果无法确定哪个数据类型是最好的，就选择你认为不会超过范围的最小类型。</li><li><strong>简单就好</strong>：<strong>简单数据类型的操作通常需要更少的CPU周期。</strong>有两个例子：一个应该使用MySQL内建的类型而不是字符串来存储日期和时间；另外一个是应该用整型存储IP地址。</li><li><strong>尽量避免NULL</strong>：很多表都包含可唯NULL的列，这是因为<strong>NULL是列的默认属性</strong>。通常情况下最好指定列为NOT NULL，除非真的需要存储NULL值。因为如果查询中包含可为NULL的列，对MySQL来说更难优化，因为可为NULL的列使得索引、索引统计和值比较都复杂。<strong>可为NULL的列会使用更多的存储空间，在MySQL中也需要特殊处理。当可为NULL的列被索引时，每个索引记录需要一个额外字节，在MyISAM里甚至还可能会导致固定大小的索引变成可变大小的索引。</strong></li></ul><p>在为列选择数据类型时，第一步需要确定合适的大类型：数字、字符串、时间等，下一步是选择具体类型，很多MySQL的数据类型可以存储相同类型的数据，只是存储的长度和范围不一样、允许的精度不同，或需要的物理空间不同等等。</p><p>例如DATETIME和TIMESTAMP都可以存储时间和日期，精确到秒，然而TIMESTAMP只是用DATETIME一半的存储空间，并且会根据时区变化，具有特殊的自动更新能力。但是另一方面，TIMESTAMP允许的时间范围要小得多。</p><h2 id="整数类型"><a href="#整数类型" class="headerlink" title="整数类型"></a>整数类型</h2><p>有两种类型的数字：<strong>整数</strong>和<strong>实数</strong>，如果存储整数，可以使用这几种整数类型：TINYINT、SMALLINT、MEDIUMINT、INT和BIGINT，分别使用8、16、24、32、64位存储空间。</p><p>整数类型又可选的UNSIGNED属性，表示不允许负值，这大致可以使正数的上限提高一倍。例如TINYINT的存储范围是-128 ~ 127，而TINYINT UNSIGNED可以存储的范围是0 ~ 255。</p><p><strong>有符号和无符号类型使用相同的存储空间，并且具有相同的性能。</strong>整数计算一般使用64位的BIGINT整数，即使在32位环境下也是如此。</p><p><strong>MySQL可以为整数类型指定宽度，但是对于大多数应用没有意义:它不会限制值的合法范围，只是规定了MySQL一些交互工具用来显示字符的个数。</strong>因此对于存储和计算来说，INT(1)和INT(20)是相同的。</p><h2 id="实数类型"><a href="#实数类型" class="headerlink" title="实数类型"></a>实数类型</h2><p>实数是带有小数部分的数字。但是它们不只是为了存储小数部分，也可以使用DECIMAL存储比BIGINT还大的整数。MySQL既支持精确类型，也支持不精确类型。</p><p>FLOAT和DOUBLE类型支持使用标准的浮点运算进行近似计算。</p><p>DECIMAL类型用于存储精确的小数，支持精确计算。因为CPU不支持对DECIMAL的直接计算，所以MySQL服务器自身实现了DECIMAL的高精度计算，相对而言，<strong>CPU直接支持原生浮点计算，所以浮点运算明显更快。</strong></p><p>浮点和DECIMAL类型都可以指定精度。对于DECIMAL列，可以指定小数点前后所允许的最大位数，这会影响列的空间消耗。MySQL中将数字打包到一个二进制字符串中（每4个字节存9个数字），例如：<strong>DECIMAL（18，9）小数点两边各存储9个数字，一共使用9个字节：小数点前的数字同4个字节，小数点后的数字用4个字节，小数点本身占1个字节。</strong>DECIMAL类型允许最多65个数字，因为DECIMAL只是一种存储格式，在计算中DECIMAL会转换为DOUBLE类型。</p><p>浮点类型在存储同样范围的值时，通常比DECIMAL使用更少的空间。FLOAT使用4个字节存储；DOUBLE占用8个字节，相比FLOAT有更高的精度和更大的范围。</p><p><strong>因为需要额外的空间和计算开销，所以应该尽量只在对小数进行精确计算时才使用DECIMAL</strong>，例如存储财务数据。<strong>在数据量比较大的时候，可以考虑使用BIGINT代替DECIMAL，将需要存储的货币单位根据小数的位数乘以相应的倍数即可。</strong></p><h2 id="字符串类型"><a href="#字符串类型" class="headerlink" title="字符串类型"></a>字符串类型</h2><p>VARCHAR和CHAR两种最主要的字符串类型，存储的具体方式与存储引擎的实现有关，所以下面描述的内容，假设存储引擎是InnoDB或者MyISAM。</p><h3 id="VARCHAR类型"><a href="#VARCHAR类型" class="headerlink" title="VARCHAR类型"></a>VARCHAR类型</h3><p>VARCHAR用于存储可变长字符串，是最常见的字符串数据类型。它更加节省空间，因为它仅使用必要的空间（即越短的字符串使用越少的空间）。但是如果表使用<code>ROW_FORMAT = FIXED</code>创建的话每一行都会使用定长存储，这样很浪费空间。</p><p><strong>VARCHAR需要使用1或2个额外字节记录字符串的长度：如果列的最大长度小于或等于255字节，则只使用1个字节表示，否则使用2个字节。</strong></p><p>由于行是变长的，在UPDATE时可能使行变得更长，这就导致需要做额外的工作。<strong>如果一个行占用的空间增长，并且在页内没有更多的空间可以存储，MyISAM会将行拆成不同的片段存储，InnoDB则需要分裂页来使行可以放进页内。</strong></p><p>下面这些情况下使用VARCHAR是合适的：字符串列的最大长度比平均长度大很多；列的更新很少，所以碎片不是问题；使用了像UTF-8这样复杂的字符集，每个字符都使用不同的字节数进行存储。</p><p>MySQL在存储和检索时会保留末尾空格，但是在4.1或者老版本中则会剔除末尾空格。<strong>InnoDB则更为灵活，它可以把过长的VARCHAR存储为BLOB。</strong></p><h3 id="CHAR类型"><a href="#CHAR类型" class="headerlink" title="CHAR类型"></a>CHAR类型</h3><p>CHAR类型是定长的：MySQL总是根据定义的字符串长度分配足够的空间。当存储CHAR值时，<strong>MySQL会删除所有的末尾空格。</strong></p><p><strong>CHAR适合存储很短的字符串，或者所有值都接近同一个长度。</strong>对于经常变更的数据，CHAR也比VARCHAR更好，因为定长的CHAR类型不容易产生碎片</p><p>与CHAR和VARCHAR类似的类型还有BINARY和VARBINARY，它们存储的是二进制字符串，<strong>二进制字符串存储的是字节码而不是字符，填充也不一样：MySQL填充BINARY采用的是“\0”而不是空格，在检索时也不会去掉填充。</strong>二进制的优势并不仅仅体现在大小写敏感上，MySQL比较BINARY字符串时，每次按一个字节，并且根据该字节的数值进行比较。因此，二进制比较比字符比较简单很多，所以也就更快。</p><p>在使用VARCHAR时，更长的列会消耗更多的内存，因为MySQL通常会分配固定大小的内存块来保存内部值。尤其是使用内存临时表进行排序或操作是会特别糟糕，<strong>所以最好的策略是只分配真正需要的空间。</strong></p><h3 id="BLOB和TEXT类型"><a href="#BLOB和TEXT类型" class="headerlink" title="BLOB和TEXT类型"></a>BLOB和TEXT类型</h3><p>BLOB和TEXT都是为存储很大的数据而设计的字符串数据类型，分别采用二进制和字符方式存储。字符类型是TINYTEXT、SMALLTEXT、TEXT、MEDIUMTEXT和LONGTEXT；二进制类型是TINYBLOB、SMALLBLOB、BLOB、MEDIUMBLOB、LONGBLOB。BLOB是SMALLBLOB的同义词，TEXT是SMALLTEXT的同义词。</p><p>MySQL把每个BLOB和TEXT值当作一个独立的对象处理，存储引擎在存储时通常会做特殊处理，<strong>当BLOB和TEXT值太大时，InnoDB会使用专门的“外部”存储区域来进行存储，此时每个值在行内需要1~4个字节存储一个指针，然后再外部存储区域存储实际的值。</strong></p><p>BLOB没有排序规则或字符集，而TEXT类型有字符集和排序规则。MySQL对BLOB和TEXT列进行排序与其他类型是不同的：它只对每个列的最前面max_sort_length字节而不是整个字符串做排序。如果只需要排序前面一小部分的字符，则可以减小max_sort_length的配置，或者使用ORDER BY SUBSTRING(column,length)。</p><p>MySQL不能将BLOB和TEXT列全部长度的字符串进行索引，也不能使用这些索引消除排序。</p><h3 id="使用枚举（ENUM）代替字符串类型"><a href="#使用枚举（ENUM）代替字符串类型" class="headerlink" title="使用枚举（ENUM）代替字符串类型"></a>使用枚举（ENUM）代替字符串类型</h3><p>有时可以使用枚举代替常用的字符串类型。<strong>枚举列可以把一些不重复的字符串存储成一个预定义的集合。</strong>MySQL在存储枚举时非常紧凑，会根据列表值的数量压缩到一个或者两个字节中。</p><p>MySQL在内部会将每个值在列表中的位置保存为整数，所以实际存储为整数，而不是字符串。所以使用数字作为ENUM枚举常量，这种双重性很容易导致混乱。而且<strong>枚举字段是按照内部存储的整数而不是定义的字符串进行排序的。</strong>因此一种绕过这种限制的方式是按照需要的顺序来定义枚举列，另外也可以在查询中使用FIELD()函数显示地指定排序顺序，但是这会导致MySQL无法利用索引消除排序。</p><p><strong>枚举最不好的地方就是：字符串列表是固定的，添加或删除字符串必须使用ALTER TABLE，除非能接受只在列表末尾添加元素。</strong></p><p>因此一个通用的设计实践：<strong>在查找表时采用整数主键而避免采用基于字符串的值进行关联</strong>。ENUM可以让表的大小缩小，因此它可以更加节省内存。</p><h2 id="日期和时间类型"><a href="#日期和时间类型" class="headerlink" title="日期和时间类型"></a>日期和时间类型</h2><p>MySQL能存储的最小时间粒度为秒，但是MySQL也可以使用微秒级的粒度进行临时运算：可以使用BIGINT类型存储微秒级别的时间戳，或者使用DOUBLE存储秒之后的小数部分。</p><p>MySQL提供两种相似的日期类型：<strong>DATETIME</strong>和<strong>TIMESTAMP</strong>。</p><ul><li><strong>DATETIME</strong>：这个类型能保存大范围的值<strong>，从1001到9999年，精度为秒。</strong>它把日期和时间封装到格式为YYYYMMDDHHMMSS的整数中，与时区无关。使用8个字节的存储空间。默认情况下，MySQL以一种可排序的、无歧义的格式显示DATETIME值。</li><li><strong>TIMESTAMP</strong>：TIMESTAMP类型保存了从1970年1月1日以来的秒数，他和UNIX时间戳相同。TIMESTAMP只使用4个字节的存储空间，因此它的范围比DATETIME小得多：<strong>只能从1970年到2038年。**</strong>MySQL按照DATETIME的方式格式化TIMESTAMP的值，但是这仅仅是显示格式上的区别，TIMESTAMP的存储格式在各个版本都是一样的。TIMESTAMP显式的值也依赖于时区。<strong>默认情况下，如果插入时没有指定第一个TIMESTAMP列的值，MySQL则设置这个列的值为当前时间，再插入一行记录时，MySQL默认也会更新第一个TIMESTAMP列的值。</strong>TIMESTAMP列默认为NOT NULL。**</li></ul><p><strong>除了特殊行为之外，通常也应该尽量使用TIMESTAMP，因为它比DATETIME空间效率更高。</strong></p><h2 id="位数据类型"><a href="#位数据类型" class="headerlink" title="位数据类型"></a>位数据类型</h2><p>MySQL有少数几种存储类型使用紧凑的位存储数据，所以这些存储类型，不管底层存储格式和处理方式如何，从技术上讲都是字符串类型。</p><ul><li><strong>BIT</strong>：可以使用BIT列在一列中存储一个或多个true/false值。BIT(1)定义一个包含单个位的字段，BIT(2)存出2个位，以此类推。BIT列的最大长度位64个位。BIT在MyISAM中会打包存储所有的BIT列，所以更加节省空间；但是在InnoDB中，为每个BIT列使用一个足够存储的最小整数类型来存放，<strong>所以不能节省空间</strong>。MySQL把BIT当作字符串类型，而不是数字类型。所以对于大部分应用，最好避免使用这种类型。</li><li><strong>SET</strong>：它在MySQL内部以一系列打包的位的集合来表的，这样就有效的利用了存储空间。可以使用一个整数包装一系列的位。</li></ul><h2 id="选择标识符-identifier"><a href="#选择标识符-identifier" class="headerlink" title="选择标识符(identifier)"></a>选择标识符(identifier)</h2><p>为标识列选择合适的数据类型非常重要。一般来说更有可能用标识列与其他值进行比较，或者通过标识列寻找其他列。</p><ul><li><strong>整数类型</strong>：整数通常是标识列最好的选择，因为它们很快并且可以使用AUTO_INCREMENT。</li><li><strong>ENUM和SET</strong>：对于标识列来说，ENUM和SET类型通常是一个糟糕的选择，所以大部分情况下都要避免这么做。</li><li><strong>字符串类型</strong>：应该尽量避免使用字符串类型作为标识列，因为它们很消耗空间，并且通常比数字类型慢。</li></ul><h2 id="特殊数据类型"><a href="#特殊数据类型" class="headerlink" title="特殊数据类型"></a>特殊数据类型</h2><p>人们通常使用VARCHAR（15）列来存储IP地址，然而，它们<strong>实际上是32位无符号整数，不是字符串。</strong>用小数点将地址分成四段的表示方法只是为了让人们容易阅读，所以应该用无符号整数存储IP地址。<strong>MySQL提供INET_ATON()和INET_NTOA()函数在这两种表示方法之间转换。</strong></p><h1 id="Schema设计中的陷阱"><a href="#Schema设计中的陷阱" class="headerlink" title="Schema设计中的陷阱"></a>Schema设计中的陷阱</h1><p>有一些问题是由MySQL的实现机制导致的，所以这里讨论一下MySQL的schema的设计上的问题。</p><ul><li><strong>太多的列</strong>：<strong>MySQL的存储引擎API工作时需要在服务器层和存储引擎层之间通过行缓冲格式拷贝数据，然后再服务器曾将缓冲解码成各个列。从行缓冲中将编码过的列转换成行数据结构的操作代价非常高，转换的代价依赖于列的数量。</strong>如果一个非常宽的表，然而只有一小部分列会实际用到，这时转换的代价就非常高。</li><li><strong>太多的关联</strong>：关联操作会导致MySQL解析和优化查询的代价非常高。<strong>MySQL限制了每个关联操作最多只能有61张表，如果希望查询执行得快速且并发性能好，单个查询最好在12个表以内做关联。</strong></li><li><strong>全能的枚举</strong>：注意防止过度使用枚举（ENUM）。</li><li><strong>变相的枚举</strong>：枚举列允许在列中存储一组定义值中的单个值，集合列则允许在列中存储一组定义值中的一个或多个值，有时候这可能比较容易导致混乱。</li><li><strong>非此发明的NULL</strong>：之前说过建议尽可能地考虑替代NULL的方案，例如可以使用0、某个特殊值或空字符串作为替代。但是<strong>遵循这个原则也不要走极端，当确实需要表示未知值时也不要害怕使用NULL。</strong>值得一提的是，<strong>MySQL会在索引中存储NULL值，而Oracle不会。</strong></li></ul><h1 id="范式和反范式"><a href="#范式和反范式" class="headerlink" title="范式和反范式"></a>范式和反范式</h1><h2 id="范式的优点和缺点"><a href="#范式的优点和缺点" class="headerlink" title="范式的优点和缺点"></a>范式的优点和缺点</h2><p><strong>优点：</strong></p><blockquote><ul><li><strong>范式化的更新操作通常比反范式化要快。</strong></li><li>当数据较好地范式化时，就只有很少或者没有重复度的数据，所以<strong>只需要修改更少的数据。</strong></li><li><strong>范式化的表通常更小</strong>，可以更好地放在内存里，所以<strong>执行操作会更快。</strong></li><li><strong>很少有多余的数据意味着检索列表数据会更少需要DISTINCT或者GROUP BY语句</strong>，而在非范式化的结构中必须使用DISTINCT或者GROUP BY才能获得一份唯一的列表。</li></ul></blockquote><p><strong>缺点：</strong></p><blockquote><ul><li>范式化的设计表的缺点是通常需要关联，这不但<strong>代价昂贵，也可能使一些索引策略无效。</strong></li></ul></blockquote><h2 id="反范式的优点和缺点"><a href="#反范式的优点和缺点" class="headerlink" title="反范式的优点和缺点"></a>反范式的优点和缺点</h2><p><strong>优点：</strong></p><blockquote><ul><li>反范式化的schema因为所有数据都在一张表中，可以更好地放在内存里，所以<strong>执行操作会更快。</strong></li><li>如果不需要关联表，则对大部分查询最差的情况————即使表没有索引————是全表扫描。可以更好地放在内存里，所以<strong>执行操作会更快。</strong></li><li><strong>单独的表也能使用更有效的索引策略。</strong></li></ul></blockquote><p>缺点见范式化的优点部分。</p><h2 id="混用范式化和反范式化"><a href="#混用范式化和反范式化" class="headerlink" title="混用范式化和反范式化"></a>混用范式化和反范式化</h2><p>完全的范式化和完全的反范式化schema都是实验室才有的东西，在真实世界中很少会这么极端地使用。<strong>在实际应用中经常需要混用。</strong></p><p>最常见的反范式化数据的方法是复制或者缓存，在不同的表中存储相同的特定列。在MySQL5.0和更新版本中，可以使用触发器更新缓存值。</p><h1 id="缓存表和汇总表"><a href="#缓存表和汇总表" class="headerlink" title="缓存表和汇总表"></a>缓存表和汇总表</h1><p>有时提升性能最好的方法是在同一张表中保存衍生的冗余数据，然而有时也需要创建一张完全独立的汇总表或缓存表（特别是为满足检索到需求时）。</p><p><strong>我们用术语“缓存表”来表示存储那些可以简单地从schema其他表获取、但是每次获取的速度比较慢的数据的表；而术语“汇总表”则保存的是使用GROUP BY语句聚合数据的表。</strong></p><p>实时计算统计值是很昂贵的操作，因为要么需要扫描表中大部分数据，要么查询语句只能在某些特定的索引上才能有效运行，而这类特定索引一般会对UPDATE操作有影响，所以一般不希望创建这样的索引。<strong>而缓存表则相反，其对优化搜索和检索查询语句很有效。</strong></p><p><strong>一个有用的技巧是对缓存表使用不同的存储引擎。</strong>例如，如果主表使用InnoDB，用MyISAM作为缓存表的引擎将会得到更小的索引占用空间，并且可以做全文搜索。</p><p>在使用缓存表和汇总表时，必须决定是实时维护数据还是定期重建。哪个更好依赖于应用程序，但是<strong>定期重建并不只是节省资源，也可以保持表不会有很多碎片，以及有完全顺序组织的索引，这会更高效。</strong></p><p>当重建汇总表和缓存表时，通常需要保证数据在操作时依然可用，这就需要通过使用“影子表”来实现。<strong>“影子表”指的是一张在真实的表背后创建的表，当完成了建表操作后，可以通过一个原子的重命名操作切换影子表和原表。</strong>而且如果新表有问题，则可以很容易地进行快速回滚操作。</p><h2 id="物化视图"><a href="#物化视图" class="headerlink" title="物化视图"></a>物化视图</h2><p><strong>物化视图实际上是预先计算并且存储在磁盘上的表，可以通过各种各样的策略刷新和更新。</strong>在第七章会详细探讨物化方法。</p><h2 id="计数器表"><a href="#计数器表" class="headerlink" title="计数器表"></a>计数器表</h2><p>如果在应用中保存计数器，则在更新计数器时可能碰到并发问题。这时<strong>可以创建一张独立的表存储计时器，这样可使计数器表小并且快，使用独立的表可以避免查询缓存失效。</strong></p><p>然而问题在于，对于任何想要更新这一行的事务来说，这条记录都有一个全局的互斥锁。这会使这些事务只能串行执行。<strong>要获得更高的并发性能，也可以将计数器保存在多行中，每次随机选择一行进行更新操作。</strong></p><h2 id="更快的读，更慢的写"><a href="#更快的读，更慢的写" class="headerlink" title="更快的读，更慢的写"></a>更快的读，更慢的写</h2><p>为了提升读查询的速度，经常会需要建一些额外索引，增加冗余列，甚至是创建缓存表和汇总表。这些方法会增加写查询到负担，但是<strong>虽然写操作变慢了，但更显著地提高了读操作的性能。</strong></p><h1 id="加快ALTER-TABLE操作的速度"><a href="#加快ALTER-TABLE操作的速度" class="headerlink" title="加快ALTER TABLE操作的速度"></a>加快ALTER TABLE操作的速度</h1><p>MySQL执行<strong>大部分</strong>修改表结构操作的方法是用新的结构常见一个空表，从旧表中查出所有数据插入新表，然后删除旧表。问题是这样的操作可能需要很长时间。</p><p>一般而言，大部分ALTER TABLE操作将导致MySQL服务中断，但是能使用两种技巧进行改善：</p><ul><li>一种是先在一台不提供服务的机器上执行ALTER TABLE操作，然后和提供服务端主库进行切换。</li><li>另外一种是“影子拷贝”，是用要求的表结构创建一张和源表无关的新表，然后通过重命名和删表操作交换两张表。</li></ul><p><strong>不是所有的ALTER TABLE操作都会引起表重建。</strong>例如修改一个列的默认值：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> film</span><br><span class="line"><span class="keyword">MODIFY</span> <span class="keyword">COLUMN</span> rental_duration <span class="built_in">TINYINT</span>(<span class="number">3</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="number">5</span>;</span><br></pre></td></tr></table></figure><p>这个语句会拷贝整张表到一张新表，但是甚至列的类型、大小和可否为NULL属性都没改变。<strong>因为所有的MODIFY COLUMN 操作都会导致表重建。</strong>另一种方法是通过ALTER COLUMN操作来改变列的默认值：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> film</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">COLUMN</span> rental_duration <span class="keyword">SET</span> <span class="keyword">DEFAULT</span> <span class="number">5</span>;</span><br></pre></td></tr></table></figure><p><strong>这个语句会直接修改.frm文件而不涉及表数据。</strong>所以这个操作是非常快的。</p><h2 id="只修改-frm文件"><a href="#只修改-frm文件" class="headerlink" title="只修改.frm文件"></a>只修改.frm文件</h2><p>从上面的例子可以看出修改表的.frm文件是很快的。下面这些操作是<strong>有可能</strong>不需要重建表的：</p><ul><li>移除（不是增加）一个列的AUTO_INCREMENT属性。</li><li>增加、溢出，或更改ENUM和SET常量，如果移除的是已有行数据用到其值的变量，查询将会返回一个空字符串。</li></ul><p><strong>基本的技术是为想要的表结构创建一个新的.frm文件，然后用它替换掉已经存在的那张表的.frm文件。</strong></p><h2 id="快速创建MyISAM索引"><a href="#快速创建MyISAM索引" class="headerlink" title="快速创建MyISAM索引"></a>快速创建MyISAM索引</h2><p>为了高效地载入数据到MyISAM表中，<strong>有一个常用的技巧是：先禁用索引、载入数据，然后重新启用索引。</strong></p><p>因为构建索引的工作被延迟到数据完全载入之后，这个时候已经可以通过排序来构建索引饿了。这样做会快很多，并且使得索引树的碎片更少、更紧凑。</p><p><strong>不幸的是，这个方法对唯一索引无效，因为DISABLE KEYS只对非唯一索引有效。</strong></p><p><strong>因此在InnoDB中有一个类似的技巧：先删除所有非唯一索引，然后增加新的列，最后重新创建删除掉的索引。</strong>Percona Server可以自动完成这些操作步骤。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>总之来说，尽可能保持任何东西小而简单总是好的。MySQL喜欢简单，需要使用数据库的人也会同样喜欢简单的原则：</p><ul><li><strong>尽量避免过度设计。</strong>例如会导致极其复杂查询的schema设计，或者有很多列的表设计。</li><li><strong>使用小而简单的合适数据类型，除非真实数据模型中有确切需要，否则应该尽可能地避免使用NULL。</strong></li><li><strong>尽量使用相同的数据类型存储相似或相关的值，尤其是要在关联条件中使用的列。</strong></li><li><strong>注意可变长字符串，其在临时表和排序时可能导致悲观的按最大长度分配内存。</strong></li><li><strong>尽量使用整型定义标识列。</strong></li><li><strong>避免使用MySQL已经遗弃的特性，例如指定浮点数的精度，或者整数的显示宽度。</strong></li><li><strong>小心使用ENUM和SET，最好避免使用BIT</strong></li></ul>]]></content>
    
    <summary type="html">
    
      这章关注MySQL数据库的设计，主要介绍MySQL数据库设计与其他关系型数据库管理系统的区别。
    
    </summary>
    
      <category term="MySQL数据库" scheme="http://yoursite.com/categories/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
  </entry>
  
  <entry>
    <title>LinkedList源码阅读</title>
    <link href="http://yoursite.com/posts/44983/"/>
    <id>http://yoursite.com/posts/44983/</id>
    <published>2019-09-13T11:49:58.000Z</published>
    <updated>2019-09-14T12:37:12.186Z</updated>
    
    <content type="html"><![CDATA[<h1 id="LinkedList的数据结构"><a href="#LinkedList的数据结构" class="headerlink" title="LinkedList的数据结构"></a>LinkedList的数据结构</h1><p>LinkedList的底层数据结构是基于双向链表实现的，如图：<img src="/posts/44983/dbb44aed2e738bd49c4d031de4ce9ed3277ff97c.jpeg" alt><br>因为链表在物理内存上可以是不连续的，所以理论上，只要计算机的内存足够大的情况下，LinkedList的长度可以无限长。</p><h1 id="顶部注释"><a href="#顶部注释" class="headerlink" title="顶部注释"></a>顶部注释</h1><blockquote><p>双向链表实现了List和Deque接口。 实现所有可选列表操作，并允许所有元素（包括null ）。<br>所有的操作都能像双向列表一样预期。 索引到列表中的操作将从开始或结束遍历列表，以更接近指定的索引为准。 </p><p>请注意，此实现不同步。 如果多个线程同时访问链接列表，并且至少有一个线程在结构上修改列表，则必须在外部进行同步。 （结构修改是添加或删除一个或多个元素的任何操作;仅设置元素的值不是结构修改。）这通常通过在自然封装列表的对象上进行同步来实现。 如果没有这样的对象存在，列表应该使用Collections.synchronizedList方法“包装”。 这最好在创建时完成，以防止意外的不同步访问列表：<br><code>List list = Collections.synchronizedList(new LinkedList(...));</code></p><p>该类的iterator和listIterator方法返回的迭代器是fail-fast的 ：如果列表在迭代器创建后的任何时间进行结构修改，除了通过Iterator自己的remove或add方法外，迭代器将抛出一个ConcurrentModificationException 。 因此，面对并发修改，迭代器将快速而干净地失败，而不是在未来未确定的时间冒着任意的非确定性行为。 </p><p>请注意，迭代器的故障快速行为无法保证，因为一般来说，在不同步并发修改的情况下，无法做出任何硬性保证。 失败快速的迭代器ConcurrentModificationException扔掉ConcurrentModificationException 。 因此，编写依赖于此异常的程序的正确性将是错误的： 迭代器的故障快速行为应仅用于检测错误。 </p></blockquote><p>从上面LinkedList的源码顶部注释可以总结以下几点：</p><ul><li><strong>底部实现</strong>：双向链表。</li><li><strong>是否允许null值</strong>：允许所有元素，包括null。</li><li><strong>线程安全</strong>：线程不安全。</li><li><strong>迭代器</strong>：迭代器是fast-fail，但是迭代器的快速失败行为不能得到保证。</li><li><strong>运行时间</strong>：因为是链表的实现，所以任何需要查询到操作都需要遍历链表，即O(n)的时间。</li></ul><h1 id="LinkedList的定义"><a href="#LinkedList的定义" class="headerlink" title="LinkedList的定义"></a>LinkedList的定义</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedList</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">extends</span> <span class="title">AbstractSequentialList</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">List</span>&lt;<span class="title">E</span>&gt;, <span class="title">Deque</span>&lt;<span class="title">E</span>&gt;, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span></span></span><br></pre></td></tr></table></figure><ul><li><strong>LinkedList<e></e></strong>：支持泛型的存储模式。</li><li><strong>extends AbstractSequentialList<e></e></strong>：继承于AbstractSequentialList，继承了其中的方法，方便操作。</li><li><strong>implements List<e></e></strong>：实现了List接口，实现该接口提供的方法，方便了实现。</li><li><strong>implements Deque<e></e></strong>：实现了双端队列的接口，因此双向链表操作起来更方便。</li><li><strong>implements Cloneable</strong>：实现了Cloneable接口，内部可以调用clone()方法来返回实例的浅拷贝(shallow copy)。</li><li><strong>implements Serializable</strong>：实现了Serializable接口，表明该类是可以序列化的。</li></ul><h1 id="全局变量"><a href="#全局变量" class="headerlink" title="全局变量"></a>全局变量</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//记录元素个数的常量</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">int</span> size = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//静态内部类Node，即存储每个数据的节点</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 内存保存的内容有三个，分别是：</span></span><br><span class="line"><span class="comment">* item:储存的元素</span></span><br><span class="line"><span class="comment">* next:该节点后面一个节点</span></span><br><span class="line"><span class="comment">* prev:该节点前面一个节点</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">       E item;</span><br><span class="line">       Node&lt;E&gt; next;</span><br><span class="line">       Node&lt;E&gt; prev;</span><br><span class="line"></span><br><span class="line">       Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123;</span><br><span class="line">           <span class="keyword">this</span>.item = element;</span><br><span class="line">           <span class="keyword">this</span>.next = next;</span><br><span class="line">           <span class="keyword">this</span>.prev = prev;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 指向第一个节点的指针。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">transient</span> Node&lt;E&gt; first;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 指向最后一个节点的指针。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">transient</span> Node&lt;E&gt; last;</span><br></pre></td></tr></table></figure><h1 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h1><p>LinkedList只有两个构造方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 构造一个空列表。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">LinkedList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 构造包含指定集合的元素的列表，按集合的迭代器返回元素的顺序排列。</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span>  c 要将其元素放入此列表的集合</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@throws</span> NullPointerException 如果指定的集合为空</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">LinkedList</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">this</span>();</span><br><span class="line">       addAll(c);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>可以从上面的代码中看出，两个构造方法分别是无参方法和传入一个集合的方法。</p><p>无参方法的方法体为空，因为是链表结构，而链表的头指针和尾指针已经在上面定义过了，而且不同于数组结构，不需要指定大小和扩容，所以方便很多，因此无参方法什么都不需要做。</p><p>传入一个集合的构造方法使用addAll()方法将传入的集合按顺序添加到链表的尾部，addAll()方法可以的具体实现可以看下面的核心方法部分。</p><h1 id="核心方法"><a href="#核心方法" class="headerlink" title="核心方法"></a>核心方法</h1><h2 id="getFirst和getLast方法"><a href="#getFirst和getLast方法" class="headerlink" title="getFirst和getLast方法"></a>getFirst和getLast方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 返回列表中的第一个元素。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 列表中的第一个元素</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> NoSuchElementException 如果这个列表是空的</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">getFirst</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; f = first;</span><br><span class="line">    <span class="keyword">if</span> (f == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">    <span class="keyword">return</span> f.item;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据代码可以看出，获取到first节点，如果列表中没有元素，所以列表是空的，first节点自然是null，所以抛出NoSuchElementException异常；否则返回first节点的数据。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 返回列表中的最后一个元素。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 列表中的最后一个元素</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> NoSuchElementException 如果这个列表是空的</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">getLast</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; l = last;</span><br><span class="line">    <span class="keyword">if</span> (l == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">    <span class="keyword">return</span> l.item;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同getFirst方法很相似，获取到last节点的值，依旧判断last是否为空，为空则抛出异常；否则返回最后一个节点last的值。</p><h2 id="removeFirst方法"><a href="#removeFirst方法" class="headerlink" title="removeFirst方法"></a>removeFirst方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 从列表中移除并返回第一个元素。.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 列表中的第一个元素</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> NoSuchElementException 如果这个列表是空的</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">removeFirst</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; f = first;</span><br><span class="line">    <span class="keyword">if</span> (f == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">    <span class="keyword">return</span> unlinkFirst(f);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 断开第一个非空节点f的链接。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> E <span class="title">unlinkFirst</span><span class="params">(Node&lt;E&gt; f)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 判断 f == first &amp;&amp; f != null;</span></span><br><span class="line">    <span class="keyword">final</span> E element = f.item;</span><br><span class="line">    <span class="comment">//头节点的下一个节点，当头节点移除后，它就是头节点</span></span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; next = f.next;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 因为头节点是第一个节点，所以它的prev自然为null</span></span><br><span class="line"><span class="comment">     * 把头结点的值和next字段赋值为null，有助于GC回收</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    f.item = <span class="keyword">null</span>;</span><br><span class="line">    f.next = <span class="keyword">null</span>; <span class="comment">// 有助于 GC</span></span><br><span class="line">    <span class="comment">//然后把next作为头节点</span></span><br><span class="line">    first = next;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 如果头节点的下一个节点是null，那么说明列表中只有一个节点</span></span><br><span class="line"><span class="comment">     * 因此把last也赋值为null，说明至此链表中已无元素</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * 否则把头结点的prev字段置为null，说明该节点是头节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (next == <span class="keyword">null</span>)</span><br><span class="line">        last = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        next.prev = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 列表中元素数量减一</span></span><br><span class="line"><span class="comment">     * 修改次数加一</span></span><br><span class="line"><span class="comment">     * 返回被删除节点的值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    size--;</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="keyword">return</span> element;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="removeLast方法"><a href="#removeLast方法" class="headerlink" title="removeLast方法"></a>removeLast方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 从列表中移除并返回最后一个元素。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 列表中的最后一个元素</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> NoSuchElementException 如果这个列表是空的</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">removeLast</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; l = last;</span><br><span class="line">    <span class="keyword">if</span> (l == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">    <span class="keyword">return</span> unlinkLast(l);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 断开最后非空的一个节点l。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> E <span class="title">unlinkLast</span><span class="params">(Node&lt;E&gt; l)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 判断 l == last &amp;&amp; l != null;</span></span><br><span class="line">    <span class="keyword">final</span> E element = l.item;</span><br><span class="line">    <span class="comment">//尾节点的前一个节点，当尾节点移除后，它就是尾节点</span></span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; prev = l.prev;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 因为尾节点是第一个节点，所以它的next自然为null</span></span><br><span class="line"><span class="comment">     * 把头结点的值和prev字段赋值为null，有助于GC回收</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    l.item = <span class="keyword">null</span>;</span><br><span class="line">    l.prev = <span class="keyword">null</span>; <span class="comment">// 有助于 GC</span></span><br><span class="line">  <span class="comment">//然后把prev作为头节点</span></span><br><span class="line">    last = prev;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 如果尾节点的前一个节点是null，那么说明列表中只有一个节点</span></span><br><span class="line"><span class="comment">     * 因此把first也赋值为null，说明至此链表中已无元素</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * 否则把尾结点的next字段置为null，说明该节点是尾节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (prev == <span class="keyword">null</span>)</span><br><span class="line">        first = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        prev.next = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 列表中元素数量减一</span></span><br><span class="line"><span class="comment">     * 修改次数加一</span></span><br><span class="line"><span class="comment">     * 返回被删除节点的值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    size--;</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="keyword">return</span> element;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="addFirst方法"><a href="#addFirst方法" class="headerlink" title="addFirst方法"></a>addFirst方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 在列表的开头插入指定的元素。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> e 要添加的元素</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addFirst</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    linkFirst(e);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 链接e作为第一个元素。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">linkFirst</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; f = first;</span><br><span class="line">    <span class="comment">//调用Node的构造方法，定义一个prev字段为null、next字段为f的newNode节点</span></span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; newNode = <span class="keyword">new</span> Node&lt;&gt;(<span class="keyword">null</span>, e, f);</span><br><span class="line">    <span class="comment">//然后把newNode作为头节点</span></span><br><span class="line">    first = newNode;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 如果原来的头节点f为空的话，说明列表中原来没有任何元素</span></span><br><span class="line"><span class="comment">     * 所以现在插入了一个新的节点，自然头节点和尾节点都是它，所以尾节点也是它。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (f == <span class="keyword">null</span>)</span><br><span class="line">        last = newNode;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *否则列表中原来不为空，只需要把新节点和原来的头节点连起来就好了</span></span><br><span class="line"><span class="comment">     *连起来的方法就是把原结点f的prev字段赋为现在的新头节点即可</span></span><br><span class="line"><span class="comment">     *即f节点是链表中第二个节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">        f.prev = newNode;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 元素数量加一</span></span><br><span class="line"><span class="comment">     * 修改次数加一</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    size++;</span><br><span class="line">    modCount++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="add和addLast方法"><a href="#add和addLast方法" class="headerlink" title="add和addLast方法"></a>add和addLast方法</h2><p>add和addLast方法中同是调用了linkLast方法，将新的元素添加到链表的尾部，二者的唯一却别就是add方法添加成功的话，会返回true表示插入成功，而addLast方法则无返回值，在内部实现上无任何区别。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *将指定的元素追加到此列表的末尾。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;这个方法相当于 addLast() 方法</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> e 要附加到此列表中的元素</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> true （由 Collection.add(E)指定） </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    linkLast(e);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将指定的元素追加到此列表的末尾。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;这个方法相当于 add() 方法</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> e 要添加的元素</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addLast</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    linkLast(e);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 链接e作为最后一个元素。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">linkLast</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; l = last;</span><br><span class="line">    <span class="comment">//定义一个前驱节点是last、后置节点是null的节点newNode，即将作为尾节点</span></span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; newNode = <span class="keyword">new</span> Node&lt;&gt;(l, e, <span class="keyword">null</span>);</span><br><span class="line">    <span class="comment">//把刚刚新定义的节点作为新的尾节点</span></span><br><span class="line">    last = newNode;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *如果原来的尾节点是null的话，说明原来列表中无元素，所以first自然也为null</span></span><br><span class="line"><span class="comment">     *所以这里新插入一个元素后，first和last节点同时指向仅有的一个元素节点</span></span><br><span class="line"><span class="comment">     *仅有的该元素节点既是头节点，也是尾节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (l == <span class="keyword">null</span>)</span><br><span class="line">        first = newNode;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 如果原来列表中元素不为空，就把新的尾节点和旧的尾节点连接起来</span></span><br><span class="line"><span class="comment">     * 方法就是把旧的尾节点的next字段置为新的尾节点，即l节点是倒数第二个节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">        l.next = newNode;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 元素数量加一</span></span><br><span class="line"><span class="comment">     * 修改次数加一</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    size++;</span><br><span class="line">    modCount++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="contains和indexOf方法"><a href="#contains和indexOf方法" class="headerlink" title="contains和indexOf方法"></a>contains和indexOf方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 如果此列表包含指定的元素，则返回true。更正式地说，当且仅当此列表包含至少一个元素e，使得Objects.equals(o, e)。</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> o 其在此列表中的存在性将被测试的元素</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; 如果此列表包含指定的元素</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *内部则调用indexOf方法，判断该元素的下标是否大于等于零</span></span><br><span class="line"><span class="comment"> *下标大于等于零则表示元素存在，如果不存在，indexOf方法会返回-1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">    <span class="keyword">return</span> indexOf(o) &gt;= <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *返回此列表中指定元素的第一个出现项的索引，如果该列表不包含该元素，则返回-1。</span></span><br><span class="line"><span class="comment"> *更正式地说，返回最低索引i满足Objects.equals(o, get(i))，如果没有这样的索引，则为-1。</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> o 要搜索的元素</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 此列表中指定元素的首次出现的索引，如果此列表不包含元素，则为-1 </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *因为LinkedList允许元素为null，所以要分开判断元素是null和非null的情况</span></span><br><span class="line"><span class="comment">     *因为null的判定方法是 == 号，而非null的元素则使用Objects.equals(o, get(i))方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (o == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *当要查找的元素是null的时候，从头节点first节点开始遍历</span></span><br><span class="line"><span class="comment">     *直到找到值为null或者节点为null为止，节点为null的也就是last之后的那个节点为止</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">        <span class="keyword">for</span> (Node&lt;E&gt; x = first; x != <span class="keyword">null</span>; x = x.next) &#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         *如果节点中的值为null，则返回其下标</span></span><br><span class="line"><span class="comment">         *否则继续向后遍历，下标加一</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">            <span class="keyword">if</span> (x.item == <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">return</span> index;</span><br><span class="line">            index++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *当要查找的元素是非null的时候，从头节点first节点开始遍历</span></span><br><span class="line"><span class="comment">     *直到找到o.equals(x.item)或者节点为空为止，也就是last之后的那个节点为止</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">        <span class="keyword">for</span> (Node&lt;E&gt; x = first; x != <span class="keyword">null</span>; x = x.next) &#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         *如果节点中的值为与要查找的节点一致，则返回其下标</span></span><br><span class="line"><span class="comment">         *否则继续向后遍历，下标加一</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">            <span class="keyword">if</span> (o.equals(x.item))</span><br><span class="line">                <span class="keyword">return</span> index;</span><br><span class="line">            index++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果遍历过整个链表都没有找到符合要求的节点的话，就返回-1</span></span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="size方法"><a href="#size方法" class="headerlink" title="size方法"></a>size方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 返回此列表中的元素数量。</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> 列表中元素的数量</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//即返回记录链表中元素数量的遍历size</span></span><br><span class="line">       <span class="keyword">return</span> size;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h2 id="remove方法"><a href="#remove方法" class="headerlink" title="remove方法"></a>remove方法</h2><p>remove方法有三个重载方法，分别是无参方法、传入下标和传入指定对象的方法。</p><h3 id="remove-Object-o"><a href="#remove-Object-o" class="headerlink" title="remove(Object o)"></a>remove(Object o)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  *从列表中删除指定元素的第一个出现项(如果存在)。如果这个列表不包含这个元素，它将保持不变。</span></span><br><span class="line"><span class="comment">  *更正式地说，删除索引i最低的元素，使得Objects.equals(o, get(i)) (如果存在这样一个元素)。</span></span><br><span class="line"><span class="comment">  *如果此列表包含指定的元素，则返回true(如果此列表由于调用而更改，则返回true)。</span></span><br><span class="line"><span class="comment">  * </span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> o 元素，如果存在，则从该列表中删除</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; 如果此列表包含指定的元素</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">if</span> (o == <span class="keyword">null</span>) &#123;</span><br><span class="line">     <span class="comment">/**</span></span><br><span class="line"><span class="comment">      *如果传入的对象是null，则遍历链表，找到第一个值为null的节点</span></span><br><span class="line"><span class="comment">      *然后调用unlink方法将其删除</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">         <span class="keyword">for</span> (Node&lt;E&gt; x = first; x != <span class="keyword">null</span>; x = x.next) &#123;</span><br><span class="line">             <span class="keyword">if</span> (x.item == <span class="keyword">null</span>) &#123;</span><br><span class="line">                 unlink(x);</span><br><span class="line">                 <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">     <span class="comment">/**</span></span><br><span class="line"><span class="comment">      *如果传入的对象是非null的，则遍历链表，找到第一个符合o.equals(x.item)的节点</span></span><br><span class="line"><span class="comment">      *然后调用unlink方法将其删除</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">         <span class="keyword">for</span> (Node&lt;E&gt; x = first; x != <span class="keyword">null</span>; x = x.next) &#123;</span><br><span class="line">             <span class="keyword">if</span> (o.equals(x.item)) &#123;</span><br><span class="line">                 unlink(x);</span><br><span class="line">                 <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">//如果删除成功，则返回true，否则返回false。</span></span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  *断开非空节点x的链接。</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="function">E <span class="title">unlink</span><span class="params">(Node&lt;E&gt; x)</span> </span>&#123;</span><br><span class="line">     <span class="comment">/**</span></span><br><span class="line"><span class="comment">      * 判断 x != null</span></span><br><span class="line"><span class="comment">      * 记录要删除的节点和其前驱节点和后置节点</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">     <span class="keyword">final</span> E element = x.item;</span><br><span class="line">     <span class="keyword">final</span> Node&lt;E&gt; next = x.next;</span><br><span class="line">     <span class="keyword">final</span> Node&lt;E&gt; prev = x.prev;</span><br><span class="line">     <span class="comment">/**</span></span><br><span class="line"><span class="comment">      *如果前驱节点是null的话，说明要删除的节点就是第一个节点</span></span><br><span class="line"><span class="comment">      *故删除后就把它的后置节点（也就是第二节点）作为新的头节点</span></span><br><span class="line"><span class="comment">      *</span></span><br><span class="line"><span class="comment">      *否则把前驱节点的下一个节点赋为当前节点的后一个节点</span></span><br><span class="line"><span class="comment">      *然后把当前节点的前驱节点置为null</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">     <span class="keyword">if</span> (prev == <span class="keyword">null</span>) &#123;</span><br><span class="line">         first = next;</span><br><span class="line">     &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         prev.next = next;</span><br><span class="line">         x.prev = <span class="keyword">null</span>;</span><br><span class="line">     &#125;</span><br><span class="line">     </span><br><span class="line">     <span class="comment">/**</span></span><br><span class="line"><span class="comment">      *如果后置节点是null的话，说明要删除的节点就是最后一个节点</span></span><br><span class="line"><span class="comment">      *故删除后就把它的前驱节点（也就是倒数第二个节点）作为新的头节点</span></span><br><span class="line"><span class="comment">      *</span></span><br><span class="line"><span class="comment">      *否则把后置节点的前一个节点赋为当前节点的前一个节点</span></span><br><span class="line"><span class="comment">      *然后把当前节点的后置节点置为null</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">     <span class="keyword">if</span> (next == <span class="keyword">null</span>) &#123;</span><br><span class="line">         last = prev;</span><br><span class="line">     &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         next.prev = prev;</span><br><span class="line">         x.next = <span class="keyword">null</span>;</span><br><span class="line">     &#125;</span><br><span class="line">     </span><br><span class="line">     <span class="comment">/**</span></span><br><span class="line"><span class="comment">      *经过上面两个if判断，当前节点的前驱节点和后置节点已经全部赋值为null</span></span><br><span class="line"><span class="comment">      *并且已经把它的前驱节点和后置节点相互连接了</span></span><br><span class="line"><span class="comment">      *这里当前节点把值赋为null，就意味着删除了，然后等待GC回收即可</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">     x.item = <span class="keyword">null</span>;</span><br><span class="line">     <span class="comment">/**</span></span><br><span class="line"><span class="comment">      *元素数量减一</span></span><br><span class="line"><span class="comment">      *修改次数加一</span></span><br><span class="line"><span class="comment">      *返回被删除的节点的值</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">     size--;</span><br><span class="line">     modCount++;</span><br><span class="line">     <span class="keyword">return</span> element;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h3 id="remove-int-index"><a href="#remove-int-index" class="headerlink" title="remove(int index)"></a>remove(int index)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 移除列表中指定位置的元素。将任何后续元素向左移动(从它们的索引中减去一个)。返回从列表中删除的元素。 </span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> index 要删除的元素的索引</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 先前位于指定位置的元素</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IndexOutOfBoundsException 表示某种索引(如数组索引、收敛索引或向量索引)超出范围。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 这里先对传入的下标进行检查，判断是否越界</span></span><br><span class="line"><span class="comment"> * 如果没有越界则使用node(index)方法找到指定位置的结点</span></span><br><span class="line"><span class="comment"> * 然后使用unlink方法将这个节点删除</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">    checkElementIndex(index);</span><br><span class="line">    <span class="keyword">return</span> unlink(node(index));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先看以下判断下标是否越界的checkElementIndex方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">checkElementIndex</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!isElementIndex(index))</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException(outOfBoundsMsg(index));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * checkElementIndex 方法实际调用了这个方法判断下标是否越界</span></span><br><span class="line"><span class="comment"> * 如果越界则抛出异常</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> index</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isElementIndex</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> index &gt;= <span class="number">0</span> &amp;&amp; index &lt; size;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在下标符合要求后，使用node方法查找到指定位置的节点：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 返回指定元素索引处的(非空)节点。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">Node&lt;E&gt; <span class="title">node</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 这里先判断要查找的下标是在链表的前半部分还是后半部分</span></span><br><span class="line"><span class="comment"> * 如果是在前半部分就从头指针开始查找</span></span><br><span class="line"><span class="comment"> * 如果是在后半部分就从尾指针开始查找</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">    <span class="keyword">if</span> (index &lt; (size &gt;&gt; <span class="number">1</span>)) &#123;</span><br><span class="line">    <span class="comment">//在前半部分，从头指针开始查找</span></span><br><span class="line">        Node&lt;E&gt; x = first;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; index; i++)</span><br><span class="line">            x = x.next;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">//在后半部分，从尾指针开始查找</span></span><br><span class="line">        Node&lt;E&gt; x = last;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = size - <span class="number">1</span>; i &gt; index; i--)</span><br><span class="line">            x = x.prev;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在使用node方法找到指定下标位置的节点之后，使用unlink方法将该节点删除掉，unlink方法在上面remove(Object o)方法中有讲过。</p><h3 id="remove"><a href="#remove" class="headerlink" title="remove()"></a>remove()</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 检索并删除此列表的头部(第一个元素)。</span></span><br><span class="line"><span class="comment"> * 该方法与removeFirst无差别，不多赘述，二者一模一样。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 这个列表的头</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> NoSuchElementException 如果这个列表是空的</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 1.5</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> removeFirst();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="lastIndexOf方法"><a href="#lastIndexOf方法" class="headerlink" title="lastIndexOf方法"></a>lastIndexOf方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 返回此列表中指定元素的最后一次出现的索引，如果该列表不包含该元素，则返回-1。</span></span><br><span class="line"><span class="comment"> * 更正式地说，返回最高索引i，满足Objects.equals(o, get(i))，如果没有这样的索引，则为-1。</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> o 要搜索的元素</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 此列表中指定元素的最后一次出现的索引，如果该列表不包含该元素，则为-1     </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lastIndexOf</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 这个方法实现indexOf方法唯一的区别就是：这个方法从后向前查找，而indexOf方法从前向后查找，其余部分无区别</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">    <span class="keyword">int</span> index = size;</span><br><span class="line">    <span class="keyword">if</span> (o == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (Node&lt;E&gt; x = last; x != <span class="keyword">null</span>; x = x.prev) &#123;</span><br><span class="line">            index--;</span><br><span class="line">            <span class="keyword">if</span> (x.item == <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">return</span> index;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (Node&lt;E&gt; x = last; x != <span class="keyword">null</span>; x = x.prev) &#123;</span><br><span class="line">            index--;</span><br><span class="line">            <span class="keyword">if</span> (o.equals(x.item))</span><br><span class="line">                <span class="keyword">return</span> index;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="toArray方法"><a href="#toArray方法" class="headerlink" title="toArray方法"></a>toArray方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 返回一个数组，该数组按适当的顺序(从第一个元素到最后一个元素)包含列表中的所有元素。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 返回的数组将是“安全的”，因为这个列表不维护对它的引用。(换句话说，这个方法必须分配一个新的数组)。</span></span><br><span class="line"><span class="comment"> * 因此，调用者可以自由地修改返回的数组。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 此方法充当基于数组和基于集合的api之间的桥梁。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 一个数组，按适当的顺序包含列表中的所有元素</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> Object[] toArray() &#123;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 实现方法就是先创建一个与size大小相等的数组</span></span><br><span class="line"><span class="comment"> * 然后从头结点开始遍历整个链表，把链表中的每个节点的值存入数组中</span></span><br><span class="line"><span class="comment"> * 最后把数组返回</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">    Object[] result = <span class="keyword">new</span> Object[size];</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (Node&lt;E&gt; x = first; x != <span class="keyword">null</span>; x = x.next)</span><br><span class="line">        result[i++] = x.item;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 以正确的顺序返回一个包含此列表中所有元素的数组（从第一个到最后一个元素）; </span></span><br><span class="line"><span class="comment"> * 返回的数组的运行时类型是指定数组的运行时类型。</span></span><br><span class="line"><span class="comment"> * 如果列表适合指定的数组，则返回其中。 否则，将为指定数组的运行时类型和此列表的大小分配一个新数组。 </span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 如果列表适用于指定的数组，并有空余余地（即数组的列表null更多），</span></span><br><span class="line"><span class="comment"> * 则紧跟在列表末尾的数组中的元素设置为null 。 （这仅在调用者知道列表不包含任何空元素的情况下才能确定列表的长度。） </span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 像toArray()方法一样，此方法充当基于阵列和基于集合的API之间的桥梁。 </span></span><br><span class="line"><span class="comment"> * 此外，该方法允许精确地控制输出阵列的运行时类型，并且在某些情况下可以用于节省分配成本。 </span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 假设x是一个已知只包含字符串的列表。 以下代码可用于将列表转储到新分配的String数组中： </span></span><br><span class="line"><span class="comment"> * String[] y = x.toArray(new String[0]); </span></span><br><span class="line"><span class="comment"> * 请注意， toArray(new Object[0])功能与toArray()相同。 </span></span><br><span class="line"><span class="comment"> *   </span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> a  要存储列表的元素的数组，如果它足够大; 否则，为此目的分配相同运行时类型的新数组。 </span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 一个包含列表元素的数组 </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> ArrayStoreException 如果指定数组的运行时类型不是此列表中每个元素的运行时类型的父类型 </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> NullPointerException 如果指定的数组为空</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; T[] toArray(T[] a) &#123;</span><br><span class="line"><span class="comment">//先检查传入的数组长度是否足够，如果不够就将数组扩容为size大小</span></span><br><span class="line">    <span class="keyword">if</span> (a.length &lt; size)</span><br><span class="line">        a = (T[])java.lang.reflect.Array.newInstance(</span><br><span class="line">                            a.getClass().getComponentType(), size);</span><br><span class="line">    <span class="comment">//在容量足够的前提下，将链表中的元素按顺序放入数组中</span></span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    Object[] result = a;</span><br><span class="line">    <span class="keyword">for</span> (Node&lt;E&gt; x = first; x != <span class="keyword">null</span>; x = x.next)</span><br><span class="line">        result[i++] = x.item;</span><br><span class="line">    <span class="comment">//将第一个空出来的位置赋值为null，表示无元素</span></span><br><span class="line">    <span class="keyword">if</span> (a.length &gt; size)</span><br><span class="line">        a[size] = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="队列操作的方法"><a href="#队列操作的方法" class="headerlink" title="队列操作的方法"></a>队列操作的方法</h2><p>因为Queue和Deque都是使用LinkedList实现的，所以这里也顺便提一下把，但是实际上有关队列操作的方法实则都是使用上面的核心方法实现的，所以这里就列一个表格对比一下：</p><ul><li>peek() ：等于getFirst()方法，唯一区别就是当链表为空时，peek方法返回null，getFirst抛出异常。</li><li>element()：等于getFirst()方法。</li><li>poll()：等于removeFirst()方法，唯一区别就是当链表为空时，poll方法返回null，removeFirst抛出异常。</li><li>remove():等于removeFirst()方法。</li><li>offer()：等于add()方法。</li><li>offerFirst()：等于addFirst()方法。</li><li>offerLast()：等于addLas()方法。</li><li>peekFirst()：等于peek()方法。</li><li>peekLast()：等于getLast()方法，唯一区别就是当链表为空时，peekLast方法返回null，getLast抛出异常。</li><li>pollFirst()：等于removeFirst()方法，唯一区别就是当链表为空时，pollFirst方法返回null，removeFirst抛出异常。</li><li>pollLast()：等于removeLast()方法，唯一区别就是当链表为空时，pollLast方法返回null，removeLast抛出异常。</li><li>push()：等于addFirst()方法.</li><li>pop()：等于removeFirst()方法。</li><li>removeFirstOccurrence()：等于remove()方法。</li><li>removeLastOccurrence()：等于removeLast()方法。</li></ul><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>总体来说，LinkedList的源码十分简单，从源码中可以简单得出以下几点：</p><ul><li>LinkedList的底层是双向链表。</li><li>有序。链表是有序的。</li><li>元素可重复，元素可为null。</li><li>随机访问效率低，增删效率高。</li></ul>]]></content>
    
    <summary type="html">
    
      在List接口实现的类中，最常用的一个类：LinkedList，常被用来实现队列和类似于ArrayList的数据结构。
    
    </summary>
    
      <category term="Java容器" scheme="http://yoursite.com/categories/Java%E5%AE%B9%E5%99%A8/"/>
    
    
  </entry>
  
  <entry>
    <title>MySQL整体架构</title>
    <link href="http://yoursite.com/posts/10568/"/>
    <id>http://yoursite.com/posts/10568/</id>
    <published>2019-09-10T12:19:13.000Z</published>
    <updated>2019-09-18T11:59:25.108Z</updated>
    
    <content type="html"><![CDATA[<h1 id="MySQL逻辑架构"><a href="#MySQL逻辑架构" class="headerlink" title="MySQL逻辑架构"></a>MySQL逻辑架构</h1><p>MySQL服务器逻辑架构图<br><img src="/posts/10568/838913-fb7f263a0d00afe7.webp" alt><br>如图所示，MySQL的架构是三层架构，具体介绍如下：</p><ul><li>最上层的服务（层）并不是MySQL独有的，大多数基于网络的客户端/服务器的工具或者服务都有类似的架构。这层的主要作用是连接处理、授权认证、安全等等。</li><li>第二层架构的是MySQL核心服务层，大多数MySQL的核心服务功能都在这一层，包括查询解析、分析、优化、缓存以及所有的内置函数，所有的跨存储引擎的功能都在这一层实现：存储过程、触发器、视图等。</li><li>第三层包括了存储引擎。存储引擎负责MySQL中数据的存储和提取。存储引擎不会去解析SQL（InnoDB例外，它会解析外键定义，因为MySQL服务器本身没有实现该功能），不同的存储引擎之间也不会相互通信，而只是简单地响应上层服务器的请求。</li></ul><h2 id="连接管理与安全性"><a href="#连接管理与安全性" class="headerlink" title="连接管理与安全性"></a>连接管理与安全性</h2><p>每个客户端都会在服务器进程中拥有一个线程，这个连接的查询只会在这个单独的线程中执行，该线程只能轮流在某个CPU核心或者CPU中运行。服务器会负责缓存线程，因此不需要为每一个新建的连接创建或者销毁线程。</p><p>当客户端连接到MySQL服务器时，服务器需要对其进行认证，认证基于用户名、原始主机信息和密码。</p><h2 id="优化与执行"><a href="#优化与执行" class="headerlink" title="优化与执行"></a>优化与执行</h2><p>MySQL会<strong>解析查询</strong>，并创建内部数据结构———解析树，然后对其进行各种优化，包括重写查询，决定表的读取顺序、以及选择合适的索引等。</p><p>用户可以通过特殊的关键字提示优化器，影响它的决策过程；也可以请求优化器解释优化过程的各个因素，使用户可以知道服务器是如何进行优化决策的，并提供一个参考基准，便于用户重构优化。</p><p>对于SELECT语句，在解析查询之前，<strong>服务器会先检查查询缓存</strong>，如果能在其中找到对应的查询，服务器就不必再执行<strong>查询解析、优化、和执行整个过程</strong>，而是直接返回查询缓存中的结果集。</p><h1 id="并发控制"><a href="#并发控制" class="headerlink" title="并发控制"></a>并发控制</h1><p>这里讨论MySQL在两个层面的并发控制：服务器层和存储引擎层。</p><h2 id="读写锁"><a href="#读写锁" class="headerlink" title="读写锁"></a>读写锁</h2><p>在处理并发或者写时，可以通过实现一个由两种类型的锁组成的锁系统来解决问题。这两种类型的锁通常被称为<strong>共享锁（shared lock）</strong>和<strong>排他锁（exclusive lock）</strong>，也叫<strong>读锁（read lock）</strong>和<strong>写锁（write lock）</strong>。</p><ul><li>读锁：是共享的，也就是相互不阻塞的。多个客户端在同一时刻可以同时读取同一个资源，而互不干扰。</li><li>写锁：是排他的，也就是一个写锁会阻塞其他的写锁和读锁，确保在给定的时间里，只有一个用户能执行写入，并防止其他用户读取正在写入的同一资源。</li></ul><h2 id="锁粒度"><a href="#锁粒度" class="headerlink" title="锁粒度"></a>锁粒度</h2><p>一种提高共享资源并发性的方式就是让锁定对象更有选择性。尽量只锁定需要修改的部分数据，而不是所有的资源。更理想的方式是：只对会修改的数据片进行精确的锁定。下面是两种最重要的锁策略：<strong>表锁和行级锁。</strong></p><h3 id="表锁"><a href="#表锁" class="headerlink" title="表锁"></a>表锁</h3><p><strong>表锁（table lock）是MySQL中最基本的锁策略，并且是开销最小的策略：它会锁定整张表。</strong></p><p>在特定场景表锁可能有良好的性能。另外，<strong>写锁也比读锁有更高的优先级</strong>，因此一个写锁请求可能会被插入到读锁列表的前面，反之读锁则不能插入到写锁的前面。</p><p>尽管存储引擎可以管理自己的锁，MySQL本身还是会使用各种有效的表锁来实现不同的目的。例如服务器会为ALTER TABLE之类的语句使用表锁，而忽略存储引擎的锁机制。</p><h3 id="行级锁"><a href="#行级锁" class="headerlink" title="行级锁"></a>行级锁</h3><p>行级锁可以最大程度的支持并发，同时开销也最大。</p><p>行级锁只在存储引擎层实现，而MySQL服务层没有实现。</p><h1 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h1><p><strong>事务就是一组原子性的SQL查询，或者说一个独立的工作单元。</strong>如果数据库引擎能够成功的对数据库应用该组查询的全部语句，那么就执行该组查询。如果其中有任何一条语句因为崩溃或其他原因无法执行，那么所有的语句都不会执行。也就是说，<strong>事务内的语句，要么全部执行成功，要么全部执行失败。</strong></p><p>可以同<code>START TRANSACTION</code>开始一个事务，然后要么用<code>COMMIT</code>提交事务将修改的数据持久保留，要么使用<code>ROLLBACK</code>撤销所有的修改。</p><p><strong>数据库的特性有四条，简称为ACID，分别是：原子性（atomicity）、一致性（consistency）、隔离性（isolated）和持久性（durability）。</strong></p><ul><li><strong>原子性（atomicity）</strong>：<strong>一个事务必须被视为一个不可分割的最小工作单元</strong>，整个事务操作要么全部提交成功，要么全部失败回滚，对于一个事务来说，不可能只执行其中一部分操作，这就是事务的原子性。</li><li><strong>一致性（consistency）</strong>：<strong>数据库总是从一个一致性的状态转换到另一个一致性的状态。</strong></li><li><strong>隔离性（isolated）</strong>：<strong>通常来说，一个事务所做的修改在最终提交以前，对其他事务是不可见的。</strong>这里的“通常来说”与隔离级别有关。</li><li><strong>持久性（durability）</strong>：<strong>一旦事务提交，则其所做的修改就会永久保存到数据库中。</strong>此时即使系统崩溃，修改的数据也不会丢失。</li></ul><h2 id="隔离级别"><a href="#隔离级别" class="headerlink" title="隔离级别"></a>隔离级别</h2><p>在SQL标准中，定义了四种隔离级别。较低级别的隔离通常可以执行更高的并发，系统的开销也更低。</p><ul><li><strong>READ UNCOMMITED（未提交读）</strong>：在READ UNCOMMITTED级别，事务中的修改，即使没有提交，对其他事务也都是可见的。事务可以读取未提交的数据，这也称为<strong>脏读（Dirty Read）</strong>。这个级别会导致很多问题，而从性能上来讲却并不会比其他级别好太多，但缺少其他级别的很多好处，在实际使用中很少使用。</li><li><strong>READ COMMITTED（提交读）</strong>：大多数数据库系统的默认隔离级别都是READ COMMITTED（但MySQL不是）。这个级别满足隔离性。这个级别有时候也叫做不可重复读，因为两次执行同样的查询，可能会得到不一样的结果。</li><li><strong>REPEATABLE READ（可重复读）</strong>：这一级别解决了脏读的问题，该级别保证了在同一个事务中多次读取同样记录的结果是一致的。但是理论上，可重复读级别还是无法结局<strong>幻读</strong>问题：当某个事务再次读取某个范围内的记录时，另外一个事务又在该范围内插入了新的记录，当之前的事务再次读取该范围内的记录时，会产生幻行。InnoDB和XtraDB存储引擎通过多版本并发控制（MVCC）解决了幻读问题。<strong>可重复读是MySQL的默认事务隔离级别。</strong></li><li><strong>SERIALIZABLE（可串行化）</strong>：<strong>这个级别是最高的隔离级别，通过强制事务串行执行，避免了幻读问题。</strong>即会再读取的每一行数据上都加上锁，所以可能导致大量的超时和锁争用问题，只要在非常需要确保数据一致性而且可以接受没有并发的情况下，才考虑使用该级别。</li></ul><p><img src="/posts/10568/TIM%E5%9B%BE%E7%89%8720190910214739.png" alt></p><h2 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h2><p><strong>死锁是指两个或者多个事务在同一资源上相互占用，并请求锁定对方占用的资源，从而导致恶性循环的现象。</strong></p><p>为了解决这种问题，数据库实现了各种死锁检测和死锁超时机制。一种解决方式是当查询的时间达到锁等待超时的设定后放弃锁请求，这种方式通常来说不太友好。<strong>InnoDB目前处理死锁的方法是：将持有最少行级排他锁的事务进行回滚。</strong></p><p>死锁产生有双重原因：有些是因为真正的数据冲突，但有些则完全由于存储引擎的实现方式导致的。死锁发生以后，只有部分或者完全回滚其中一个事务，才能打破死锁。</p><h2 id="事务日志"><a href="#事务日志" class="headerlink" title="事务日志"></a>事务日志</h2><p><strong>使用事务日志在修改表的数据时只需要修改其内存拷贝，再把该修改行为记录到持久在硬盘上的事务日志中，而不用每次都将修改的数据本身持久到磁盘。</strong></p><p>事务日志采用的是追加的方式，因此写日志的操作是磁盘上一小块区域的顺序I/O，所以采用事务日志的方式相对来说要快很多。</p><p>事务日志持久化以后，内存中被修改的数据在后台可以慢慢地刷回到磁盘。因此通常称之为预写式日志，修改数据需要写两次磁盘。</p><p><strong>如果数据的修改已经记录到事务日志并持久化，但数据本身还没有写回磁盘，此时系统崩溃，存储引擎在重启时能够自动恢复这部分修改等数据。</strong></p><h2 id="MySQL中的事务"><a href="#MySQL中的事务" class="headerlink" title="MySQL中的事务"></a>MySQL中的事务</h2><p>MySQL提供了两种事务型的存储引擎：InnDB和NDB Cluster。另外还有一些第三方的存储引擎也支持事务，例如XtraDB和PBXT。</p><h3 id="自动提交"><a href="#自动提交" class="headerlink" title="自动提交"></a>自动提交</h3><p>MySQL默认采用自动提交（AUTOCOMMIT）模式，也就是说，如果不是显式地开始一个事务，则每个查询都被当作一个事务执行提交操作。可以通过<code>SET AUTOCOMMIT = ON/OFF</code>来 开启/关闭 自动提交模式。</p><p>MySQL可以通过执行<br><code>SET [GLOBAL | SESSION] TRANSATION ISOLATION LEVEL  READ UNCOMMITTED| READ COMMITTED| REPEATABLE READ| SERIALIZABLE</code>来设置全局/当前会话的隔离级别，新的隔离级别会在下一个事务开始的时候生效。</p><h3 id="隐式和显式锁定"><a href="#隐式和显式锁定" class="headerlink" title="隐式和显式锁定"></a>隐式和显式锁定</h3><p>InnoDB采用的是<strong>两阶段锁定协议</strong>。<strong>在执行过程中，随时都可以执行锁定，锁只有在执行COMMIT或者ROLLBACK的时候才会释放，并且所有的锁都是在同一时刻被释放。</strong>这就是隐式锁定。</p><p>InnoDB也支持通过特定的语句进行显式锁定：<code>SELECT ... LOCK IN SHARE MODE</code> 和 <code>SELECT ... FOR UPDATE</code>,MySQL也支持<code>LOCK TABLES</code>和<code>UNLOCK TABLES</code>语句，这是在服务层实现的，和存储引擎无关。</p><p>显示的使用这些语句不但没有必要，还会严重影响性能，实际上InnoDB的行级锁工作的更好，<strong>所以应当尽量避免使用LOCK TABLES。</strong></p><h1 id="多版本并发控制"><a href="#多版本并发控制" class="headerlink" title="多版本并发控制"></a>多版本并发控制</h1><p>MySQL的大多数事务型存储引擎实现的都不是简单的行级锁，基于提升并发性能的考虑，它们一般都同时实现了<strong>多版本并发控制（MVCC）</strong>。可以认为MVCC是行级锁的一个变种，但是它在很多情况下避免了加锁操作，因此开销更低。虽然实现机制有可能不同，但大都<strong>实现了非阻塞的读操作，写操作也只锁定必要的行。</strong></p><p><strong>MVCC的实现是通过保存数据在某个时间点的快照来实现的。</strong>也就是说，不管需要执行多长时间，每个事务看到的数据都是一致的。根据事务开始的时间不同，每个事务对同一张表，同一时刻看到的数据可能是不一样的。</p><p><strong>InnoDB的MVCC是通过在每行记录后面保存两个隐藏的列来实现的。这两个列，一个保存了行的创建时间，一个保存行的过期时间（或删除时间）。当然存储的不是实际的时间值，而是系统版本号。每开始一个新的事务，系统版本号都会递增。事务开始时刻的系统版本号会作为事务的版本号，用来和查询到的每行记录的版本号进行比较。</strong></p><ul><li><p><strong>SELECT</strong>：InnoDB会根据以下两个条件检查每行记录： </p><blockquote><ul><li><strong>InnoDB只查找早于当前事务版本的数据行</strong>（即行的系统版本号小于或等于事务的系统版本号），这样可以确保读取的行要么在事务开始前已经存在，要么是事务自身插入或者修改过的。</li><li><strong>行的删除要么未定义，要么大于当前事务版本号。</strong>这样可以确保读取的行在事务开始之前未被删除。</li></ul></blockquote></li><li><p><strong>INSERT</strong>：InnoDB为新插入的每一行保存当前系统版本号作为行版本号。</p></li><li><p><strong>DELETE</strong>：InnoDB为删除的每一行保存当前系统版本号作为行删除标识。</p></li><li><p><strong>UPDATE</strong>：<strong>InnoDB为插入一行新记录，</strong>保存当前系统版本号作为行版本号，<strong>同时保存当前系统版本号到原来的行作为行删除标识。</strong></p></li></ul><p><strong>保存这两个额外系统版本号，优点就是使大多数读操作都可以不用加锁，读数据操作很简单，性能很好，并且也能保证只会读取到符合标准的行。缺点就是每行记录都需要额外的存储空间，需要做更多的行检查工作，以及一些额外的维护工作。</strong></p><p><strong>MVCC只在 REPEATABLE READ（可重复读）和READ COMMITTED（提交读）两个隔离级别下工作</strong>，因为READ UNCOMMITTED总是读取最新的数据行，而SERIALIZABLE则会对所有读取的行加锁。</p><h1 id="MySQL的存储引擎"><a href="#MySQL的存储引擎" class="headerlink" title="MySQL的存储引擎"></a>MySQL的存储引擎</h1><p>可以使用<code>SHOW TABLE STATUS</code> 命令显示表的相关信息。例如：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show table status like 'user' \G</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">           Name: user//表名</span><br><span class="line">         Engine: InnoDB//表引擎</span><br><span class="line">        Version: 10//版本</span><br><span class="line">     Row_format: Dynamic//行的格式。Dynamic的行长度是可变的，一般包含可变长度的字段，如VARCHAR</span><br><span class="line">//；Fixed的行长度则是固定的，只包含固定长度的列，如CHAR。Compressed的行只在压缩</span><br><span class="line">//表中存在。</span><br><span class="line">           Rows: 5//表中的行数，MyISAM和其他一些存储引擎是精确值，但InnoDB是估计值。</span><br><span class="line"> Avg_row_length: 59//平均每行包含的字节数</span><br><span class="line">    Data_length: 16384//表数据的大小（字节）</span><br><span class="line">Max_data_length: 0//表的最大数据容量，该值与存储引擎关</span><br><span class="line">   Index_length: 0//索引的大小</span><br><span class="line">      Data_free: 0//对于MyISAM表，表示已分配但目前没有使用的空间</span><br><span class="line"> Auto_increment: 6//下一个AUTO_INCREMENT的值</span><br><span class="line">    Create_time: 2018-11-19 20:58:21//表的创建时间</span><br><span class="line">    Update_time: NULL//表数据的最后修改时间</span><br><span class="line">     Check_time: NULL//使用<span class="keyword">CHECK</span> <span class="keyword">TABLE</span>命令或者myisamchk工具最后一次检查表的时间</span><br><span class="line">      <span class="keyword">Collation</span>: utf8_general_ci//表的默认字符集和字符列排序规则</span><br><span class="line">       <span class="keyword">Checksum</span>: <span class="literal">NULL</span>//如果启用，保存的是整个表的实时校验和</span><br><span class="line"> Create_options://创建表时指定的其他选项</span><br><span class="line">        <span class="keyword">Comment</span>://建表时的备注</span><br><span class="line"><span class="number">1</span> <span class="keyword">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure><h2 id="InnoDB存储引擎"><a href="#InnoDB存储引擎" class="headerlink" title="InnoDB存储引擎"></a>InnoDB存储引擎</h2><p>InnoDB是MySQL的默认事务型引擎，也是最重要、使用最广泛的存储引擎。它被设计用来处理大量的短期事务，短期事务大部分情况是正常提交的，很少会回滚。InnoDB的性能和自动崩溃恢复特性，使得它在非事务型存储的需求中也很流行。</p><p>InnoDB的数据存储在表空间长，表空间是由InnoDB管理的一个黑盒子，有一系列的数据文件组成，InnoDB可以将每个表的数据和索引存放在单独的文件中。</p><p>InnoDB采用MVCC来支持高并发，并且实现了四个标准的隔离级别，默认为REPATABLE READ，并且通过<strong>间隙锁（next-key locking）</strong>策略防止幻读的出现。间隙锁使得InnoDB不仅仅锁定查询涉及的行，还会对索引中的间隙进行锁定，以防止幻影行的插入。</p><p>InnoDB表是基于聚簇索引建立的，聚簇索引对主键查询有很高的性能，不过它的二级索引中必须包含主键列。因此若表上的索引较多的话，主键应当尽可能的小。InnoDB是平台独立的，可以将数据和索引文件在平台之间拷贝。</p><p>InnoDB内部做了很多优化，包括从磁盘读取数据时采用的可预测性预读，能够自动在内存中创建hash索引以及加速读操作的自适应哈希索引，以及能够加速插入操作的插入缓冲区等。</p><h2 id="MyISAM存储引擎"><a href="#MyISAM存储引擎" class="headerlink" title="MyISAM存储引擎"></a>MyISAM存储引擎</h2><p>M有IASM是MySQL5.1之前的默认存储引擎。MyISAM提供了大量的特性，包括全文索引、压缩、空间函数等，但MyIASM不支持事务和行级锁，而且有一个<strong>最大的缺陷就是崩溃后无法安全恢复。</strong></p><h3 id="存储"><a href="#存储" class="headerlink" title="存储"></a>存储</h3><p>MyIASM会将表存储在两个文件中：<strong>数据文件和索引文件</strong>，分别以.MYD和.MYI为扩展名。MyIASM表可以包含动态或者静态行。MySQL会根据表的定义来决定采用何种行格式。MyIASM表可以存储的行记录数，一般<strong>受限于可用的磁盘空间，或者操作系统中单个文件的最大尺寸。</strong></p><p>在MySQL5.0中，MyIASM表如果是可变行，则默认配置只能处理256TB的数据，可以通过修改表单<code>MAX_ROWS</code>和<code>AVG_ROW_lENGTH</code>选项的值来实现，两者相乘就是表可能达到的最大大小。修改这两个参数会导致重建整个表和表的所有索引，这可能需要很长的时间才能完成。</p><h3 id="MyIASM特性"><a href="#MyIASM特性" class="headerlink" title="MyIASM特性"></a>MyIASM特性</h3><ul><li><strong>加锁与并发</strong>：<strong>MyIASM对整张表加锁</strong>，而不是针对行。<strong>读取时会对需要读到的表加共享锁，写入时则对表加排他锁。但是在表有读取查询的同时，也可以往表中插入新的记录（也被称为并发插入）</strong>。</li><li><strong>修复</strong>：对于MyIASM表，<strong>MySQL可以手工或者自动检查和修复操作。</strong>执行表的修复可能导致一些数据的丢失，而且修复操作是非常慢的。可以通过<code>CHECK TABLE mytable</code>检查表的错误，如果有错误可以通过执行<code>REPAIR TABLE mytable</code>来修复，或者使用myiasmchk命令行工具也可以。</li><li><strong>索引特性</strong>：对于MyIASM表，即使是BLOB和TEXT等长字段，也可以基于其前500个字符创建索引。MyIASM也支持全文索引，这是一种基于分词创建的索引。</li><li><strong>延迟更新索引键（Delayed Key Write）</strong>：如果在创建MyIASM表时指定了<code>DELAY_KEY_WRITE</code>选项，在每次修改执行完时，不会立刻将修改的索引数据写入磁盘，而是会写到内存中的<strong>键缓冲区</strong>，只有在清理键缓冲区或者关闭表的时候才会将对应的索引块写入到磁盘。这种方式可以极大的提升写入性能。</li></ul><h3 id="MyIASM压缩表"><a href="#MyIASM压缩表" class="headerlink" title="MyIASM压缩表"></a>MyIASM压缩表</h3><p>如果表在创建并导入以后，不会再进行修改操作，那么这样得表更适合采用MyIASM压缩表。</p><p>可以使用myiaspack对MyIASM表进行压缩。<strong>压缩表是不能进行修改的（除非先将表解压、修改数据、然后再次压缩）</strong>。压缩表可以极大的减少磁盘空间占用，减少磁盘I/O，从而提升查询性能。压缩表也支持索引，但索引也是只读的。</p><h3 id="MyIASM性能"><a href="#MyIASM性能" class="headerlink" title="MyIASM性能"></a>MyIASM性能</h3><p><strong>MyIASM引擎数据以紧密格式存储</strong>，所以在默写场景下的性能很好。</p><p>MyIASM有一些服务器级别的性能扩展限制，比如对索引键缓冲区的Mutex锁，MariaDB基于段的索引键缓冲区机制来避免该问题，性能上的表锁问题。</p><h2 id="选择合适的引擎"><a href="#选择合适的引擎" class="headerlink" title="选择合适的引擎"></a>选择合适的引擎</h2><p>对于如何选择存储引擎，可以简单的归纳为一句话：<strong>除非需要用到某些InnoDB不具备的特性，并且没有其他办法可以代替，否则都应该优先选择InnoDB引擎</strong>。</p><p><strong>除非万不得已，否则建议不要混合使用多种存储引擎，佛祖额可能带来一系列复杂的问题，以及一些潜在的bug和边界问题。</strong></p><p>如果需要不同的存储引擎，应先考虑以下几个因素：</p><ul><li>事务：如果应用到事务，那么InnoDB是目前最稳定并且经过沿着轨道选择。如果不需要事务，并且主要是SELECT和INSERT操作，那么MyISAM是不错的选择。</li><li>备份：如果需要在线热备份，那么选择InnoDB就是基本的要求。</li><li>崩溃恢复：建议选择InnoDB，因为拥有自动恢复功能。</li><li>特有的特性：有些应用可能依赖一些存储引擎所独有的特性或者优化，比如聚簇索引的优化，应该综合各种情况考虑，选择满足特殊情况下最优的引擎。</li></ul><h2 id="转换表的引擎"><a href="#转换表的引擎" class="headerlink" title="转换表的引擎"></a>转换表的引擎</h2><p>转换表的引擎有三种方法：</p><ul><li><strong>ALTER TABLE</strong>：将表从一个引擎修改为另一个引擎最简单的办法是使用<code>ALTER TABLE</code>语句。例如：<code>ALTER TABLE mytable ENGINE = InnoDB</code>。<strong>这种语法是用于任何存储引擎，但是有一个缺点：需要执行很长时间。</strong>MySQL会按照行将数据从原表复制到一张新的表，在复制期间可能会消耗系统所有的I/O能力，同时原表会加上锁。<strong>同时如果转换表的存储引擎，将会失去和引擎相关的所有特性.</strong></li><li><strong>导出与导入</strong>：可以使用mysqldump工具将数据导出到文件，然后修改文件中<code>CREATE TABLE</code>语句的存储引擎选项。</li><li><strong>创建与查询</strong>：这种方法不需要导出整个表，而是先创建一个新的存储引擎的表，然后利用INSERT–SELECT语法来导数据。<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> innodb_table <span class="keyword">LIKE</span> myisam_table;</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> innodb_table <span class="keyword">ENGINE</span> = <span class="keyword">InnoDB</span>;</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> innodb_table (<span class="keyword">SELECT</span> * <span class="keyword">FROM</span> myisam_table);</span><br></pre></td></tr></table></figure></li></ul><p>当然如果数据量很大的情况下，可以采用分批导入的方法。</p>]]></content>
    
    <summary type="html">
    
      概要地描述了MySQL的服务器架构、各种存储引擎之间的主要区别，以及这些区别的重要性。
    
    </summary>
    
      <category term="MySQL数据库" scheme="http://yoursite.com/categories/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
  </entry>
  
  <entry>
    <title>类加载器</title>
    <link href="http://yoursite.com/posts/16040/"/>
    <id>http://yoursite.com/posts/16040/</id>
    <published>2019-09-06T09:19:20.000Z</published>
    <updated>2019-09-14T12:59:05.315Z</updated>
    
    <content type="html"><![CDATA[<h1 id="类与类加载器"><a href="#类与类加载器" class="headerlink" title="类与类加载器"></a>类与类加载器</h1><p><strong>对于任意一个类，都需要由加载它的类加载器和这个类本身一同确立其在Java虚拟机中的唯一性，每一个类加载器，都拥有一个独立的类名称空间。</strong></p><p>上面这句话的意思即：<strong>比较两个类是否“相等”，只有在这两个类是由同一个类加载器加载的前提下才有意义，否则，即使这两个类来源于同一个Class文件，被同一个虚拟机加载，只要加载它们的类加载器不同，那这两个类就必定不相等。</strong></p><h1 id="双亲委派模型"><a href="#双亲委派模型" class="headerlink" title="双亲委派模型"></a>双亲委派模型</h1><p>从Java虚拟机的角度来讲，只存在两种不同的类加载器：<strong>一种是启动类加载器（Bootstrap ClassLoader），这个类加载器使用C++语言实现，是虚拟机自身的一部分；另一种就是所有其他的类加载器，这些加载器都由Java语言实现，独立于虚拟机外部，并且全都继承自抽象类java.lang.ClassLoader。</strong></p><p>以下是三种系统提供的主要的类加载器：</p><ul><li><strong>启动类加载器（Bootstrap ClassLoader）</strong>：这个类加载器负责将存放在<java_home>\lib目录中的，或者被<code>-Xbootclasspath</code>参数所指定的路径中的，并且是虚拟机识别的类库加载到虚拟机内存中。启动类加载器无法被Java程序直接引用。</java_home></li><li><strong>扩展类加载器（Extension ClassLoader）</strong>：这个加载器它负责加载<java_home>\lib\ext目录中的，或者被java.ext.dirs系统变量所指定的路径中的所有类库，开发者可以直接使用扩展类加载器。</java_home></li><li><strong>应用程序类加载器（Application ClassLoader）</strong>：由于这个类加载器是ClassLoader中的getSystemClassLoader()方法的返回值，所以一般也称它为系统类加载器。它负责加载用户类路径（ClassPath）上所指定的类库，开发者可以直接使用这个类加载器。一般情况下这个就是应用程序中默认的类加载器。</li></ul><p>下图展示的类加载器之间的这种层次关系，称为类加载器的双亲委派模型。<img src="/posts/16040/classloader_WPS%E5%9B%BE%E7%89%87.png" alt></p><p><strong>双亲委派模型要求除了顶层的启动类加载器之外，其余的类加载器都应当有自己的父类加载器，</strong>这里类加载器之间的父子关系一般不会以继承的关系来实现，而是都使用组合关系来复用父加载器的代码。</p><p>双亲委派模型并不是一个强制性的约束模型，而是Java设计者推荐给开发者的一种类加载器实现方式。</p><p>每个类加载都有一个父类加载器，通过下面的程序来验证。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassLoaderDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"ClassLodarDemo's ClassLoader is "</span> + ClassLoaderDemo.class.getClassLoader());</span><br><span class="line">        System.out.println(<span class="string">"The Parent of ClassLodarDemo's ClassLoader is "</span> + ClassLoaderDemo.class.getClassLoader().getParent());</span><br><span class="line">        System.out.println(<span class="string">"The GrandParent of ClassLodarDemo's ClassLoader is "</span> + ClassLoaderDemo.class.getClassLoader().getParent().getParent());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ClassLodarDemo<span class="string">'s ClassLoader is sun.misc.Launcher$AppClassLoader@18b4aac2</span></span><br><span class="line"><span class="string">The Parent of ClassLodarDemo'</span>s ClassLoader is sun.misc.Launcher$ExtClassLoader@<span class="number">1</span>b6d3586</span><br><span class="line">The GrandParent of ClassLodarDemo<span class="string">'s ClassLoader is null</span></span><br></pre></td></tr></table></figure><p>由结果可以看出AppClassLoader的父类加载器为ExtClassLoader，ExtClassLoader的类父加载器为null，但是null并不代表没有父类加载，而是BootstrapClassLoader。</p><p>双亲委派模型这里的<code>双亲</code>更多的表达的是“父母这一辈人而已，并不是说真的有一个Mother ClassLoader和一个Father ClassLoader”。</p><p>双亲委派模型的工作过程是：<strong>如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成，每一层次的类加载器都是如此，因此所有的加载请求最终都应该传送到顶层的类加载器中，只有当父类加载器反馈自己无法完成这个请求（它的搜索范围中没有找到所需的类）时，子加载器才会尝试自己去加载。</strong></p><p>双亲委派模型的源码实现如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ClassLoader parent; </span><br><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; loadClass(String name, <span class="keyword">boolean</span> resolve)</span><br><span class="line">        <span class="keyword">throws</span> ClassNotFoundException</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (getClassLoadingLock(name)) &#123;</span><br><span class="line">            <span class="comment">// 首先，检查请求的类是否已经被加载过</span></span><br><span class="line">            Class&lt;?&gt; c = findLoadedClass(name);</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">long</span> t0 = System.nanoTime();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (parent != <span class="keyword">null</span>) &#123;<span class="comment">//父加载器不为空，调用父加载器loadClass()方法处理</span></span><br><span class="line">                        c = parent.loadClass(name, <span class="keyword">false</span>);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;<span class="comment">//父加载器为空，使用启动类加载器 BootstrapClassLoader 加载</span></span><br><span class="line">                        c = findBootstrapClassOrNull(name);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">                   <span class="comment">//抛出异常说明父类加载器无法完成加载请求</span></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">long</span> t1 = System.nanoTime();</span><br><span class="line">                    <span class="comment">//自己尝试加载</span></span><br><span class="line">                    c = findClass(name);</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// this is the defining class loader; record the stats</span></span><br><span class="line">                    sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0);</span><br><span class="line">                    sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);</span><br><span class="line">                    sun.misc.PerfCounter.getFindClasses().increment();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (resolve) &#123;</span><br><span class="line">                resolveClass(c);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> c;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>这个过程为：先检查是否已经被加载过，若没有加载则调用父加载器的loadClass()方法，若父加载器为空，则默认使用启动类加载器作为父加载器。如果父加载器加载失败，抛出ClassNotFoundException异常后，再调用自己的findClass()方法去加载。</p><p><strong>双亲委派模型的好处：</strong>Java类锁着它的类加载器一起具备了一种带有优先级的层次关系，保证了Java程序的稳定运行，可以避免类的重复加载，同时也保证了Java的核心API不被篡改。</p><p><strong>破坏双亲委派模型的三种方式：</strong></p><ol><li>我们可以自己定义一个类加载器，然后重载loadClass()即可。</li><li>Java设计团队引入的线程上下文类加载器（Thread Context ClassLoader）。这个类加载器可以通过java.lang.Thread类的setContextClassLoader()方法进行设置，如果创建线程时还未设置，它将会从父线程中继承一个，如果再应用程序的全部范围内都没有设置过的化，那这个类的加载器默认就是应用程序类加载器。</li><li>OSGi环境下的网状结构类加载过程。</li></ol>]]></content>
    
    <summary type="html">
    
      虚拟机设计团队把类加载过程中的“通过一个类的全限定名来获取描述此类的二进制字节流”这个动作放到Java虚拟机外部去实现，以便让应用程序自己决定如何去获取所需要的类。实现这个动作的代码模块称为“类加载器”。
    
    </summary>
    
      <category term="Java虚拟机" scheme="http://yoursite.com/categories/Java%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    
    
  </entry>
  
  <entry>
    <title>虚拟机类加载过程</title>
    <link href="http://yoursite.com/posts/2708/"/>
    <id>http://yoursite.com/posts/2708/</id>
    <published>2019-09-05T10:47:25.000Z</published>
    <updated>2019-09-14T12:59:44.100Z</updated>
    
    <content type="html"><![CDATA[<p> 虚拟机把描述类的数据从Class文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的Java类型，这就是虚拟机的类加载机制。</p><p>在Java语言里面，类型的加载、连接和初始化都是在程序运行期间完成的，这种策略虽然会令加载时稍微增加一些性能开销，但是会为Java应用程序提供高度的灵活性。</p><h1 id="类加载的时机"><a href="#类加载的时机" class="headerlink" title="类加载的时机"></a>类加载的时机</h1><p><strong>类从被加载到虚拟机内存中开始，到卸载出内存为止，它的整个生命周期包括：加载（Loading）、验证（Verification）、准备（Preparation）、解析（Resolution）、初始化（Initialization）、使用（Using）和卸载（Unloading）7个阶段，其中验证、准备、解析3个部分通称为连接。</strong><br><img src="/posts/2708/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B.jpg" alt><br>图中加载、验证、准备、初始化和卸载这5个阶段的顺序是确定的，类的加载过程必须按照这种顺序按部就班的<strong>开始</strong>（而不是完成，因为通常会在一个阶段执行的过程中调用、激活另外一个阶段），而解析阶段则不一定：它在某些情况下可以在初始化阶段之后再开始，这是为了支持Java语言的运行时绑定（也成为动态绑定或晚期绑定）。</p><p>对于初始化阶段，虚拟机规范严格指定了有且只有5种情况必须立即对类进行“初始化”：</p><blockquote><ol><li>遇到new、getstatic、putstatic或invokestatic这4条字节码指令时，如果类没有进行过初始化，则需要先触发其初始化。生成这4条指令最常见的Java代码场景是：使用new关键字实例化对象、读取或设置一个类的静态字段（被final修饰、已在编译期把结果放入常量池的静态字段除外），以及调用一个类的静态方法的时候。</li><li>使用java.lang.reflect包的方法对类进行反射调用的时候，如果类没有进行过初始化，则需要先触发其初始化。</li><li>当初始化一个类的时候，如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化。</li><li>当虚拟机启动时，用户需要指定一个要执行的主类（包括main（）方法的那个类），虚拟机会先初始化这个主类。</li><li>当使用JDK1.7的动态语言支持时，如果一个java.lang.invoke.MethodHandle实例最后的解析结果REF_getStatic、REF_putStatic、REF_invokeStatic的方法句柄，并且这个方法句柄所对应的类没有进行过初始化，则需要先触发其初始化。</li></ol></blockquote><p><strong>“有且只有”</strong>这5种场景中的行为称为对一个类进行主动引用。除此之外，所有引用类的方式都不会触发初始化，称为被动引用。被动引用的场景例如：</p><ul><li>通过子类引用父类的静态字段，不会导致子类初始化。</li><li>通过数组来定义引用类，不会触发此类的初始化。</li><li>常量在编译阶段会存入调用类的常量池中，本质上并没有直接引用到定义常量的类。因此不会触发定义常量的类的初始化。</li></ul><p><strong>接口与类真正有所区别的是有且仅有需要开始初始化的5种场景中的第三种：当一个类在初始化时，要求其父类全部都已经初始化过了，但是一个接口在初始化时，并不要求其父接口全部完成了初始化，只有在真正使用到父接口的时候才会初始化。</strong></p><h1 id="类加载的过程"><a href="#类加载的过程" class="headerlink" title="类加载的过程"></a>类加载的过程</h1><p>接下来详细讲解一下Java虚拟机中类加载的全过程，也就是加载、验证、准备、解析、初始化这5个阶段所执行的具体操作。</p><h2 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h2><p>在加载阶段，虚拟机需要完成以下3件事情：</p><ol><li>通过一个类的全限定名来获取定义此类的二进制字节流。</li><li>将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。</li><li>在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口。</li></ol><p>虚拟机规范对上面这3点并不具体，因此是非常灵活的。比如：”通过全类名获取定义此类的二进制字节流” 并没有指明具体从哪里获取、怎样获取。比如：比较常见的就是从 ZIP 包中读取（日后出现的JAR、EAR、WAR格式的基础）、其他文件生成（典型应用就是JSP）等等。</p><p>一个非数组类的加载阶段（加载阶段中获取类的二进制字节流的动作）是开发人员可控性最强的，因为加载阶段既可以通过使用系统提供的引导类加载器来完成，也可以由用户自动移动类加载器去完成（即重写一个loadClass（）方法）。</p><p>对于数组类而言，数组类本身不通过类加载器创建，它是由Java虚拟机直接创建的。一个数组类（称为C）的创建过程遵循以下规则：</p><blockquote><ul><li>如果数组的组件类型（即数组去掉一个维度的类型）是引用类型，那就递归采用本节中定义的加载过程去加载这个组件类型，数组C将在加载该组件类型的类加载器的类名称空间上被标识。</li><li>如果数组的组件类型不是引用类型（例如int[]数组）,Java虚拟机将会把数组C标记为与引导类加载器关联。</li><li>数组类的可见性与它的组件类型的可见性一致；如果数组的组件类型不是引用类型，那数组类的可见性将默认为public。</li></ul></blockquote><p>加载阶段完成后，虚拟机外部的二进制字节流就按照虚拟机所需的格式存储在方法区之中，然后再内存中实例化一个java.lang.Class类的对象。</p><p>加载阶段与连接阶段的部分内容（如一部分字节码文件格式验证动作）是交叉进行的。加载阶段尚未完成，连接阶段可能已经开始，在这些夹在加载阶段之中进行的动作，仍然属于连接阶段的内容，这两个阶段的开始时间仍然保持着固定的先后顺序。</p><h2 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h2><p>验证这一阶段的目的是为了确保Class文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。</p><p>Java语言本身是相对安全的语言，但Class文件并不一定要求用Java源码编译而来，，在字节码层面上，有些Java代码无法做到的时区都是可能实现的，至少语义上可能表达出来。</p><p>对于虚拟机的类加载机制来说，验证阶段是一个非常重要的、但是不一定必要的阶段。如果运行的全部代码都已经被反复使用和验证过，那么在实施阶段就可以考虑使用<code>-Xverify:none</code>参数来关闭大部分的类验证措施，以缩短虚拟机类加载的时间。</p><p><strong>验证阶段大致会完成下面4个阶段的校验工作：文件格式验证、元数据验证、字节码验证、符号引用验证。</strong><br><img src="/posts/2708/%E9%AA%8C%E8%AF%81%E9%98%B6%E6%AE%B5.png" alt></p><h3 id="文件格式验证"><a href="#文件格式验证" class="headerlink" title="文件格式验证"></a>文件格式验证</h3><p><strong>第一阶段要验证字节流是否符合Class文件格式的规范，并且能够被当前版本的虚拟机处理。</strong>这一阶段可能包括验证是否以魔数0xCAFEBABE开头、主、次版本号是否在当前虚拟机处理范围之内等等。</p><p>该阶段的主要目的是为了保证输入的字节流能正确地解析并存储于方法区之内，格式上符合描述一个Java类型信息的要求。</p><h3 id="元数据验证"><a href="#元数据验证" class="headerlink" title="元数据验证"></a>元数据验证</h3><p><strong>第二阶段是对字节码描述的信息进行语义分析，以保证其描述的信息符合Java语言规范的要求。</strong>这个阶段可能包括但验证例如：这个类是否有父类、这个类的父类是否继承了不允许被继承的类等等。</p><p>这个阶段的主要目的是对类的元数据信息进行语义校验，保证不存在不符合Java语言规范的元数据信息。</p><h3 id="字节码验证"><a href="#字节码验证" class="headerlink" title="字节码验证"></a>字节码验证</h3><p><strong>这阶段是整个验证过程中最复杂的一个阶段，主要目的是通过数据流和控制流分析，确定程序语义是合法的。</strong>在这个阶段对类的方法体进行校验分析，保证被校验类的方法在运行时不会做出危害虚拟机安全的事件，例如：保证任意时刻操作数栈的数据类型与指令代码序列都能配合工作，例如不会出现在操作栈放置了一个int类型的数据，使用时却按long类型来加载入本地变量表等等。</p><p>在JDK1.6之后的javac编译器和Java虚拟机中进行了一项优化，给方法体的Code属性表中增加了一项名为“StackMapTable”的属性，这项属性描述了方法体中所有的基本快开始时本地变量表和操作栈应有的状态，在字节码验证期间，就不需要根据程序推导这些状态的合法性，只需检查StackMapTable属性中的记录是否合法即可，这样可以节省时间。</p><h3 id="符号引用验证"><a href="#符号引用验证" class="headerlink" title="符号引用验证"></a>符号引用验证</h3><p>最后一个阶段的校验发生在虚拟机将符号引用转化为直接引用的时候，这个转化动作将在连接的第三阶段（解析阶段）中发生。符号引用的目的是确保解析动作能正常执行。</p><h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><p><strong>准备阶段是正式为<code>类变量</code>（被static修饰的变量）分配内存并设置初始值的阶段</strong>，这些变量所使用的内存都将在方法区中进行分配，这阶段不包括实例变量，实例变量将会在对象实例化时随对象一起分配在Java堆中。</p><p>其次这里说的初始值<strong>通常情况</strong>下是数据类型的零值。假设一个类变量的定义为：<code>public static int value = 123；</code>，那变量value在准备阶段后的初始值是0而不是123，而赋值为123的指令putstatic被程序编译后，存放于类构造器<clinit>方法中。</clinit></p><p>基本数据类型的零值：<br><img src="/posts/2708/%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%9A%84%E9%9B%B6%E5%80%BC.png" alt></p><p>相对于通常情况的特殊情况就是：如果类字段的字段属性表中存在ConstantValue属性，那在准备阶段变量value就会被初始化为ConstantValue属性所指定的值，例如<code>public static final int value = 123;</code>，在准备阶段会根据ConstantValue的设置将value赋值为123。</p><h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><p>解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程。</p><blockquote><ul><li>符号引用：以一组符号来描述所引用的目标，符号可以是任何形式的字面量，只要使用时能无歧义的定位到目标即可。与虚拟机实现的内存布局无关，引用的目标不一定已经加载到内存中。</li><li>直接引用：可以是直接指向目标的指针、相对偏移量或是一个能间件定位到目标的的句柄。和虚拟你实现的内存布局相关，引用到目标必定已经在内存中存在了。</li></ul></blockquote><p>虚拟机规范之中并未规定解析阶段发生的具体实现，只要求了在执行anewarray、checkcast、getfield、getstatic、instanceof、invokedynamic、invokeinterface、invokespecial、invokestatic、invokevirtual、ldc、ldc_w、multianewarray、new、putfield和putstatic这16个用于操作符号引用的字节码指令之前，先对他们所使用的符号引用进行解析。<strong>所以虚拟机实现可以根据需要来判断到底是在类被加载器加载时就对常量池中的符号引用进行解析，还是等到一个符号引用将要被使用前才去解析它。</strong></p><p>对同一个符号引用进行多次解析请求是很常见的事情，虚拟机可以对第一次解析的结果进行缓存，从而避免解析动作重复进行。</p><p>解析动作主要针对类、接口、字段、类方法、接口方法、方法类型、方法句柄和调用点限定符7类符号引用进行，分别对应常量池中的CONSTANT_Class_info、CONSTANT_Fieldref_info、CONSTANT_Methodref_info、CONSTANT_InterfaceMethodref_info、CONSTANT_MethodType_info、CONSTANT_MethodHandle_info和CONSTANT_InvokeDynamic_info 7种常量类型。下面讲解前四种静态符号引用的过程。</p><h3 id="类或接口的解析"><a href="#类或接口的解析" class="headerlink" title="类或接口的解析"></a>类或接口的解析</h3><p>加色和当前代码所处的类为D，如果要把一个从未解析过的符号引用N解析为一个类或接口C的直接引用，虚拟机解析过程如下三个步骤：</p><ol><li>如果C不是一个数组类型，那虚拟机将会把代表N的全限定名传递给D的类加载器去加载这个类C。在加载过程中，由于元数据验证、字节码验证的需要，又可能触发其他相关类的加载动作，例如加载这个类的父类或实现的接口。一旦这个加载过程出现了任何异常，解析过程就宣告失败。</li><li>如果C视野更数组类型，并且数组的元素类型为对象，，那将会按照第1步的规则加载数组的元素类型。</li><li>解析完成之前进行符号引用验证，确认D是否已具备对C的访问权限，如果不具备访问权限，将抛出IllegalAccessError异常。</li></ol><h3 id="字段解析"><a href="#字段解析" class="headerlink" title="字段解析"></a>字段解析</h3><p>首先将会对字段表内class_index项中索引的CONSTAN_Class_info符号引用进行解析，也就是字段所属的类或接口的符号引用。如果解析成功，拿奖这个字段所属的类或接口用C表示，后续解析步骤如下：</p><ol><li>如果C本身就包含了简单名称和字段描述符都与目标相匹配的字段，则返回这个字段的直接引用，解析结束。</li><li>否则，如果在C中实现了接口，将会按照继承关系从下往上递归搜索各个接口和它的父接口，如果接口中包含了简单名称和字段描述符都与目标相匹配的字段，则返回这个字段的直接引用，查找结束。</li><li>否则，如果C不是java.lang.Object的话，将会按照继承关系从下往上递归搜索其父类，如果在父类中包含了简单名称和字段描述符都与目标相匹配的字段，则返回这个字段直接引用，查找失败。</li><li>否则查找失败，抛出NoSuchFieldError异常。</li><li>如果查找过程成功返回了引用，将会对这个字段进行权限验证，如果发现具备对字段的访问权限，将抛出IllegalAccessError异常。</li></ol><p>如果有一个同名字段同时存在于C的接口和父类中，或者同时在自己或父类的多个接口中出现，那编译器将可能拒绝编译。</p><h3 id="类方法解析"><a href="#类方法解析" class="headerlink" title="类方法解析"></a>类方法解析</h3><p>类方法解析的第一个步骤与字段解析一样，也需要先解析出类方法表的class_index项中索引的方法所属的类或接口的符号引用，如果解析成功，用C表示这个类。后续步骤如下：</p><ol><li>类方法和接口方法符号引用的常量类型定义是分开的，如果在类方法表中发现class_index中索引的C是个接口，那就直接抛出java.lang.IncompatibleClassChangeError异常。</li><li>如果通过了第1步，在类C中查找是否有简单名称和描述符都与目标相匹配的方法，如果有则返回这个方法的直接引用，查找结束。</li><li>否则，在类C的父类中递归查找是否有简单名称和描述符都与目标相匹配的方法，如果有则返回这个方法的直接引用，查找结束。</li><li>否则，在类C实现的接口列表及他们的父接口之中递归查找是否有简单名称和描述符都与目标相匹配的方法，如果存在匹配的方法，说明类C是一个抽象，这时查找结束，抛出java.lang.AbstractMethodError异常。</li><li>否则，宣告方法查找失败，抛出java.lang.NoSuchMethodError。</li><li>最后，如果查找过程成功返回了直接引用，将会对这个方法进行权限验证，如果发现不具备对此方法的访问权限，将抛出java.lang.IllegalAccessError异常。</li></ol><h3 id="接口方法解析"><a href="#接口方法解析" class="headerlink" title="接口方法解析"></a>接口方法解析</h3><p>接口方法也需要先解析出接口方法表的class_index项中索引的方法所属的类或接口的符号引用，如果解析成功，依然用C表示这个接口，接下来虚拟机将会按照如下步骤进行后续的接口方法搜索。</p><ol><li>与类方法解析不同，如果在接口方法表中发现class_index中的索引C是个类而不是接口，那就直接抛出java.lang.IncompatibleClassChangeError异常。</li><li>否则，在接口C中查找是否有简单名称和描述符都与目标相匹配的方法，如果有则返回这个方法的直接引用，查找结束。</li><li>否则，在接口C的父接口中递归查找，直到java.lang.Object（查找范围会包括Object类）为止，看是否有简单名称和描述符都与目标相匹配的方法，如果有则返回这个方法的直接引用，查找结束。</li><li>否则，宣告方法查找失败，抛出java.lang.NoSuchMethodError异常。</li></ol><p>由于接口中的所有方法默认都是public，所以不存在访问权限的问题，因此接口方法的符号解析应当不会抛出java.lang.IllegalAccessError异常。</p><h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><p>到了初始化阶段，才真正开始执行类中定义的Java程序代码（或者说字节码）。也可以说初始化阶段是执行类的<clinit>方法的过程。</clinit></p><ol><li><clinit>方法是由编译器自动收集类中的所有<strong>类变量</strong>的复制动作和<strong>静态语句块</strong>中的语句合并产生的，编译器收集的顺序是由语句在源文件中出现的顺序所决定的，静态语句块中只能访问到定义在静态语句块之前的变量；定义i在它之后的变量，在前面的静态语句块可以赋值，但是不能访问。</clinit></li><li><strong><clinit>方法不许需要显式的调用父类的构造器，虚拟机会保证在子类的<clinit>方法执行之前，父类的<clinit>方法已经执行完毕。</clinit></clinit></clinit></strong>因此在虚拟机中第一个被执行的<clinit>方法的类肯定是java.lang.Object。</clinit></li><li><strong>由于父类的<clinit>方法先执行，因此父类中定义的静态语句块要优先于子类的变量赋值操作。</clinit></strong></li><li><strong><clinit>方法对于类或接口来说不是必须的</clinit></strong>，一个类中没有没有静态语句块，也没有对变量的赋值操作，那么编译器就可以不为这个类生成<clinit>方法。</clinit></li><li>接口中不能使用静态语句块，但仍然有变量初始化的赋值操作，因此也会生出<clinit>方法。<strong>但是与类不同，执行接口的<clinit>方法不需要先执行父接口的<clinit>方法，只有当父接口中定义的变量使用时，父接口才会被初始化，接口的实现类在初始化时也一样不会执行接口的<clinit>方法。</clinit></clinit></clinit></strong></clinit></li><li><strong>虚拟机会保证一个类的<clinit>方法在多线程环境中被正确的加锁、同步。</clinit></strong>如果多个线程同时去初始化一个类，那么只会有一个线程去执行这个类的<clinit>方法，其他线程都需要阻塞等待，直到活动线程执行<clinit>方法完毕。</clinit></clinit></li></ol>]]></content>
    
    <summary type="html">
    
      在Class文件中描述的各种信息，最终都需要加载到虚拟机中之后才能运行和使用，而虚拟机如何加载这些Class文件？
    
    </summary>
    
      <category term="Java虚拟机" scheme="http://yoursite.com/categories/Java%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    
    
  </entry>
  
  <entry>
    <title>类文件结构</title>
    <link href="http://yoursite.com/posts/31580/"/>
    <id>http://yoursite.com/posts/31580/</id>
    <published>2019-09-03T09:56:59.000Z</published>
    <updated>2019-09-14T12:58:50.380Z</updated>
    
    <content type="html"><![CDATA[<p>Java虚拟机不和包括Java在内的任何语言绑定，它只与“Class”文件这种特定的二进制文件格式所关联，Class文件中包含了Java虚拟机指令集和符号表以及若干其他辅助信息。</p><p>可以说Class文件是不同的语言在Java虚拟机之间的重要桥梁，同时也是支持Java跨平台很重要的一个原因。</p><h1 id="Class类文件结构总览"><a href="#Class类文件结构总览" class="headerlink" title="Class类文件结构总览"></a>Class类文件结构总览</h1><p>Class文件是一组以8位字节为基础单位的二进制流，各个数据项目严格地按照顺序紧凑地排列在Class文件之中，中间没有添加任何分隔符，当遇到需要占用8位字节以上空间的数据项时，则会按照高位在前的方式分割成若干个8位子节进行存储。</p><p>任何一个Class文件都对应着唯一一个类或接口的定义信息，但反过来说，类或接口并不一定都得定义在文件里（譬如类或接口也可以通过类加载器直接生成）。</p><p>Class文件格式采用一种类似于C语言结构体的伪结构来存储数据，这种伪结构中<strong>只有两种数据类型：无符号数和表。</strong></p><ul><li>无符号数属于基本的数据类型，以u1、u2、u4、u8来分别代表1个字节、2个字节、4个字节和8个字节的无符号数，无符号数可以用来描述数字、索引引用、数量值或者按照UTF-8编码构成字符串值。</li><li>表是由多个无符号数或者其他表作为数据项构成的复合数据类型，所以表都习惯性地以”_info”结尾，表用于描述有层次关系的复合结构的数据，整个Class文件本质上就是一张表。</li></ul><p><strong>Class文件格式：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">u4             magic; <span class="comment">//Class 文件的标志</span></span><br><span class="line">u2             minor_version;<span class="comment">//Class 的小版本号</span></span><br><span class="line">u2             major_version;<span class="comment">//Class 的大版本号</span></span><br><span class="line">u2             constant_pool_count;<span class="comment">//常量池的数量</span></span><br><span class="line">cp_info        constant_pool[constant_pool_count-<span class="number">1</span>];<span class="comment">//常量池</span></span><br><span class="line">u2             access_flags;<span class="comment">//Class 的访问标志</span></span><br><span class="line">u2             this_class;<span class="comment">//当前类</span></span><br><span class="line">u2             super_class;<span class="comment">//父类</span></span><br><span class="line">u2             interfaces_count;<span class="comment">//接口</span></span><br><span class="line">u2             interfaces[interfaces_count];<span class="comment">//一个类可以实现多个接口</span></span><br><span class="line">u2             fields_count;<span class="comment">//Class 文件的字段属性</span></span><br><span class="line">field_info     fields[fields_count];<span class="comment">//一个类会可以有个字段</span></span><br><span class="line">u2             methods_count;<span class="comment">//Class 文件的方法数量</span></span><br><span class="line">method_info    methods[methods_count];<span class="comment">//一个类可以有个多个方法</span></span><br><span class="line">u2             attributes_count;<span class="comment">//此类的属性表中的属性数</span></span><br><span class="line">attribute_info attributes[attributes_count];<span class="comment">//属性表集合</span></span><br></pre></td></tr></table></figure><p>无论是无符号数还是表，当需要描述同一类型数据但数量不定时，经常会使用一个潜质的容量计数器加若干个连续的数据项形式，这时称这一系列的某一类型的数据为某一类型的集合。</p><p>Class文件字节码结构组织示意图：<br><img src="/posts/31580/%E7%B1%BB%E6%96%87%E4%BB%B6%E5%AD%97%E8%8A%82%E7%A0%81%E7%BB%93%E6%9E%84%E7%BB%84%E7%BB%87%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt></p><h1 id="魔数"><a href="#魔数" class="headerlink" title="魔数"></a>魔数</h1><p>每个Class文件的头4个字节称为魔数（Magic Number），<strong>它的唯一作用就是确定这个文件是否为一个能被虚拟机接受到Class文件</strong>，很多文件存储标准中都使用魔数来进行身份识别而不是扩展名的主要原因是基于安全方面的考虑，因为文件扩展名可以随意的改动。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">u4             magic;<span class="comment">//Class 文件的标志</span></span><br></pre></td></tr></table></figure><p>Java中Class文件的魔数值为：0xCAFEBABE（咖啡宝贝？）。</p><h1 id="Class文件版本"><a href="#Class文件版本" class="headerlink" title="Class文件版本"></a>Class文件版本</h1><p><strong>紧接着魔术的4个字节存储的是Class文件的版本号：第5个和第6个是次版本号（Minor Version），第7个和第8个是主版本号（Major Version）</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">u2             minor_version;<span class="comment">//Class 的次版本号</span></span><br><span class="line">u2             major_version;<span class="comment">//Class 的主版本号</span></span><br></pre></td></tr></table></figure><p>Java版本号是从45开始的，JDK1.1之后每个JDK大版本发布主版本号向上加一，高版本的JDK能向下兼容以前版本的Class文件，但不能运行以后版本的Class文件，即使文件格式并未发生任何变化。</p><h1 id="常量池"><a href="#常量池" class="headerlink" title="常量池"></a>常量池</h1><p><strong>紧接着主次版本号之后的是常量池入口，常量池可以理解为Class文件之中的资源仓库，它是Class文件结构中与其他项目关联最多的数据类型，也是战役Class文件空间最大的数据项目之一，同时它还是在Class文件中第一个出现的表类型数据项目。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">u2             constant_pool_count;<span class="comment">//常量池的数量</span></span><br><span class="line">cp_info        constant_pool[constant_pool_count-<span class="number">1</span>];<span class="comment">//常量池</span></span><br></pre></td></tr></table></figure><p><strong>常量池的入口为一项u2类型的数据，代表常量池容量计数值（constant_pool_count），这个容量计数是从1开始而不是从0开始的，值为0代表“不引用任何一个常量池项目”的特殊情况。Class文件结构中只有常量池的容量计数是从1开始的。</strong></p><p><strong>常量池中主要存放两大类常量：字面量和符号引用。</strong>字面量比较接近于Java语言层面的常量概念，如文本字符串、声明为final类型的常量值等；而符号引用则属于编译原理方面的概念，包括下面三类常量：</p><ul><li>类和接口的全限定名</li><li>字段的名称和描述符</li><li>方法的名称和描述符</li></ul><p>在Class文件之不会保存各个方法、字段的最终内存的布局信息，当虚拟机运行时，需要从常量池获得对应的符号引用，再在类创建时或运行时解析、翻译到具体的内存地址之中。</p><p><strong>常量池中每一个项都是一个表，这14种表有一个共同的特点：表开始的第一位是一个u1类型的标志位（tag），代表这个常量属于哪种常量类型。</strong><br><img src="/posts/31580/constant_pool.jpg" alt></p><p>由于Class文件中方法、字段等都需要引用CONSTANT_Utf8_info型常量来描述名称，而这里的最大长度就是length的最大值，既u2类型能表达的最大值65535，所以Java程序中如果定义可超过64KB英文字符的变量或方法名，将会无法编译。</p><p>Class 文件可以通过javap -v class类名 指令来看一下其常量池中的信息(javap -v  class类名-&gt; temp.txt ：将结果输出到 temp.txt 文件)。</p><p>常量池中一部分自动生成的常量的确都没有在Java代码里面出现过，但它们会被后面即将讲到的字段表（field_info）、方法表（method_info）、属性表（attribute_info）引用到，他们会用来描述一些不方便使用“固定字节”进行表达的内容，譬如描述方法的返回值是什么？有几个参数？每个参数的类型是什么？</p><p>常量池中的14种常量项的结构总表：<br><img src="/posts/31580/3458176-8b9bb010f69e4a93.webp" alt><br><img src="/posts/31580/3458176-878fa839b1e28cf3.webp" alt></p><h1 id="访问标志"><a href="#访问标志" class="headerlink" title="访问标志"></a>访问标志</h1><p>在常量池结束之后，紧接着的两个字节代表访问标志（access_flags），这个标志用于识别一些类或者接口层次的访问信息，包括：这个Class是接口还是类；是否定义为public类型；是否定义为abstract类型；如果是类的话，是否声明为final等。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">u2access_flags;<span class="comment">//Class 的访问标记</span></span><br></pre></td></tr></table></figure><p><img src="/posts/31580/%E8%AE%BF%E9%97%AE%E6%A0%87%E5%BF%97.png" alt><br>最后这两个字节的值是上面这8个标志位的值的异或结果，没有用到的标志位一律为0。</p><h1 id="类索引、父类索引与接口索引集合"><a href="#类索引、父类索引与接口索引集合" class="headerlink" title="类索引、父类索引与接口索引集合"></a>类索引、父类索引与接口索引集合</h1><p>类索引和父类索引都是一个u2类型的数据，而接口索引集合是一组u2类型的数据的集合，Class文件中由这三项来确定这个类的继承关系。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">u2             this_class;<span class="comment">//当前类</span></span><br><span class="line">u2             super_class;<span class="comment">//父类</span></span><br><span class="line">u2             interfaces_count;<span class="comment">//接口</span></span><br><span class="line">u2             interfaces[interfaces_count];<span class="comment">//一个类可以实现多个接口</span></span><br></pre></td></tr></table></figure><p>类索引用于确定这个类的全限定名，父类索引用于确定这个类的父类的全限定名。<strong>除了Java.lang.Object之外，所有的Java类都有父类，因此除了Java.lang.Object之外，所有Java类的父类索引都不为0，</strong></p><p>接口索引集合就用来描述这个类实现了哪些接口，这些实现的接口将按implements语句（如果这个类本身是一个接口，则应当是extends语句）后的接口顺序从左到右排列在接口索引集合中。</p><p>类索引、父类索引和接口索引集合都按顺序排列在访问标志之后；对于接口索引集合，入口的第一项————u2类型的数据为接口计数器，表示索引表的容量，如果该类没有实现任何接口，则该计数器值为0。</p><h1 id="字段表集合"><a href="#字段表集合" class="headerlink" title="字段表集合"></a>字段表集合</h1><p>字段表（field_info）用于描述接口或者类中声明的变量。字段包括类级变量以及实例级变量，但不包括在方法内部声明的局部变量。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">u2             fields_count;<span class="comment">//Class 文件的字段的个数</span></span><br><span class="line">field_info     fields[fields_count];<span class="comment">//一个类会可以有个字段</span></span><br></pre></td></tr></table></figure><p>字段表的结构：<br><img src="/posts/31580/%E5%AD%97%E6%AE%B5%E8%A1%A8%E7%9A%84%E7%BB%93%E6%9E%84.png" alt></p><p>字段修饰符放在access_flags项目中，在实际情况中，ACC_PUBLIC、ACC_PRIVATE、ACC_PROTECTED三个标志最多只能选择其一，ACC_FINAL、ACC_VOLATILE不能同时选择，接口之中的字段必须有ACC_PUBLIC、ACC_STATIC、ACC_FINAL标志，其可以设置的标志位和含义如图：<br><img src="/posts/31580/%E5%AD%97%E6%AE%B5%E7%9A%84access_flags%E7%9A%84%E5%8F%96%E5%80%BC.png" alt></p><p>跟随access_flags标志的是两项索引值：name和descriptor_index。它们都是对常量池的引用，分别代表着字段的简单名称以及字段和方法的描述符。</p><blockquote><p>全限定名：一个类的全名的“.”全部替换成“/”<br>简单名称：没有类型和参数修饰的方法或字段名称，既只有名字<br>描述符：用来描述字段的数据类型、方法的参数列表（包括数量、类型和顺序）和返回值。描述符标识字符含义：<img src="/posts/31580/4222138-e6178ef8b07a6a77.webp" alt>对于数组来说，每一维度将使用一个前置的“[”字符来描述；描述方法时，按照先参数列表，后返回值的顺序描述，参数列表按照参数的严格顺序放在一组小括号“（）”内</p></blockquote><p>descriptor_index之后跟随着一个属性表集合用于存储一些额外的信息，字段都可以在描述表中描述零至多项的额外信息。</p><p>字段表集合中不会列出从超累或者父类中继承来的字段，但有可能列出原本Java代码之中不存在的字段，譬如在内部类中为了保持对外部类的访问性，会自动添加指向外部类实例的字段。另外如果两个字段的描述符不一致，那字段重名就是合法的。</p><h1 id="方法表集合"><a href="#方法表集合" class="headerlink" title="方法表集合"></a>方法表集合</h1><p>方法表的结构如同字段表一样：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">u2             methods_count;<span class="comment">//Class 文件的方法的数量</span></span><br><span class="line">method_info    methods[methods_count];<span class="comment">//一个类可以有个多个方法</span></span><br></pre></td></tr></table></figure><p><img src="/posts/31580/%E6%96%B9%E6%B3%95%E8%A1%A8%E7%9A%84%E7%BB%93%E6%9E%84.png" alt><br>方法表的 access_flag 取值：<img src="/posts/31580/%E6%96%B9%E6%B3%95%E8%A1%A8%E7%9A%84access_flag%E7%9A%84%E6%89%80%E6%9C%89%E6%A0%87%E5%BF%97%E4%BD%8D.png" alt></p><p>方法里的Java代码，经过编译器编译成字节码指令后，存放在方法属性表集合中一个名为“Code”的属性里面，属性表作为Class文件格式中最具扩展性的一种数据项目，见下一节。</p><p>与字段表集合相对应的，如果父类方法在子类中没有进行重写（Override），方法表集合中就不会出现来自弗雷德方法信息。但同样有可能出现由编译器自动添加的方法，最典型的便是类构造器<clinit>方法和实例构造器<init>方法。</init></clinit></p><p>Java语言中，要重载（Overload）一个方法，除了要与原方法具有相同的简单名称之外，还要求必须拥有一个与原方法不同的特征签名，特征签名就是一个方法中各个参数在常量池中的字段符号引用的集合，也就是因为返回值不会包含在特征签名中，因此Java语言无法仅仅依靠返回值的不同来对一个已有方法进行重载。</p><h1 id="属性表集合"><a href="#属性表集合" class="headerlink" title="属性表集合"></a>属性表集合</h1><p>在Class文件、字段表、方法表都可以携带自己的属性表集合，以用于描述某些场景专有的信息。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">u2             attributes_count;<span class="comment">//此类的属性表中的属性数</span></span><br><span class="line">attribute_info attributes[attributes_count];<span class="comment">//属性表集合</span></span><br></pre></td></tr></table></figure><p>属性表的限制相对其他的数据项目稍微宽松了一些，不再要求各个属性表具有严格的顺序，并且只要不与已有属性名重复，任何人实现的编译器都可以向属性表中写入自己定义的属性信息，Java虚拟机运行时会忽略它不认识的属性。<br><img src="/posts/31580/20170528124404308.png" alt><img src="/posts/31580/20170528124505057.png" alt><img src="/posts/31580/20170528124624262.png" alt></p><p>对于每个属性，它的名称需要从常量池中引用一个CONSTANT_Utf8_info类型的常量来标识，而属性值的结构则是完全自定义的，只需要通过一个u4的长度属性去说明属性值所占用的位数即可。<br><img src="/posts/31580/20141213150547531.png" alt></p><h2 id="Code属性"><a href="#Code属性" class="headerlink" title="Code属性"></a>Code属性</h2><p>Java程序方法体中的代码经过Javac编译器处理后，最后变为字节码指令存储在Code属性内。Code属性出现在方法表的属性集合之中，但并非所有的方法表都必须存在这个属性，譬如接口或者抽象类中的方法就不存在Code属性。<br><img src="/posts/31580/20170528124832359.png" alt></p><p>attribute_name_index是一项指向CONSTANT_Utf8_info型常量的索引，常量值固定为“Code”，它代表该属性的属性名称。</p><p>attribute_length指示了属性值的长度，由于属性名称索引与属性长度一共为6字节，所以属性值的长度固定为整个属性表长度减去6个字节。</p><p>max_stack代表了操作栈数深度的最大值。</p><p>max_locals代表了局部变量表所需的存储空间，单位是Slot，Slot时虚拟机为局部变量分配内存所使用的最小单位。对于byte、char、float、int、short、boolean和returnAdress等长度不超过32位的数据类型，每个局部变量占用1个Slot，而double和long这种64位的数据类型则需要两个Slot来存放。并不是在方法中用到了多少个局部变量，就把这些局部变量所占Slot之和作为max_locals的值，原因是局部变量表中的Slot可以重用，当代码执行超过一个局部变量的作用域时，这个局部变量所占的Slot可以被其他局部变量所使用，Javac编译器会根据变量的作用域来分配Slot给各个变量使用，然后计算出max_locals的大小。</p><p>code_length和code用来存储Java源程序编译后生成的字节码指令，code_length代表字节码长度，code是用于存储字节码指令的一系列字节流，每个指令长度为u1类型的单字节，虚拟机每次读入一个字节码指令。关于code_length，虽然他是一个u4类型的长度值，但虚拟机明确限制了一个方法不允许超过65535条字节码指令，即它实际只使用了u2的长度。</p><p>在实例方法的局部变量表中至少会存在一个指向当前对象实例的局部变量，局部变量表中也会预留出一个Slot位来存放对象实例的引用，方法参数值从1开始计算。</p><p>exception_table：异常表如下。<img src="/posts/31580/20170528125111983.png" alt>如果当字节码在第start_pc行到第end_pc行之间（不含end_pc行）出现了类型为catch_type或者其子类的异常（catch_type为指向一个CONSTANT_Class_info型常量的引用），则转到第handler_pc行继续处理。当catch_type的值为0时，代表任意异常情况都需要转向到handler_pc行进行处理。 </p><h2 id="Exceptions属性"><a href="#Exceptions属性" class="headerlink" title="Exceptions属性"></a>Exceptions属性</h2><p>Exceptions属性的作用是列举出方法中可能抛出的受查异常（Checked Exceptions），也就是方法描述时在throws关键字后面列举的异常。<br><img src="/posts/31580/TIM%E5%9B%BE%E7%89%8720190903214436.png" alt><br>Exceptions属性中的number_of_exceptions项表示方法可能抛出number_of_exceptions种受查异常。每一种受查异常使用一个number_index_table项表示，exception_index_table是一个指向常量池中CONSTANT_Class_info型常量的索引，代表了该受查异常的类型。</p><h2 id="LineNumberTable属性"><a href="#LineNumberTable属性" class="headerlink" title="LineNumberTable属性"></a>LineNumberTable属性</h2><p>LineNumberTable属性用于描述Java源码行号与字节码（字节码的偏移量）之间的对应关系。<br><img src="/posts/31580/TIM%E5%9B%BE%E7%89%8720190903215128.png" alt><br>line_number_table是一个数量为line_number_table_length、类型为line_number_info的集合，line_number_info表包括了start_pc和line_number两个u2类型的数据项，前者是字节码行号，后者是Java源码行号。</p><h2 id="LocalVariableTable属性"><a href="#LocalVariableTable属性" class="headerlink" title="LocalVariableTable属性"></a>LocalVariableTable属性</h2><p>LocalVariableTable属性用于描述栈帧中局部变量表中与Java源码中定义的变量之间的关系。<br><img src="/posts/31580/TIM%E5%9B%BE%E7%89%8720190903215615.png" alt><br> start_pc和length属性分别代表了这个局部变量的生命周期开始地字节码偏移量及其作用范围覆盖的长度，两者结合起来就是这个局部变量在字节码之中的作用域范围。</p><p>name_index和descriptor_index都是指向常量池中CONSTANT_Utf8_info型常量的索引，分别代表了局部变量的名称以及这个局部变量的描述符。</p><p>index是这个局部变量在栈帧局部变量表中Slot的位置。当这个变量数据类型是64位类型时（double和long），他占用的Slot为index和index+1两个。</p><p>在JDK1.5引入泛型之后，LocalVariableTable属性增加了一个“姐妹属性”：LocalVariableTypeTable，这个新增的属性结构与LocalVariableTable非常相似，仅仅是吧记录的字段描述符的descriptor_index替换成了字段的特征签名（Signature），对于非泛型类型来说，描述符和特征签名能描述的信息是基本一致的，但是泛型引入后，由于描述符中反省的参数化类型被擦除掉，描述符就不能准确的描述泛型类型了，因此出现了LocalVariableTypeTable。</p><h2 id="SourceFile属性"><a href="#SourceFile属性" class="headerlink" title="SourceFile属性"></a>SourceFile属性</h2><p>SourceFile属性用于记录生成这个Class文件的源码文件名称。<br><img src="/posts/31580/TIM%E5%9B%BE%E7%89%8720190903220650.png" alt><br>sourcefile_index数据项是指向常量池中CONSTANT_Utf8_info型常量的索引，常量值是源码文件的文件名。</p><h2 id="ConstantValue属性"><a href="#ConstantValue属性" class="headerlink" title="ConstantValue属性"></a>ConstantValue属性</h2><p>ConstantValue属性的作用是通知虚拟机自动为静态变量赋值。只有被static关键字修饰的变量（类变量）才可以使用这项属性。对于非static类型的变量的赋值是在实力构造器<init>方法中进行的；而对于类变量，则有两种方式可以选择：再类构造器<clinit>方法中或者使用ConstantValue属性。<br><img src="/posts/31580/TIM%E5%9B%BE%E7%89%8720190903221413.png" alt><br> 从数据结构中可以看出，ConstantValue属性是一个定长属性，他的attribute_length数据项值必须固定为2。constantvalue_index数据项代表了常量池中一个字面量常量的引用，根据字段类型的不同，字面量可以是CONSTANT_Long_info、CONSTANT_Float_info、CONSTANT_Double_info、CONSTANT_Integer_info、CONSTANT_String_info常量中的一种。</clinit></init></p><h2 id="InnerClasses属性"><a href="#InnerClasses属性" class="headerlink" title="InnerClasses属性"></a>InnerClasses属性</h2><p>Inner属性用于记录内部类与宿主类之间的关联。如果一个类中定义了内部类，那编译器将会为它以及它所包含的内部类生成InnerClasses属性。</p><h2 id="Deprecated及Synthetic属性"><a href="#Deprecated及Synthetic属性" class="headerlink" title="Deprecated及Synthetic属性"></a>Deprecated及Synthetic属性</h2><p>Depreciated和Syntactic两个属性都属于标志类型的布尔属性，只存在有和没有的区别，没有属性值的概念。</p><p>Depreciated属性用于表示某个类、字段或者方法，已经被程序作者定为不再推荐使用，它可以通过在代码中使用<code>@deprecated</code>注解进行设置。</p><p>Syntactic属性代表此字段或者方法并不是由Java源码直接产生的，而是由编译器自行添加的。<strong>唯一例外的是实例构造器<init>方法和类构造器<clinit>方法。</clinit></init></strong></p><h2 id="StackMapTable属性"><a href="#StackMapTable属性" class="headerlink" title="StackMapTable属性"></a>StackMapTable属性</h2><p>StackMapTable属性在JDK1.6发布后增加到Class文件规范中，它是一个复杂的变长属性，位于Code属性的属性表中。</p><p>这个属性会在虚拟机类加载的字节码验证阶段被新类型检查验证器使用，目的在于代替以前比较消耗性能的基于数据流分析的类型推导验证器。</p><h2 id="Signature属性"><a href="#Signature属性" class="headerlink" title="Signature属性"></a>Signature属性</h2><p>Signature属性在KJDk1.5发布后增加到了Class文件规范中，他是一个可选的定长类属性，可以出现于类、字段表、和方法表结构的属性表中。</p><p>在JDK 1.5大幅增强了Java语言的语法，在此之后，任何类、接口、初始化方法或成员的泛型签名如果包含了类型变量（Type Variables）或参数化类型（Parameterized Types），则Signature属性会为它记录泛型签名信息。之所以要专门使用这样一个属性去记录泛型类型，是因为Java语言的泛型采用的是擦除法实现的伪泛型。</p><p>使用擦除法的好处是实现简单（主要修改Javac编译器，虚拟机内部只做了很少的改动）、非常容易实现Backport，运行期也能够节省一些类型所占的内存空间。但坏处是运行期就无法像C#等有真泛型支持的语言那样，将泛型类型与用户定义的普通类型同等对待，例如运行期做反射时无法获得到泛型信息。Signature属性就是为了弥补这个缺陷而增设的。</p><h2 id="BootstrapMethods属性"><a href="#BootstrapMethods属性" class="headerlink" title="BootstrapMethods属性"></a>BootstrapMethods属性</h2><p>BootstrapMethods属性在JDK1.7发布后增加到了Class文件规范之中，它是一个复杂的变长属性，位于类文件的属性表中。这个属性用于保存invokeddynamic指令引用的引导方法限定符。目前的Javac暂时无法生成InvokeDynamic指令和BootstrapMethods属性，必须通过一些非常规的手段才能使用它们。</p>]]></content>
    
    <summary type="html">
    
      在 Java 中，JVM 可以理解的代码就叫做字节码（即扩展名为 .class 的文件），它不面向任何特定的处理器，只面向虚拟机。Java 语言通过字节码的方式，在一定程度上解决了传统解释型语言执行效率低的问题，同时又保留了解释型语言可移植的特点。
    
    </summary>
    
      <category term="Java虚拟机" scheme="http://yoursite.com/categories/Java%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    
    
  </entry>
  
  <entry>
    <title>虚拟机性能监控与故障处理工具</title>
    <link href="http://yoursite.com/posts/61312/"/>
    <id>http://yoursite.com/posts/61312/</id>
    <published>2019-09-01T12:42:20.000Z</published>
    <updated>2019-09-14T12:59:51.443Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JDK的命令行工具"><a href="#JDK的命令行工具" class="headerlink" title="JDK的命令行工具"></a>JDK的命令行工具</h1><p>JDK的bin目录中除了有我们所熟知的“java.exe”、“Javac.exe”这两个命令行工具，还有也许我们并不了解的其他命令行工具。这里我们主要介绍一些用于监视虚拟机和故障处理的工具，这些关工具都非常稳定而且功能强大，能在处理应用程序性能问题、定位故障时发挥很大的作用。</p><p>这些命令行工具大多数是jdk/lib/tool.jar类库的一层薄包装而已，它们主要的功能代码是在tools类库中实现的。JDK开发团队选择采用Java代码来实现这些监控工具是有特别用意的：当应用程序部署到生产环境后，无论是直接接触物理服务器还是远程Telnet到服务器上都可能会受到限制，借助tools.jar类库里面的接口，我们可以直接在应用程序中实现功能强大的监控分析功能。</p><p><strong>Sun JDK 监控和故障处理工具：</strong>  </p><table><thead><tr><th align="center">名称</th><th align="center">主要作用</th></tr></thead><tbody><tr><td align="center">jps</td><td align="center">JVM Process Status Tool ， 显示指定系统内所有的HotSpot虚拟机进程</td></tr><tr><td align="center">jstat</td><td align="center">JVM Statistics Monitoring Tool ， 用于收集HotSpot虚拟机各方面的运行数据</td></tr><tr><td align="center">jinfo</td><td align="center">Configuration In for Java ， 显示虚拟机配置信息</td></tr><tr><td align="center">jmap</td><td align="center">Memory Map for Java ， 生成虚拟机的内存转储快照（heapdump文件）</td></tr><tr><td align="center">jhat</td><td align="center">JVM Heap Dump Browser ， 用于分析headgump文件，它会建立一个HTTP/HTML服务器，让用户可以在浏览器上查看分析结果</td></tr><tr><td align="center">jstack</td><td align="center">Stack Trace for Java ， 显示虚拟机的线程快照</td></tr></tbody></table><h2 id="jps：虚拟机进程状况工具"><a href="#jps：虚拟机进程状况工具" class="headerlink" title="jps：虚拟机进程状况工具"></a>jps：虚拟机进程状况工具</h2><p>JDK的很多小工具的命名方式采用了UNIX命令的命名方式，jps就是其中的典型，它的作用就是类似于UNIX的ps命令：</p><p><strong>可以列出正在运行的虚拟机进程，并显示虚拟机执行主类（Main Class，main() 函数所在的类）名称以及这些进程的本地虚拟机唯一ID（Local Virtual Mechain Identifier，LVMID）。</strong>对于本地虚拟机进程来说，LVMID与操作系统的进程ID是一致的。</p><p>jps命令格式：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jps[options][hostid]</span><br></pre></td></tr></table></figure><p>jps工具主要选项：</p><table><thead><tr><th align="center">选项</th><th align="center">作用</th></tr></thead><tbody><tr><td align="center">-q</td><td align="center">只输出LVMID，省略主类的名称</td></tr><tr><td align="center">-m</td><td align="center">输出虚拟机进程启动时，传递给主类main()函数的参数</td></tr><tr><td align="center">-l</td><td align="center">输出主类全名，如果进程执行的是Jar包，输出Jar路径</td></tr><tr><td align="center">-v</td><td align="center">输出虚拟机启动时JVM参数</td></tr></tbody></table><h2 id="jstat：虚拟机统计信息监视工具"><a href="#jstat：虚拟机统计信息监视工具" class="headerlink" title="jstat：虚拟机统计信息监视工具"></a>jstat：虚拟机统计信息监视工具</h2><p>jstat是用于监视虚拟机各种运行状态信息的命令行工具。<strong>它可以显示虚拟机进程中的类装载、内存、垃圾收集、JIT编译等运行数据。</strong></p><p>jstat命令格式：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jstat[option vmid/lvmid  [interval[s|ms][count]] ]</span><br></pre></td></tr></table></figure><p>vmid/lvmid分别是远程虚拟机进程与本地虚拟机进程。参数interval和count代表查询间隔和次数，如果省略这两个参数，说明只查询一次。</p><p>option主要分为三类：类装载、垃圾收集、运行期编译。jstat工具主要选项：</p><table><thead><tr><th align="center">选项</th><th align="center">作用</th></tr></thead><tbody><tr><td align="center">-class</td><td align="center">监视类装载、卸载数量、总空间以及类装载所耗费的时间</td></tr><tr><td align="center">-gc</td><td align="center">监视Java堆状况，包括Eden区、两个Survivor区、老年代、永久代等的容量、已用空间、GC时间合计等信息</td></tr><tr><td align="center">-gccapacity</td><td align="center">监视内容与-gc基本相同，但输出主要关注Java堆各个区域使用到的最大、最小空间</td></tr><tr><td align="center">-gcutil</td><td align="center">监视内容与-gc基本相同，但输出主要关注已使用空间占总空间的百分比</td></tr><tr><td align="center">-gccause</td><td align="center">与-gcutil功能一样，但是会额外输出导致上一次GC产生的原因</td></tr><tr><td align="center">-gcnew</td><td align="center">监视新生代GC状况</td></tr><tr><td align="center">-gcnewcapacity</td><td align="center">监视内容与-gcnew基本相同，输出主要关注使用到的最大、最小空间</td></tr><tr><td align="center">-gcold</td><td align="center">监视老年代GC状况</td></tr><tr><td align="center">-gcoldcapacity</td><td align="center">监视内容与-gcold基本相同，输出主要关注使用到的最大、最小空间</td></tr><tr><td align="center">-gcpermcapacity</td><td align="center">输出永久代使用到的最大、最小空间</td></tr><tr><td align="center">-compiler</td><td align="center">输出JIT编译器编译过的方法、耗时等信息</td></tr><tr><td align="center">-printcompilation</td><td align="center">输出已经被JIT编译过的方法</td></tr></tbody></table><h2 id="jinfo：Java配置信息工具"><a href="#jinfo：Java配置信息工具" class="headerlink" title="jinfo：Java配置信息工具"></a>jinfo：Java配置信息工具</h2><p>jinfo的作用是实时地查看和调整虚拟机各项参数。</p><p>jinfo的<code>-flag</code>选项可以查询未被显式指定的参数的系统默认值，可以使用<code>-flag [+|-]</code>或者<code>-flag name=value</code>修改一部分运行期可写的虚拟机参数值 。jinfo还可以使用-sysprops选项把虚拟机进程的System.getProperties()的内容打印出来。</p><h2 id="jamp：Java内存映像工具"><a href="#jamp：Java内存映像工具" class="headerlink" title="jamp：Java内存映像工具"></a>jamp：Java内存映像工具</h2><p>jmap命令用于生成堆转储快照（一般为heapdump或者dump文件），如果不使用 jmap 命令，要想获取 Java 堆转储，可以使用 “-XX:+HeapDumpOnOutOfMemoryError” 参数，可以让虚拟机在 OOM 异常出现之后自动生成 dump 文件，Linux 命令下可以通过 kill -3 发送进程退出信号也能拿到 dump 文件。它还可以查询finalize执行队列、Java堆和永久代的详细信息，如空间使用率、当前使用的是哪种收集器等。和jinfo一样，jmap有不少功能在 Windows 平台下也是受限制的。</p><p>jamp命令格式：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jmap[option]vmid</span><br></pre></td></tr></table></figure><p>jmap工具主要选项：</p><table><thead><tr><th align="center">选项</th><th align="center">作用</th></tr></thead><tbody><tr><td align="center">-dump</td><td align="center">生成Java堆转出快照。格式为：-dump[live,]format=b,file=<filename>,其中live子参数说明是否只dump出存活对象</filename></td></tr><tr><td align="center">-finalizerinfo</td><td align="center">显示在F-Queue中等待Finalizer线程等待执行finalize方法的对象。只在Linux/Solaris平台下有效</td></tr><tr><td align="center">-heap</td><td align="center">显示Java堆详细信息，如使用哪种回收器、参数配置、分代状况等。</td></tr><tr><td align="center">-histo</td><td align="center">显示堆中对象统计信息，包括类、实例数量、合计容量</td></tr><tr><td align="center">-permstat</td><td align="center">已ClassLoader为统计口径，显示永久代内存状况。只在Linux/Solaris平台下有效</td></tr><tr><td align="center">-F</td><td align="center">当虚拟机进程堆-dump选项没有响应时，可使用这个选项强制生成dump快照。只在Linux/Solaris平台下有效</td></tr></tbody></table><h2 id="jhat：虚拟机堆转储快照分析工具"><a href="#jhat：虚拟机堆转储快照分析工具" class="headerlink" title="jhat：虚拟机堆转储快照分析工具"></a>jhat：虚拟机堆转储快照分析工具</h2><p>jhat与jmap搭配使用，来分析jmap生成的堆转储快照，可以在浏览器中查看。</p><p>但是一般不会直接使用jhat命令来分析dump文件，主要原因有二：</p><ul><li>一般不会在部署应用程序的服务器上直接分析dump文件，即使可以这样做，也会尽量将dump文件复制到其他机器上分析，因为分析是一个耗时而且消耗硬件资源的过程，尽然都要在其他机器上进行，就没有必要受到命令行工具的限制了。</li><li>jhat的分析功能相对来说比较简陋，有更强的工具可以代替它。</li></ul><p>jamp命令格式：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jhatfilename</span><br></pre></td></tr></table></figure><h2 id="jstack：Java堆栈跟踪工具"><a href="#jstack：Java堆栈跟踪工具" class="headerlink" title="jstack：Java堆栈跟踪工具"></a>jstack：Java堆栈跟踪工具</h2><p>jstack命令用于生成虚拟机当前时刻的线程快照（一般称为threaddump或者javacore文件）。线程出现停顿的时候通过jstack来查看各个线程的调用堆栈，就可以知道没有响应的线程到底在后台做什么，或者等待什么资源。</p><p>线程快照就是当前虚拟机每一条线程正在执行的方法堆栈的集合，生成线程快照的主要目的是定位线程出现长时间停顿的原因，如线程死锁、死循环、请求外部资源导致的长时间等待等都是导致线程长时间停顿的常见原因。</p><p>jstack命令格式：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jstack[option]vmid</span><br></pre></td></tr></table></figure><p>jmap工具主要选项：</p><table><thead><tr><th align="center">选项</th><th align="center">作用</th></tr></thead><tbody><tr><td align="center">-F</td><td align="center">当正常输出的请求不被响应时，强制输出线程堆栈</td></tr><tr><td align="center">-l</td><td align="center">除堆栈外，显示关于锁的附加信息</td></tr><tr><td align="center">-m</td><td align="center">如果调用到本地方法的话，可以显示C/C++的堆栈</td></tr></tbody></table><h1 id="JDK的可视化工具"><a href="#JDK的可视化工具" class="headerlink" title="JDK的可视化工具"></a>JDK的可视化工具</h1><p>JDK中除了提供大量的命令行工具外，还有两个功能强大的可视化工具：JConsole和VisualVM。</p><h2 id="JConsole：Java监视与管理控制台"><a href="#JConsole：Java监视与管理控制台" class="headerlink" title="JConsole：Java监视与管理控制台"></a>JConsole：Java监视与管理控制台</h2><p>JConsole是一种基于JMX的可视化监视、管理工具。它管理部分的功能是针对JMX MBean进行管理。</p><h3 id="启动JConsole"><a href="#启动JConsole" class="headerlink" title="启动JConsole"></a>启动JConsole</h3><p>提供JDK/bin目录下的“jconsole.exe”启动JConsole后，将自动搜索出本机运行的所有虚拟机进程，双击选择其中一个进程即可开始监控，也可以使用下面的“远程进程”功能来连接远程服务器，对远程虚拟机进行监控。<br><img src="/posts/61312/%E5%90%AF%E5%8A%A8JConsole.png" alt><img src="/posts/61312/JConsole%E6%A6%82%E8%BF%B0.png" alt><br>“概述”页签显示的是整个虚拟机主要运行数据的概览，其中包括“堆内存使用情况”、“线程”、“类”、“CPU使用情况”4种信息的曲线图。</p><h3 id="内存监控"><a href="#内存监控" class="headerlink" title="内存监控"></a>内存监控</h3><p>JConsole可以显示当前内存的详细信息，不仅包括堆内存/非堆内存的整体信息，还可以细化到Eden区、Survivor区等的使用情况。点击右边的“执行 GC(G)”按钮可以强制应用程序执行一个Full GC。<br><img src="/posts/61312/3%E5%86%85%E5%AD%98%E7%9B%91%E6%8E%A7.png" alt></p><h3 id="线程监控"><a href="#线程监控" class="headerlink" title="线程监控"></a>线程监控</h3><p>类似于jstack命令，遇到线程停顿时可以使用这个页签进行监控分析。最下面有一个”检测死锁 (D)”按钮，点击这个按钮可以自动为你找到发生死锁的线程以及它们的详细信息 。<br><img src="/posts/61312/4%E7%BA%BF%E7%A8%8B%E7%9B%91%E6%8E%A7.png" alt></p><h2 id="VisualVM：多合一故障处理工具"><a href="#VisualVM：多合一故障处理工具" class="headerlink" title="VisualVM：多合一故障处理工具"></a>VisualVM：多合一故障处理工具</h2><p>VisualVM是到目前为止随JDK发布的功能最强大的运行监视和故障处理程序。它除了运行监视、故障处理外，还提供了很多其他方面的功能，如性能分析。</p><p>VisualVM还有一个很大的优点：不需要被监视的程序基于特殊Agent运行，因此它对应用程序的实际性能的影响很小，使得它可以直接应用在生产环境中。</p><p>VisualVM 基于 NetBeans 平台开发，因此他一开始就具备了插件扩展功能的特性，通过插件扩展支持，VisualVM 可以做到：</p><ul><li>显示虚拟机进程以及进程的配置、环境信息（jps、jinfo）。</li><li>监视应用程序的CPU、GC、堆、方法区以及线程的信息（jstat、jstack）。</li><li>dump以及分析堆转储快照（jmap、jhat）。</li><li>方法级的程序运行性能分析，找出被顶用最多、运行时间最长的方法。</li><li>离线程序快照：收集程序的运行时配置、线程dump、内存dump等信息建立一个快照，可以将快照发送开发者除进行Bug反馈。</li><li>其他plugins的无限的可能性……</li></ul>]]></content>
    
    <summary type="html">
    
      在了解关于虚拟机的内存分配与回收技术的理论知识之后，就要考虑把这些知识应用到实际工作中的问题。这里就介绍一些经常使用的虚拟机监控和分析的工具，使用它们可以帮助我们快速分析数据，定位解决问题。
    
    </summary>
    
      <category term="Java虚拟机" scheme="http://yoursite.com/categories/Java%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    
    
  </entry>
  
  <entry>
    <title>内存分配与回收策略</title>
    <link href="http://yoursite.com/posts/44680/"/>
    <id>http://yoursite.com/posts/44680/</id>
    <published>2019-08-31T06:48:38.000Z</published>
    <updated>2019-09-14T12:59:35.322Z</updated>
    
    <content type="html"><![CDATA[<p>Java技术体系中所提倡的自动内存管理最终可以归结为自动化地解决了两个问题：给对象分配内存以及回收分配给对象的内存。</p><p>对象的内存分配，往大方向讲，就是在堆上分配，对象主要分配在新生代的Eden区上，如果启动了本地线程分配缓冲（TLAB），将按线程优先在TLAB上分配。少数情况下也可能会直接分配在老年代中，分配堆规则并不是百分之百固定的。<br><img src="/posts/44680/%E5%A0%86%E5%86%85%E5%AD%98.jpg" alt></p><h1 id="新生代GC和老年代GC"><a href="#新生代GC和老年代GC" class="headerlink" title="新生代GC和老年代GC"></a>新生代GC和老年代GC</h1><p>在了解分配策略之前，先了解一下新生代（Minor）GC和老年代（Full/Major）GC有什么不同。</p><ul><li>新生代GC（Minor GC）：指发生在新生代的垃圾收集动作，因为Java对象大多都具备朝生夕灭的特性，所以Minor GC非常频繁，一般回收速度也比较快。</li><li>老年代GC（Major/Full GC）：指发生在老年代的GC，出现了Major GC，经常会伴随至少一次的Minor GC（但并非绝对，在Parallel Scavenge收集器的收集策略里就有直接进行Major GC的策略选择过程）。Major GC的速度一般会比Minor GC慢10倍以上。</li></ul><h1 id="对象优先在Eden分配"><a href="#对象优先在Eden分配" class="headerlink" title="对象优先在Eden分配"></a>对象优先在Eden分配</h1><p>大多数情况下，对象在新生代Eden区中分配。当Eden区没有足够的空间进行分配时，虚拟机将发起一次Minor GC。</p><p>当给一个对象分配内存的的时候，发现Eden已经被占用的了一部分,剩余的空间已不足以分配当前对象所需的内存，因此发生Minor GC。GC期间虚拟机首先尝试把Eden中的对象放入Survivor空间中，如果Survivor中的空间大小不足的话，就会通过分配担保机制提前转移到老年代去。</p><h1 id="大对象直接进入老年代"><a href="#大对象直接进入老年代" class="headerlink" title="大对象直接进入老年代"></a>大对象直接进入老年代</h1><p>所谓的大对象是指，需要大量连续内存空间的Java对象，最典型的大对象就是那种很长的字符串以及数组。</p><p>虚拟机提供了一个<code>-XX:PretenureSizeThreshold</code>参数，令大于这个设置值的对象直接在老年代分配，这样做的目的是避免Eden区及两个Survivor区之间发生大量的内存复制（新生代采用复制算法收集内存）。</p><h1 id="长期存活的对象将进入老年代"><a href="#长期存活的对象将进入老年代" class="headerlink" title="长期存活的对象将进入老年代"></a>长期存活的对象将进入老年代</h1><p>既然虚拟机采用了分代收集的思想来管理内存，那么内存回收时就必须能识别哪些对象应放在新生代，哪些对象应放在老年代中。为了做到这一点，虚拟机给每个对象一个对象年龄（Age）计数器。</p><p>如果对象在Eden出生经过一次Minor GC后仍然存活，并且能够被Survivor容纳的话，将被移动到Survivor空间中，并且对象年龄设为1。</p><p>对象在Survivor区中每熬过一次Minor GC，年龄就增加1岁，当他的年龄增加到一定程度（默认为15岁），就会被晋升到老年代中。对象晋升到老年代中的阈值，可以通过参数<code>-XX:MaxTenuringThreshold</code>设置。</p><h1 id="动态对象年龄判定"><a href="#动态对象年龄判定" class="headerlink" title="动态对象年龄判定"></a>动态对象年龄判定</h1><p>为了更好的适应不同程序的内存状况，虚拟机并不是永远的要求对象的年龄达到了阈值才能晋升到老年代中，如果在Survivor空间中相同年龄所有对象大小的总和大于Survivor空间的一半，年龄大于或等于该年龄的对象就可以直接进入老年代，无须等到MaxTenuringThreshold中要求的年龄。</p><h1 id="空间分配担保"><a href="#空间分配担保" class="headerlink" title="空间分配担保"></a>空间分配担保</h1><p>在发生Minor GC之前，虚拟机会先检查老年代最大可用的连续空间是否大于新生代所有对象总空间，如果这个条件成立，那么Minor GC可以确保是安全的。如果不成立，则虚拟机会查看HandlePromotionFailure设置值是否允许担保失败。如果允许，那么会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，如果大于，将尝试着进行一次Minor GC，尽管这次Minor GC是有风险的；如果小于，或者HandlePromotionFailure设置不允许冒险，那这时也要改为进行一次Full GC。</p><p>取平均值进行比较其实仍然是一种动态概率的手段，也就是说，如果某次Minor GC存活后的对象突增，远远高于平均值的话，依然会导致担保失败（Handle Promotion Failure）。如果出现了HandlePromotionFailure失败，那就只好在失败后重新发起一次Full GC。</p><p>虽然担保失败时绕的圈子是最大的，但大部分情况下都还是会将HandlePromotionFailure开关打开，避免Full GC过于频繁。</p>]]></content>
    
    <summary type="html">
    
      关于内存回收这一点，在Java垃圾收集机制中详细介绍了各种回收算法以及JVM中常见的收集器。接下来主要看看JVM是如何给对象分配内存的。
    
    </summary>
    
      <category term="Java虚拟机" scheme="http://yoursite.com/categories/Java%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    
    
  </entry>
  
  <entry>
    <title>理解GC日志</title>
    <link href="http://yoursite.com/posts/41052/"/>
    <id>http://yoursite.com/posts/41052/</id>
    <published>2019-08-31T06:13:03.000Z</published>
    <updated>2019-09-14T12:59:28.043Z</updated>
    
    <content type="html"><![CDATA[<p>每一种收集器的日志形式都是由它们自身的实现所决定的,换而言之,每个收集器的日志格式都可以不一样。但虚拟机设计者为了方便用户阅读,将各个收集器的日志都维持一定的共性,例如以下两段典型的GC日志:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">33.125</span>: [GC [DefNew: <span class="number">3324</span>K-&gt;<span class="number">152</span>K(<span class="number">3712</span>K), <span class="number">0.0025925</span> secs] <span class="number">3324</span>K-&gt;<span class="number">152</span>K(<span class="number">11904</span>K), <span class="number">0.0031680</span>secs]</span><br><span class="line"></span><br><span class="line"><span class="number">100.667</span>: [Full GC [Tenured: <span class="number">0</span>K-&gt;<span class="number">210</span>K(<span class="number">10240</span>K), <span class="number">0.0149142</span> secs] <span class="number">4603</span>K-&gt;<span class="number">210</span>K(<span class="number">19456</span>K), [Perm : <span class="number">2999</span>K-&gt;<span class="number">2999</span>K(<span class="number">21248</span>K)], <span class="number">0.0150007</span> secs] [Times: user=<span class="number">0.01</span> sys=<span class="number">0.00</span>, real=<span class="number">0.02</span> secs]</span><br></pre></td></tr></table></figure><p>最前面的数字“<code>33.125</code>”和“<code>100.66</code>7”：代表了GC发生的时间，这个数字的含义是从Java虚拟机启动以来经过的秒数。</p><p>GC日志开头的“<code>[GC</code>”和“<code>[Full GC</code>”<strong>说明了这次垃圾收集的停顿类型，而不是用来区分新生代GC还是老年代GC的。</strong>如果有“<code>Full</code>”，说明这次GC是发生了Stop-The-World的。</p><p>接下来的“<code>[DefNew</code>”、“<code>[Tenured</code>”、“<code>[Perm</code>”表示GC发生的区域，这里显示的区域名称与使用的GC收集器是密切相关的。例如上面Serial收集器中的新生代名为“Default NewGeneration”，所以显示的收集“<code>[DefNew</code>”。如果是ParNew收集器，新生代名称就会变为“<code>[ParNew</code>”，意为“Parallel New Generation”。如果采用Parallel Scavenge收集器，那它配套的新生代为“PSYoungGen”，老年代和永久代同理,名称也是由收集器决定的。</p><p>后面方括号内部的“<code>3324K-&gt;152K(3712K)</code>” 含义是 “<strong>GC前该区域已使用容量 -&gt; GC后该区域已使用容量（该内存区域总容量</strong>）”。</p><p>而在方括号之外的“<code>3324K-&gt;152K(11904K)</code>” 表示 “<strong>GC前Java堆已使用容量 -&gt; GC后Java堆已使用容量（Java堆总容量）</strong>”。</p><p>再往后，“<code>0.0031680secs</code>”表示该内存区域GC所占用的时间，单位是秒。有的收集器会给出更具体的时间数据，如“<code>[Times: user=0.01 sys=0.00, real=0.02 secs]</code>”，这里面的user、sys和real与Linux的time命令所输出的含义一致，分别代表用户态消耗的CPU时间、内核态消耗的CPU时间和操作从开始到结束所经过的墙钟时间。</p><p>CPU时间与墙钟时间的区别是,墙钟时间包括各种非运算的等待耗时,例如等待磁盘I/O、等待线程阻塞,而CPU时间不包括这些耗时,但当系统有多CPU或者多核的话,多线程操作会叠加这些CPU时间,所以读者看到user或sys时间超过real时间是完全正常的。</p>]]></content>
    
    <summary type="html">
    
      阅读GC日志是处理Java虚拟机内存问题的基础技能，他只是一些人为规定的规则，没有太多技术含量。这里只是对两段典型的GC日志分析。
    
    </summary>
    
      <category term="Java虚拟机" scheme="http://yoursite.com/categories/Java%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    
    
  </entry>
  
  <entry>
    <title>JVM垃圾收集器</title>
    <link href="http://yoursite.com/posts/51819/"/>
    <id>http://yoursite.com/posts/51819/</id>
    <published>2019-08-30T06:50:44.000Z</published>
    <updated>2019-09-14T12:58:11.645Z</updated>
    
    <content type="html"><![CDATA[<h1 id="本文索引"><a href="#本文索引" class="headerlink" title="本文索引"></a>本文索引</h1><p><img src="/posts/51819/29176325.jpg" alt><br>关于内存分配和回收策略会在下一篇博文中讲解，本文就主要讲解后面三个关于GC的问题。</p><h1 id="对象已经死亡吗？"><a href="#对象已经死亡吗？" class="headerlink" title="对象已经死亡吗？"></a>对象已经死亡吗？</h1><p>在里面存放着Java世界中几乎所有的对象实例，垃圾收集器在对堆进行回收之前，第一件事情就是要确定这些对象之中那些还“存活”着，哪些已经“死去”（即不可能再被任何途径使用的对象）。<br><img src="/posts/51819/11034259.jpg" alt></p><h2 id="引用计数算法"><a href="#引用计数算法" class="headerlink" title="引用计数算法"></a>引用计数算法</h2><p>引用计数法的算法是这样的：<strong>给对象添加一个引用计数器，每当有一个地方引用它时，计数器的值就加一；当引用失效时，计数器的值就减一；任何时刻计数器为零的对象就是不可能再被使用的。</strong></p><p>虽然客观的说，引用计数算法的实现很简单，判定效率也很高，在大部分情况下它都是一个不错的算法。<strong>但是，至少主流的Java虚拟机里面没有选用引用计数算法来管理内存，其中最主要的原因就是它很难解决对象之间相互循环引用的问题。</strong></p><p>具体的例子如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReferenceCountingGc</span> </span>&#123;</span><br><span class="line">Object instance = <span class="keyword">null</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ReferenceCountingGc objA = <span class="keyword">new</span> ReferenceCountingGc();</span><br><span class="line">        ReferenceCountingGc objB = <span class="keyword">new</span> ReferenceCountingGc();</span><br><span class="line">        objA.instance = objB;</span><br><span class="line">        objB.instance = objA;</span><br><span class="line">        objA = <span class="keyword">null</span>;</span><br><span class="line">        objB = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对象objA和objB都有字段instance，赋值令 <code>objA.instance = objB</code>及<code>objB.instance = objA</code>，除此之外，这两个对象再无任何引用，实际上这两个对象不可能再被访问，但是他们因为互相引用着对方，导致它们的引用计数都不为零，于是引用计数算法无法通知GC回收它们。</p><h2 id="可达性分析算法"><a href="#可达性分析算法" class="headerlink" title="可达性分析算法"></a>可达性分析算法</h2><p>这个算法的基本思路就是通过一系列的称为“GC Roots”的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链，当一个对象到GC Roots没有任何引用链相连（用图论的话来说，就是从GC Roots到这个对象不可达）时，则证明此对象是不可用的。<br><img src="/posts/51819/72762049.jpg" alt></p><p>在Java语言中，可作为GC Roots的对象包括下面几种：</p><ul><li>虚拟机栈（栈帧中的本地变量表）中引用的对象</li><li>方法区中类静态属性引用的对象</li><li>方法区中常量引用的对象</li><li>本地方法中JNI（即一般说的Native方法）引用的对象</li></ul><h2 id="再谈引用"><a href="#再谈引用" class="headerlink" title="再谈引用"></a>再谈引用</h2><p>在JDK1.2之前，Java中引用的定义很传统：如果reference类型的数据存储的数值代表的是另一块内存的起始地址，就称这块内存代表一个引用<br>在JDK1.2之后，Java对引用的概念进行了扩充，将引用分为 强引用、软引用、弱引用、虚引用 四种，这四种引用强度依次逐渐减弱。</p><h3 id="强引用"><a href="#强引用" class="headerlink" title="强引用"></a>强引用</h3><p>强引用（Strong Reference）就是指在程序代码中普遍存在的，类似<code>Object obj = new Object()</code>这类的引用，我们使用的大部分引用实际上都是强引用。</p><p><strong>只要强引用还存在，垃圾收集器永远不会回收掉被引用的对象。</strong>当内存空间不足，Java虚拟机宁愿抛出 OutOfMemoryError错误，使程序异常终止，也不会随意回收具有强引用的对象来解决内存不足的问题。</p><h3 id="软引用"><a href="#软引用" class="headerlink" title="软引用"></a>软引用</h3><p>软引用（Soft Reference）是用来描述一些还有用，但是并非必需的对象。</p><p>如果内存空间足够，垃圾收集器就不会回收它；如果内存空间不足，在系统将要发生内存溢出异常之前，将会把这些对象列进回收范围之中进行第二次回收。如果这次回收还没有足够内存的话，才会抛出内存溢出异常。</p><h3 id="弱引用"><a href="#弱引用" class="headerlink" title="弱引用"></a>弱引用</h3><p>弱引用（Weak Reference）也是用来描述非必需的对象，但是它的强度更弱，被弱引用关联的对象只能生存到下一次垃圾收集发生之前。</p><p>当垃圾收集器工作时，无论当前内存是否足够，都会回收掉只被弱引用关联的对象。不过由于垃圾收集器是一个优先级很低的线程，因此不一定会很快发现那些只具有弱引用的对象。</p><h3 id="虚引用"><a href="#虚引用" class="headerlink" title="虚引用"></a>虚引用</h3><p>虚引用（Phantom Reference）顾名思义，就是形同虚设，它是最弱的一种引用关系。</p><p>一个对象是否具有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象的实例。</p><p>为一个对象设置虚引用关联的唯一目的就是能在这个对象被收集器回收时收到一个系统通知。</p><p><strong>在程序中一般很少使用弱引用和虚引用，使用软引用的情况比较多，因为软引用可以加速Java虚拟机堆垃圾内存的回收速度，可以维护系统的运行安全，防止内存溢出（OutOfMemoryError）等问题发生。</strong></p><p><img src="/posts/51819/249993-20170306195851516-1068507269.png" alt></p><h2 id="生存还是死亡"><a href="#生存还是死亡" class="headerlink" title="生存还是死亡"></a>生存还是死亡</h2><p>即使在可达性分析算法中不可达的对象，也并非是“非死不可”的，要真正宣告一个对象死亡，至少要经历两次标记过程：</p><p>如果对象在可达性分析后发现没有与GC Roots相连接的引用链，那它将会被标记并且进行第一次筛选，筛选的条件是此对象是否有必要执行finalize（）方法。<strong>当对象没有覆盖finalize（）方法，或者finalize（）方法已经被虚拟机调用过，虚拟机将这两种情况都视为“没有必要执行”。</strong></p><p>如果这个对象被判定有必要执行finalize（）方法，那么这个对象将会被放置在一个叫做F-Queue的队列之中，并在稍后由一个由虚拟机自动建立的、低优先级的Finalizer线程去执行它。</p><p>被判定为需要执行的对象，将会被放在F-Queue队列中进行二次标记。<strong>如果对象在finalize（）中成功拯救了自己————只要重新与引用链上的任何一个对象建立关联即可，譬如把自己赋值给某个类变量或者对象的成员变量，那在第二次标记的时候它将被移除出“即将回收”的集合；如果这个对象这时候还没有逃脱，那他基本上就真的被回收了。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 此代码演示了两点：</span></span><br><span class="line"><span class="comment"> * 1.对象可以再被GC时自我拯救</span></span><br><span class="line"><span class="comment"> * 2.这种自救的机会只有一次，因为一个对象的finalize()方法最多只会被系统自动调用一次</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FinalizeEscapeGC</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> FinalizeEscapeGC SAVE_HOOK = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FinalizeEscapeGC</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">isAlive</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"yes, i am still alive :)"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">finalize</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.finalize();</span><br><span class="line">        System.out.println(<span class="string">"finalize method executed!"</span>);</span><br><span class="line">        System.out.println(<span class="keyword">this</span>);</span><br><span class="line">        FinalizeEscapeGC.SAVE_HOOK = <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        SAVE_HOOK = <span class="keyword">new</span> FinalizeEscapeGC(<span class="string">"leesf"</span>);</span><br><span class="line">        System.out.println(SAVE_HOOK);</span><br><span class="line">        <span class="comment">// 对象第一次拯救自己</span></span><br><span class="line">        SAVE_HOOK = <span class="keyword">null</span>;</span><br><span class="line">        System.out.println(SAVE_HOOK);</span><br><span class="line">        System.gc();</span><br><span class="line">        <span class="comment">// 因为finalize方法优先级很低，所以暂停0.5秒以等待它</span></span><br><span class="line">        Thread.sleep(<span class="number">500</span>);</span><br><span class="line">        <span class="keyword">if</span> (SAVE_HOOK != <span class="keyword">null</span>) &#123;</span><br><span class="line">            SAVE_HOOK.isAlive();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"no, i am dead : ("</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 下面这段代码与上面的完全相同,但是这一次自救却失败了</span></span><br><span class="line">        <span class="comment">// 一个对象的finalize方法只会被调用一次</span></span><br><span class="line">        SAVE_HOOK = <span class="keyword">null</span>;</span><br><span class="line">        System.gc();</span><br><span class="line">        <span class="comment">// 因为finalize方法优先级很低，所以暂停0.5秒以等待它</span></span><br><span class="line">        Thread.sleep(<span class="number">500</span>);</span><br><span class="line">        <span class="keyword">if</span> (SAVE_HOOK != <span class="keyword">null</span>) &#123;</span><br><span class="line">            SAVE_HOOK.isAlive();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"no, i am dead : ("</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">leesf</span><br><span class="line"><span class="keyword">null</span></span><br><span class="line">finalize method executed!</span><br><span class="line">leesf</span><br><span class="line">yes, i am still alive :)</span><br><span class="line">no, i am dead : (</span><br></pre></td></tr></table></figure><p>从上面的运行结果可以看出，SAVE_HOOK对象的finalize（）方法确实被GC收集器触发过，并且在被收集前成功逃脱了。但是在第二次执行相同代码的时候，却逃脱失败，这是因为任何一个对象的finalize（）方法都只会被系统自动调用一次，如果对象面临下一次回收，它的finalize（）方法不会被再次执行，因此第二段代码的自救行动失败。</p><h2 id="回收方法区"><a href="#回收方法区" class="headerlink" title="回收方法区"></a>回收方法区</h2><p>很多人认为方法区是没有垃圾收集器的，虽然在方法区进行垃圾收集的性价比比较低，但是也并不代表在方法区去就一定没有垃圾收集的工作。</p><p>永久代的垃圾收集主要回收两部分内容：<strong>废弃常量</strong>和<strong>无用的类</strong>。</p><p>回收废弃常量与回收Java堆中的对象非常相似，以字符串为例，<strong>如果当前没有任何String对象引用常量池中的该字符串常量，也没有其他地方引用了这个字面量</strong>，就说明这个字符串常量为废弃常量。如果这是发生内存回收，而且有必要的话，这个常量就会被系统清理出常量池。</p><p>而判定一个类是否为“无用的类”的条件则苛刻的多，类需要同时满足下面三个条件才能算是“无用的类”：</p><blockquote><ul><li>该类所有的实例都已经被回收，也就是Java堆中不存在该类的任何实例。</li><li>加载该类的ClassLoader已经被回收。</li><li>该类对应的java.lang.Class 对象没有在任何地方被引用，无法在任何地方通过反射访问该类。</li></ul></blockquote><p>虚拟机<strong>可以</strong>对满足上述三个条件的无用类进行回收，这里说的仅仅是<strong>“可以”</strong>，并不是必然被回收。</p><h1 id="垃圾收集算法"><a href="#垃圾收集算法" class="headerlink" title="垃圾收集算法"></a>垃圾收集算法</h1><p><img src="/posts/51819/%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E7%AE%97%E6%B3%95.jpg" alt><br>由于垃圾收集算法的实现涉及大量的程序细节，且各个平台的虚拟机操作内存的方法又各不相同，因此这里不过多的讨论实现的细节，仅介绍几种算法的思想。</p><h2 id="标记-清除算法"><a href="#标记-清除算法" class="headerlink" title="标记-清除算法"></a>标记-清除算法</h2><p>最基础的算法就是“标记-清除（Mark-Sweep）”算法，顾名思义，<strong>算法分为“标记”和“清除”两个阶段：首先标记出所有需要回收的对象，在标记完成后统一回收所有被标记的对象。</strong></p><p>它的标记过程在前一节已经介绍过了，而且之所以说它是最基础的算法，因为后续的收集算法都是基于这种思路，并对其不足进行改进而得到的。</p><p>它的不足有两个：</p><blockquote><ul><li><strong>效率问题</strong>：标记和清除两个过程的效率都不高。</li><li><strong>空间问题</strong>：标记清除之后会产生大量不连续的内存碎片，空间碎片太多可能会导致以后再程序运行过程中需要分配较大对象时，无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作。  </li></ul></blockquote><p><img src="/posts/51819/63707281.jpg" alt></p><h2 id="复制算法"><a href="#复制算法" class="headerlink" title="复制算法"></a>复制算法</h2><p>复制算法是为了解决标记-清除算法的效率问题，<strong>它将内存按容量划分为大小相等的两块，每次只使用其中的一块。当这一块的内存用完了，就将还活着的对象复制到另一块上面，然后再把已使用过的内存空间一次清理掉。这样使得每次都是对整个半区进行内存回收，内存分配时也就不用考虑内存碎片等复杂情况，只要移动堆顶指针，按顺序分配内存即可，实现简单，运行高效。只是这种算法的代价是将内存缩小为了原来的一半，未免有点太高。</strong><br><img src="/posts/51819/90984624.jpg" alt></p><p>有统计表示，新生代中的对象98%是“朝生息死”的，所以并不需要按照1：1的比例来划分内存空间。</p><p><img src="/posts/51819/2019-3%E5%A0%86%E7%BB%93%E6%9E%84.png" alt></p><p>而是将内存分为一块较大的Eden空间和两块较小的Survivor空间，每次使用Eden和其中一块Survivor。当Eden满了时，触发一次Minor GC，然后将Eden和Survivor中还存活着的对象一次性的复制到另一块Survivor空间上（<strong>这个过程非常重要，因为这种复制算法保证了S1中来自S0和Eden两部分的存活对象占用连续的内存空间，避免了碎片化的发生</strong>），最后清理掉Eden和刚刚使用过的Survivor空间。HotSpot虚拟机默认Eden和Survivor的大小比例是8：1。</p><p>如此循环往复，如果对象的复制次数达到了16次，该对象就会被送到老年代中。</p><p><strong>其次当Survivor空间不够用时，需要依赖其他内存（这里指老年代）进行分配担保。大对象（就是需要大量连续内存空间的对象）直接进入老年代，因为这样做为了避免大对象分配内存时由于分配担保机制带来的复制而降低效率。</strong></p><p>复制收集算法在对象存活率较高时就要进行较多的复制操作，效率将会变低。</p><h2 id="标记-整理算法"><a href="#标记-整理算法" class="headerlink" title="标记-整理算法"></a>标记-整理算法</h2><p>因为复制算法的缺点，根据老年代的特点，有人提出另一种“标记-整理”算法。</p><p><strong>标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存。</strong><br><img src="/posts/51819/94057049.jpg" alt></p><h2 id="分代收集算法"><a href="#分代收集算法" class="headerlink" title="分代收集算法"></a>分代收集算法</h2><p><strong>当前商业虚拟机的垃圾收集都采用“分代收集”算法</strong>。这种算法把“复制算法”和“标记-整理”结合起来，根据对象存活周期的不同将内存划分为几块，把Java堆划分为新生代和老年代，根据各个年代的特点选择合适的垃圾收集算法。</p><p><strong>新生代中，每次垃圾收集时都发现有大批对象死去，只有少量存活，那就选用复制算法，只需要付出少量存活对象的复制成本就可以完成收集。</strong><br><strong>而老年代中因为对象存活率高、没有额外空间对它进行分配担保，就必须使用“标记-清理”或者“标记-整理”算法来进行回收</strong>。</p><h1 id="垃圾收集器"><a href="#垃圾收集器" class="headerlink" title="垃圾收集器"></a>垃圾收集器</h1><p>如果说收集算法时内存回收的方法论，那么垃圾收集器就是内存回收的具体实现。<br><img src="/posts/51819/%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8.jpg" alt><br>虽然我们对各个收集器进行比较，但并非要挑选出一个最好的收集器。因为直到现在为止还没有最好的垃圾收集器出现，更加没有万能的垃圾收集器，我们能做的就是根据具体应用场景选择适合自己的垃圾收集器。</p><h2 id="Serial收集器"><a href="#Serial收集器" class="headerlink" title="Serial收集器"></a>Serial收集器</h2><p>Serial收集器是最基本、发展历史最悠久的收集器。<strong>这个收集器是一个单线程的收集器，但它的“单线程”意义并不仅仅说明它只会使用一个CPU或者一条收集线程去完成垃圾收集工作，更重要的是他在进行垃圾收集时，必须暂停其他所有的工作线程，直到它收集完成。</strong><br><img src="/posts/51819/1075738-20190112090848364-1723329586.png" alt><br><strong>新生代采用复制算法，老年代采用标记-整理算法。</strong></p><p>虽然现在一个个越来越优秀的收集器出现，用户线程的停顿时间在不断缩短，但是仍然没有办法完全消除。</p><p>但实际上到现在为止，它依然是虚拟机运行在Client模式下的默认新生代收集器<strong>。它的优点如下：简单而高效，对于限定单个CPU的环境来说，Serial收集器由于没有线程交互的开销，专心做垃圾收集自然可以获得最高的单线程收集效率。</strong></p><h2 id="ParNew收集器"><a href="#ParNew收集器" class="headerlink" title="ParNew收集器"></a>ParNew收集器</h2><p><strong>ParNew收集器其实就是Serial收集器的多线程版本，除了使用多线程进行垃圾收集之外，其余行为（控制参数、收集算法、回收策略等等）都与Serial收集器完全一样。</strong><br><img src="/posts/51819/2018061116094429.png" alt><br><strong>新生代采用复制算法，老年代采用标记-整理算法。</strong></p><p>它是许多运行在Server模式下的虚拟机的首要选择，除了Serial收集器外，只有它能与CMS收集器（真正意义上的并发收集器，后面会介绍到）配合工作。</p><p>ParNew收集器在单CPU的环境中绝对不会有比Serial收集器更好的效果。</p><h3 id="并发和并行概念的补充"><a href="#并发和并行概念的补充" class="headerlink" title="并发和并行概念的补充"></a>并发和并行概念的补充</h3><ul><li>并行：指多条垃圾收集线程并行工作，但此时用户线程仍然处于等待状态。</li><li>并发：指用户线程与垃圾收集线程同时执行（但不一定是并行的，可能会交替执行），用户程序在继续执行，而垃圾收集程序运行在另一个CPU上。</li></ul><h2 id="Parallel-Scavenge收集器"><a href="#Parallel-Scavenge收集器" class="headerlink" title="Parallel Scavenge收集器"></a>Parallel Scavenge收集器</h2><p>Parallel Scavenge收集器收集算法和线程方面与ParNew收集器一样，但Parallel Scavenge收集器的目标则是达到一个可控制的吞吐量，因此该收集器也被称为“吞吐量优先”收集器。</p><p>该收集器提供了两个参数用于精确控制吞吐量，分别控制最大垃圾收集停顿时间的<code>-XX:MaxGCPauseMillis</code>参数以及直接设置吞吐量大小的<code>-XX:GCTimeRatio</code>参数。</p><p>该收集器还有一个参数<code>-XX:+UseAdaptiveSizePolicy</code>值得关注，这是一个开关参数。当这个参数打开之后，虚拟机会根据当前系统的运行情况收集性能监控信息，动态调整这些参数以提供最合适的停顿时间或者最大的吞吐量，这种调节方式称为GC自适应的调节策略。<strong>这也是该收集器与ParNew收集器的一个重要区别。</strong></p><h2 id="Serial-Old收集器"><a href="#Serial-Old收集器" class="headerlink" title="Serial Old收集器"></a>Serial Old收集器</h2><p>该收集器是Serial收集器的老年代版本。它主要的两大用途：</p><ul><li>在JDK1.5以及之前的版本中与Parallel Scavenge收集器搭配使用。</li><li>作为CMS收集器的后备预案。</li></ul><h2 id="Parallel-Old收集器"><a href="#Parallel-Old收集器" class="headerlink" title="Parallel Old收集器"></a>Parallel Old收集器</h2><p>Parallel Old收集器是Parallel Scavenge收集器的老年代版本。在注重吞吐量以及CPU资源的场合，都可以优先考虑Parallel Scavenge加Parallel Old收集器。工作过程如图所示。<br><img src="/posts/51819/20180611162333334.png" alt></p><h2 id="CMS收集器"><a href="#CMS收集器" class="headerlink" title="CMS收集器"></a>CMS收集器</h2><p>CMS（Concurrent Mark Sweep）收集器是一种以获取最短回收停顿时间为目标的收集器，它是HotSpot虚拟机第一款真正意义上的并发收集器，他第一次实现了让垃圾收集线程与用户线程（基本上）同时工作。</p><p>CMS收集器是基于“标记-清除”算法实现的，整个过程分为4个步骤：</p><ol><li><strong>初始标记</strong>：暂停所有的其他线程，并记录下直接与GC Roots能直接关联的对象，速度很快。</li><li><strong>并发标记</strong>：同时开启GC和用户线程,从GC Roots开始对堆中对象进行可达性分析,找出存活的对象，这阶段耗时较长。</li><li><strong>重新标记</strong>：暂停所有的其他线程，为了修正并发标记期间，因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间一般会比初始标记阶段稍长一些，但远比并发标记的时间短。</li><li><strong>并发清除</strong>：开启所有线程，同时GC线程对为标记的区域做清扫。</li></ol><p><img src="/posts/51819/82825079.jpg" alt><br>因为它的性能优点，也称它为并发低停顿收集器。但是它有以下三个明显的缺点：</p><ul><li><strong>CMS收集器对CPU资源非常敏感。</strong>在并发阶段虽然不会导致用户线程停顿，但是会因为占用一部分线程（或者说CPU资源）而导致应用程序变慢，总吞吐量降低。</li><li><strong>CMS收集器无法处理浮动垃圾，可能出现“Concurrent Mode Failure”失败而导致另一次Full GC的产生。</strong>由于用户程序在运行，那么自然就会有新的垃圾产生，这部分垃圾被标记过后，CMS无法在当次集中处理它们（为什么？原因在于CMS是以获取最短停顿时间为目标的，自然不可能在一次垃圾处理过程中花费太多时间），只好在下一次GC的时候处理。这部分未处理的垃圾就称为“浮动垃圾”。 这使得并发清除时需要预留一定的内存空间，不能像其他收集器在老年代几乎填满再进行收集。在JDK1.6中，CMS收集器启动阈值已经提升至92%。要是CMS运行期间的内存无法满足程序需要，就会出现一次“Concurrent Mode Failure”失败，这时虚拟机启用后备预案：临时启用Serail Old收集器，而导致另一次Full GC的产生。</li><li><strong>收集结束时会有大量空间碎片产生。</strong>因为它使用的回收算法-“标记-清除”算法会导致收集结束时会有大量空间碎片产生。，所以为了解决这个问题，CMS收集器提供了一个开关参数<code>-XX:+UseCMSCompactAtFullCollection</code>（默认开启），用于在CMS收集器顶不住要进行Full GC时开启内存碎片的合并整理过程，但是会导致停顿时间变长。</li></ul><h2 id="G1收集器"><a href="#G1收集器" class="headerlink" title="G1收集器"></a>G1收集器</h2><p>G1收集器是当今收集器技术发展的最前沿成果之一，以极高概率满足GC停顿时间要求的同时，还具备高吞吐量性能特征。它具备以下特点：</p><blockquote><ul><li><strong>并行与并发</strong>：G1能充分利用多CPu、多核环境下的硬件优势，使用多个CPU（或者CPU核心）来缩短Stop-The-Word停顿的时间，部分其他收集器原本需要停顿Java线程执行的GC动作，G1收集器仍然可以通过并发的方式让Java程序继续运行。</li><li><strong>分代收集</strong>：同其他收集器一样保留了分代的概念，但是它能够采用不同的方式去处理新创建的对象和已经存活了一段时间、熬过多次GC的旧对象以获取更好的收集效果。</li><li><strong>空间整合</strong>：不同于CMS的“标记-清除”算法，G1从整体看是基于“标记-整理”算法实现的收集器，从局部（两个Region之间）上来看是基于“复制”算法是实现的，但无论如何，这两种算法都意味着G1运行期间不会产生内存空间碎片。</li><li><strong>可预测的停顿</strong>：这是G1相对于CMS的另一大优势，G1除了追求低停顿外，还能建立可预测的停顿时间模型，能让使用者明确指定在一个长度为M浩渺的时间片段内。</li></ul></blockquote><p>G1收集器中Java堆的内存布局与其他收集器有很大区别，<strong>它将整个Java堆划分为多个大小相等的独立区域（Region），虽然还保留新生代和老生代的概念，但新生代和老生代不再是物理隔离的了，它们都是一部分Region（不需要连续）的集合。</strong></p><p>G1跟踪各个Region里面的垃圾堆积的价值大小（回收所获得的空间大小以及回收所需时间吨经验值），在后台维护一个优先列表，每次根据允许的收集时间，优先回收价值最大的Region（这也是Garbage-First名称的由来）。这种使用Region划分内存空间以及有优先级的区域回收方式，保证了G1收集器在有限的时间内可以获取尽可能高的收集效率。</p><p>在G1收集器中，Region之间的对象引用以及其他收集器中的新生代与老年代之间的对象引用，虚拟机都是使用Remembered Set 来避免全堆扫描的。G1中每个Region都有一个与之对应的Remembered Set，如果不计算维护Remembered Set的操作，G1收集器的运作大致可划分为以下几个步骤：</p><ol><li><strong>初始标记</strong>：仅仅只是标记一下GC Roots能直接关联到的对象，并且修改TAMS（Next Top At Mark Start）的值，让下一阶段用户程序并发运行时，能在正确可用的Region中创建新对象。<strong>这阶段需要停顿线程，但耗时很短。</strong></li><li><strong>并发标记</strong>：这阶段是从GC Roots开始对堆中对象进行可达性分析，找出存活的对象，<strong>这阶段耗时较长，但可与用户程序并发执行。</strong></li><li><strong>最终标记</strong>：这阶段则是为了修正在并发标记阶段期间因用户程序继续运行而导致标记产生变化的那一部分标记记录，虚拟机将这段时间变化记录在线程Remembered Set Logs里面，最终标记阶段需要把Remembered Set Logs的数据合并到Remembered Set中，<strong>这阶段需要停顿线程，但可并行执行。</strong></li><li><strong>筛选回收</strong>：最后首先对各个Region的回收价值和成本进行排序，根据用户所期望的GC停顿时间来制定回收计划，这个阶段其实也可以做到与用户程序一起并发执行。</li></ol><p><img src="/posts/51819/20180607234900880.png" alt></p><h2 id="垃圾收集器参数总结"><a href="#垃圾收集器参数总结" class="headerlink" title="垃圾收集器参数总结"></a>垃圾收集器参数总结</h2><p><img src="/posts/51819/%E5%8F%82%E6%95%B0%E6%80%BB%E7%BB%93.png" alt></p>]]></content>
    
    <summary type="html">
    
      经过半个多世纪的发展，目前内存的动态分配与内存回收技术已经相当成熟，一切看起来都进入“自动化时代”。但是当需要排查各种内存溢出，内存泄漏问题时，当垃圾收集成为系统达到更高并发量的瓶颈时，我们就需要对这些“自动化”的技术实施必要的监控。
    
    </summary>
    
      <category term="Java虚拟机" scheme="http://yoursite.com/categories/Java%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    
    
  </entry>
  
  <entry>
    <title>HotSpot 虚拟机对象探秘</title>
    <link href="http://yoursite.com/posts/58276/"/>
    <id>http://yoursite.com/posts/58276/</id>
    <published>2019-08-26T14:19:49.000Z</published>
    <updated>2019-09-14T12:58:18.034Z</updated>
    
    <content type="html"><![CDATA[<h1 id="对象的创建"><a href="#对象的创建" class="headerlink" title="对象的创建"></a>对象的创建</h1><p>下图便是一个Java对象创建的过程<br><img src="/posts/58276/Java%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1%E7%9A%84%E8%BF%87%E7%A8%8B.png" alt></p><h2 id="类加载检查"><a href="#类加载检查" class="headerlink" title="类加载检查"></a>类加载检查</h2><p>在Java程序运行期间无时无刻都有对象被创建出来，在语言层面来说，创建对象通常仅仅是一个new关键字而已，而在虚拟机中，遇到一条new指令时，<strong>首先将去检查这个指令的参数是否能在常量池中定位到这个类的符号引用，并且检查这个符号引用代表的类是否已被加载、解析和初始化过。如果没有，那必须先执行相应的类加载过程。</strong></p><h2 id="分配内存"><a href="#分配内存" class="headerlink" title="分配内存"></a>分配内存</h2><p>在类加载检查通过之后，接下来虚拟机将为新生对象分配内存。对象所需的内存大小在类加载完成后便可完全确定（具体将在下一节介绍）。</p><p>为对象分配内存空间的任务等于把一块确定大小的内存从Java堆中划分出来。分配方式有两种：<strong>“内存碰撞”</strong>和<strong>“空闲列表”</strong>，选择哪种方式由Java堆是否规整决定，而Java堆是否规整取决于虚拟机所采用的垃圾收集器是否带有压缩整理功能。</p><blockquote><ul><li>指针碰撞：Java堆中内存是绝对规整的，所有用过的内存放在一边，空闲的内存放在另一边，中间放着一个指针作为分界点的指示器，那么分配内存就是把指针向空闲空间那边挪动对象大小的距离即可。</li><li>空闲列表：如果Java堆中内存并不是规整的，已使用的内存与空闲的内存相互交错，那么虚拟机就必须维护一个列表，记录那些内存是可用的，在分配的时候从列表中找到一块足够大的内存空间划分给对象实例，并更新列表上的记录。</li></ul></blockquote><p><img src="/posts/58276/%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%9A%84%E4%B8%A4%E7%A7%8D%E6%96%B9%E5%BC%8F.png" alt></p><p>因为在虚拟机中对象创建是一个非常频繁的行为，即使是仅仅修改一个指针所指向的位置，在并发的情况下也并不是线程安全的。可能出现正在给A对象分配内存，指针还没来得及修改，对象B又同时使用了原来的指针来分配内存的情况。所以对于内存分配引发的并发问题有两种解决方案：<strong>CAS+失败重试</strong>和<strong>本地线程分配缓冲（TLAB）</strong></p><blockquote><ul><li>CAS+失败重试：以这种方式保证更新操作的原子性。</li><li>本地线程分配缓冲（TLAB）：把内存分配堆动作按线程划分在不同的空间之中进行，即每个线程在Java堆中预先分配一小块内存，每个线程在自己的TLAB上分配内存，只有当对象大于TLAB中的剩余内存或者TLAB用完时，采用同步锁定（synchronized）的方式分配新的TLAB。</li></ul></blockquote><h2 id="初始化零值"><a href="#初始化零值" class="headerlink" title="初始化零值"></a>初始化零值</h2><p>内存分配完成后，虚拟机将对分配到的内存空间都初始化为零值（不包括对象头），如果使用TLAB，这一步可以提前至TLAB分配时进行。</p><p>这一步的操作保证了对象的实例字段在Java代码中可以不赋初始值就直接使用，程序能访问到这些字段的数据类型所对应的零值。</p><h2 id="设置对象头"><a href="#设置对象头" class="headerlink" title="设置对象头"></a>设置对象头</h2><p>初始化零值之后，虚拟机要对对象进行必要的设置，例如这个对象是哪个类的实例、如何才能找到类的元数据信息、对象的哈希码、对象的GC分代年龄等信息。<strong>这些信息都存放在对象头中。</strong></p><p>根据虚拟机当前的运行状态不同，如是否启用偏向锁等，对象头会有相应的不同的设置方式，具体会在下一节做详细介绍。</p><h2 id="执行init方法"><a href="#执行init方法" class="headerlink" title="执行init方法"></a>执行init方法</h2><p>在上面四个步骤完成之后，在Java虚拟机的角度，一个新的对象已经产生了；但是在Java程序的角度来看，对象的创建才刚开始，<code>&lt;init&gt;</code>方法还没有执行，所有的字段都是零。</p><p>所以一般来说，<strong>执行new指令之后会接着执行<code>&lt;init&gt;</code>方法，把对象按照程序员的意愿进行初始化</strong>，这样一个真正可用的对象才算完全产生出来。</p><h1 id="对象的内存布局"><a href="#对象的内存布局" class="headerlink" title="对象的内存布局"></a>对象的内存布局</h1><p><strong>在HotSpot虚拟机中，对象在内存中存储的布局可以分为3块区域：对象头（Header）、实例数据（Instance Data）和对齐填充（Padding）。</strong></p><h2 id="对象头"><a href="#对象头" class="headerlink" title="对象头"></a>对象头</h2><p>HotSpot虚拟机的对象头包括两部分信息:<strong>Mark Word</strong> 和 <strong>类型指针（Class Pointer）</strong>。</p><p>Java虚拟机中对象头的方式有以下俩种（以32位Java虚拟机为例）：<br>普通对象：<img src="/posts/58276/%E6%99%AE%E9%80%9A%E5%AF%B9%E8%B1%A1Header.png" alt><br>数组对象：<img src="/posts/58276/%E6%95%B0%E7%BB%84%E5%AF%B9%E8%B1%A1Header.png" alt></p><h3 id="Mark-Word"><a href="#Mark-Word" class="headerlink" title="Mark Word"></a>Mark Word</h3><p><strong>第一部分用于存储对象自身的运行时数据（mark Word）</strong>，如哈希码、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳等。<br>这部分数据的长度在32位和64位的虚拟机（未开启压缩指针）中分别为32bit和64bit，也就是一个Word的大小，官方称它为“Mark Word”。</p><p>对象需要存储的运行时数据很多时，如果超出了32位或64位Bitmap结构所能记录的限度。考虑到虚拟机的空间效率，Mark Word被设计成一个非固定的数据结构以便在极小的空间内存储尽量多信息，<strong>它会根据对象的状态复用自己的存储空间</strong>。</p><p>大部分情况下，Mark Word的32bit空间中的25bit用于存储对象哈希码，4bit用于存储对象分代年龄，2bit用于存储锁状态标志位，1bit用于标记对象是否启用偏向锁</p><p>不同锁状态标志位标记位表示的整个Mark Word含义不同，具体如下： <img src="/posts/58276/MarkWord.png" alt>    </p><p>其中各部分的含义如下：</p><blockquote><ul><li><strong>lock</strong> : 2位的锁状态标记位，该标记的值不同，整个Mark Word表示的含义不同。</li></ul><table><thead><tr><th align="center">存储内容</th><th align="center">biased_lock</th><th align="center">lock（标记位）</th><th align="center">状态</th></tr></thead><tbody><tr><td align="center">对象的哈希码、分代年龄</td><td align="center">0</td><td align="center">01</td><td align="center">无锁</td></tr><tr><td align="center">偏向线程ID、偏向时间戳、对象分代年龄</td><td align="center">1</td><td align="center">01</td><td align="center">偏向锁</td></tr><tr><td align="center">指向锁记录的指针</td><td align="center">0</td><td align="center">00</td><td align="center">轻量级锁</td></tr><tr><td align="center">指向重量级锁的指针</td><td align="center">0</td><td align="center">10</td><td align="center">重量级锁</td></tr><tr><td align="center">空，不需要记录信息</td><td align="center">0</td><td align="center">11</td><td align="center">GC标记</td></tr></tbody></table><ul><li><strong>biased_lock</strong> : 只占1位，用于标记对象是否启用偏向锁。为1时表示对象启用偏向锁，为0时表示对象没有偏向锁。</li><li><strong>age</strong> ： 4位的Java对象分代年龄。由于只有4位，所以最大值为15。</li><li><strong>identity_hashcode</strong> ： 25位的对象标识哈希码，采用延迟加载技术。调用<code>System.identityHashCode()</code>计算，并会将结果写到该对象头中。<strong>当对象被锁定时，该值会移动到管程Monitor中。</strong></li><li><strong>thread</strong> ： 占23位，表示持有偏向锁的线程ID。</li><li><strong>epoch</strong> ： 占2位，表示偏向时间戳。</li><li><strong>ptr_to_lock_record</strong> ： 占30位，指向栈中锁记录的指针。</li><li><strong>ptr_to_heavyweight_monitor</strong> ： 占30位，指向管程Monitor的指针。</li></ul></blockquote><h3 id="类型指针"><a href="#类型指针" class="headerlink" title="类型指针"></a>类型指针</h3><p>对象头的另一部分就是类型指针，<strong>即对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例</strong>。</p><p>该指针的位长度为JVM的一个字大小，即32位的JVM为32位，64位的JVM为64位。如果应用的对象过多，使用64位的指针将浪费大量内存，统计而言，64位的JVM将会比32位的JVM多耗费50%的内存。为了节约内存可以开启压缩指针（<code>+UseCompressedOops</code>），，其中，OOPS（ordinary object pointers），即普通对象指针。开启该选项后，下列指针将压缩至32位：</p><ul><li>每个Class的属性指针（即静态变量）</li><li>每个对象的属性指针（即对象变量）</li><li>普通对象数组的每个元素指针</li></ul><p><strong>如果对象是一个Java数组，那在对象头中还必须有一块用于记录数组长度的数据，</strong>这部分数据的长度也随着JVM架构的不同而不同：32位的JVM上，长度为32位；64位JVM则为64位。</p><h2 id="实例数据"><a href="#实例数据" class="headerlink" title="实例数据"></a>实例数据</h2><p><strong>实例数据部分是对象真正存储的有效信息</strong>，也就是在程序代码中所定义的各种类型的字段。</p><p><strong>这部分的存储顺序会受到虚拟机分配策略和字段在Java源码中定义的顺序的影响</strong>，HotSpot虚拟机默认的分配策略为longs/doubles、ints、shorts/chars、bytes/booleans、OOPS（ordinary object pointers），从这个分配策略可以看出，子类中较窄的变量也可能会插入到父类变量的空隙之中。</p><h2 id="对齐填充"><a href="#对齐填充" class="headerlink" title="对齐填充"></a>对齐填充</h2><p><strong>第三部分对齐填充并不是必然存在的，也没有特别的含义，仅仅起着占位符的作用</strong>，因为 Hotspot 虚拟机的自动内存管理系统要求对象起始地址必须是 8 字节的整数倍，换句话说就是对象的大小必须是 8 字节的整数倍。而对象头部分正好是 8 字节的倍数（1 倍或 2 倍），因此，当对象实例数据部分没有对齐时，就需要通过对齐填充来补全。</p><p>关于对象头的具体实现处，可以参考ArrayList的数组默认最大长度（Integer.MAX_VALUE - 8）。</p><h1 id="对象的访问定位"><a href="#对象的访问定位" class="headerlink" title="对象的访问定位"></a>对象的访问定位</h1><p>建立对象就是为了使用对象，<strong>我们的Java程序需要通过栈上的reference数据来操作堆上的具体对象</strong>。</p><p>而由于reference类型在Java虚拟机规范中只规定了一个指向对象的引用，没有定义这个引用该通过何种方式去定位、访问堆中的对象的具体位置。所以目前主流的访问方式有两种：<strong>句柄</strong>和<strong>直接指针</strong>。</p><h2 id="句柄"><a href="#句柄" class="headerlink" title="句柄"></a>句柄</h2><p>如果使用句柄访问的话，那么<strong>Java堆中将会划分出一块内存来作为句柄池，reference中储存的就是对象的句柄地址，而句柄中包含了对象实例数据与类型数据各自的具体地址信息</strong>。如图所示：<img src="/posts/58276/%E5%AF%B9%E8%B1%A1%E7%9A%84%E8%AE%BF%E9%97%AE%E5%AE%9A%E4%BD%8D-%E4%BD%BF%E7%94%A8%E5%8F%A5%E6%9F%84.png" alt></p><h2 id="直接指针"><a href="#直接指针" class="headerlink" title="直接指针"></a>直接指针</h2><p>如果使用直接指针，那么<strong>Java堆对象的布局中就必须考虑如何放置访问类型数据的相关信息，而reference在储存的直接就是对象的地址</strong>。如图所示：<img src="/posts/58276/%E5%AF%B9%E8%B1%A1%E7%9A%84%E8%AE%BF%E9%97%AE%E5%AE%9A%E4%BD%8D-%E7%9B%B4%E6%8E%A5%E6%8C%87%E9%92%88.png" alt></p><h2 id="句柄和直接指针对比"><a href="#句柄和直接指针对比" class="headerlink" title="句柄和直接指针对比"></a>句柄和直接指针对比</h2><p>这两种方式各有优势。</p><ul><li><p><strong>句柄方式的最大好处就是reference中存储的是稳定的句柄地址</strong>，在对象被移动（GC回收时移动对象是非常普遍的行为）时只会改变句柄中的示例数据指针，而reference本身不需要改变。</p></li><li><p><strong>直接指针方式的最大好处就是速度更快</strong>，它节省了一次指针定位的时间开销。由于对象的访问在Java中非常频繁，因此这类开销积少成多后也是一项非常可观的执行成本。</p></li></ul>]]></content>
    
    <summary type="html">
    
      在了解了Java内存区域是如何划分后，就要落实到具体的问题来思考了，要知道数据是如何创建、如何布局以及如何访问的细节问题，因此就以HotSpot虚拟机为例来了解这些细节问题。
    
    </summary>
    
      <category term="Java虚拟机" scheme="http://yoursite.com/categories/Java%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    
    
  </entry>
  
  <entry>
    <title>Java内存区域</title>
    <link href="http://yoursite.com/posts/35314/"/>
    <id>http://yoursite.com/posts/35314/</id>
    <published>2019-08-25T13:50:45.000Z</published>
    <updated>2019-09-14T12:58:28.882Z</updated>
    
    <content type="html"><![CDATA[<h1 id="运行时数据区域"><a href="#运行时数据区域" class="headerlink" title="运行时数据区域"></a>运行时数据区域</h1><p>Java虚拟机（JVM）在执行Java程序的过程中会把它所管理的内存划分为若干个不同的数据区域。而在JDK1.8前后数据区域的划分略有不同，下面会介绍到。<br>JDK1.8之前：<img src="/posts/35314/JVM%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E5%9F%9F.png" alt><br>JDK1.8： <img src="/posts/35314/2019-3Java%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E5%9F%9FJDK1.8.png" alt><br>因此根据上面的运行时数据区划分图可以看出：</p><p><strong>线程私有的：</strong></p><blockquote><ul><li>程序计数器</li><li>虚拟机栈</li><li>本地方法栈</li></ul></blockquote><p><strong>线程共享的：</strong></p><blockquote><ul><li>堆</li><li>方法区</li><li>直接内存（非运行时数据区的一部分）</li></ul></blockquote><p>下面就按照上面的顺序逐个进行了解。</p><h2 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h2><p>程序计数器是一块较小的内存空间。在虚拟机的概念模型里面，字节码解释器工作时需要知道该执行哪一条字节码指令，而程序计数器的作用就是，通过改变程序计数器的值，来让字节码解释器知道，下一条需要执行的指令是什么。</p><p>其次，Java虚拟机的多线程执行，是通过线程之间轮流执行，而对于一个处理器（如果是多核处理器，那么就是一个内核），在任意一个确定的时刻，只会执行一条线程中的指令。因此，为了避免一个线程过长时间（可能因为计算时间过长或者陷入死循环等原因）占用处理器，导致系统崩溃，所以处理器会给每个线程分配执行的时间，如果当分配的时间结束时，该线程的任务还没有执行完，处理器会被剥夺并分配给另一个线程，直到到达下一次该线程的时间片，处理器才会切换回来，继续执行该线程。因此，为了线程切换后能恢复到正确的执行位置，所以每条线程都需要有一个独立的程序计数器，各线程之间计数器互不影响，独立存储，我们称这类内存区域为“线程私有”的内存。</p><p>从上面的介绍中我们知道程序计数器主要有两个作用：</p><blockquote><ul><li>字节码解释器通过改变程序计数器，从而实现代码的流程控制，如：顺序执行、选择、循环、异常处理等。</li><li>在多线程情况下，程序计数器用于记录当前线程执行的位置，从而当线程切换回来的时候，能够知道该线程上次执行到哪里，接下来该执行什么指令。</li></ul></blockquote><p><strong>注意：</strong></p><blockquote><ul><li>如果线程正在执行的是一个Java方法，那么这个程序计数器是正在执行的方法的虚拟机字节码指令的地址。</li><li>如果线程正在执行的是一个Native方法，那么这个程序计数器则为空（Undefined）。<strong>因此程序计数器是唯一一个不会出现 OutOfMemoryError 的内存区域</strong>，它的生命周期随着线程的创建而创建，随着线程的结束而死亡。</li></ul></blockquote><h2 id="Java虚拟机栈"><a href="#Java虚拟机栈" class="headerlink" title="Java虚拟机栈"></a>Java虚拟机栈</h2><p>Java虚拟机栈描述的是Java方法的内存模型，每次方法调用的数据都是通过栈传递的。而栈中储存的是一个个的栈帧，栈帧就是每个方法在执行的时候都会创建一个栈帧（Stack Frame），栈帧用于储存局部变量表、操作数栈、动态链接、方法出口等信息。因为线程每调用一个方法从开始到结束，都意味着一个栈帧在虚拟机栈中从入栈到出栈的过程。</p><p>Java内存可以粗糙的分为堆内存（Heap）和栈内存（Stack），其中的栈就是Java虚拟机栈，或者说是Java虚拟机栈中的局部变量表部分。</p><p>局部变量表存放了编译器可知的各种（八种）基本数据类型（boolean、byte、char、short、int、float、double、long）、对象引用（不同于对象本身，可能是一个指向对象起始地址的引用指针，也可能是指向一个代表对象的句柄或其他与此对象相关的位置）和returnAdress类型（指向一条字节码指令地址）。<br>其中64位的长度的double和long类型的数据都会占用两个局部变量空间，其余数据只会占用一个局部变量空间。局部变量表所需内存空间在编译期间完成分配，因此当进入一个方法时，这个局部变量表的大小就已经完全确定了，运行期间不会改变其大小。</p><p>Java 虚拟机栈会出现两种异常：<strong>StackOverFlowError 和 OutOfMemoryError</strong></p><blockquote><ul><li><strong>StackOverFlowError:</strong>若Java虚拟机栈的内存大小<strong>不允许</strong>动态扩展，那么如果线程请求的栈深度大于虚拟机所允许的最大深度，那么就会抛出StackOverFlowError异常。</li><li><strong>OutOfMemoryError：</strong>若Java虚拟机栈的内存大小<strong>允许</strong>动态扩展，那么如果线程在扩展时无法申请到足够的内存，就会抛出OutOfMemoryError异常。</li></ul></blockquote><p>Java方法的返回方式有两种：<strong>return语句</strong>和<strong>抛出异常</strong>，不管哪种方法，都会导致栈帧出栈。</p><h2 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h2><p>本地方法栈的作用与Java虚拟机栈的结构和作用几乎完全一样，可以认为二者唯一的区别就是：<strong>Java虚拟机栈为虚拟机执行Java方法（也就是字节码）服务；而本地方法栈为虚拟机执行Native方法服务</strong>。甚至在HotSpot虚拟机栈中将两者合二为一。</p><p><strong>总结得到一点：程序计数器、Java虚拟机栈和本地方法栈都是线程所私有的，故而他们的生命周期和线程相同，它们的生命周期随着线程的创建而创建，随着线程的结束而死亡。</strong></p><h2 id="Java堆"><a href="#Java堆" class="headerlink" title="Java堆"></a>Java堆</h2><p>Java堆（Heap）是Java虚拟机所管理的内存中最大的一块。Java 堆是所有线程共享的一块内存区域，在虚拟机启动时创建。此内存的唯一目的就是：<strong>存放对象实例，几乎所有的对象实例都在这里分配</strong>，在Java虚拟机规范中的描述是：<strong>所有对象的实例以及数组都要在堆上分配。</strong>，但是随着JIT编译器的发展，这种情况也不是那么绝对的了。</p><p>java堆也是垃圾收集器管理的主要区域，因此也被称为 GC堆 ，从垃圾回收的角度看，Java堆中还可细分为：新生代和老生代；再度细分可分：Eden 空间、From Survivor、To Survivor 空间等为；大部分情况下，对象都会首先在Eden区域分配，再一次新生代垃圾回收后，如果对象还存活，则会进入s0或是s1在，并且对象年龄还加一，当他的年龄增加到一定程度（默认为15岁）时，就会被划分到老年代中。</p><p>不论如何划分，都与存放的内容无关；不论哪个区域，存储的都是对象的实例。<strong>进一步划分的目的是为了更好的回收内存，更快的分配内存。</strong></p><p>Java堆可以处于物理上不连续的内存空间中，只要逻辑上是连续的即可。</p><p>Java堆的内存大小可以是固定大小的，也可以是可扩展的（大部分都是）。如果在堆中没有内存来完成实例的分配，并且堆也无法再扩展时，将会抛出<strong>OutOfMemoryError</strong>异常。</p><h2 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h2><p>方法区同样是各个线程共享的内存区域，<strong>它用于储存已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。</strong>方法区有一个别名叫“非堆（Non-Heap）”，目的就是为了将其与Java堆区分开来。</p><p>仅在HotSpot虚拟机中，方法区也被称为“<strong>永久代</strong>”，仅仅是因为在HotSpot虚拟机中把GC分代收集扩展至方法区，这样可以省去专门为方法区编写内存管理代码的工作。但是问题也因此而来，因为永久代有大小上限，所以当触碰到内存大小的上限时，会抛出OutOfMemoryError异常。</p><p>所以在JDK1.8之后，永久代被彻底删除了，取而代之的是<strong>元空间</strong>（MetaSpace），与永久代有JVM本身内存大小上限的限制不同的是，元空间使用的是直接内存，受到的是本机可用内存的上限限制，只有当触碰到本地内存的极限时，才会抛出OutofMemoryError异常（概率极小）。</p><p>与java堆一样，方法区同样不需要连续的内存和可以选择固定大小或可扩展外，还可以选择不实现垃圾收集。相对而言垃圾收集行为在该区域比较少见，因为该区域内存回收目标主要是针对常量池的回收和对类型的卸载。</p><h2 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h2><p>JDK1.7之前，运行时常量池是方法区的一部分。Class文件中除了有类的版本、字段、方法、接口等描述信息外，还有常量池信息，用于存放编译期生成的各种<strong>字面量</strong>和<strong>符号引用</strong>。<br>运行时常量池相对于Class文件常量池还有一个重要特征是具备<strong>动态性</strong>，将运行期间可能得到的新的常量放入池中。<br>因此既然运行时常量池是方法区的一部分，所以当常量池无法再申请到内存时会抛出 OutOfMemoryError 异常。</p><p><strong>但是在JDK1.7及其之后版本的JVM中，将运行时常量池从方法区中移了出来，在Java堆中开辟了一块内存存放运行时常量池，这样也更加方便于垃圾回收的工作。</strong><br><img src="/posts/35314/26038433.jpg" alt></p><h2 id="直接内存"><a href="#直接内存" class="headerlink" title="直接内存"></a>直接内存</h2><p><strong>直接内存既不是虚拟机运行时数据区的一部分，也不是Java虚拟机规范中定义的内存区域，但是这一部分内存被频繁的使用，而且也可能导致OutofMemoryError异常。</strong></p><p>在JDK1.4中新加入了NIO类，引入了一种基于通道（Channel）于缓存区（Buffer）的I/O方式，它使用Native函数库直接分配堆外内存，然后通过一个存储在Java堆中的DirectByteBuffer对象作为这块内存的引用进行操作。<strong>这样就能在一些场景中显著提高性能，因为避免了在Java堆和Native堆之间来回复制数据。</strong></p><p>虽然本机直接内存并不会收到Java堆的内存大小限制，但是显然会受到本地总内存的大小限制，因此也可能会在动态扩展时抛出OutOfMemoryError异常。</p>]]></content>
    
    <summary type="html">
    
      对于Java程序员来说，在虚拟机自动内存管理机制的帮助下，不需要为每一个new的操作去写配对的delete/free代码，不容易出现内存泄露和内存溢出的问题，因为把这些工作交给虚拟机去管理内存；但也正是因为如此，一旦出现内存泄露和溢出方面的问题，如果不了解虚拟机是如何使用内存的，那么排查错误将会成为一项异常艰难的工作。
    
    </summary>
    
      <category term="Java虚拟机" scheme="http://yoursite.com/categories/Java%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    
    
  </entry>
  
  <entry>
    <title>ArrayList源码阅读</title>
    <link href="http://yoursite.com/posts/33665/"/>
    <id>http://yoursite.com/posts/33665/</id>
    <published>2019-08-06T11:57:45.000Z</published>
    <updated>2019-09-14T12:57:56.280Z</updated>
    
    <content type="html"><![CDATA[<h1 id="ArrayList的数据结构"><a href="#ArrayList的数据结构" class="headerlink" title="ArrayList的数据结构"></a>ArrayList的数据结构</h1><p>ArrayList往往被人用来与LinkedList对比，它们俩最重要的差异之一就是：ArrayList的底层是由数组组成的，而LinkedList的底层则是由链表组成，对于LinkedList不再多赘述，具体可以看一下LinkedList的文章。回到ArrayList中来，其实现的数据结构是一个名为elementData的Object数组，可以存放所有Object对象，因此我们对ArrayList类的实例的所有的操作底层都是基于这个数组的。<br><img src="/posts/33665/ArrayListDataStructure.jpg" alt></p><h1 id="顶部注释"><a href="#顶部注释" class="headerlink" title="顶部注释"></a>顶部注释</h1><blockquote><p>List接口的可调整大小的数组实现。 实现所有可选列表操作，并允许所有元素，包括null 。 除了实现List接口之外，该类还提供了一些方法来处理内部用于存储列表的数组的大小。 （这个类大致相当于Vector ，除了它是不同步的。）<br>该size ， isEmpty ， get ， set ， iterator ，并listIterator操作在固定时间内运行。 add操作以摊销的常数运行 ，即添加n个元素需要O（n）个时间。 所有其他操作都以线性时间运行（粗略地说）。 与LinkedList实现相比，常数因子较低。 </p><p>每个ArrayList实例都有一个容量 。 容量是用于存储列表中的元素的数组的大小。 它总是至少与列表大小一样大。 当元素添加到ArrayList时，其容量会自动增长。 没有规定增长政策的细节，除了添加元素具有不变的摊销时间成本。 </p><p>在使用ensureCapacity操作添加大量元素之前，应用程序可以增加ArrayList实例的容量。 这可能会减少增量重新分配的数量。 </p><p>请注意，此实现不同步。 如果多个线程同时访问ArrayList实例，并且至少有一个线程在结构上修改列表，则必须在外部进行同步。 （结构修改是添加或删除一个或多个元素的任何操作，或明确调整后台数组的大小;仅设置元素的值不是结构修改。）这通常是通过在一些自然地封装了名单。 如果没有这样的对象存在，列表应该使用Collections.synchronizedList方法“包装”。 这最好在创建时完成，以防止意外的不同步访问列表： </p><p>List list = Collections.synchronizedList(new ArrayList(…)); 由这个类的iterator和listIterator方法返回的迭代器是故障快速的 ：如果列表在迭代器创建之后的任何时间被结构地修改，除了通过迭代器自己的remove或add方法之外，迭代器将抛出一个ConcurrentModificationException 。 因此，面对并发修改，迭代器将快速而干净地失败，而不是在未来未确定的时间冒着任意的非确定性行为。 </p><p>请注意，迭代器的故障快速行为无法保证，因为一般来说，在不同步并发修改的情况下，无法做出任何硬性保证。 失败快速的迭代器ConcurrentModificationException扔出ConcurrentModificationException 。 因此，编写依赖于此异常的程序的正确性将是错误的： 迭代器的故障快速行为应仅用于检测错误。 </p><p>这个类是Java Collections Framework的成员。 </p></blockquote><p>总结上面的顶部注释可以得到以下几点：</p><ul><li><strong>底部实现</strong>：可调整大小的数组实现的。</li><li><strong>是否允许null值</strong>：允许所有元素，包括null。</li><li><strong>是否是线程安全的</strong>：不是线程安全的。</li><li><strong>迭代器</strong>： 迭代器是fast-fail，但是迭代器的快速失败行为不能得到保证。</li><li><strong>运行时间</strong>：在get，set，size等操作中，都是以常数时间运行，而add操作需要O(n)时间运行。</li></ul><h1 id="ArrayList的定义"><a href="#ArrayList的定义" class="headerlink" title="ArrayList的定义"></a>ArrayList的定义</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayList</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractList</span>&lt;<span class="title">E</span>&gt; <span class="keyword">implements</span> <span class="title">List</span>&lt;<span class="title">E</span>&gt;, <span class="title">RandomAccess</span>, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span></span></span><br></pre></td></tr></table></figure><ul><li><strong>ArrayList<e></e></strong>：支持泛型的存储模式。</li><li><strong>extends AbstractList<e></e></strong>：继承于AbstractList，继承了其中的方法，方便操作。</li><li><strong>implements List<e></e></strong>：实现了List接口，与继承AbstractList作用相同，实现该接口提供的方法，方便了实现。但是据开发这个collection 的作者Josh说：这其实是一个mistake，因为他写这代码的时候觉得这个会有用处，但是其实并没什么用，但因为没什么影响，就一直留到了现在。</li><li><strong>implements RandomAccess</strong>：实现了RandomAccess接口，表明支持固定时间的快速随机访问，这也是其在get和set方法时已固定时间运行的原因</li><li><strong>implements Cloneable</strong>：实现了Cloneable接口，内部可以调用clone()方法来返回实例的浅拷贝(shallow copy)。</li><li><strong>implements Serializable</strong>：实现了Serializable接口，表明该类时可以序列化的。</li></ul><h1 id="静态全局变量"><a href="#静态全局变量" class="headerlink" title="静态全局变量"></a>静态全局变量</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 默认的初始容量</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_CAPACITY = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    *  用于空实例的共享空数组实例。</span></span><br><span class="line"><span class="comment">    * 也就是说当传入的指定容量为0的时候建立数组。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 共享空数组实例，用于默认大小的空实例。</span></span><br><span class="line"><span class="comment">    * 我们将其与EMPTY_ELEMENTDATA区分开来，以了解添加第一个元素时应该膨胀多少。</span></span><br><span class="line"><span class="comment">    * 当无指定的容量传入时，返回的数组。其与EMPTY_ELEMENTDATA的区别在于：</span></span><br><span class="line"><span class="comment">    * EMPTY_ELEMENTDATA是当传入的指定容量为时候返回的</span></span><br><span class="line"><span class="comment">    * DEFAULTCAPACITY_EMPTY_ELEMENTDATA是为传入指定容量参数时候返回的。 </span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 存储ArrayList元素的数组缓冲区。</span></span><br><span class="line"><span class="comment">    * ArrayList的容量是这个数组缓冲区的长度。</span></span><br><span class="line"><span class="comment">    * 当添加第一个元素时，任何带有elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA的空ArrayList都将扩展为DEFAULT_CAPACITY。</span></span><br><span class="line"><span class="comment">    * 也就是底层用来存储元素的数组</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">transient</span> Object[] elementData; <span class="comment">// 非私有以简化嵌套类访问,这里是用来为subList方法使用的。</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * ArrayList的大小(它包含的元素的数量)。</span></span><br><span class="line"><span class="comment">    * ArrayList中实际包含的元素的数量</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@serial</span></span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">int</span> size;</span><br><span class="line"></span><br><span class="line">       <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 最大可分配的数组大小，减去8是为了一些vm在数组中保留一些头信息。</span></span><br><span class="line"><span class="comment">   * 试图分配更大的数组可能会导致OutOfMemoryError:请求的数组大小超过VM限制</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_ARRAY_SIZE = Integer.MAX_VALUE - <span class="number">8</span>;</span><br></pre></td></tr></table></figure><h1 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h1><h2 id="指定初始容量"><a href="#指定初始容量" class="headerlink" title="指定初始容量"></a>指定初始容量</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    *构造具有指定初始容量的空列表。</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span>  initialCapacity  列表的初始容量</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@throws</span> IllegalArgumentException 如果指定初始容量是负的       </span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 如果指定的初始容量大于零，则创建一个指定初始容量大小的数组</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">       <span class="keyword">if</span> (initialCapacity &gt; <span class="number">0</span>) &#123;</span><br><span class="line">           <span class="keyword">this</span>.elementData = <span class="keyword">new</span> Object[initialCapacity];</span><br><span class="line">       &#125; <span class="keyword">else</span> <span class="keyword">if</span> (initialCapacity == <span class="number">0</span>) &#123;</span><br><span class="line">       <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * 如果指定的初始等于零，则使用空数组EMPTY_ELEMENTDATA</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">           <span class="keyword">this</span>.elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">       <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * 如果指定的初始为负数，抛出异常</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal Capacity: "</span>+</span><br><span class="line">                                              initialCapacity);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><ul><li>如果传入的指定初始容量大于零，那就创建一个指定初始容量大小的数组用来存放数据</li><li>如果指定的初始等于零，则使用静态全局变量中的空数组EMPTY_ELEMENTDATA</li><li>如果指定的初始为负数，抛出异常</li></ul><h2 id="无指定初始容量"><a href="#无指定初始容量" class="headerlink" title="无指定初始容量"></a>无指定初始容量</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 当无指定初始容量参数时，使用默认容量，构造一个初始容量为10的空列表。</span></span><br><span class="line"><span class="comment"> * 但是其实在初始化后，此时的数组容量为0，当第一次存入数据时，才对这个空数组进行扩容，变为长度为10的数组</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="传入集合初始化"><a href="#传入集合初始化" class="headerlink" title="传入集合初始化"></a>传入集合初始化</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *构造包含指定集合的元素的列表，按集合的迭代器返回元素的顺序排列。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> c 要将其元素放入此列表的集合</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> NullPointerException 如果指定的集合为空</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 把传入的集合转化为数组</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">    elementData = c.toArray();</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 判断传入的集合是否为空，如果为空则初始化为EMPTY_ELEMENTDATA数组，也就是等于指定初始容量为0时的情况</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> ((size = elementData.length) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 为了防止传入集合转型后的数组的类型不是Object类型，所以在这里进行验证</span></span><br><span class="line">        <span class="comment">// 如果不是Object类型，则使用Arrays.copyOf()的方法重新拷贝成Object[].class类型</span></span><br><span class="line">        <span class="keyword">if</span> (elementData.getClass() != Object[].class)</span><br><span class="line">            elementData = Arrays.copyOf(elementData, size, Object[].class);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 用空数组替换。</span></span><br><span class="line">        <span class="keyword">this</span>.elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="核心方法"><a href="#核心方法" class="headerlink" title="核心方法"></a>核心方法</h1><h2 id="trimToSize-方法"><a href="#trimToSize-方法" class="headerlink" title="trimToSize 方法"></a>trimToSize 方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 修改此ArrayList实例的容量成为列表的当前大小。 应用程序可以使用此操作来最小化ArrayList实例的存储。 </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">trimToSize</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 因为是对结构进行了修改，所以modCount加一次</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 如果当前数组中的元素数量小于数组长度，就对数组进行修改</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (size &lt; elementData.length) &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 如果数组中的元素数量为0，则把数组变为EMPTY_ELEMENTDATA</span></span><br><span class="line"><span class="comment">     * 如果数组中的元素数量不为0，则把当前数组中的所有元素拷贝到一个新的数组，数组长度为元素的数量</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">        elementData = (size == <span class="number">0</span>)</span><br><span class="line">          ? EMPTY_ELEMENTDATA</span><br><span class="line">          : Arrays.copyOf(elementData, size);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该方法用于回收多余的内存。也就是说一旦我们确定集合不在添加多余的元素之后，调用 trimToSize() 方法会将实现集合的数组大小刚好调整为集合元素的大小。<br>注意：该方法会花时间来复制数组元素，所以应该在确定不会添加元素之后在调用。</p><h2 id="ensureCapacity-方法"><a href="#ensureCapacity-方法" class="headerlink" title="ensureCapacity 方法"></a>ensureCapacity 方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 如果需要，增加此 ArrayList实例的容量，以确保它至少能够容纳最小容量参数指定的元素数。 </span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> minCapacity 所需的最小容量 </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ensureCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 先判断是否满足增加容量的条件：</span></span><br><span class="line"><span class="comment"> * 1.新的容量大于当前数组的长度，不然没有必要扩容</span></span><br><span class="line"><span class="comment"> * 2.数组中有数据，或者数组中没有数据并且新的容量大于默认的容量长度</span></span><br><span class="line"><span class="comment"> * 满足上面的两个条件后，modCount加一，然后调用grow方法进行数组的扩容和复制</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">    <span class="keyword">if</span> (minCapacity &gt; elementData.length</span><br><span class="line">        &amp;&amp; !(elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA</span><br><span class="line">             &amp;&amp; minCapacity &lt;= DEFAULT_CAPACITY)) &#123;</span><br><span class="line">        modCount++;</span><br><span class="line">        grow(minCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="grow-方法"><a href="#grow-方法" class="headerlink" title="grow 方法"></a>grow 方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 增加容量，以确保它至少可以容纳由最小容量参数指定的元素数目。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> minCapacity 所需的最小容量</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> OutOfMemoryError 如果minCapacity小于零</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> Object[] grow(<span class="keyword">int</span> minCapacity) &#123;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用newCapacity方法获得新的合适的容量大小，因为minCapacity不一定时最合适的扩容容量</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">    <span class="keyword">return</span> elementData = Arrays.copyOf(elementData,</span><br><span class="line">                                       newCapacity(minCapacity));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> Object[] grow() &#123;</span><br><span class="line">    <span class="keyword">return</span> grow(size + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="newCapacity-方法"><a href="#newCapacity-方法" class="headerlink" title="newCapacity 方法"></a>newCapacity 方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 返回至少与给定的最小容量相同大的容量。返回当前容量增加50%(如果足够的话)。</span></span><br><span class="line"><span class="comment"> * 除非给定的最小容量大于MAX_ARRAY_SIZE，否则不会返回大于MAX_ARRAY_SIZE的容量。</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> minCapacity 所需的最小容量</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> OutOfMemoryError 如果minCapacity小于零</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">newCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 旧的容量是现在数组的长度</span></span><br><span class="line"><span class="comment">     * 默认的新的容量是旧容量的1.5倍</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">int</span> oldCapacity = elementData.length;</span><br><span class="line">    <span class="keyword">int</span> newCapacity = oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 如果传入的要求的最小容量（newCapacity）大于等于默认的新的容量，就进入if做边界条件的判断</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (newCapacity - minCapacity &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 如果当前数组是空数组，这种情况下就是数组进行了初始化，但是没有放入任何数据，还是一个空数组，所以上面得到的oldCapacity和newCapacity都是0</span></span><br><span class="line"><span class="comment">     * 那么就取要求的最小容量和默认容量（16）二者中较大的那个进行扩容。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">        <span class="keyword">if</span> (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA)</span><br><span class="line">            <span class="keyword">return</span> Math.max(DEFAULT_CAPACITY, minCapacity);</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 因为上面的if判断的是 &lt;= 的情况，所以有可能传入的 minCapacity是负数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">        <span class="keyword">if</span> (minCapacity &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> OutOfMemoryError();</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 边界没有溢出的话，就扩大为minCapacity</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">return</span> minCapacity;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 如果传入的要求的最小容量（newCapacity）小于默认的新的容量，就不使用传入的minCapacity</span></span><br><span class="line"><span class="comment">     * 如果默认的新的容量小于数组最大容量Integer.MAX_VALUE-8，那么就使用它，也就是数组扩容1.5倍</span></span><br><span class="line"><span class="comment">     * 但是如果大于数组最大容量Integer.MAX_VALUE-8，就尝试使用minCapacity，进入hugeCapacity函数判断</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">return</span> (newCapacity - MAX_ARRAY_SIZE &lt;= <span class="number">0</span>)</span><br><span class="line">        ? newCapacity</span><br><span class="line">        : hugeCapacity(minCapacity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">hugeCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (minCapacity &lt; <span class="number">0</span>) <span class="comment">// 溢出</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> OutOfMemoryError();</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 如果newCapacity大于数组最大容量Integer.MAX_VALUE-8，但是minCapacity没有，就使用Integer.MAX_VALUE-8</span></span><br><span class="line"><span class="comment">     * 但是如果newCapacity和minCapacity都大于了Integer.MAX_VALUE-8的话，就把数组扩容为Integer.MAX_VALUE</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">return</span> (minCapacity &gt; MAX_ARRAY_SIZE)</span><br><span class="line">        ? Integer.MAX_VALUE</span><br><span class="line">        : MAX_ARRAY_SIZE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结来说，对于数组容量扩容过程如下：</p><ol><li>先确定三个变量：传入的所需的最小容量（minCapacity），旧容量（oldCapacity）也就是当前现在数组的长度，默认的新的容量（newCapacity）是旧容量的1.5倍。</li><li>对比minCapacity和newCapacity，如果对比minCapacity大于等于（&gt;=）newCapacity,那么进入3，否则进入5。</li><li>如果elementData是只进行初始化，但是还没有存入数据的数组，那么它的长度肯定是0，所以这种情况下上面得到的oldCapacity和newCapacity是0，因此取默认初始容量（16）和minCapacity中的较大值，作为扩容后的容量。否则进入4。</li><li>判断如果传入的minCapacity是负数，那么抛出异常。否则将其作为扩容后的容量。</li><li>如果newCapacity小于等于MAX_ARRAY_SIZE（Integer.MAX_VALUE-8），那么newCapacity就是扩容大小，也就是扩容1.5倍。否则进行6。</li><li>如果newCapacity大于minCapacity，但是minCapacity其实是负数，那么直接抛出异常。否则再次判断minCapacity与MAX_ARRAY_SIZE的大小关系，如果minCapacity也大于MAX_ARRAY_SIZE，那么newCapacity和minCapacity都大于了MAX_ARRAY_SIZE，就把数组扩容为Integer.MAX_VALUE。否则进行7。</li><li>否则就只有newCapacity大于MAX_ARRAY_SIZE，而minCapacity小于等于MAX_ARRAY_SIZE，则数组扩容为MAX_ARRAY_SIZE。</li></ol><h2 id="size-方法"><a href="#size-方法" class="headerlink" title="size 方法"></a>size 方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 以常数时间返回此列表中的元素数量。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 列表中元素的数量</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> size;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="isEmpty-方法"><a href="#isEmpty-方法" class="headerlink" title="isEmpty 方法"></a>isEmpty 方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 如果此列表不包含任何元素，则返回true。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; 如果此列表不包含任何元素</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> size == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="contains-方法"><a href="#contains-方法" class="headerlink" title="contains 方法"></a>contains 方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 如果此列表包含指定的元素，则返回true 。</span></span><br><span class="line"><span class="comment"> * 更正式地说，返回true当且仅当此列表包含至少一个元素e这样Objects.equals(o, e) 。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> o 其在此列表中的存在性将被测试</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; 如果此列表包含指定的元素</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 实则调用了indexOf方法得到其下标，只需判断得到的下标是否小于零即可</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">    <span class="keyword">return</span> indexOf(o) &gt;= <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="indexOf-于-lastIndexOf-方法"><a href="#indexOf-于-lastIndexOf-方法" class="headerlink" title="indexOf 于 lastIndexOf 方法"></a>indexOf 于 lastIndexOf 方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 以常数时间返回此列表中指定元素的第一次出现的索引，如果此列表不包含元素，则返回-1。</span></span><br><span class="line"><span class="comment"> * 更正式地，返回最低下标i ，使得Objects.equals(o, get(i)) ，如果没有这样的下标则返回-1。 </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 如果要寻找的对象是null，那么就遍历数组，找第一个null的下标</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">    <span class="keyword">if</span> (o == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">            <span class="keyword">if</span> (elementData[i]==<span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 如果要寻找的对象非null，那么就遍历数组，找第一个为o的元素的下标</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">            <span class="keyword">if</span> (o.equals(elementData[i]))</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 如果找不到的话，就返回-1</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 返回此列表中指定元素的最后一次出现的索引，如果此列表不包含元素，则返回-1。</span></span><br><span class="line"><span class="comment"> * 更正式地说，返回满足i这样Objects.equals(o, get(i)) ，如果没有这样的索引则返回-1。 </span></span><br><span class="line"><span class="comment"> * 搜索方法与indexOf相似，同为遍历整个数组，区别就是该方法从后向前寻找。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lastIndexOf</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (o == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = size-<span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">            <span class="keyword">if</span> (elementData[i]==<span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = size-<span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">            <span class="keyword">if</span> (o.equals(elementData[i]))</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该方法需要遍历整个数组，寻找对应的元素的下标，所以时间复杂度为O(N)。</p><h2 id="clone​-方法"><a href="#clone​-方法" class="headerlink" title="clone​ 方法"></a>clone​ 方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 返回此ArrayList实例的浅拷贝。（元素本身不被复制。） </span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 这个 ArrayList实例的克隆 </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">clone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 调用AbstractList的clone方法得到一个ArrayList</span></span><br><span class="line"><span class="comment">     * 然后给这个v的elementData数组复制为当前数组，同时modCount重置为0</span></span><br><span class="line"><span class="comment">     * 返回这个ArrayList。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">        ArrayList&lt;?&gt; v = (ArrayList&lt;?&gt;) <span class="keyword">super</span>.clone();</span><br><span class="line">        v.elementData = Arrays.copyOf(elementData, size);</span><br><span class="line">        v.modCount = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> v;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (CloneNotSupportedException e) &#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 这不应该发生，因为我们是可克隆的</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InternalError(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该方法只返回此ArrayList实例的浅拷贝，元素本身不被复制。</p><h2 id="toArray-方法"><a href="#toArray-方法" class="headerlink" title="toArray 方法"></a>toArray 方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 以正确的顺序（从第一个到最后一个元素）返回一个包含此列表中所有元素的数组。 </span></span><br><span class="line"><span class="comment"> * 返回的数组将是“安全的”，因为该列表不保留对它的引用。 （换句话说，这个方法必须分配一个新的数组）。</span></span><br><span class="line"><span class="comment"> * 因此，调用者可以自由地修改返回的数组。 </span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 此方法充当基于阵列和基于集合的API之间的桥梁。 </span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 一个包含该列表中所有元素的数组</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> Object[] toArray() &#123;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用Arrays的copyOf拷贝elementData，得到并且返回一个新的数组。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">    <span class="keyword">return</span> Arrays.copyOf(elementData, size);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 以正确的顺序返回一个包含此列表中所有元素的数组（从第一个到最后一个元素）; 返回的数组的运行时类型是指定数组的运行时类型。 </span></span><br><span class="line"><span class="comment"> * 如果列表适合指定的数组，则返回其中。 否则，将为指定数组的运行时类型和此列表的大小分配一个新数</span></span><br><span class="line"><span class="comment"> * 如果列表符合指定的数组，则有剩余空间（即数组的列表数量较多），则紧跟在集合结束后的数组中的元素设置为null 。 </span></span><br><span class="line"><span class="comment"> * （这仅在调用者知道列表不包含任何空元素的情况下才能确定列表的长度。） </span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> a 要存储列表的元素的数组，如果它足够大; 否则，为此目的分配相同运行时类型的新数组。 </span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 包含列表元素的数组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> ArrayStoreException 如果指定数组的运行时类型不是此列表中每个元素的运行时类型的超类型 </span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> NullPointerException 如果指定的数组为空</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; T[] toArray(T[] a) &#123;</span><br><span class="line">    <span class="keyword">if</span> (a.length &lt; size)</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 如果传入的数组的长度小于当前的元素数量，则创建一个新的数组a的运行时类型的数组，把elementData数组中的元素复制到该数组中。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">return</span> (T[]) Arrays.copyOf(elementData, size, a.getClass());</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 否则直接把elementData数组中的元素复制到该数组中。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    System.arraycopy(elementData, <span class="number">0</span>, a, <span class="number">0</span>, size);</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 如果传入数组长度大于元素数量，那么就把最后一个元素的后面的元素设置为null。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (a.length &gt; size)</span><br><span class="line">        a[size] = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>toArray 方法主要有两种方式，一种是无参方法，直接返回包含此列表中所有元素的数组；另一种是传入一个数组，然后把此列表中所有元素复制到该数组中，然后返回该数组。</p><h2 id="get-方法"><a href="#get-方法" class="headerlink" title="get 方法"></a>get 方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 因为底层是数组，所以以常数时间返回此列表中指定位置的元素。 </span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>  index 要返回的元素的索下标</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 该列表中指定位置的元素 </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IndexOutOfBoundsException  如果下标超出范围（ index &lt; 0 || index &gt;= size() ） </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Objects.checkIndex方法调用了Preconditions.checkIndex(index, length, null)检查下标是否超出范围</span></span><br><span class="line"><span class="comment"> * Preconditions.checkIndex() 方法判断如果index &lt; 0 || index &gt;= size()，就抛出异常，否则返回传出的index。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">    Objects.checkIndex(index, size);</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 如果下标满足要求，返回elementData数组中对应下标处的元素。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">return</span> elementData(index);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="set-方法"><a href="#set-方法" class="headerlink" title="set 方法"></a>set 方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 用指定的元素替换此列表中指定位置的元素。 </span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> index 要替换的元素的下标</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> element 要存储在指定位置的元素 </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 该元素以前在指定的位置 </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IndexOutOfBoundsException  如果索引超出范围（ index &lt; 0 || index &gt;= size() ） </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">set</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 同get方法一样，先判断下表是否越界，如果越阶就抛出异常。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">    Objects.checkIndex(index, size);</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 记录下elementData数组中指定位置处的旧元素，用于返回。</span></span><br><span class="line"><span class="comment">     * 将elementData数组中指定位置处的元素设置为传入的元素，然后返回旧的元素</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    E oldValue = elementData(index);</span><br><span class="line">    elementData[index] = element;</span><br><span class="line">    <span class="keyword">return</span> oldValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="add-方法"><a href="#add-方法" class="headerlink" title="add 方法"></a>add 方法</h2><h3 id="将指定的元素追加到此列表的末尾"><a href="#将指定的元素追加到此列表的末尾" class="headerlink" title="将指定的元素追加到此列表的末尾"></a>将指定的元素追加到此列表的末尾</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 以常数时间，将指定的元素追加到此列表的末尾。 </span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> e 要附加到此列表的元素 </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; (由 Collection.add(E)指定)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 因为往数组中添加元素，所以结构发生了改变，因此modCount加一</span></span><br><span class="line"><span class="comment"> * 调用内部的add方法添加元素，add方法见下面。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">    modCount++;</span><br><span class="line">    add(e, elementData, size);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="内部的add方法添加元素"><a href="#内部的add方法添加元素" class="headerlink" title="内部的add方法添加元素"></a>内部的add方法添加元素</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 这个helper方法从add(E)中分离出来，以将方法字节码大小保持在35以下(-XX:MaxInlineSize默认值)，这有助于在c1编译的循环中调用add(E)。</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(E e, Object[] elementData, <span class="keyword">int</span> s)</span> </span>&#123;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 先判断数组中的元素数量是否达到了数组长度</span></span><br><span class="line"><span class="comment"> * 如果达到，则对数组进行扩容，扩容大小是原数组长度的1.5倍</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">    <span class="keyword">if</span> (s == elementData.length)</span><br><span class="line">        elementData = grow();</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 然后将传入的元素添加到数组尾部，元素数量加一</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    elementData[s] = e;</span><br><span class="line">    size = s + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="在指定位置插入指定的元素"><a href="#在指定位置插入指定的元素" class="headerlink" title="在指定位置插入指定的元素"></a>在指定位置插入指定的元素</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 以O(N)的时间，在此列表中的指定位置插入指定的元素。 </span></span><br><span class="line"><span class="comment"> * 将当前位于该位置的元素（如果有）和任何后续元素（向其索引添加一个）移动。 </span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> index  要在其中插入指定元素的下标 </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> element 要插入的元素 </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IndexOutOfBoundsException  如果索引超出范围（ index &lt; 0 || index &gt; size() ） </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * rangeCheckForAdd方法见下面；</span></span><br><span class="line"><span class="comment"> * 同样把数组修改次数加一；</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">    rangeCheckForAdd(index);</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> s;</span><br><span class="line">    Object[] elementData;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 如果数组中的元素数量是否达到了数组长度，对数组进行扩容，扩容大小是原数组长度的1.5倍</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> ((s = size) == (elementData = <span class="keyword">this</span>.elementData).length)</span><br><span class="line">        elementData = grow();</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 然后将该index位置的元素和它后面的所有元素后移一位</span></span><br><span class="line"><span class="comment">     * 把index的位置空出来，然后将其赋值为传入的元素</span></span><br><span class="line"><span class="comment">     * 元素数量加一。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    System.arraycopy(elementData, index,</span><br><span class="line">                     elementData, index + <span class="number">1</span>,</span><br><span class="line">                     s - index);</span><br><span class="line">    elementData[index] = element;</span><br><span class="line">    size = s + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 由add和addAll使用的rangeCheck的一个版本。同为对下标范围的判断，本质与之前的checkIndex方法没什么区别。</span></span><br><span class="line"><span class="comment"> * 只是自己自定义了抛出异常的语句而已</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">rangeCheckForAdd</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (index &gt; size || index &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException(outOfBoundsMsg(index));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结来说，如果在指定位置插入指定的元素，因为要移动指定位置后面的所有元素，那么O(N)的时间；如果将指定的元素追加到此列表的末尾，那么仅花费常数的时间，但是如果数组需要扩容的话，将花费时间对数组进行扩容，所以尽量在初始化该List时就指定好容量大小。</p><h2 id="remove-方法"><a href="#remove-方法" class="headerlink" title="remove 方法"></a>remove 方法</h2><h3 id="删除指定位置的元素"><a href="#删除指定位置的元素" class="headerlink" title="删除指定位置的元素"></a>删除指定位置的元素</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 删除该列表中指定位置的元素。 将任何后续元素移动到左侧（从其索引中减去一个元素）。  </span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> index 要删除的元素的下标</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 从列表中删除的元素 </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IndexOutOfBoundsException 如果索引超出范围（ index &lt; 0 || index &gt;= size() ） </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 依旧先对下标范围进行检查</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">    Objects.checkIndex(index, size);</span><br><span class="line">    <span class="keyword">final</span> Object[] es = elementData;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 把旧的元素暂存下来，调用fastRemove方法把指定位置的元素删除，等删除后返回。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    E oldValue = (E) es[index];</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * fastRemove方法见下面</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    fastRemove(es, index);</span><br><span class="line">    <span class="keyword">return</span> oldValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="删除第一个出现的指定元素"><a href="#删除第一个出现的指定元素" class="headerlink" title="删除第一个出现的指定元素"></a>删除第一个出现的指定元素</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 从列表中删除第一个出现的指定元素（如果存在）。 </span></span><br><span class="line"><span class="comment"> * 如果列表不包含该元素，则它不会更改。</span></span><br><span class="line"><span class="comment"> * 更正式地，删除具有最低索引i的元素，使得Objects.equals(o, get(i)) （如果这样的元素存在）。</span></span><br><span class="line"><span class="comment"> *  如果此列表包含指定的元素（或等效地，如果此列表作为调用的结果而更改），则返回true 。 </span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> o 要从此列表中删除的元素（如果存在） </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; 如果此列表包含指定的元素</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Object[] es = elementData;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> size = <span class="keyword">this</span>.size;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    found: &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 遍历整个数组，查找指定元素o的下标，如果数组中不存在该元素，就直接返回false</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">        <span class="keyword">if</span> (o == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (; i &lt; size; i++)</span><br><span class="line">                <span class="keyword">if</span> (es[i] == <span class="keyword">null</span>)</span><br><span class="line">                    <span class="keyword">break</span> found;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (; i &lt; size; i++)</span><br><span class="line">                <span class="keyword">if</span> (o.equals(es[i]))</span><br><span class="line">                    <span class="keyword">break</span> found;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 找到该元素的下标后，调用fastRemove方法进行删除。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    fastRemove(es, i);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="fastRemove-方法"><a href="#fastRemove-方法" class="headerlink" title="fastRemove 方法"></a>fastRemove 方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 私有的remove方法，该方法跳过边界检查，并且不返回已删除的值。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">fastRemove</span><span class="params">(Object[] es, <span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 数组修改次数加一</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> newSize;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将指定元素第一次出现的下标后面的元素全部左移一位，等于将指定元素覆盖掉</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> ((newSize = size - <span class="number">1</span>) &gt; i)</span><br><span class="line">        System.arraycopy(es, i + <span class="number">1</span>, es, i, newSize - i);</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 然后将最后那个空出来的元素变赋值为null，同时size减小1</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    es[size = newSize] = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="clear-方法"><a href="#clear-方法" class="headerlink" title="clear 方法"></a>clear 方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 从列表中删除所有元素。 此呼叫返回后，列表将为空。 </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 数组修改次数加一</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="keyword">final</span> Object[] es = elementData;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 遍历整个数组，把所有下标置为null，同时size设置为0</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> to = size, i = size = <span class="number">0</span>; i &lt; to; i++)</span><br><span class="line">        es[i] = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="addAll-方法"><a href="#addAll-方法" class="headerlink" title="addAll 方法"></a>addAll 方法</h2><h3 id="将指定集合中的所有元素追加到列表的末尾"><a href="#将指定集合中的所有元素追加到列表的末尾" class="headerlink" title="将指定集合中的所有元素追加到列表的末尾"></a>将指定集合中的所有元素追加到列表的末尾</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 按指定集合的Iterator返回的顺序。</span></span><br><span class="line"><span class="comment"> * 如果在操作进行中修改了指定的集合，则此操作的行为是不确定的。（这意味着如果指定的集合是此列表，则此调用的行为是不确定的，并且此列表是非空的。） </span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> c 包含要添加到此列表的元素的集合 </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; 如果此列表因调用而更改 </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> NullPointerException  如果指定的集合为空 </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">addAll</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 把传入的集合转化为数组，方便进行拷贝，同时修改次数加一</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">    Object[] a = c.toArray();</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 如果传入的集合中没有元素，那么此列表没有更改，因此返回false </span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">int</span> numNew = a.length;</span><br><span class="line">    <span class="keyword">if</span> (numNew == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    Object[] elementData;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> s;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * elementData.length- size 得到数组剩余的空闲空间，</span></span><br><span class="line"><span class="comment">     * 如果传入的集合长度numNew大于数组剩余的空闲空间，因此当前数组放不下传入的元素，所以要对数组进行扩容</span></span><br><span class="line"><span class="comment">     * 扩容的后的大小最小值为：当前元素数量加将要添加的元素数量</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (numNew &gt; (elementData = <span class="keyword">this</span>.elementData).length - (s = size))</span><br><span class="line">        elementData = grow(s + numNew);</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将传入的集合元素数组拷贝到列表数组的后面</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    System.arraycopy(a, <span class="number">0</span>, elementData, s, numNew);</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 元素数量加上传入的元素数量</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    size = s + numNew;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="从指定的位置开始，将指定集合中的所有元素插入到此列表中。"><a href="#从指定的位置开始，将指定集合中的所有元素插入到此列表中。" class="headerlink" title="从指定的位置开始，将指定集合中的所有元素插入到此列表中。"></a>从指定的位置开始，将指定集合中的所有元素插入到此列表中。</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 将指定集合中的所有元素插入到此列表中，从指定的位置开始。</span></span><br><span class="line"><span class="comment">    * 将当前位于该位置（如果有的话）的元素和随后的任何元素移动到右边（增加其索引）。</span></span><br><span class="line"><span class="comment">    * 新元素将按照指定集合的迭代器返回的顺序显示在列表中。 </span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> index 从中指定集合插入第一个元素的索引 </span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> c 包含要添加到此列表的元素的集合 </span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; 如果此列表因呼叫而更改</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@throws</span> IndexOutOfBoundsException 如果索引超出范围（ index &lt; 0 || index &gt; size() ）</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@throws</span> NullPointerException 如果指定的集合为空 </span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">addAll</span><span class="params">(<span class="keyword">int</span> index, Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 使用自定义的方法对下标是否越界进行检查</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">       rangeCheckForAdd(index);</span><br><span class="line">       <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * 将传入的集合转化为数组，方便拷贝</span></span><br><span class="line"><span class="comment">        * 同时修改次数加一</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">       Object[] a = c.toArray();</span><br><span class="line">       modCount++;</span><br><span class="line">       <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * 如果传入的集合中没有元素，那么此列表没有更改，因此返回false </span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">       <span class="keyword">int</span> numNew = a.length;</span><br><span class="line">       <span class="keyword">if</span> (numNew == <span class="number">0</span>)</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">       Object[] elementData;</span><br><span class="line">       <span class="keyword">final</span> <span class="keyword">int</span> s;</span><br><span class="line">       <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * elementData.length- size 得到数组剩余的空闲空间，</span></span><br><span class="line"><span class="comment">        * 如果传入的集合长度numNew大于数组剩余的空闲空间，因此当前数组放不下传入的元素，所以要对数组进行扩容</span></span><br><span class="line"><span class="comment">        * 扩容的后的大小最小值为：当前元素数量加将要添加的元素数量</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">       <span class="keyword">if</span> (numNew &gt; (elementData = <span class="keyword">this</span>.elementData).length - (s = size))</span><br><span class="line">           elementData = grow(s + numNew);</span><br><span class="line">       <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * s - index 计算得到需要向右移动的元素的长度</span></span><br><span class="line"><span class="comment">        * 然后将其向右移动该长度</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">       <span class="keyword">int</span> numMoved = s - index;</span><br><span class="line">       <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)</span><br><span class="line">           System.arraycopy(elementData, index,</span><br><span class="line">                            elementData, index + numNew,</span><br><span class="line">                            numMoved);</span><br><span class="line">       <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * 把传入的集合中的元素拷贝到指定的位置，也就是上面数组向右移动后空出来的位置</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">       System.arraycopy(a, <span class="number">0</span>, elementData, index, numNew);</span><br><span class="line">       <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * 元素数量加上传入的集合中的元素数量</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">       size = s + numNew;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h2 id="removeAll-与-retainAll-方法"><a href="#removeAll-与-retainAll-方法" class="headerlink" title="removeAll 与 retainAll 方法"></a>removeAll 与 retainAll 方法</h2><h3 id="removeAll-方法"><a href="#removeAll-方法" class="headerlink" title="removeAll 方法"></a>removeAll 方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 从此列表中删除指定集合中包含的所有元素。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> c 包含要从此列表中删除的元素的集合 </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; 如果此列表因调用而更改</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> ClassCastException 如果此列表的元素的类与指定的集合不兼容（ 可选 ） </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> NullPointerException 如果此列表包含空元素，并且指定的集合不允许空元素（ 可选 ），或者如果指定的集合为空</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">removeAll</span><span class="params">(Collection&lt;?&gt; c)</span> </span>&#123;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * batchRemove 方法见下面</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">    <span class="keyword">return</span> batchRemove(c, <span class="keyword">false</span>, <span class="number">0</span>, size);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="retainAll-方法"><a href="#retainAll-方法" class="headerlink" title="retainAll 方法"></a>retainAll 方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 仅保留此列表中包含在指定集合中的元素。 </span></span><br><span class="line"><span class="comment"> * 换句话说，从此列表中删除其中不包含在指定集合中的所有元素。</span></span><br><span class="line"><span class="comment"> * 本质就是求交集。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> c 包含要保留在此列表中的元素的集合</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; 如果此列表因调用而更改</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> ClassCastException 如果此列表的元素的类与指定的集合不兼容（ 可选 ） </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> NullPointerException 如果此列表包含空元素，并且指定的集合不允许空元素（ 可选 ），或者如果指定的集合为空</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">retainAll</span><span class="params">(Collection&lt;?&gt; c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> batchRemove(c, <span class="keyword">true</span>, <span class="number">0</span>, size);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="batchRemove-方法"><a href="#batchRemove-方法" class="headerlink" title="batchRemove 方法"></a>batchRemove 方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 对比removeAll和retainAll方法，同样都是调用了batchRemove方法，唯一的区别就是传入的complement参数</span></span><br><span class="line"><span class="comment"> * removeAll的参数是false，而retainAll方法传入的是true，所导致的结果则截然不同，所以这个complement是决定结果的关键</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">batchRemove</span><span class="params">(Collection&lt;?&gt; c, <span class="keyword">boolean</span> complement,</span></span></span><br><span class="line"><span class="function"><span class="params">           <span class="keyword">final</span> <span class="keyword">int</span> from, <span class="keyword">final</span> <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 该方法判断传入的集合c是否为null，如果是null则抛出异常，代码见下方</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">Objects.requireNonNull(c);</span><br><span class="line"><span class="keyword">final</span> Object[] es = elementData;</span><br><span class="line"><span class="keyword">int</span> r;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 从头开始遍历数组，它的作用就是找到数组中第一个在集合c包含或者不包含的元素的位置，具体看下面</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">for</span> (r = from;; r++) &#123;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 如果r走到了最后依旧没找到任何一个集合c中包含或者不包含的元素</span></span><br><span class="line"><span class="comment"> * 那么数组将不会发生任何变化，返回false</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (r == end)</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 如果complement是false，那么在找到数组中第一个存在于集合c中的元素时，结束循环</span></span><br><span class="line"><span class="comment"> * 如果complement是true，那么在找到数组中第一个不存在于集合c中的元素时，结束循环</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (c.contains(es[r]) != complement)</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 看到w和r，顾名思义，w是write，r是read，也就是写和读，具体作用看下面就知道了</span></span><br><span class="line"><span class="comment"> * 这里把r赋给了w，r加一</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">int</span> w = r++;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">for</span> (Object e; r &lt; end; r++)</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 从上一次循环中，扎到数组中第一个存在/不存在于集合c中的元素的下标开始遍历</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 如果complement是false，那么在找到数组中一个不存在于集合c中的元素时，把他覆盖到刚刚找到的第一个存在于集合c中的元素的位置处</span></span><br><span class="line"><span class="comment"> * 这里可能难以理解一点，可以这样想：</span></span><br><span class="line"><span class="comment"> * 因为complement是false的情况是删除重复的元素嘛，所以用数组后面不重复的元素覆盖前面的元素，以此代替了删除。</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 同样如果complement是true，那么在找到数组中一个存在于集合c中的元素时，把他覆盖到刚刚找到的第一个不存在于集合c中的元素的位置处</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (c.contains(e = es[r]) == complement)</span><br><span class="line">es[w++] = e;</span><br><span class="line">&#125; <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 即使c.contains()抛出异常，也可以保持与AbstractCollection的兼容性</span></span><br><span class="line"><span class="comment"> * 将已经覆盖的元素后面重复出来的元素删除掉</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">System.arraycopy(es, r, es, w, end - r);</span><br><span class="line">w += end - r;</span><br><span class="line"><span class="keyword">throw</span> ex;</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 修改此处对应增加改变的数量</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">modCount += end - w;</span><br><span class="line">shiftTailOverGap(es, w, end);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">T <span class="title">requireNonNull</span><span class="params">(T obj)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (obj == <span class="keyword">null</span>)</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">       <span class="keyword">return</span> obj;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="comment">/**通过以下元素向下滑动，消除从lo到hi的间隔。 */</span></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">shiftTailOverGap</span><span class="params">(Object[] es, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi)</span> </span>&#123;</span><br><span class="line">       System.arraycopy(es, hi, es, lo, size - hi);</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> to = size, i = (size -= hi - lo); i &lt; to; i++)</span><br><span class="line">           es[i] = <span class="keyword">null</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>这里总结一下removeAll，retainAll和addAll方法之间的关系吧：</p><ul><li>removeAll 方法就是把存在于指定的集合中的元素全部删除掉，也就是求补集。</li><li>retainAll 方法就是把不存在于指定的集合中的元素全部删除掉，也就是求交集。</li><li>addAll 方法就把不存在于指定的集合中的元素全部添加到列表中，也就是求并集。</li></ul><h2 id="subList-方法"><a href="#subList-方法" class="headerlink" title="subList 方法"></a>subList 方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 返回指定的fromIndex （含）和toIndex之间的列表部分的视图。 （如果fromIndex和toIndex相等，返回的列表为空。）</span></span><br><span class="line"><span class="comment"> * 返回的列表由此列表支持，因此返回列表中的非结构更改将反映在此列表中，反之亦然。 返回的列表支持所有可选列表操作。 </span></span><br><span class="line"><span class="comment"> * 该方法消除了对显式范围操作（对于数组通常存在的排序）的需要。 </span></span><br><span class="line"><span class="comment"> * 任何期望列表的操作都可以通过传递一个子列表视图而不是整个列表来用作范围操作。 例如，以下成语从列表中移除了一系列元素： list.subList(from, to).clear();</span></span><br><span class="line"><span class="comment"> * 可以为indexOf(Object)和lastIndexOf(Object)构造类似的成语，并且可以将Collections类中的所有算法应用于子列表。 </span></span><br><span class="line"><span class="comment"> * 如果支持列表（即，此列表）以除了通过返回的列表之外的任何方式进行结构修改 ，则此方法返回的列表的语义将变为不正确。 </span></span><br><span class="line"><span class="comment"> * （结构修改是那些改变此列表的大小，或以其他方式扰乱它，使得正在进行的迭代可能产生不正确的结果）。</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 简单的来说，就是返回整个列表中，指定范围那部分的列表的视图。</span></span><br><span class="line"><span class="comment"> * 但是！！如果对返回的这部分列表进行修改，那么同时原列表的对应位置也会发生修改</span></span><br><span class="line"><span class="comment"> * 所以本质就是返回了一部分引用而已。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IndexOutOfBoundsException 如果端点索引值超出范围 (fromIndex &lt; 0 || toIndex &gt; size) </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IllegalArgumentException 如果端点索引不正确 (fromIndex &gt; toIndex) </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;E&gt; <span class="title">subList</span><span class="params">(<span class="keyword">int</span> fromIndex, <span class="keyword">int</span> toIndex)</span> </span>&#123;</span><br><span class="line">    subListRangeCheck(fromIndex, toIndex, size);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> SubList&lt;&gt;(<span class="keyword">this</span>, fromIndex, toIndex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以总结来说，尽量不要使用subList方法，如果要使用的话，一定要注意下面几点使用方法：</p><ol><li>千万不要再对原 List 进行任何改动的操作(例如: 增删改), 查询和遍历倒是可以. 因为如果对原 List 进行了改动, 那么后续只要是涉及到子 List 的操作就一定会出问题. 而至于会出现什么问题呢? 具体来说就是:<br>(1) 如果是对原 List 进行修改 (即: 调用 set() 方法) 而不是增删, 那么子 List 的元素也可能会被修改 (这种情况下不会抛出并发修改异常).<br>(2) 如果是对原 List 进行增删, 那么此后只要操作了子 List , 就一定会抛出并发修改异常.</li><li>千万不要直接对子 List 进行任何改动的操作(例如: 增删改), 但是查询和间接改动倒是可以. 不要对子 List 进行直接改动, 是因为如果在对子 List 进行直接改动之前, 原 List 已经被改动过, 那么此后在对子 List 进行直接改动的时候就会抛出并发修改异常.</li><li>如果要进行操作，则使用例如：List<integer> subList = new ArrayList&lt;&gt;(list.subList(2, list.size()));  的方法，把分割出来的数组转化为一个新的列表，在新的列表基础上操作就不会对原列表产生任何影响。</integer></li></ol><h1 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h1><p>考虑一点：elementData设置成了transient，那ArrayList是怎么把元素序列化的呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">writeObject</span><span class="params">(java.io.ObjectOutputStream s)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> java.io.IOException</span>&#123;</span><br><span class="line">    <span class="comment">// 防止序列化期间有修改</span></span><br><span class="line">    <span class="keyword">int</span> expectedModCount = modCount;</span><br><span class="line">    <span class="comment">// 写出非transient非static属性（会写出size属性）</span></span><br><span class="line">    s.defaultWriteObject();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 写出元素个数</span></span><br><span class="line">    s.writeInt(size);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 依次写出元素</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;size; i++) &#123;</span><br><span class="line">        s.writeObject(elementData[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果有修改，抛出异常</span></span><br><span class="line">    <span class="keyword">if</span> (modCount != expectedModCount) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readObject</span><span class="params">(java.io.ObjectInputStream s)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> java.io.IOException, ClassNotFoundException </span>&#123;</span><br><span class="line">    <span class="comment">// 声明为空数组</span></span><br><span class="line">    elementData = EMPTY_ELEMENTDATA;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读入非transient非static属性（会读取size属性）</span></span><br><span class="line">    s.defaultReadObject();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读入元素个数，没什么用，只是因为写出的时候写了size属性，读的时候也要按顺序来读</span></span><br><span class="line">    s.readInt();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (size &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 计算容量</span></span><br><span class="line">        <span class="keyword">int</span> capacity = calculateCapacity(elementData, size);</span><br><span class="line">        SharedSecrets.getJavaOISAccess().checkArray(s, Object[].class, capacity);</span><br><span class="line">        <span class="comment">// 检查是否需要扩容</span></span><br><span class="line">        ensureCapacityInternal(size);</span><br><span class="line"></span><br><span class="line">        Object[] a = elementData;</span><br><span class="line">        <span class="comment">// 依次读取元素到数组中</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;size; i++) &#123;</span><br><span class="line">            a[i] = s.readObject();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>查看writeObject()方法可知，先调用s.defaultWriteObject()方法，再把size写入到流中，再把元素一个一个的写入到流中。</p><p>一般地，只要实现了Serializable接口即可自动序列化，writeObject()和readObject()是为了自己控制序列化的方式，这两个方法必须声明为private，在java.io.ObjectStreamClass#getPrivateMethod()方法中通过反射获取到writeObject()这个方法。</p><p>在ArrayList的writeObject()方法中先调用了s.defaultWriteObject()方法，这个方法是写入非static非transient的属性，在ArrayList中也就是size属性。同样地，在readObject()方法中先调用了s.defaultReadObject()方法解析出了size属性。</p><p>elementData定义为transient的优势，自己根据size序列化真实的元素，而不是根据数组的长度序列化元素，减少了空间占用。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ol><li>ArrayList内部使用数组存储元素，当数组长度不够时进行扩容，每次加一半的空间，ArrayList不会进行缩容；</li><li>ArrayList支持随机访问，通过索引访问元素极快，时间复杂度为O(1)；</li><li>ArrayList添加元素到尾部极快，平均时间复杂度为O(1)；</li><li>ArrayList添加元素到中间比较慢，因为要搬移元素，平均时间复杂度为O(n)；</li><li>ArrayList从尾部删除元素极快，时间复杂度为O(1)；</li><li>ArrayList从中间删除元素比较慢，因为要搬移元素，平均时间复杂度为O(n)；</li><li>ArrayList支持求并集，调用addAll(Collection&lt;? extends E&gt; c)方法即可；</li><li>ArrayList支持求交集，调用retainAll(Collection&lt;? extends E&gt; c)方法即可；</li><li>ArrayList支持求单向差集，调用removeAll(Collection&lt;? extends E&gt; c)方法即可；</li></ol>]]></content>
    
    <summary type="html">
    
      对Java集合中比较常用的一个容器：ArrayList的源码进行分析，相比来说ArrayList的源码还是比较容易阅读的。
    
    </summary>
    
      <category term="Java容器" scheme="http://yoursite.com/categories/Java%E5%AE%B9%E5%99%A8/"/>
    
    
  </entry>
  
  <entry>
    <title>HashMap源码阅读</title>
    <link href="http://yoursite.com/posts/42557/"/>
    <id>http://yoursite.com/posts/42557/</id>
    <published>2019-07-27T11:51:13.239Z</published>
    <updated>2019-09-14T12:57:49.411Z</updated>
    
    <content type="html"><![CDATA[<h2 id="HashMap的数据结构"><a href="#HashMap的数据结构" class="headerlink" title="HashMap的数据结构"></a>HashMap的数据结构</h2><p>先介绍一点基础结构<br>  <img src="/posts/42557/HashMapDateStructure.jpg" alt><br>HashMap的基础结构是由数组（Node&lt;K,V&gt;[] table）+ 链表 + 红黑树组成的，因为我对红黑树不太了解，所以就没有看后面红黑树部分的东西（1400行之后的代码基本全是在说红黑树部分的），下面就没有讲述红黑树部分的内容。<br>数组的每个下标位置储存的是Node结点， 在Javadoc中把存放数据的table数组的每个下表称作bin（桶），数组每个下标的一开始存放的是链表，当链表长度大于等于（&gt;=）8的时候，会将链表转换为红黑树。  </p><p><strong>顶部注释：</strong></p><blockquote><p>HashMap是Map接口基于哈希表的实现。这种实现提供了所有可选的Map操作，并允许key和value为null（除了HashMap是unsynchronized的和允许使用null外，HashMap和HashTable大致相同。）。此类不保证映射的顺序，特别是它不保证该顺序恒久不变。</p><p>此实现假设哈希函数在桶内适当地分布元素，为基本实现(get 和 put)提供了稳定的性能。迭代 collection 视图所需的时间与 HashMap 实例的“容量”（桶的数量）及其大小（键-值映射关系数）成比例。如果遍历操作很重要，就不要把初始化容量initial capacity设置得太高（或将加载因子load factor设置得太低），否则会严重降低遍历的效率。</p><p>HashMap有两个影响性能的重要参数：初始化容量initial capacity、加载因子load factor。容量是哈希表中桶的数量，初始容量只是哈希表在创建时的容量。加载因子是哈希表在其容量自动增加之前可以达到多满的一种尺度。initial capacity<em>load factor就是当前允许的最大元素数目，超过initial capacity</em>load factor之后，HashMap就会进行rehashed操作来进行扩容，扩容后的的容量为之前的两倍。</p><p>通常，默认加载因子 (0.75) 在时间和空间成本上寻求一种折衷。加载因子过高虽然减少了空间开销，但同时也增加了查询成本（在大多数 HashMap类的操作中，包括 get 和 put 操作，都反映了这一点）。在设置初始容量时应该考虑到映射中所需的条目数及其加载因子，以便最大限度地减少rehash操作次数。如果初始容量大于最大条目数除以加载因子，则不会发生rehash 操作。</p><p>如果很多映射关系要存储在 HashMap 实例中，则相对于按需执行自动的 rehash 操作以增大表的容量来说，使用足够大的初始容量创建它将使得映射关系能更有效地存储。</p><p>注意，此实现不是同步的。如果多个线程同时访问一个哈希映射，而其中至少一个线程从结构上修改了该映射，则它必须保持外部同步。（结构上的修改是指添加或删除一个或多个映射关系的任何操作；仅改变与实例已经包含的键关联的值不是结构上的修改。）这一般通过对自然封装该映射的对象进行同步操作来完成。如果不存在这样的对象，则应该使用 Collections.synchronizedMap 方法来“包装”该映射。最好在创建时完成这一操作，以防止对映射进行意外的非同步访问，如下所示：<br>Map m = Collections.synchronizedMap(new HashMap(…));</p><p>由所有此类的“collection 视图方法”所返回的迭代器都是fail-fast 的：在迭代器创建之后，如果从结构上对映射进行修改，除非通过迭代器本身的remove方法，其他任何时间任何方式的修改，迭代器都将抛出 ConcurrentModificationException。因此，面对并发的修改，迭代器很快就会完全失败，而不冒在将来不确定的时间发生任意不确定行为的风险。</p><p>注意，迭代器的快速失败行为不能得到保证，一般来说，存在非同步的并发修改时，不可能作出任何坚决的保证。快速失败迭代器尽最大努力抛出 ConcurrentModificationException。因此，编写依赖于此异常的程序的做法是错误的，正确做法是：迭代器的快速失败行为应该仅用于检测bug。</p><p>此类是 Java Collections Framework 的成员。</p></blockquote><p><strong>从上面的内容可以总结出以下几点：</strong></p><ul><li><strong>底层</strong>： HashMap是Map接口基于哈希表实现的。</li><li><strong>是否允许null</strong>： HashMap允许key和value为null。</li><li><strong>是否有序</strong>：HashMap不保证映射到顺序，特别是它不保证顺序恒久不变。</li><li><strong>两个影响HashMap性能的参数</strong>： 初始化容量initial capacity、加载因子load factor。</li><li><strong>每次扩容大小</strong>：扩容后的的容量为之前的两倍。</li><li><strong>初始化容量对性能的影响</strong>： 不应设置的太小，容量小虽然可以节省空间，但是可能会导致频繁的扩容，扩容操作非常消耗时间；也不应该设置的太大，容量大会导致严重降低遍历的效率以及内存空间的浪费。<strong>总结来说就是：小了会增大时间开销（频繁的扩容）；大了会增大空间开销和时间开销（降低遍历效率）。</strong></li><li><strong>加载因子对性能的影响</strong>： 0.75是一个折中的值，加载因子过高虽然减少了空间开销，但是也增加了查询到成本；而加载因子过低会导致频繁的扩容。</li><li><strong>是否同步</strong>： HashMap不是同步的。</li><li><strong>迭代器</strong>： 迭代器是fast-fail，但是迭代器的快速失败行为不能得到保证。</li></ul><h2 id="HashMap的定义"><a href="#HashMap的定义" class="headerlink" title="HashMap的定义"></a>HashMap的定义</h2><pre><code>public class HashMap&lt;K,V&gt; extends AbstractMap&lt;K,V&gt; implements Map&lt;K,V&gt;, Cloneable, Serializable </code></pre><ul><li><strong>HashMap&lt;K,V&gt;</strong>：HashMap是以key-value形式存储数据。</li><li><strong>extends AbstractMap&lt;K,V&gt;</strong>： 继承于AbstractMap，大大减少了实现Map接口时需要的工作。</li><li><strong>implements Map&lt;K,V</strong>： 实现了Map接口，提供所有可选的Map操作。</li><li><strong>implements Cloneable</strong>：实现了Cloneable接口，内部可以调用clone()方法来返回实例的浅拷贝(shallow copy)。</li><li><strong>implements Serializable</strong>：实现了Serializable接口，表明该类时可以序列化的。</li></ul><h2 id="静态全局变量"><a href="#静态全局变量" class="headerlink" title="静态全局变量"></a>静态全局变量</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 默认初始容量—必须是2的幂。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">4</span>;<span class="comment">// 也就是 16</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 如果具有参数的任一构造函数隐式指定更高的值，则使用最大容量。</span></span><br><span class="line"><span class="comment"> * 必须是2的幂 &lt;= 1 &lt;&lt; 30。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAXIMUM_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">30</span>;<span class="comment">// 也就是 2的30次方</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 构造函数中没有指定时使用的加载因子，即默认的加载因子。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> DEFAULT_LOAD_FACTOR = <span class="number">0.75f</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将链表转化成红黑树的临界值。</span></span><br><span class="line"><span class="comment"> * 当链表长度(包括下标处开始的那个结点)大于等于8时，桶中的链表被转化成红黑树。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TREEIFY_THRESHOLD = <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将红黑树恢复成链表时的临界值。</span></span><br><span class="line"><span class="comment"> * 当红黑树的长度小于等于6时，桶中的红黑树被转化成链表。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> UNTREEIFY_THRESHOLD = <span class="number">6</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 桶被转化成红黑树的最小容量。</span></span><br><span class="line"><span class="comment"> * 当链表长度大于等于8，且HashMap的总体大小大于等于64时，才会将桶中的链表被转化成红黑树。</span></span><br><span class="line"><span class="comment"> * 否则只会采取扩容的方式来减少冲突。</span></span><br><span class="line"><span class="comment"> * 该值不能小于 4 * TREEIFY_THRESHOLD</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MIN_TREEIFY_CAPACITY = <span class="number">64</span>;</span><br></pre></td></tr></table></figure><h2 id="静态内部类-Node"><a href="#静态内部类-Node" class="headerlink" title="静态内部类 Node"></a>静态内部类 Node</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * HashMap的基本节点类型，即是HashMap底层的组成元素，也是每个桶（bin）中的链表的组成元素。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">   <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * key的hash值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">       <span class="keyword">final</span> <span class="keyword">int</span> hash;</span><br><span class="line">       <span class="keyword">final</span> K key;</span><br><span class="line">       V value;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 指向下一个Node节点的引用</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">       Node&lt;K,V&gt; next;</span><br><span class="line"></span><br><span class="line">       Node(<span class="keyword">int</span> hash, K key, V value, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">           <span class="keyword">this</span>.hash = hash;</span><br><span class="line">           <span class="keyword">this</span>.key = key;</span><br><span class="line">           <span class="keyword">this</span>.value = value;</span><br><span class="line">           <span class="keyword">this</span>.next = next;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> K <span class="title">getKey</span><span class="params">()</span>        </span>&#123; <span class="keyword">return</span> key; &#125;</span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">getValue</span><span class="params">()</span>      </span>&#123; <span class="keyword">return</span> value; &#125;</span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> key + <span class="string">"="</span> + value; &#125;</span><br><span class="line"></span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">           <span class="keyword">return</span> Objects.hashCode(key) ^ Objects.hashCode(value);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">setValue</span><span class="params">(V newValue)</span> </span>&#123;</span><br><span class="line">           V oldValue = value;</span><br><span class="line">           value = newValue;</span><br><span class="line">           <span class="keyword">return</span> oldValue;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">           <span class="keyword">if</span> (o == <span class="keyword">this</span>)</span><br><span class="line">               <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">           <span class="keyword">if</span> (o <span class="keyword">instanceof</span> Map.Entry) &#123;</span><br><span class="line">               Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;)o;</span><br><span class="line">               <span class="keyword">if</span> (Objects.equals(key, e.getKey()) &amp;&amp;</span><br><span class="line">                   Objects.equals(value, e.getValue()))</span><br><span class="line">                   <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h2 id="静态工具"><a href="#静态工具" class="headerlink" title="静态工具"></a>静态工具</h2><h3 id="hash方法详解"><a href="#hash方法详解" class="headerlink" title="hash方法详解"></a>hash方法详解</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * 计算key.hashCode（）并将更高位的散列扩展（XOR）降低。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">   <span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">int</span> h;</span><br><span class="line">       <span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">i = (table.length - <span class="number">1</span>) &amp; hash;<span class="comment">//这一步是在后面添加元素putVal()方法中进行位置的确定</span></span><br></pre></td></tr></table></figure><p>主要分为三步：</p><ol><li>取hashCode的值： key.hashCode()。调用Object. hashCode() 方法，该方法根据一定规则将与对象相关的信息，例如对象的存储地址，对象的字段等，映射成与一个32位 int 类型的值，这个数值称作为hash值。</li><li>让高位参与运算： h&gt;&gt;&gt;16 。将得到的hash值无符号右移十六位，空出来的高位补零。</li><li>取模运算： (n-1) &amp; hash 。 为了让数组元素分布均匀，把hash值对数组长度-1取余，也就是hash%n，得到在数组中保存的位置下标。</li></ol><p><strong>为什么要这样做的理由：</strong><br>  <img src="/posts/42557/1120165-20180405000930403-1215437085.png" alt><br>整个过程如上图所示，将原本的32位的hash值右移16位，然后与原值进行异或运算，是为了混合原始哈希码的高位和低位，以此来加大低位的随机性。</p><p>看到这里有个疑问，<strong>为什么要做异或运算？</strong><br>设想一下，如果n很小，假设为16的话，那么n-1即为15（0000 0000 0000 0000 0000 0000 0000 1111），这样的值如果跟hashCode()直接做与操作，实际上只使用了哈希值的后4位。如果当哈希值的高位变化很大，低位变化很小，这样很容易造成碰撞，所以把高低位都参与到计算中，从而解决了这个问题，而且也不会有太大的开销。<br>然后将得到的最终的hash值对数组长度-1取余，就可以得到在数组中保存的位置下标。这也是为什么要保证数组的长度总是2的n次方的理由。当数组长度length总是2的n次方时，(n - 1) &amp; hash == hash % n，但是位运算的速度更快，因此保证效率更高。</p><h3 id="comparableClassFor方法解读"><a href="#comparableClassFor方法解读" class="headerlink" title="comparableClassFor方法解读"></a>comparableClassFor方法解读</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 当对象x的类型为X，并且X实现了Comparable接口（比较的参数本身必须为X类本身）时</span></span><br><span class="line"><span class="comment">    * 返回x的运行时类型，否则返回null。</span></span><br><span class="line"><span class="comment">    * </span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">static</span> Class&lt;?&gt; comparableClassFor(Object x) &#123;</span><br><span class="line">       <span class="keyword">if</span> (x <span class="keyword">instanceof</span> Comparable) &#123;</span><br><span class="line">           Class&lt;?&gt; c; Type[] ts, as; ParameterizedType p;</span><br><span class="line">           <span class="keyword">if</span> ((c = x.getClass()) == String.class) <span class="comment">// bypass checks</span></span><br><span class="line">               <span class="keyword">return</span> c;</span><br><span class="line">           <span class="keyword">if</span> ((ts = c.getGenericInterfaces()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">               <span class="keyword">for</span> (Type t : ts) &#123;</span><br><span class="line">                   <span class="keyword">if</span> ((t <span class="keyword">instanceof</span> ParameterizedType) &amp;&amp;</span><br><span class="line">                       ((p = (ParameterizedType) t).getRawType() ==</span><br><span class="line">                        Comparable.class) &amp;&amp;</span><br><span class="line">                       (as = p.getActualTypeArguments()) != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                       as.length == <span class="number">1</span> &amp;&amp; as[<span class="number">0</span>] == c) <span class="comment">// type arg is c</span></span><br><span class="line">                       <span class="keyword">return</span> c;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>如注释所示，传参传入一个对象，当对象x的类型为X，并且X实现了Comparable接口（比较的参数本身必须为X类本身）时，返回x的运行时类型，否则返回null。<br>接下来分析这个方法的每行代码。</p><ul><li><strong>instanceof</strong><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x <span class="keyword">instanceof</span> Comparable</span><br></pre></td></tr></table></figure></li></ul><p><strong>instanceof</strong>可以理解为是某种类型的实例。不论是运行时类型，或者是他的父类、它实现的接口、他的父类实现的接口、甚至是他父类的父类的父类实现的接口的父类的父类，总之，只要在继承链上有这个类型就可以了。  </p><ul><li><strong>getClass()</strong><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">c = x.getClass()</span><br></pre></td></tr></table></figure></li></ul><p>与instanceof相应对的是<strong>getClass()</strong>方法，无论该对象如何转型，该方法返回的只会是它的运行时类型，可以简单的理解为它的实际类型，也就是new它的时候的类型。<br>有一种例外情况：匿名对象。当匿名对象调用该方法时，返回的是依赖它的对象的运行时类型，并且以1，2，3…的索引区分。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">       D d = <span class="keyword">new</span> D();</span><br><span class="line">       System.out.println(<span class="keyword">new</span> A()&#123;&#125;.getClass());   <span class="comment">// class Demo$1</span></span><br><span class="line">       System.out.println(<span class="keyword">new</span> B()&#123;&#125;.getClass());   <span class="comment">// class Demo$2</span></span><br><span class="line">       System.out.println(<span class="keyword">new</span> Comparable&lt;Object&gt;()&#123;    <span class="comment">// class Demo$3</span></span><br><span class="line">           <span class="meta">@Override</span></span><br><span class="line">           <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">               <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">           &#125;&#125;.getClass());</span><br><span class="line">       System.out.println(d.c.getClass()); <span class="comment">// class D$1</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span></span>&#123;&#125;</span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">B</span></span>&#123;&#125;</span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">C</span></span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span></span>&#123;</span><br><span class="line">   C c;</span><br><span class="line">   D()&#123;</span><br><span class="line">       c= <span class="keyword">new</span> C()&#123;&#125;;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>getGenericInterfaces()</strong><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ts = c.getGenericInterfaces()</span><br></pre></td></tr></table></figure></li></ul><p>getGenericInterfaces()方法返回的是该对象的运行时类型”直接实现”的接口，这意味着:</p><blockquote><ul><li>返回的一定是接口</li><li>必然是该类型自己直接实现的接口，继承过来的不算</li></ul></blockquote><ul><li><p><strong>getGenericSuperclass()和getSuperclass()</strong><br>这两个方法虽然没有出现在上述代码中，但是也顺便说一下：</p><blockquote><ul><li>getGenericSuperclass()返回的是父类的直接类型，不包括泛型参数。</li><li>getSuperclass()返回的是包括泛型参数的父类类型，但是注意，如果子类在继承父类时，没有实现（声明）父类的泛型，那么这时候子类是没有泛型参数的。</li></ul></blockquote></li><li><p><strong>ParameterizedType</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">t <span class="keyword">instanceof</span> ParameterizedType</span><br></pre></td></tr></table></figure></li></ul><p>ParameterizedType是Type接口的子接口，表示实现了泛型参数的类型。需要注意：</p><blockquote><ul><li>如果直接用Bean对象 instanceof ParameterizedType，结果都是false。</li><li>Class对象不能 instanceof ParameterizedType，编译会报错。</li><li>只有用Type对象 instanceof ParameterizedType ，才能得到想要的比较结果。可以理解为：一个Bean类不会是ParameterizedType，只有代表这个Bean类的类型（Type）才有可能是ParameterizedType。</li><li>实现泛型参数，必须给泛型传入参数，例如：class Child2&lt;A,B&gt; extends Super&lt;A,B&gt;{} ;只声明泛型而不实现,例如：class Child3&lt;A,B&gt; extends Super{} , 对比结果为false。</li></ul></blockquote><ul><li><strong>getRawType()</strong><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">((p = (ParameterizedType) t).getRawType()</span><br></pre></td></tr></table></figure></li></ul><p>该方法返回实现了这个类型的类或者接口，即去掉了泛型参数部分的类型对象。</p><ul><li><strong>getActualTypeArguments()</strong><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">as = p.getActualTypeArguments()</span><br></pre></td></tr></table></figure></li></ul><p>该方法与getRawType()相对应，以数组形式返回泛型的参数列表。</p><blockquote><ul><li>当参数是真实类型时，打印的是全类名</li><li>当参数是另一个新声明的泛型参数时，打印的是代表该泛型类型的符号。</li></ul></blockquote><p>所以总结comparableClassFor(Object x)方法的实现为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> Class&lt;?&gt; comparableClassFor(Object x) &#123;</span><br><span class="line">       <span class="keyword">if</span> (x <span class="keyword">instanceof</span> Comparable) &#123;  <span class="comment">// 判断是否实现了Comparable接口</span></span><br><span class="line">           Class&lt;?&gt; c; Type[] ts, as; Type t; ParameterizedType p;</span><br><span class="line">           <span class="keyword">if</span> ((c = x.getClass()) == String.class) </span><br><span class="line">               <span class="keyword">return</span> c;   <span class="comment">// 如果是String类型，直接返回String.class</span></span><br><span class="line">           <span class="keyword">if</span> ((ts = c.getGenericInterfaces()) != <span class="keyword">null</span>) &#123;  <span class="comment">// 判断是否有直接实现的接口</span></span><br><span class="line">               <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ts.length; ++i) &#123;   <span class="comment">// 遍历直接实现的接口</span></span><br><span class="line">                   <span class="keyword">if</span> (((t = ts[i]) <span class="keyword">instanceof</span> ParameterizedType) &amp;&amp;   <span class="comment">// 该接口实现了泛型</span></span><br><span class="line">                       ((p = (ParameterizedType)t).getRawType() == <span class="comment">// 获取接口不带参数部分的类型对象</span></span><br><span class="line">                        Comparable.class) &amp;&amp;   <span class="comment">//  该类型是Comparable</span></span><br><span class="line">                       (as = p.getActualTypeArguments()) != <span class="keyword">null</span> &amp;&amp;    <span class="comment">// 获取泛型参数数组</span></span><br><span class="line">                       as.length == <span class="number">1</span> &amp;&amp; as[<span class="number">0</span>] == c)   <span class="comment">// 只有一个泛型参数，且该实现类型是该类型本身</span></span><br><span class="line">                       <span class="keyword">return</span> c;   <span class="comment">// 返回该类型</span></span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h3 id="compareComparables-方法"><a href="#compareComparables-方法" class="headerlink" title="compareComparables 方法"></a>compareComparables 方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns k.compareTo(x) if x matches kc (k's screened comparable</span></span><br><span class="line"><span class="comment"> * class), else 0.</span></span><br><span class="line"><span class="comment"> * 如果x的类型是kc，返回 k.compareTo(x) 的比较结果</span></span><br><span class="line"><span class="comment"> * 如果x为空，或者类型不是kc，返回0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@SuppressWarnings</span>(&#123;<span class="string">"rawtypes"</span>,<span class="string">"unchecked"</span>&#125;) <span class="comment">// for cast to Comparable</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">compareComparables</span><span class="params">(Class&lt;?&gt; kc, Object k, Object x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (x == <span class="keyword">null</span> || x.getClass() != kc ? <span class="number">0</span> :</span><br><span class="line">            ((Comparable)k).compareTo(x));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="tableSizeFor-方法"><a href="#tableSizeFor-方法" class="headerlink" title="tableSizeFor 方法"></a>tableSizeFor 方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns a power of two size for the given target capacity.</span></span><br><span class="line"><span class="comment"> * 返回给定数值的比第一个比它大的2的幂次方的数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">tableSizeFor</span><span class="params">(<span class="keyword">int</span> cap)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = cap - <span class="number">1</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">2</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">4</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">8</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">16</span>;</span><br><span class="line">    <span class="keyword">return</span> (n &lt; <span class="number">0</span>) ? <span class="number">1</span> : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该方法是为了在构造函数中，把传入的指定容量转化为2的幂次方的整数，保证HashMap的容量为2的幂次方。</p><h2 id="字段"><a href="#字段" class="headerlink" title="字段"></a>字段</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * table数组，存放HashMap的所有元素的容器</span></span><br><span class="line"><span class="comment"> * 在第一次使用的时候初始化，并且可以根据需要调整大小</span></span><br><span class="line"><span class="comment"> * 当分配时，长度总是为2的幂次方</span></span><br><span class="line"><span class="comment"> * 在某些操作中容忍长度为零，以允许当前不需要的引导机制</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">transient</span> Node&lt;K,V&gt;[] table;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 保存缓存的 entrySet </span></span><br><span class="line"><span class="comment"> * AbstractMap字段用于keySet（）和values（）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">transient</span> Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * HashMap中的包含的键值对数量</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">int</span> size;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 该HashMap经过结构修改的次数</span></span><br><span class="line"><span class="comment"> * 结构修改指的是更改HashMap中的键值对数量或者以其他方式修改其内部结构（例如：rehash）</span></span><br><span class="line"><span class="comment"> * 该字段用于在迭代器中的快速失败（fail-fast），抛出 ConcurrentModificationException 的异常</span></span><br><span class="line"><span class="comment"> * 因为HashMap时线程不安全的容器，所以当A线程遍历时HashMap时，还没有遍历到的部分，被线程B修改，如删除</span></span><br><span class="line"><span class="comment"> * 那么当线程A遍历到被删除的地方时就会抛出该异常</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">int</span> modCount;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 下一个要调整HashMap大小的值，容量乘加载因子(capacity * load factor).</span></span><br><span class="line"><span class="comment"> * 因为当大小超过这个值时，哈希碰撞的概率会大大增加，所以达到该值时，对HashMap扩容</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@serial</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">int</span> threshold;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 哈希表的加载因子</span></span><br><span class="line"><span class="comment"> * 默认为 0.75f</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@serial</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">float</span> loadFactor;</span><br></pre></td></tr></table></figure><h2 id="核心方法"><a href="#核心方法" class="headerlink" title="核心方法"></a>核心方法</h2><h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h3><h4 id="指定初始化容量和加载因子"><a href="#指定初始化容量和加载因子" class="headerlink" title="指定初始化容量和加载因子"></a>指定初始化容量和加载因子</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 构造具有指定初始容量和加载因子的空HashMap。</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span>  initialCapacity 初始容量</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span>  loadFactor      加载因子</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@throws</span> IllegalArgumentException 如果初始容量为负或负载因子为非正时，抛出该异常</span></span><br><span class="line"><span class="comment">   *         </span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal initial capacity: "</span> +</span><br><span class="line">                                             initialCapacity);</span><br><span class="line"><span class="comment">//当指定初始容量超过最大容量（2的30次方）时，把其值设置为最大容量</span></span><br><span class="line">      <span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">          initialCapacity = MAXIMUM_CAPACITY;</span><br><span class="line">      <span class="keyword">if</span> (loadFactor &lt;= <span class="number">0</span> || Float.isNaN(loadFactor))</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal load factor: "</span> +</span><br><span class="line">                                             loadFactor);</span><br><span class="line">      <span class="keyword">this</span>.loadFactor = loadFactor;</span><br><span class="line"><span class="comment">//将传入指定容量转换为最近的2的整数次方</span></span><br><span class="line">      <span class="keyword">this</span>.threshold = tableSizeFor(initialCapacity);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h4 id="指定初始化容量"><a href="#指定初始化容量" class="headerlink" title="指定初始化容量"></a>指定初始化容量</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 构造一个具有指定初始容量和默认加载因子(0.75)的空HashMap。</span></span><br><span class="line"><span class="comment">   * </span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span>  initialCapacity 初始容量</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@throws</span> IllegalArgumentException 如果初始容量为负时，抛出该异常</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line"><span class="comment">//调用指定初始化容量和加载因子的构造方法，加载因子为默认（0.75）</span></span><br><span class="line">      <span class="keyword">this</span>(initialCapacity, DEFAULT_LOAD_FACTOR);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h4 id="默认的初始化容量和加载因子"><a href="#默认的初始化容量和加载因子" class="headerlink" title="默认的初始化容量和加载因子"></a>默认的初始化容量和加载因子</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 构造一个具有默认初始容量(16)和默认负载因子(0.75)的空HashMap。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.loadFactor = DEFAULT_LOAD_FACTOR; <span class="comment">// 所有其他字段都默认</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="使用与指定映射相同的映射"><a href="#使用与指定映射相同的映射" class="headerlink" title="使用与指定映射相同的映射"></a>使用与指定映射相同的映射</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 使用与指定映射相同的映射构造新的HashMap。</span></span><br><span class="line"><span class="comment">   * HashMap是使用默认负载因子(0.75)创建的，初始容量足以容纳指定映射中的映射。</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span>   m 要在此map中放置其键值对（映射）的map</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@throws</span>  NullPointerException 如果指定的映射为空抛出该异常</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.loadFactor = DEFAULT_LOAD_FACTOR;</span><br><span class="line"><span class="comment">//putMapEntries方法见核心方法putMapEntries()章节</span></span><br><span class="line">      putMapEntries(m, <span class="keyword">false</span>);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h3 id="putMapEntries方法"><a href="#putMapEntries方法" class="headerlink" title="putMapEntries方法"></a>putMapEntries方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 实现了Map接口的 Map.putAll and Map 构造方法</span></span><br><span class="line"><span class="comment">   * 其中的加载因子等参数、是默认的</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> m 指定map</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> 在最初构造此映射时为false，否则为true</span></span><br><span class="line"><span class="comment">   *        (传递到下面的afterNodeInsertion方法，该方法请详见允许LinkedHashMap后操作的回调节)。</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">putMapEntries</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m, <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">int</span> s = m.size();</span><br><span class="line">       <span class="keyword">if</span> (s &gt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="comment">//如果table未初始化，对其进行初始化</span></span><br><span class="line">           <span class="keyword">if</span> (table == <span class="keyword">null</span>) &#123; <span class="comment">// pre-size</span></span><br><span class="line"><span class="comment">//使用默认的加载因子（0.75）和传入的map的大小计算出阈值（扩容的临界值）</span></span><br><span class="line">               <span class="keyword">float</span> ft = ((<span class="keyword">float</span>)s / loadFactor) + <span class="number">1.0F</span>;</span><br><span class="line">               <span class="comment">//用上一步计算出的阈值与最大容量对比，如果超过最大容量，就把它赋为最大容量</span></span><br><span class="line">               <span class="keyword">int</span> t = ((ft &lt; (<span class="keyword">float</span>)MAXIMUM_CAPACITY) ? (<span class="keyword">int</span>)ft : MAXIMUM_CAPACITY);</span><br><span class="line">               <span class="comment">//如果当前默认的阈值小于t，就把当前的阈值扩容为大于t的最小的2的整数次方的整数</span></span><br><span class="line">               <span class="keyword">if</span> (t &gt; threshold)</span><br><span class="line">                   threshold = tableSizeFor(t);</span><br><span class="line">           &#125;<span class="comment">//如果table已经初始化，且传入的map的大小超过阈值，就对table扩容（resize()方法请在核心方法章节查看）</span></span><br><span class="line">           <span class="keyword">else</span> <span class="keyword">if</span> (s &gt; threshold)</span><br><span class="line">               resize();</span><br><span class="line">           <span class="comment">//做完初始化、扩容等准备工作，现在table已经可以放下传入的map的元素了，迭代map，挨个放入table中</span></span><br><span class="line">           <span class="keyword">for</span> (Map.Entry&lt;? extends K, ? extends V&gt; e : m.entrySet()) &#123;</span><br><span class="line">               K key = e.getKey();</span><br><span class="line">               V value = e.getValue();</span><br><span class="line"><span class="comment">//putVal()方法见下面</span></span><br><span class="line">               putVal(hash(key), key, value, <span class="keyword">false</span>, evict);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="size方法"><a href="#size方法" class="headerlink" title="size方法"></a>size方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 返回此映射中键值对的数目。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 此映射中键值映对的数目。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> size;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="isEmpty方法"><a href="#isEmpty方法" class="headerlink" title="isEmpty方法"></a>isEmpty方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 如果此映射不包含键值映射，则返回&#123;<span class="doctag">@code</span> true&#125;。</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span> 如果此映射不包含键值映射，则返回&#123;<span class="doctag">@code</span> true&#125;。</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//键值对数目为零则为空</span></span><br><span class="line">      <span class="keyword">return</span> size == <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h3 id="get方法"><a href="#get方法" class="headerlink" title="get方法"></a>get方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *返回指定键映射到的值，如果该映射不包含键的映射，则返回null。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 更正式地说，如果这个映射包含从键k到值v的映射(key==null ?k==null:key.equals(k))，</span></span><br><span class="line"><span class="comment"> * 则该方法返回v;否则返回null。(最多可以有一个这样的映射。)</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 返回值为null并不一定表示映射不包含键的映射;也有可能映射显式地将键映射为null。</span></span><br><span class="line"><span class="comment"> * containsKey操作可用于区分这两种情况。</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #put(Object, Object)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="comment">//getNode方法见下面</span></span><br><span class="line">    <span class="keyword">return</span> (e = getNode(hash(key), key)) == <span class="keyword">null</span> ? <span class="keyword">null</span> : e.value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="getNode方法"><a href="#getNode方法" class="headerlink" title="getNode方法"></a>getNode方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 实现 Map接口的get方法 和其他相关方法</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> hash key的hash值</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> key 键（key）</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> 返回节点，如果不存在的话返回null</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title">getNode</span><span class="params">(<span class="keyword">int</span> hash, Object key)</span> </span>&#123;</span><br><span class="line">       Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; <span class="keyword">int</span> n; K k;</span><br><span class="line">       <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * 1.如果table为空，那么代表HashMap没有进行初始化</span></span><br><span class="line"><span class="comment">        * 2.如果table长度小于等于0，那么就代表HashMap中没有数据</span></span><br><span class="line"><span class="comment">        * 3.如果根据key的hash值计算出的下标处，没有结点，那么不存在以该key为键得映射</span></span><br><span class="line"><span class="comment">        * 满足以上三种情况得任意一种，直接返回null；只有三种情况全部满足的情况下，才进入链表/红黑树查找</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">       <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">           (first = tab[(n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">       <span class="comment">//检查该下标处得第一个结点，如果符合即返回</span></span><br><span class="line">           <span class="keyword">if</span> (first.hash == hash &amp;&amp; <span class="comment">// 总是检查第一个结点</span></span><br><span class="line">               ((k = first.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">               <span class="keyword">return</span> first;</span><br><span class="line">           <span class="comment">//头节点不合符，那么检查头结点后面的结点</span></span><br><span class="line">           <span class="keyword">if</span> ((e = first.next) != <span class="keyword">null</span>) &#123;</span><br><span class="line">           <span class="comment">//如果桶中的数据结构是红黑树，则用红黑树的方法查找</span></span><br><span class="line">               <span class="keyword">if</span> (first <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                   <span class="keyword">return</span> ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);</span><br><span class="line">               <span class="keyword">do</span> &#123;</span><br><span class="line">               <span class="comment">/**</span></span><br><span class="line"><span class="comment">                * 如果同桶中的数据结构是链表，从链表的第二个节点开始，遍历链表的每一个结点查找</span></span><br><span class="line"><span class="comment">                * e.hash == hash 比较hash值是否相等</span></span><br><span class="line"><span class="comment">                * key.equals(k) 和 (k = e.key) == key其实是一样的</span></span><br><span class="line"><span class="comment">                * Object的equals方法内部调用的就是 == 来验证是否相等</span></span><br><span class="line"><span class="comment">                * 此处体现出了严谨性</span></span><br><span class="line"><span class="comment">                */</span></span><br><span class="line">                   <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                       ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                       <span class="keyword">return</span> e;</span><br><span class="line">               &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h3 id="get和getNode方法总结"><a href="#get和getNode方法总结" class="headerlink" title="get和getNode方法总结"></a>get和getNode方法总结</h3><p>从上面的源码中可以看出，get方法可以分为三个步骤：</p><ol><li>通过hash方法得到key的hash值（hash方法在上面有详细的解释）</li><li>将上一步得到的key的hash值和key传入getNode方法，得到该key对应的Node</li><li>如果该key对应的Node为空，则返回null，否则返回Node中的value，如果Node中的value为空，那么也返回null</li></ol><p>getNode方法步骤如下：</p><ol><li>判断HashMap中存放数据的table的是否初始化，是否有数据（长度是否为0），根据key的hash值计算得到的该key在table中对应得下标处是否有结点；只有三种情况全部满足的情况下，才进入下标处得链表/红黑树查找，否则直接返回null</li><li>检查下标处的头节点是否匹配，匹配则返回该节点，否则检查头结点后面的结点</li><li>判断桶中存放数据的的数据结构是红黑树还是链表，如果桶中的数据结构是红黑树，则用红黑树的方法查找。</li><li>如果是链表则从链表的第二个节点开始，遍历链表的每一个结点查找，找到就返回对应的节点。</li><li>如果红黑树或链表的遍历中都没有找到，那么就返回null，代表不存在该节点。</li></ol><h3 id="containsKey方法"><a href="#containsKey方法" class="headerlink" title="containsKey方法"></a>containsKey方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 如果此映射包含特定键的映射，则返回true。</span></span><br><span class="line"><span class="comment"> * 否则返回false。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>   key   要测试在此映射中存在的key</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; 如果此映射包含指定的key</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">containsKey</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> getNode(hash(key), key) != <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该方法其实本质调用了getNode的方法，判断是否存在以key的键的结点，如过Node存在则返回true，否则返回false。</p><h3 id="put方法"><a href="#put方法" class="headerlink" title="put方法"></a>put方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将指定参数key和指定参数value插入map中，如果key已经存在，那就替换key对应的value</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key 指定key</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> value 指定value</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 如果value被替换，则返回旧的value，否则返回null。当然，可能key对应的value就是null。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//putVal方法的实现就在下面</span></span><br><span class="line">    <span class="keyword">return</span> putVal(hash(key), key, value, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>put方法可以分为三个步骤：</p><ol><li>通过hash方法获取到传入的key的hash值（hash方法在上面有详细的解释）</li><li>通过putVal方法放入map中</li><li>返回putVal方法的结果</li></ol><h3 id="putVal方法"><a href="#putVal方法" class="headerlink" title="putVal方法"></a>putVal方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 实现了 Map接口的 put和 相关方法。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> hash key的hash值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key  键</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> value 要放入的值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> onlyIfAbsent 如果为true，即使指定参数key在map中已经存在，也不会替换value</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> evict 如果为false，则该表处于创建模式。</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 如果value被替换，则返回旧的value，否则返回null。当然，可能key对应的value就是null。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent,</span></span></span><br><span class="line"><span class="function"><span class="params">               <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, i;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 如果table为null，则代表table没有初始化；或者table数组的长度为0，</span></span><br><span class="line"><span class="comment">     * 这两种情况下，调用resize方法对table进行初始化，</span></span><br><span class="line"><span class="comment">     * resize方法不仅可以对table扩容，还可以对table初始化</span></span><br><span class="line"><span class="comment">     * n用来记录table的长度</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">        n = (tab = resize()).length;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 如果通过key的hash值计算得到的下标处没有结点，那么新建一个链表结点放入</span></span><br><span class="line"><span class="comment">     * newNode方法调用了Node的构造方法，生成了一个新的结点。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>)</span><br><span class="line">        tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">    <span class="keyword">else</span> &#123;<span class="comment">//下面就是产生了碰撞的情况</span></span><br><span class="line">        Node&lt;K,V&gt; e; K k;</span><br><span class="line">        <span class="comment">//如果第一个结点的key就与传入的key相等，那么就把这个结点记录下来，在后面覆盖</span></span><br><span class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">            ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            e = p;</span><br><span class="line">        <span class="comment">//如果第一个key没有碰撞，而且桶中的结构是树，那么就调用相应的树的方法放置键值对</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//如果第一个key没有碰撞，而且桶中的结构是链表，那么就遍历链表</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;<span class="comment">//binCount记录了链表长度</span></span><br><span class="line">            <span class="comment">//当遍历到链表尾部，新建节点然后插入链表尾部</span></span><br><span class="line">                <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    p.next = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">                    <span class="comment">/**</span></span><br><span class="line"><span class="comment">                     * 如果插入后的链表长度大于等于8，那就把链表转化为树</span></span><br><span class="line"><span class="comment">                     * 这里减一是为了加上头结点，因为链表是从第二个结点开始遍历的</span></span><br><span class="line"><span class="comment">                     */</span></span><br><span class="line">                    <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) </span><br><span class="line">                        treeifyBin(tab, hash);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//如果在链表中某个结点的key就与传入的key相等，那么就把这个结点记录下来，在后面覆盖</span></span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                p = e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果发生了结点相等的情况，那么之前就记录了下来，所以e不为null，在这里进行覆盖</span></span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123; </span><br><span class="line">        <span class="comment">//把结点的原值记录下来，用来返回</span></span><br><span class="line">            V oldValue = e.value;</span><br><span class="line">            <span class="comment">//如果存在则覆盖或者旧节点的值为空，那么覆盖</span></span><br><span class="line">            <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>)</span><br><span class="line">                e.value = value;</span><br><span class="line">            <span class="comment">//回调方法，文章最后会说</span></span><br><span class="line">            afterNodeAccess(e);</span><br><span class="line">            <span class="comment">//把旧值返回</span></span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//因为上面是覆盖，所以未发生结构性改变，但是如果是插入，那么久发生了结构改变，所以modCount加一</span></span><br><span class="line">    ++modCount;</span><br><span class="line">    <span class="comment">//如果table大小超过了阈值，那就进行扩容，扩容后面会详细讲解</span></span><br><span class="line">    <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">        resize();</span><br><span class="line">    <span class="comment">////回调方法，文章最后会说</span></span><br><span class="line">    afterNodeInsertion(evict);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结putVal方法，共有如下几个步骤：</p><ol><li>判断table数组是否初始化，如果没有就进行初始化</li><li>根据key的hash值计算得到的下标处，如果该下标处没有节点，那么就新建一个结点放入桶中</li><li>如果该下标处已经存在节点，那么就代表发生了碰撞，开始对链表/红黑树进行遍历</li><li>如果第一个结点的key就与传入的key相等，那么就把这个结点记录下来，在后面覆盖；</li><li>如果第一个key没有碰撞，而且桶中的结构是树，那么就调用相应的树的方法放置键值对， 如果第一个key没有碰撞，而且桶中的结构是链表，那么就遍历链表</li><li>当遍历到链表尾部，新建节点然后插入链表尾部，然后判断链表长度，是否需要转化为红黑树，如果在遍历链表中发生了key相等，那么就把这个结点记录下来，在后面覆盖；</li><li>如果发生了key相等的情况，就对结点旧值覆盖，然后把旧值返回</li><li>如果没有发生key相等的情况，而是插入了新的结点，那么modCount和size都加一，判断size是否超过阈值，超过就扩容</li><li>返回null</li></ol><h3 id="resize方法"><a href="#resize方法" class="headerlink" title="resize方法"></a>resize方法</h3><p>当像HashMap中不断地添加元素的时候，元素的数量就会增加，数量增大就不避免的增大了碰撞的概率。所以当元素的数量达到一个阈值的时候，就对HashMap进行扩容。当然数组是无法自动扩容的，扩容方法使用一个新的数组代替已有的容量小的数组。<br>resize方法非常巧妙，因为每次扩容都是翻倍，保证了数组大小为2得整数次方，同时与原来计算（n-1）&amp;hash的结果相比，节点要么就在原来的位置，要么就被分配到“原位置+旧容量”这个位置。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    *  对table进行初始化或者大小翻倍的扩容。  </span></span><br><span class="line"><span class="comment">    * 如果为空，则按照字段阈值中包含的初始容量目标分配。</span></span><br><span class="line"><span class="comment">    * 否则，因为我们使用的是2的幂展开，所以每个bin中的元素必须保持相同的索引，或者在新表中以2的幂偏移量移动。</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> 新的table数组</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">       Node&lt;K,V&gt;[] oldTab = table;</span><br><span class="line">       <span class="comment">//记录旧的容量大小和旧的阈值</span></span><br><span class="line">       <span class="keyword">int</span> oldCap = (oldTab == <span class="keyword">null</span>) ? <span class="number">0</span> : oldTab.length;</span><br><span class="line">       <span class="keyword">int</span> oldThr = threshold;</span><br><span class="line">       <span class="comment">//定义新的容量和阈值</span></span><br><span class="line">       <span class="keyword">int</span> newCap, newThr = <span class="number">0</span>;</span><br><span class="line">     <span class="comment">//如果旧的容量 &gt; 0</span></span><br><span class="line">       <span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123;</span><br><span class="line">       <span class="comment">//如果旧的容量 &gt; 最大容量，那么就把阈值变为最大值</span></span><br><span class="line">           <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class="line">               threshold = Integer.MAX_VALUE;</span><br><span class="line">               <span class="keyword">return</span> oldTab;</span><br><span class="line">           &#125;<span class="comment">//如果旧容量的二倍小于规定的最大容量，并且旧的容量大于默认容量</span></span><br><span class="line">           <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">                    oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">           <span class="comment">//则对数组的容量和阈值进行翻倍扩容，新的容量和阈值是旧值的二倍</span></span><br><span class="line">               newThr = oldThr &lt;&lt; <span class="number">1</span>; <span class="comment">// double threshold</span></span><br><span class="line">       &#125;<span class="comment">//如果旧容量 = 0，而且旧临界值 &gt; 0，那么就把容量设置为旧的阈值</span></span><br><span class="line">       <span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>) <span class="comment">// 初始容量设置为阈值</span></span><br><span class="line">           newCap = oldThr;</span><br><span class="line">       <span class="keyword">else</span> &#123; <span class="comment">// 如果旧容量 = 0，且旧阈值 = 0，表示使用默认值，容量为16，阈值为容量*加载因子</span></span><br><span class="line">           newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">           newThr = (<span class="keyword">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//在当上面的条件判断中，只有oldThr &gt; 0成立时，newThr == 0</span></span><br><span class="line">       <span class="keyword">if</span> (newThr == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//ft为临时阈值，使用上面得到的新的容量和默认的加载因子计算得到</span></span><br><span class="line">           <span class="keyword">float</span> ft = (<span class="keyword">float</span>)newCap * loadFactor;</span><br><span class="line">           <span class="comment">//这个阈值是否合法，如果合法，那就是真正的临界值，如果超出了最大容量，那么就是最大容量</span></span><br><span class="line">           newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="keyword">float</span>)MAXIMUM_CAPACITY ?</span><br><span class="line">                     (<span class="keyword">int</span>)ft : Integer.MAX_VALUE);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//把阈值变为新阈值</span></span><br><span class="line">       threshold = newThr;</span><br><span class="line">       <span class="meta">@SuppressWarnings</span>(&#123;<span class="string">"rawtypes"</span>,<span class="string">"unchecked"</span>&#125;)</span><br><span class="line">       <span class="comment">//创建一个新的数组，大小为新的容量，并且后面把旧的table中的数据全部转移到新的table中</span></span><br><span class="line">       Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node[newCap];</span><br><span class="line">       <span class="comment">//把系统的table变为新的table</span></span><br><span class="line">       table = newTab;</span><br><span class="line">       <span class="comment">//如果旧table不为空，将旧table中的元素复制到新的table中</span></span><br><span class="line">       <span class="keyword">if</span> (oldTab != <span class="keyword">null</span>) &#123;</span><br><span class="line">       <span class="comment">//遍历旧的table的每个桶</span></span><br><span class="line">           <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; oldCap; ++j) &#123;</span><br><span class="line">               Node&lt;K,V&gt; e;</span><br><span class="line">               <span class="comment">//如果该桶中含有元素，那么久开始复制，先使用e复制下来</span></span><br><span class="line">               <span class="keyword">if</span> ((e = oldTab[j]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">               <span class="comment">//然后把旧的桶赋为null，便于GC回收</span></span><br><span class="line">                   oldTab[j] = <span class="keyword">null</span>;</span><br><span class="line">                   <span class="comment">//如果这个桶中只有一个结点，那么计算新的坐标后放入</span></span><br><span class="line">                   <span class="keyword">if</span> (e.next == <span class="keyword">null</span>)</span><br><span class="line">                       newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e;</span><br><span class="line">                   <span class="comment">//如果这个桶中的数据结构为红黑树，那么就使用红黑树的方法将其拆分后复制</span></span><br><span class="line">                   <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                       ((TreeNode&lt;K,V&gt;)e).split(<span class="keyword">this</span>, newTab, j, oldCap);</span><br><span class="line">                   <span class="keyword">else</span> &#123; <span class="comment">// 使用两个头尾对象保持顺序，是由于链表中的元素的下标在扩容后,要么是原下标+oldCap,要么不变,下面会证实</span></span><br><span class="line">                       Node&lt;K,V&gt; loHead = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;</span><br><span class="line">                       Node&lt;K,V&gt; hiHead = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;</span><br><span class="line">                       Node&lt;K,V&gt; next;</span><br><span class="line">                       <span class="keyword">do</span> &#123;<span class="comment">//遍历链表，分别把要存放新坐标的结点和要存放旧坐标的结点放到两根链表中</span></span><br><span class="line">                           next = e.next;</span><br><span class="line">                           <span class="comment">//如果计算得到0，那么下标没有改变，使用旧的头尾对象保存</span></span><br><span class="line">                           <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;</span><br><span class="line">                           <span class="comment">//如果链表中没有结点，就把该节点设置为头节点</span></span><br><span class="line">                               <span class="keyword">if</span> (loTail == <span class="keyword">null</span>)</span><br><span class="line">                                   loHead = e;</span><br><span class="line">                               <span class="keyword">else</span></span><br><span class="line">                                   loTail.next = e;</span><br><span class="line">                               loTail = e;</span><br><span class="line">                           &#125;</span><br><span class="line">                           <span class="keyword">else</span> &#123;<span class="comment">//否则下标改变，使用新的头尾对象保存</span></span><br><span class="line">                           <span class="comment">//如果链表中没有结点，就把该节点设置为头节点</span></span><br><span class="line">                               <span class="keyword">if</span> (hiTail == <span class="keyword">null</span>)</span><br><span class="line">                                   hiHead = e;</span><br><span class="line">                               <span class="keyword">else</span></span><br><span class="line">                                   hiTail.next = e;</span><br><span class="line">                               hiTail = e;</span><br><span class="line">                           &#125;</span><br><span class="line">                       &#125; <span class="keyword">while</span> ((e = next) != <span class="keyword">null</span>);</span><br><span class="line">                       <span class="comment">// 原下标对应的链表</span></span><br><span class="line">                       <span class="keyword">if</span> (loTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                       <span class="comment">// 尾部节点next设置为null，代码严谨</span></span><br><span class="line">                           loTail.next = <span class="keyword">null</span>;</span><br><span class="line">                           <span class="comment">//下标没有改变</span></span><br><span class="line">                           newTab[j] = loHead;</span><br><span class="line">                       &#125;</span><br><span class="line">                       <span class="comment">// 新下标对应的链表</span></span><br><span class="line">                       <span class="keyword">if</span> (hiTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                           hiTail.next = <span class="keyword">null</span>;</span><br><span class="line">                         <span class="comment">//新下标为就 旧的下标+新的容量</span></span><br><span class="line">                           newTab[j + oldCap] = hiHead;</span><br><span class="line">                       &#125;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> newTab;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>resize方法总结：<br>总体可以两大部分：</p><ol><li>首先是计算新桶数组的容量 newCap 和新阈值 newThr</li><li>将原集合的元素重新映射到新集合中<br>细节的过程如下：<br><img src="/posts/42557/resize.png" alt></li></ol><h3 id="remove方法"><a href="#remove方法" class="headerlink" title="remove方法"></a>remove方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 如果存在，则从此映射中删除指定键的映射，并且返回与该键相关联的值。</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span>  key 要从映射中删除其映射的键</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> 与key关联的值，如果没有key的映射，则为null。</span></span><br><span class="line"><span class="comment">    * (null返回值还可以代表将null与key关联的映射。)</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> V <span class="title">remove</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">       Node&lt;K,V&gt; e;</span><br><span class="line"><span class="comment">//removeNode方法就在下面</span></span><br><span class="line">       <span class="keyword">return</span> (e = removeNode(hash(key), key, <span class="keyword">null</span>, <span class="keyword">false</span>, <span class="keyword">true</span>)) == <span class="keyword">null</span> ?</span><br><span class="line">           <span class="keyword">null</span> : e.value;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h3 id="removeNode方法"><a href="#removeNode方法" class="headerlink" title="removeNode方法"></a>removeNode方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 实现了 Map接口的remove方法 和其他相关方法</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> hash key（键）的hash值</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> key 键</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> value 如果matchValue为true，则value也作为确定被删除的node的条件之一，否则忽略</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> matchValue 如果为true，则仅在键值都相等时删除</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> movable 如果为false，删除时不会移动其他节点</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> Node节点，如果没有，则为空</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title">removeNode</span><span class="params">(<span class="keyword">int</span> hash, Object key, Object value,</span></span></span><br><span class="line"><span class="function"><span class="params">                              <span class="keyword">boolean</span> matchValue, <span class="keyword">boolean</span> movable)</span> </span>&#123;</span><br><span class="line">       Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, index;</span><br><span class="line">       <span class="comment">//如果table数组不为空，且数组内有元素，且根据hash值计算得到的下标处的桶里有元素，才寻找，否则直接返回null</span></span><br><span class="line">       <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">           (p = tab[index = (n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">           Node&lt;K,V&gt; node = <span class="keyword">null</span>, e; K k; V v;</span><br><span class="line">         <span class="comment">//如果桶上第一个node的就是要删除的node，那么就把他先记录下来，在下面删除</span></span><br><span class="line">           <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">               ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">               node = p;</span><br><span class="line">           <span class="comment">//如果第一个结点不是，并且还有后续结点，那么就在后续节点中还寻找</span></span><br><span class="line">           <span class="keyword">else</span> <span class="keyword">if</span> ((e = p.next) != <span class="keyword">null</span>) &#123;</span><br><span class="line">           <span class="comment">//如果是红黑树，就是用红黑树的方法寻找这个结点，也记录下来</span></span><br><span class="line">               <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                   node = ((TreeNode&lt;K,V&gt;)p).getTreeNode(hash, key);</span><br><span class="line">               <span class="keyword">else</span> &#123;<span class="comment">//如果是链表，就从链表的第二个个节点开始遍历寻找</span></span><br><span class="line">                   <span class="keyword">do</span> &#123;<span class="comment">//如果找到，就把这个这个结点记录下来，在下面删除</span></span><br><span class="line">                       <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                           ((k = e.key) == key ||</span><br><span class="line">                            (key != <span class="keyword">null</span> &amp;&amp; key.equals(k)))) &#123;</span><br><span class="line">                           node = e;</span><br><span class="line">                           <span class="keyword">break</span>;</span><br><span class="line">                       &#125;</span><br><span class="line">                       p = e;</span><br><span class="line">                   &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">//如果得到的node不为null且(matchValue为false||node.value和参数value匹配)</span></span><br><span class="line">           <span class="keyword">if</span> (node != <span class="keyword">null</span> &amp;&amp; (!matchValue || (v = node.value) == value ||</span><br><span class="line">                                (value != <span class="keyword">null</span> &amp;&amp; value.equals(v)))) &#123;</span><br><span class="line">           <span class="comment">//如果是红黑树，就使用红黑树的方法删除</span></span><br><span class="line">               <span class="keyword">if</span> (node <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                   ((TreeNode&lt;K,V&gt;)node).removeTreeNode(<span class="keyword">this</span>, tab, movable);</span><br><span class="line">               <span class="keyword">else</span> <span class="keyword">if</span> (node == p)<span class="comment">//如果第一个结点就是要删除的目标，则使用第二个结点代替第一个结点</span></span><br><span class="line">                   tab[index] = node.next;</span><br><span class="line">               <span class="keyword">else</span><span class="comment">//如果要删除的目标结点在链表中，则使用下一个结点代替该结点</span></span><br><span class="line">                   p.next = node.next;</span><br><span class="line">               <span class="comment">//结构修改记录加一，元素个数减一</span></span><br><span class="line">               ++modCount;</span><br><span class="line">               --size;</span><br><span class="line">               <span class="comment">//回调函数，最后会讲</span></span><br><span class="line">               afterNodeRemoval(node);</span><br><span class="line">               <span class="comment">//把删除的结点返回</span></span><br><span class="line">               <span class="keyword">return</span> node;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//如果数组table为空或key映射到的桶为空，返回null。</span></span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>总结removeNode方法为：</p><ol><li>如果数组table为空或key映射到的桶为空，直接返回null。</li><li>如果key映射到的桶上第一个Node的就是要删除的Node，记录下来。</li><li>如果桶内不止一个Node，且桶内的结构为红黑树，记录key映射到的Node。</li><li>桶内的结构不为红黑树，那么桶内的结构就肯定为链表，遍历链表，找到key映射到的Node，记录下来。</li><li>如果被记录下来的Node不为null，则使用数据结构相对应的删除方法删除Node，++modCount;–size;</li><li>返回被删除的node。</li></ol><h3 id="clear方法"><a href="#clear方法" class="headerlink" title="clear方法"></a>clear方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 删除HashMap中的所有映射。</span></span><br><span class="line"><span class="comment"> * 这个调用返回后HashMap将为空。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab;</span><br><span class="line">    <span class="comment">//结构修改次数+1</span></span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="comment">//如果table不为空且其中有元素，就进行清空</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; size &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">//元素数量设置为零</span></span><br><span class="line">        size = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//遍历table数组每一个桶，将桶置为null，剩下的交给让GC自动回收</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tab.length; ++i)</span><br><span class="line">            tab[i] = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="containsValue方法"><a href="#containsValue方法" class="headerlink" title="containsValue方法"></a>containsValue方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 如果此HashMap中将一个或多个键映射到指定的值，则返回true。</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> value 值，其在此映射中的存在性将被测试</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 如果此映射将一个或多个键映射到指定值，则返回true，否则返回false。</span></span><br><span class="line"><span class="comment"> *         </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">containsValue</span><span class="params">(Object value)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; V v;</span><br><span class="line">    <span class="comment">//如果table不为空且其中有元素，就进行寻找，否则直接返回false</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; size &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">//遍历table数组中每个小标出处的桶寻找</span></span><br><span class="line">        <span class="keyword">for</span> (Node&lt;K,V&gt; e : tab) &#123;</span><br><span class="line">        <span class="comment">//遍历桶中的Node结点链</span></span><br><span class="line">            <span class="keyword">for</span> (; e != <span class="keyword">null</span>; e = e.next) &#123;</span><br><span class="line">            <span class="comment">//如果有值匹配，就返回true</span></span><br><span class="line">                <span class="keyword">if</span> ((v = e.value) == value ||</span><br><span class="line">                    (value != <span class="keyword">null</span> &amp;&amp; value.equals(v)))</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="一些其他方法"><a href="#一些其他方法" class="headerlink" title="一些其他方法"></a>一些其他方法</h2><h3 id="keySet方法"><a href="#keySet方法" class="headerlink" title="keySet方法"></a>keySet方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 返回此映射中所包含的键的 Set 视图。</span></span><br><span class="line"><span class="comment"> * 该 set 受映射的支持，所以对映射的更改将反映在该 set 中，反之亦然。</span></span><br><span class="line"><span class="comment"> * 如果在对 set 进行迭代的同时修改了映射（通过迭代器自己的 remove 操作除外），则迭代结果是不确定的。</span></span><br><span class="line"><span class="comment"> * 该 set 支持元素的移除，通过 Iterator.remove、 Set.remove、 removeAll、 retainAll 和 clear 操作可从该映射中移除相应的映射关系。</span></span><br><span class="line"><span class="comment"> * 它不支持 add 或 addAll 操作。</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> 此映射中包含的键的 set 视图</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> Set&lt;K&gt; <span class="title">keySet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       Set&lt;K&gt; ks = keySet;</span><br><span class="line">       <span class="keyword">if</span> (ks == <span class="keyword">null</span>) &#123;</span><br><span class="line">           ks = <span class="keyword">new</span> KeySet();</span><br><span class="line">           keySet = ks;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> ks;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h3 id="values方法"><a href="#values方法" class="headerlink" title="values方法"></a>values方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 返回此映射所包含的值的 Collection 视图。</span></span><br><span class="line"><span class="comment"> * 该 collection 受映射的支持，所以对映射的更改将反映在该 collection 中，反之亦然。</span></span><br><span class="line"><span class="comment"> * 如果在对 collection 进行迭代的同时修改了映射（通过迭代器自己的 remove 操作除外），则迭代结果是不确定的。</span></span><br><span class="line"><span class="comment"> * 该 collection 支持元素的移除，</span></span><br><span class="line"><span class="comment"> * 通过 Iterator.remove、 Collection.remove、 removeAll、 retainAll 和 clear 操作可从该映射中移除相应的映射关系。</span></span><br><span class="line"><span class="comment"> * 它不支持 add 或 addAll 操作。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> a view of the values contained in this map</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Collection&lt;V&gt; <span class="title">values</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Collection&lt;V&gt; vs = values;</span><br><span class="line">    <span class="keyword">if</span> (vs == <span class="keyword">null</span>) &#123;</span><br><span class="line">        vs = <span class="keyword">new</span> Values();</span><br><span class="line">        values = vs;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> vs;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="entrySet方法"><a href="#entrySet方法" class="headerlink" title="entrySet方法"></a>entrySet方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 返回此映射所包含的映射关系的 Set 视图。 </span></span><br><span class="line"><span class="comment"> * 该 set 受映射支持，所以对映射的更改将反映在此 set 中，反之亦然。</span></span><br><span class="line"><span class="comment"> * 如果在对 set 进行迭代的同时修改了映射（通过迭代器自己的 remove 操作，或者通过在该迭代器返回的映射项上执行 setValue 操作除外），则迭代结果是不确定的。</span></span><br><span class="line"><span class="comment"> * 该 set 支持元素的移除，通过 Iterator.remove、 Set.remove、 removeAll、 retainAll 和 clear 操作可从该映射中移除相应的映射关系。</span></span><br><span class="line"><span class="comment"> * 它不支持 add 或 addAll 操作。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> a set view of the mappings contained in this map</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet() &#123;</span><br><span class="line">    Set&lt;Map.Entry&lt;K,V&gt;&gt; es;</span><br><span class="line">    <span class="keyword">return</span> (es = entrySet) == <span class="keyword">null</span> ? (entrySet = <span class="keyword">new</span> EntrySet()) : es;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="clone方法"><a href="#clone方法" class="headerlink" title="clone方法"></a>clone方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 返回此HashMap实例的浅拷贝:键和值本身没有克隆。</span></span><br><span class="line"><span class="comment"> * 浅拷贝与深拷贝的区别：</span></span><br><span class="line"><span class="comment"> * 简单的来说就是，在有指针的情况下，浅拷贝只是增加了一个指针指向已经存在的内存</span></span><br><span class="line"><span class="comment"> * 而深拷贝就是增加一个指针并且申请一个新的内存，使这个增加的指针指向这个新的内存</span></span><br><span class="line"><span class="comment"> * 采用深拷贝的情况下，释放内存的时候就不会出现在浅拷贝时重复释放同一内存的错误！</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> a shallow copy of this map</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">clone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    HashMap&lt;K,V&gt; result;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        result = (HashMap&lt;K,V&gt;)<span class="keyword">super</span>.clone();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (CloneNotSupportedException e) &#123;</span><br><span class="line">        <span class="comment">// this shouldn't happen, since we are Cloneable</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InternalError(e);</span><br><span class="line">    &#125;</span><br><span class="line">    result.reinitialize();</span><br><span class="line">    result.putMapEntries(<span class="keyword">this</span>, <span class="keyword">false</span>);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="回调方法"><a href="#回调方法" class="headerlink" title="回调方法"></a>回调方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 允许LinkedHashMap后操作的回调</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">afterNodeAccess</span><span class="params">(Node&lt;K,V&gt; p)</span> </span>&#123; &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">afterNodeInsertion</span><span class="params">(<span class="keyword">boolean</span> evict)</span> </span>&#123; &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">afterNodeRemoval</span><span class="params">(Node&lt;K,V&gt; p)</span> </span>&#123; &#125;</span><br></pre></td></tr></table></figure><p>这三个回调方法在之前方法中出现过，它们的作用就是在给LinkedHashMap时继承使用，在HashMap中没有实质的作用，所以方法体为空。LinkedHashMap 是 HashMap 的一个子类，它保留插入的顺序，如果需要输出的顺序和输入时的相同，那么就选用 LinkedHashMap。</p><h2 id="个人总结"><a href="#个人总结" class="headerlink" title="个人总结"></a>个人总结</h2><ol><li>可以看出HashMap在扩容时的操作是很花费时间的，所以尽量在创建HashMap的时候就把容量指定，避免扩容操作，增大运行时间。</li><li>不知道有没有人想过，为什么在很多方法中，都是新建局部变量，然后把相应的数据赋给局部变量，而不是直接使用全局变量呢？例如下面这样：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; <span class="keyword">int</span> n; K k;</span><br><span class="line">tab = table;</span><br><span class="line">n = tab.length;</span><br><span class="line">first = tab[(n - <span class="number">1</span>) &amp; hash];</span><br><span class="line">k = first.key;</span><br></pre></td></tr></table></figure></li></ol><p>个人猜测这样做的原因是：<br>新定义的变量在栈顶，出栈快，局部变量，用完就销毁，提高速度，也不额外占用内存。<br>当然还有一种可能是因为HashMap不是线程安全的，所以可能因为使用全局变量的话会导致数据差异的原因，所以在每个方法里面，把这个方法开始的时候的数据保存下来，只对当前保存下来的数据进行运算，不影响其他线程和方法对数据的使用，同时也体现了高明的严谨性。</p><p>当然这只是个人猜测的结果，具体的原因也没有查到，所以这里就算是一个遗留的小问题吧。</p>]]></content>
    
    <summary type="html">
    
      花了两天时间，对HashMap 1.8的一千多行的源码认真的研究了一下，不禁感叹源码的严谨性，在我平常看来有很多判断都是没有必要的，但是仔细想想为什么这样写，其实严谨的不无道理。 因为源码一共有两千多行，但是真正关键的部分大概是1400行之前，所以就详细的对这些部分做一个解释。
    
    </summary>
    
      <category term="Java容器" scheme="http://yoursite.com/categories/Java%E5%AE%B9%E5%99%A8/"/>
    
    
  </entry>
  
</feed>
