<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Potato Blog</title>
  
  <subtitle>李土豆的Blog</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-10-30T14:26:41.938Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Potato</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>TCP与UDP</title>
    <link href="http://yoursite.com/posts/6245/"/>
    <id>http://yoursite.com/posts/6245/</id>
    <published>2019-10-27T13:44:29.000Z</published>
    <updated>2019-10-30T14:26:41.938Z</updated>
    
    <content type="html"><![CDATA[<p>TCP/IP中有两个具有代表性的传输层协议，它们分别时TCP和UDP。TCP体哦概念股可靠的通信传输，而UDP则常被用于让广播和细节控制交给应用的通信传输。总之，根据通信的具体特征，选择合适的传输层协议是非常重要的。</p><ul><li><strong>TCP</strong>：TCP是面向连接的、可靠的流协议。流就是指不间断的数据结构，你可以把它想象成排水管道中的水流。当应用程序采用TCP发送消息时，虽然可以保证发送的顺序，但还是犹如没有任何间隔的数据流发送给接收端。</li><li><strong>UDP</strong>：UDP是不具有可靠性的数据报协议。细微的处理它会交给上层的应用去完成。在UDP的情况下，虽然可以确保发送消息的大小，却不能保证消息一定会到达。因此，应用有时会根据自己的需要进行重发处理。</li></ul><h1 id="端口号"><a href="#端口号" class="headerlink" title="端口号"></a>端口号</h1><h2 id="端口号定义"><a href="#端口号定义" class="headerlink" title="端口号定义"></a>端口号定义</h2><p><strong>数据链路和IP中的地址，分别指的是MAC地址和IP地址，前者用来识别同一链路中不同的计算机，后者用来识别TCP/IP网络中互联的主机和路由器。</strong>在传输层中也有这种类似于地址的概念，那就是端口号。<strong>端口号用来识别一台计算机中进行通信的不同应用程序。因此，它也被称为程序地址。</strong></p><h2 id="根据端口号识别应用"><a href="#根据端口号识别应用" class="headerlink" title="根据端口号识别应用"></a>根据端口号识别应用</h2><p>一台计算机上同时可以运行多个程序。例如接收WWW服务的Web浏览器、电邮客户端、远程登录用的ssh客户端等程序都可同时运行。传输层协议正是利用这些端口号识别本机中正在进行通信的应用程序，并准确的将数据传输。<img src="/posts/6245/TIM%E6%88%AA%E5%9B%BE20191027215945.png" alt></p><p><strong>但是仅凭目标端口识别某一个通信是远远不够的。TCP/IP或UDP/IP通信中通常采用5个信息来识别一个通信。它们是“源IP地址”、“目标IP地址”、“协议号”、“源端口号”、“目标端口号”。只要其中某一项不同，则被认为是其它通信。</strong></p><h2 id="端口号如何确定"><a href="#端口号如何确定" class="headerlink" title="端口号如何确定"></a>端口号如何确定</h2><p>在实际进行通信时，要事先确定端口号。确定端口号的方法有两种：</p><h3 id="标准既定的端口号"><a href="#标准既定的端口号" class="headerlink" title="标准既定的端口号"></a>标准既定的端口号</h3><p><strong>这种方法也叫静态方法。它是指每个应用程序都有其指定的端口号。</strong>但并不是说可以随意使用任何一个端口号。每个端口号都有其对应的使用目的。</p><p>例如，HTTP、TELNET、FTP等广为使用的应用协议中所使用的端口号就是固定的。这些端口号也被称为知名端口号。知名端口号一般由0到1023的数字分配而成。应用程序应该避免使用知名端口号进行既定目的之外的通信，以免产生冲突。</p><h3 id="时序分配法"><a href="#时序分配法" class="headerlink" title="时序分配法"></a>时序分配法</h3><p><strong>第二种方法也叫时序（或动态）分配法。此时，服务端有必要确定监听端口号，但是接受服务的客户端没必要确定端口号。</strong></p><p>在这种方法下，客户端应用程序可以完全不用自己设置端口号，而全权交给操作系统进行分配。操作系统可以为每个应用程序分配互不冲突的端口号。例如：每需要一个新的端口号，就在之前分配的号码的基础上加1.这样操作系统就可以动态的管理端口号了。</p><p>根据这种分配端口号的机制，即使是同一个客户端程序发起的多个TCP连接，是被这些通信的5部分数字也不会全部相同。</p><p>动态分配的端口号取值范围在49152到65536之间。</p><h2 id="端口号与协议"><a href="#端口号与协议" class="headerlink" title="端口号与协议"></a>端口号与协议</h2><p><strong>端口号有其使用的传输层协议决定。因此不同的传输协议可使用相同的端口号，</strong>例如，TCP与UDP使用同一个端口号，但使用目的各不相同，这是因为端口号上的处理是根据每个传输协议的不同而进行的。</p><p><strong>数据到达IP层后，会先检查IP首部中的协议号，再传给相应协议的模块。如果TCP则传给TCP模块，如果是UDP则传给UDP模块去做端口号的处理。即使是同一个端口号，由于传输协议是各自独立地进行处理，因此相互之间不会受到影响。</strong></p><p>此外，那些知名端口号与传输层协议并无关系，只要端口号一致都将分配同一程序进行处理。</p><h1 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h1><p>UDP是User Datagram Protocol的缩写。</p><p><strong>UDP不提供复杂的控制机制，利用IP提供面向无连接的通信服务。并且它是将应用程序发来的数据在收到的那一刻，立即按照原样发送到网络上的一种机制。</strong></p><p><strong>即使是出现网络拥堵的情况下，UDP也无法进行流量控制等避免网络阻塞的行为。此外，传输途中即使出现丢包，UDP也不负责重发。甚至当出现包的到达顺序乱掉时也没有纠正的功能。如果需要这些细节控制，那么不得不交由采用UDP的应用程序去处理</strong>。</p><p>由于UDP面向无连接，它可以随时发送数据。再叫上UDP本身的处理既简单又高效，因此经常用于以下几个方面：</p><ul><li>包总量较少的通信（DNS、SNMP等）</li><li>视频、音频等多媒体通信</li><li>限定于LAN等特定网络中的应用通信</li><li>广播通信（广播、多播）</li></ul><h1 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h1><p>与UDP相比，TCP与UDP的区别相当大。<strong>它充分的实现了数据传输时各种控制能力，可以进行丢包时的重发控制，还可以对次序乱掉的分包进行顺序控制。此外，YCP作为一种面向连接的协议，只有在确认通信对端存在时才会发送数据，从而可以控制通信流量的浪费。</strong></p><h2 id="通过序列号与确认应答提高可靠性"><a href="#通过序列号与确认应答提高可靠性" class="headerlink" title="通过序列号与确认应答提高可靠性"></a>通过序列号与确认应答提高可靠性</h2><p><strong>在TCP种，当发送端的数据到达接受主机时，接收端主机会返回一个已收到消息的通知。这个消息叫做确认应答（ACK）。TCP通过肯定的确认应答实现可靠的数据传输。</strong>当发送端将数据发出之后会等待对端的确认应答。如果有确认应答，说明数据已经成功到达对端。反之，则数据丢的可能性很大。</p><p>在一定时间内没有等到确认应答，发送端就可以认为数据已经丢失，并进行重发。由此即使产生了丢包，仍然能够保证数据能到达对端，实现可靠传输。</p><p>此外，还有可能因为一些其他原因导致确认应答延迟到达，在源主机重发数据之后才到达的情况。此时源发送主机只要按照机制重发数据即可，但是对于目标主机来说简直是一种“灾难”。它会反复收到相同的数据，而为了对上层应用提供可靠的传输，必须得放弃重复的数据包。</p><p>为此，就必须引入一种机制，它能够识别是否已经收到数据，又能判断是否需要接受。<strong>接收端查询接收数据TCP首部中的序列号和数据的长度，将自己下一步应该接受的序号作为确认应答反送回去。</strong>这样通过序列号和确认应答号TCP就可以实现可靠传输。</p><h2 id="重发超时如何确定"><a href="#重发超时如何确定" class="headerlink" title="重发超时如何确定"></a>重发超时如何确定</h2><p>重发超时是指在重发数据之前，等待确认应答到来的那个特定时间间隔。如果超过了这个时间仍未收到确认应答，发送端将进行数据重发，所以问题就是如何确定这个重发超时的时间长度。</p><p>TCP要求不论在何种网络环境下都要提供高性能通信，并且无论网络拥堵情况发生何种变化，都必须保持这一特性。<strong>为此，它在每次发包时都会计算往返时间及其偏差。将这二者相加，重发超时的时间就是比这个总和要稍大一点的值。</strong></p><p>综上所述，其重发超时时间一般设置为6秒左右。数据被重发之后若还是收不到确认应答，则进行再次发送。此时，等待确认应答的时间将会以2倍、4倍的指数函数延长。</p><p>当然数据也不会被无限次反复的重发，当达到一定重发次数之后，如果仍没有任何确认应答返回，就会判断为网络对端主机发生了异常，强制关闭连接。并且通知应用通信异常强行终止。</p><h2 id="连接管理"><a href="#连接管理" class="headerlink" title="连接管理"></a>连接管理</h2><h3 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h3><p>三次握手其实就是指建立一个TCP连接时，需要客户端和服务器总共发送3个包。</p><p><strong>进行三次握手的主要作用就是为了确认双方的接收能里和发送能力是否正常，指定自己初始化序列号为后面的可靠传输做准备，实质上就是连接服务器指定端口，建立TCP连接，并同步连接双方的序列号和确认号，减缓TCP窗口大小的信息。</strong></p><ol><li><strong>刚开始客户端处于 Closed 的状态，服务端处于 Listen 状态。</strong></li><li><strong>第一次握手：建立连接时，客户端发送SYN包（SYN=1，即同步序列号；seq=x）到服务器，并进入SYN_SENT状态，等待服务器确认。</strong></li><li><strong>第二次握手：服务器收到SYN包，必须确认客户的SYN（ack=x+1，ACK=1），同时自己也发送一个SYN包（SYN=1，seq=y），即SYN+ACK包，此时服务器进入SYN_RECV状态。</strong></li><li><strong>第三次握手：客户端收到服务器的SYN+ACK包，向服务器发送确认包ACK（ACK=1，seq=x+1，ack=y+1)，此包发送完毕，客户端和服务器进入ESTABLISHED的状态，表示连接成功。</strong><br><img src="/posts/6245/v2-2a54823bd63e16674874aa46a67c6c72_hd.jpg" alt></li></ol><h4 id="半连接队列"><a href="#半连接队列" class="headerlink" title="半连接队列"></a>半连接队列</h4><p><strong>服务器第一次收到客户端的SYN之后，就会处于SYN_SEND的状态，此时双方还没有完全建立其连接，服务器就会把此状态下请求连接放到一个队列里，这种队列就称之为半连接队列。</strong></p><p><strong>当然还有一个全连接队列，就是已经完成三次握手，建立起连接的就会放在全连接队列中。如果队列满了就有可能会出现丢包现象。</strong></p><p>服务器发送完SYN-ACK包，如果未收到客户确认包，服务器进行首次重传，等待一段时间仍未收到客户确认包，进行第二次重传。如果重传次数超过系统规定的最大重传次数，系统将该连接信息从半连接队列中删除。注意，每次重传等待的时间不一定相同，一般会是指数增长，例如间隔时间为 1s，2s，4s，8s…</p><h4 id="seq的选择"><a href="#seq的选择" class="headerlink" title="seq的选择"></a>seq的选择</h4><p>当一端为建立连接而发送它的SYN时，它为连接选择一个初始序号，这个序号就是seq，也叫做ISN。</p><p><strong>ISN随时间变化，因此每个连接都将具有不同的ISN。</strong>ISN可以看作是一个32比特的计数器，每4ms加一。这样选择序号的目的在于防止在网络中被延迟的分组在以后又被传送，而导致某个连接的一方对它做出错的反应。<strong>因此ISN是动态生成的。</strong></p><h4 id="携带数据"><a href="#携带数据" class="headerlink" title="携带数据"></a>携带数据</h4><p><strong>在三次握手中，第一次、第二次握手是不可以携带数据的，但是第三次握手是可以携带数据的。</strong></p><p>为什么这样呢?大家可以想一个问题，假如第一次握手可以携带数据的话，如果有人要恶意攻击服务器，那他每次都在第一次握手中的 SYN 报文中放入大量的数据。因为攻击者根本就不理服务器的接收、发送能力是否正常，然后疯狂着重复发 SYN 报文的话，这会让服务器花费很多时间、内存空间来接收这些报文。</p><p>也就是说，第一次握手不可以放数据，其中一个简单的原因就是会让服务器更加容易受到攻击了。而对于第三次的话，此时客户端已经处于 ESTABLISHED 状态。对于客户端来说，他已经建立起连接了，并且也已经知道服务器的接收、发送能力是正常的了，所以能携带数据也没啥毛病。</p><h4 id="SYN攻击及解决办法"><a href="#SYN攻击及解决办法" class="headerlink" title="SYN攻击及解决办法"></a>SYN攻击及解决办法</h4><p>服务端的资源分配是在第二次握手时分配的，但客户端端资源是在完成三次握手时分配的，所以服务器容易受到SYN洪泛攻击。SYN攻击就是客户端在短时间内伪造大量不存在的IP地址，并向服务器不断的发送SYN包，服务器则回复确认包，并等待客户端回复。这些伪造的SYN包将长时间占用未连接队列，导致正常的SYN请求因为队列满而被丢弃，从而引起网络拥塞甚至系统瘫痪。SYN攻击是一种典型的DDOS攻击。</p><p>常见的防御 SYN 攻击的方法有如下几种：</p><ul><li><strong>缩短超时时间</strong></li><li><strong>增大最大短连接数</strong></li><li><strong>过滤网关防护</strong></li><li><strong>SYN cookie技术</strong></li></ul><h3 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h3><ol><li><strong>客户端发出连接释放报文，即FIN包（FIN=1，seq=u，u为前面已经传过来的数据的最后一个字节的序号+1），并且停止发送数据，此时，客户端进入FIN_WAIT_1状态，FIN报文即使不携带数据，也要消耗一个序号。</strong></li><li><strong>服务器收到FIN包，发出确认报文，即ACK包（ACK=1，seq=v，ack=u+1），此时服务端就进入了CLOSE_WAIT状态，TCP服务器通知高层的应用程序，客户端向服务器的方向就释放了，这时候处于半关闭状态，因为即使客户端已经没有数据要发送了，但是服务器若要发送数据，客户端依然要接收。</strong></li><li><strong>客户端收到服务器的确认请求后，此时客户端就进入FIN_WAIT_2状态，等待服务器发送连接释放报文，即服务器的FIN包。</strong></li><li><strong>服务器最后的数据发送完毕后，就向客户端发送FIN包（FIN==1，ACK=1，seq=w，ack=u+1），此时服务器就进入了LAST_ACK状态，等待客户端确认。</strong></li><li><strong>客户端收到服务器的连接释放报文后，必须发出确认ACK包（ACK=1，seq=u+1，ack=w+1），此时客户端就进入了TIME_WAIT状态！！此时TCP连接还没有释放，必须经过2MSL的等待后，才进入CLOSED状态。</strong></li><li><strong>服务器收到客户端的ACK包后，立即进入CLOSED状态。结束这次的TCP连接。</strong><br><img src="/posts/6245/v2-c7d4b5aca66560365593f57385ce9fa9_hd.jpg" alt></li></ol><h4 id="等待2XMLS的意义"><a href="#等待2XMLS的意义" class="headerlink" title="等待2XMLS的意义"></a>等待2XMLS的意义</h4><p>MSL说“最长报文段寿命”的意思，他是任何报文在网络上存在最长时间，超过这个时间报文将被丢弃。</p><p>为了保证客户端发送的最后一个ACK包能够到达服务器，因为这个ACK有可能丢失，从而导致处在LAST_ACK状态的服务器收不到对FIN_ACK的确认报文，服务器会重传这个FIN_ACK包，接着客户端再重传一次确认，重新启动时间等待器。最后客户端和服务端都能正常关闭。</p><p>假设客户端不等待2MLS，而是在发送完ACK之后直接释放关闭，一旦这个ACK丢失，服务器就无法正常进入关闭连接状态。因此可以总结为两个理由：</p><ul><li><strong>保证客户端发送的最后一个ACK报文段能够到达服务器</strong></li><li><strong>防止“已失效的连接请求报文段”出现在本连接中</strong></li></ul><h2 id="TCP以段为单位发送数据"><a href="#TCP以段为单位发送数据" class="headerlink" title="TCP以段为单位发送数据"></a>TCP以段为单位发送数据</h2><p>在建立TCP连接的同时，也可以确定发送数据包的单位，我们也可以称其为“最大消息长度（MSS）”。最理想的情况是，最大消息长度正好是IP中不会被分片的最大数据长度。</p><p><strong>TCP在传送大量数据时，是以MSS的大小将数据进行分割发送，进行重发时也是以MSS为单位。</strong></p><p><strong>MSS是在三次握手的时候，在两端主机之间被计算得出。两端的主机在发出建立连接的请求时，会在TCP首部中写入MSS选项，告诉对方自己的接口能够适应的MSS大小。然后会在两者之间选择一个较小的值使用。</strong></p><p><img src="/posts/6245/TIM%E6%88%AA%E5%9B%BE20191029223512.png" alt></p><h2 id="利用窗口控制提高速度"><a href="#利用窗口控制提高速度" class="headerlink" title="利用窗口控制提高速度"></a>利用窗口控制提高速度</h2><p>TCP以1个段为单位，每发一个段进行一次确认应答的处理，这样的传输方式的缺点就是，包的往返时间越长通信性能就越低。</p><p>为了解决这个这个问题，TCP引入了窗口的概念，确认应答不再是以每个分段，而是以更大的单位进行确认时，转发时间将会被大幅度的缩短怒。也就是说，发送端主机，在发送了一个段以后不必要一直等待确认应答，而是继续发送。<img src="/posts/6245/TIM%E6%88%AA%E5%9B%BE20191030201429.png" alt><br>窗口大小就是指无需等待确认应答而可以继续发送数据的最大值。上图中窗口大小为4个段。这个机制实现了使用大量的缓冲区，通过对多个段同时进行确认应答的功能。</p><p><strong>如下图所示，发送数据中高亮圈起的部分正是前面所提到的窗口。在这个窗口内的数据即便是没有收到确认应答也可以被发送出去。不过，在整个窗口的确认应答没有到达之前，如果其中部分数据出现丢包，那么发送端仍然要负责重传。为此发送端主机得设置缓存保留这些待被重传的数据，直到收到它们的确认应答。</strong><br><img src="/posts/6245/TIM%E6%88%AA%E5%9B%BE20191030201845.png" alt><br>在滑动窗口以外的部分包括尚未发送的数据以及已经确认对端已收到的数据。当数据发出后若如期收到确认应答就可以不用再进行重发，此时数据就可以从缓存区清除。</p><p><strong>收到确认应答的情况下，将窗口滑动到确认应答的序列号的位置。这样可以顺序的将多个段同时发送提高通信性能。这种机制也被称为滑动窗口控制。</strong></p><h2 id="窗口控制与高速重发控制"><a href="#窗口控制与高速重发控制" class="headerlink" title="窗口控制与高速重发控制"></a>窗口控制与高速重发控制</h2><p>在没有使用窗口控制的时候，没有收到确认应答的数据都会被重发。而是用了窗口控制，就如下图所示，某些确认应答即使丢失也无需重发。<img src="/posts/6245/TIM%E6%88%AA%E5%9B%BE20191030210504.png" alt><strong>窗口在一定程度上较大时，即使有少部分的确认应答丢失也不会进行数据重发，可以通过下一个确认应答进行确认。</strong></p><p>其次考虑一下某个报文段丢失的情况，接受主机如果收到一个应该接受的序号以外的数据时，会针对当前为止收到的数据返回确认应答。<img src="/posts/6245/TIM%E6%88%AA%E5%9B%BE20191030211102.png" alt></p><p><strong>当某一段报文丢失后，发送端会一直收到序号为1001的确认应答，这个确认应答好像在提醒发送端“我想接受的是从1001开始的数据”.因此，在窗口比较大，又出现报文段丢失的情况下，同一个序号的确认应答将会被重复不断地返回。而发送端主机如果连续3次收到同一个确认应答，就会将其所对应的数据进行重发。这种机制比之前提到的超时管理更加高效，因此也被称作为高速重发控制。</strong></p><h2 id="流控制"><a href="#流控制" class="headerlink" title="流控制"></a>流控制</h2><p>发送端根据自己的实际情况发送数据。但是接收端可能收到的是一个毫无关系的数据包又可能会在处理其他问题上花费一些时间。因此在为这个数据包做其他处理时会消耗一些时间，甚至在高负荷的情况下无法接收任何数据。如此一来，如果接收端将本应该接受的数据丢弃的话，就会触发重发机制，从而导致网络流量的无端浪费。</p><p>为了防止这种现象的发生，TCP提供一种机制可以让发送端根据接收端的实际接受能力控制发送的数据量。这就是所谓的流控制。</p><p><strong>它的具体操作是，接收端主机向发送端主机通知自己可以接收数据的大小，于是发送端会发送不超过这个限度的数据。改大小限度就被称为窗口大小，上一节提高的窗口大小的值就是由接收端主机决定的。</strong></p><p>TCP首部中，专门有一个字段来通知窗口的大小，接受主机将自己可以接收的缓冲区大小放入这个字段中，通知给发送端。这个字段的值越大，说明网络的吞吐量越高。</p><p><strong>不过接收端的这个缓冲区一旦面临数据溢出时，窗口大小的值也会随之被设置为一个更小的值通知给发送端，从而控制数据发送量。也就是说，发送端主机会根据接收端主机的指示，对发送数据的量进行控制，这也就形成了一个完整的TCP流控制。</strong></p><h2 id="拥塞控制-慢启动"><a href="#拥塞控制-慢启动" class="headerlink" title="拥塞控制-慢启动"></a>拥塞控制-慢启动</h2><p>一般来说，如果在通信刚开始就发送大量的数据，可能会引发其他问题。在网络出现拥堵时，如果突然出现一个叫大量的数据，极有可能会导致整个网络的瘫痪。</p><p>TCP为了防止该问题的出现，在通信一开始就会发送一个叫做<strong>慢启动</strong>的算法得出的数值，对发送数据量进行控制。<br><img src="/posts/6245/TIM%E6%88%AA%E5%9B%BE20191030213453.png" alt><br><strong>首先，为了在发送端调节所要发送的数据的量，定义了一个叫做“拥塞窗口”的概念，于是在慢启动的时候，将这个拥塞窗口的大小设置为1个数据段（1MSS）发送数据，之后每次收到一次确认应答（ACk），拥塞窗口的值就加1.在发送数据包时，将拥塞窗口的大小与接收端主机通知的窗口大小做比较，然后按照它们当中较小的那个值，发送比其还小的数据量。</strong></p><p><strong>不过随着包的往返，拥塞窗口也会以1、2、4等指数函数的增长，拥堵状况甚至导致网络拥塞的发生。为了防止这些，引入了慢启动阈值的概念。只要拥塞窗口的值超过了这个阈值，在每收到一次确认应答时，只允许以下面这种比例放大拥塞窗口</strong>：<img src="/posts/6245/TIM%E6%88%AA%E5%9B%BE20191030214347.png" alt></p><p><strong>TCP的通信开始时，并没有设置相应的慢启动阈值，而是在超时重发时，才会设置为当时拥塞窗口一般的大小。</strong></p><h1 id="其它传输层协议"><a href="#其它传输层协议" class="headerlink" title="其它传输层协议"></a>其它传输层协议</h1><h2 id="UDP-Lite"><a href="#UDP-Lite" class="headerlink" title="UDP-Lite"></a>UDP-Lite</h2><p>UDP-Lite是扩展UDP技能的一种传输层协议。在基于UDP的通信当中如果校验和出现错误，所收到的包将被全部丢弃。然而现实操作中，有些应用在面对这种情况时并不希望把已经收到的所有包丢弃。</p><p>UDP-Lite因此规定计算校验和的范围可以由应用自行决定。这个范围可以是包加上伪首部的校验和，可以是首部与伪首部的校验和计算，也可以是首部、伪首部与数据从起始到中间某个位置的校验和计算。</p><p>有了这样的机制，就可以针对不允许发生错误的部分进行校验和检查。对于其他部分，即使发生了错误，也会被忽略不计。而这个包也不会被丢弃，而是直接传给应用继续处理。</p><h2 id="SCTP"><a href="#SCTP" class="headerlink" title="SCTP"></a>SCTP</h2><p>SCTP主要用于进行通信的应用之间发送众多较小消息的情况，这些较小的应用消息被称为数据块，多个数据块组成一个包。</p><h2 id="DCCP"><a href="#DCCP" class="headerlink" title="DCCP"></a>DCCP</h2><p>DCCP是UDP的改进版本，它不能提供发送数据的可靠性传输，但是它面向连接，能够根据网络拥堵情况进行拥塞控制。</p><h1 id="UDP首部格式"><a href="#UDP首部格式" class="headerlink" title="UDP首部格式"></a>UDP首部格式</h1><p><img src="/posts/6245/TIM%E6%88%AA%E5%9B%BE20191030215737.png" alt></p><ul><li><strong>源端口号</strong>:表示发送端端口号，字段长16位。该字段是可选项，有时可能不会设置源端口号。没有源端口号的时候该字段的值设置为0，可用于不需要返回的通信中。</li><li><strong>目标端口号</strong>：表示接收端端口，字段长度16位。</li><li><strong>包长度</strong>：保存了UDP首部长度跟数据的长度之和，单位为字节。</li><li><strong>校验和</strong>：校验和是为了提供可靠的UDP首部和数据而被设计。UDP也有可能不用校验和，此时该字段中填入0，这种情况下，由于不进行校验和计算，因此协议处理的开销就会降低，从而提高数据转发的速度。</li></ul><h1 id="TCP首部格式"><a href="#TCP首部格式" class="headerlink" title="TCP首部格式"></a>TCP首部格式</h1><p><img src="/posts/6245/TIM%E6%88%AA%E5%9B%BE20191030220210.png" alt><br>TCP中没有表示包长度和数据长度的字段，因为可由IP层获知TCP的包长度，由TCP的包长可知数据的长度。</p><ul><li><p><strong>源端口号</strong>：表示发送端端口号，字段长16位。</p></li><li><p><strong>目标端口号</strong>：表示接收端端口号，字段长16位。</p></li><li><p><strong>序列号（seq）</strong>：字段长32位，<strong>有时也叫序号，是指发送数据的位置，没法送一次数据，就会累加一次该数据字节数的大小。序列号不会从0或1开始，而是在建立连接时由计算机生成的随机数作为其初始值，通过SYN包传给接收端主机。然后再将每转发过去的字节数累加到初始值上表示数据的位置。此外，在建立连接和断开连接时发送的SYN包和FIN包虽然并不写携带数据，但是也会作为一个字节增加对应的序列号。</strong></p></li><li><p><strong>确认应答号（ack）</strong>：字段长度32位，是指下一次应该接收到的数据的序列号。实际上它是指已收到确认应答号前一位为止的数据。发送端收到这个确认应答以后可以认为这个序号以前的数据已经被正常接收。</p></li><li><p><strong>数据偏移</strong>：该字段表示TCP所传输的数据部分应该从TCP包的哪个位开始计算，当然也可以把它看作TCP首部的长度。</p></li><li><p><strong>保留</strong>：长度为4位，为以后扩展时使用。</p></li><li><p><strong>控制位</strong>：<img src="/posts/6245/TIM%E6%88%AA%E5%9B%BE20191030221343.png" alt>字段长8位，每一位从左至右分别为CWR、ECE、URG、ACK、PSH、RST、SYN、FIN。这些控制标志也叫做控制位，当它们对应位上的值为1时，具体含义如下：</p><ul><li>CWR：与后面的ECE标志都用于IP收不到ECN字段，标志通知对方以将拥塞窗口缩小。</li><li>ECE：通知对方，从对方到这边的网络有拥塞。</li><li>URG：表示包中有需要紧急处理的数据。</li><li>ACK：确认应答的字段变为有效，<strong>TCP规定除了最初建立连接时的SYN包之外该位必须设置为1。</strong></li><li>PSH：表示需要将收到的数据立刻传给上层应用协议，为0时则表示先进行缓存。</li><li>RST：表示TCP连接中出现异常必须强制断开连接。例如对方主机突然断电。</li><li>SYN：用于建立连接，SYN为1表示希望建立连接，<strong>并在其序列号的字段进行序列号初始值设定。</strong></li><li>FIN：表示今后不会再有数据发送，希望断开连接。</li></ul></li><li><p><strong>窗口大小</strong>：长16为，用于通知从相同TCP收不到确认应答号所指位置开始能够接收端数据大小。TCP不允许发送超过此处所示大小的数据，不过如果窗口为0，则表示可以发送窗口探测，以了解最新的窗口大小，但这个数据必须是1个字节。</p></li><li><p><strong>校验和</strong>：与UDP相似，区别在于TCP中无法关闭。</p></li><li><p><strong>紧急指针</strong>：长为16位，只要在URG控制位为1时有效。该字段的数值表示本报文段中紧急数据的指针。正确来讲，从数据部分的首位到紧急指针的位置为止为紧急数据，因此可以说紧急指针指出了紧急数据的末尾在报文段中的位置。</p></li><li><p><strong>选项</strong>：<img src="/posts/6245/TIM%E6%88%AA%E5%9B%BE20191030222443.png" alt></p><ul><li>类型2的MSS选项用于在建立连接时决定的那个最大段长度。</li><li>类型3的窗口扩大，是一个用来改善TCP吞吐量的选项。</li><li>类型8时间戳字段选项，用于高速通信中对序列号的管理。</li><li>类型4、5用于选择确认应答。</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      本篇文章旨在介绍传输层的两个主要协议TCP（Transmission Control Protocol）与UDP（User Datagram Protocol）。
    
    </summary>
    
      <category term="计算机网络" scheme="http://yoursite.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
  </entry>
  
  <entry>
    <title>IP协议相关技术</title>
    <link href="http://yoursite.com/posts/15583/"/>
    <id>http://yoursite.com/posts/15583/</id>
    <published>2019-10-26T13:56:38.000Z</published>
    <updated>2019-10-27T07:42:11.025Z</updated>
    
    <content type="html"><![CDATA[<h1 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h1><p>我们平常在访问某个网站时不使用IP地址，而是用一串由几个英文字母用点号连接构成的域名。在这种情况下，产生了一个可以有效管理域名和IP地址之间对应关系的系统，那就是DNS系统。</p><p>在应用中，当用户输入域名时，DNS会自动检索那个注册了域名和IP地址的数据库，并迅速定位对应的IP地址。而且。如果主机名和IP地址需要进行变更时，也只需要在组织机构内部进行处理即可。</p><p>DNS系统是一个分布式数据库，它的结构如下图：<img src="/posts/15583/607e9d15fd6d5f9d02f6f4b0adb261b9_hd.jpg" alt></p><h2 id="DNS查询过程"><a href="#DNS查询过程" class="headerlink" title="DNS查询过程"></a>DNS查询过程</h2><ol><li>例如当在浏览器输入<a href="http://www.qq.com域名时，浏览器首先会在自己的缓存中查找是否有该域名对应的IP地址，如果有，就先调用这个IP地址映射，完成域名解析。" target="_blank" rel="noopener">www.qq.com域名时，浏览器首先会在自己的缓存中查找是否有该域名对应的IP地址，如果有，就先调用这个IP地址映射，完成域名解析。</a></li><li>如果浏览器中没有缓存，则操作系统会先检查自己本地的hosts文件中是否有这个网址的映射关系，如果有，就先调用这个IP地址映射，完成域名解析。</li><li>如果hosts中没有这个域名的映射，则查找本地的DNS解析器缓存，是否有这个网址的映射，如果有则直接返回，完成解析。</li><li>如果hosts文件与本地DNS解析器缓存都没有对应的网址映射关系，首先会找这个TCP/IP参数中设置的首选DNS服务器，在此我们叫它本地DNS服务器，此服务器收到查询时，如果本地配置资源中包含要查找到域名的映射关系，则返回解析结果给客户端，完成域名解析，此解析具有权威性。</li><li>如果要查询的域名不由本地DNS服务器区域解析，但是该服务器已缓存了此网址的映射，则调用这个映射结果，完成域名解析，此解析不具有权威性。</li><li>如果本地DNS服务器的本地区域文件和缓存都解析失败的话，则根据本地DNS服务器端设置进行查询。如果未用转发模式，本地DNS服务器就会把请求发送至13台根DNS服务器，根DNS服务器收到请求后会判断这个域名是谁来授权管理，并会返回一个负责该顶级DNS服务器的IP地址。本地DNS服务器收到IP信息后，将会联系这台顶级DNS服务器。这台顶级DNS服务器收到请求后，如果自己无法解析，他会找一个自己的下一级DNS服务器，也就是权威DNS服务器，给本地DNS服务器。当本地DNS服务器收到返回的权威DNS服务器IP时，重复上面的动作进行查询，直到找到<a href="http://www.qq.com的IP地址。" target="_blank" rel="noopener">www.qq.com的IP地址。</a></li><li>如果用的是转发模式，次DNS服务器会把请求转发至上一级DNS服务器，由上一级进行解析，上一级如果不能解析，或找根DNS服务器或把请求转发至上上级，以此循环，直到找到<a href="http://www.qq.com的IP地址。" target="_blank" rel="noopener">www.qq.com的IP地址。</a></li></ol><h1 id="ARP"><a href="#ARP" class="headerlink" title="ARP"></a>ARP</h1><p>只要确定了IP地址，就可以向这个目标地址发送IP数据报。然而，在底层数据链路层，进行实际通信时却有必要了解每个IP地址所对应的MAC地址。ARP是一种解决地址问题的协议，以目标IP地址为线索，用来定位下一个应该接收数据分包的网络设备对应的MAC地址。</p><h2 id="ARP工作机制"><a href="#ARP工作机制" class="headerlink" title="ARP工作机制"></a>ARP工作机制</h2><p>简单地说，ARP是借助ARP请求与ARP响应两种类型的包确定MAC地址的。假设主机A向同一链路上的主机B发送IP包，主机A的IP地址为172.20.1.1，主机B的IP地址为172.20.1.2，它们互不知道对方的MAC地址。</p><p>主机A为了获得主机B的MAC地址，<strong>起初要通过广播发送一个ARP请求包。</strong>这个包中包含了想要了解其MAC地址的主机IP地址，也就是说，ARP请求包中已经包含了主机B的IP地址172.20.1.2.由于广播的包可以被同一链路上的所有的主机和路由器接收，<strong>因此ARP请求的包也就会被这同一链路上的所有注解和路由器进行解析。如果ARP请求包中的目标IP地址与自己的IP地址一致，那么这个节点就将自己的MAC地址塞入ARP响应包返回给主机A。</strong></p><p><strong>总之，从一个IP地址发送ARP请求包以了解其MAC地址，目标地址将自己的MAC地址填入其中的ARP响应包返回到IP地址，由此，可以通过ARP从IP地址获得MAC地址，实现链路内的IP通信。</strong></p><p>如果没法送一个IP数据包都要进行一次ARP请求将会造成不必要的网络流量，因此，通常的做法就是把获取到的MAC地址缓存一段时间。</p><h2 id="RARP"><a href="#RARP" class="headerlink" title="RARP"></a>RARP</h2><p>RARP是将ARP反过来，从MAC地址定位IP地址的一种协议。例如将打印机服务器等小型嵌入式设备接入到网络时就经常会用得到。</p><p>平常我们个人电脑设置IP地址，也可以通过DHCP自动分配获取IP地址。然而对于嵌入式设备，会遇到没有任何输入接口或无法通过DHCP动态获取IP地址的情况。在类似情况下，就可以使用RARP。</p><p><strong>为此，需要架设一台RARP服务器，从而在这个服务器上注册设备的MAC地址已经IP地址，然后再将这个设备连接到网络，插电启动时，该设备会发送一条“我的MAC地址是***，请告诉我我的IP地址应该是什么”的请求信息。RARP服务器接受到这个请求后，返回类似于“MAC地址为***，IP地址为***”的信息给这个设备。而设备就根据从RARP服务器所收到的应答信息，从而设置自己的IP地址。</strong></p><h2 id="代理ARP"><a href="#代理ARP" class="headerlink" title="代理ARP"></a>代理ARP</h2><p>通常ARP包会被路由器隔离，但是采用代理ARP的路由器可以将ARP请求转发给邻近的网段。由此，两个以上网段的节点之间就可以像在一个网段中一样进行转发通信。</p><h2 id="ARP攻击和防护"><a href="#ARP攻击和防护" class="headerlink" title="ARP攻击和防护"></a>ARP攻击和防护</h2><p>ARP会引起的攻击有以下几种：</p><ul><li><strong>ARP泛洪攻击</strong>：<strong>通过向网关发送大量ARP报文，导致网关无法正常响应。</strong>首先发送大量的ARP请求报文，然后又发送大量虚假的ARP响应报文，从而造成网关部分的CPU利用率上升难以响应正常服务请求，而且网关还会被错误的ARP表充满导致无法更新维护正常ARP表，消耗网络带宽资源。</li><li><strong>ARP欺骗主机的攻击</strong>：ARP欺骗主机的攻击也是ARP众多攻击类型中很常见的一种。攻击者通过ARP欺骗使得局域网内被攻击主机发送给网关的流量信息实际上都发送给攻击者。主机刷新自己的ARP使得在自己的ARP缓存表中对应的MAC为攻击者的MAC，这样一来其他用户要通过网关发送出去的数据流就会发往主机这里，这样就会造成用户的数据外泄。</li><li><strong>欺骗网关的攻击</strong>：欺骗网关就是把别的主机发送给网关的数据通过欺骗网关的形式使得这些数据通过网关发送给攻击者。这种攻击目标选择的不是个人主机而是局域网的网关，这样就会攻击者源源不断的获取局域网内其他用户韵数据．造成数据的泄露，同时用户电脑中病毒的概率也会提升。</li><li><strong>中间人攻击</strong>：中间人攻击是同时欺骗局域网内的主机和网关，局域网中用户的数据和网关的数据会发给同一个攻击者，这样，用户与网关的数据就会泄露。</li><li><strong>IP地址冲突攻击</strong>：通过对局域网中的物理主机进行扫描，扫描出局域网中的物理主机的MAC地址，然后根据物理主机的MAC进行攻击，导致局域网内的主机产生IP地址冲突，影响用户的网络正常使用。</li></ul><p>相对应的攻击防护方法有以下几种：</p><ol><li>不要把网络信任关系单纯地建立在IP基础上或MAC基础上（RARP同样存在欺骗的问题），<strong>应在网络中架设DHCP服务器，绑定网关与客户端IP+MAC，</strong>该做法需要注意的是要保证网络中的dhcp服务器相互之间不冲突。</li><li><strong>添加静态的ARP映射表，</strong>不让主机刷新设定好的映射表，该做法适用于网络中主机位置稳定，不适用在主机更换频繁的局域网中。</li><li>停止使用ARP，将ARP作为永久条目保存在映射表中。</li><li>架设ARP服务器。通过该服务器查找自己的ARP映射表来响应其他机器的ARP广播。</li><li>IP的传输使用“proxy”代理。</li><li>使用防火墙等连续监控网络。注意有使用SNMP的情况下，ARP的欺骗有可能导致陷阱包丢失。</li></ol><h1 id="ICMP"><a href="#ICMP" class="headerlink" title="ICMP"></a>ICMP</h1><p>架构IP网络时需要特别注意两点：确认网络是否正常工作，以及遇到异常时进行问题诊断。ICMP正式提供这类功能的一种协议。</p><p><strong>ICMP的主要功能包括，确认IP包是否成功送达目标地址，通知在发送过程当中IP包被废弃的具体原因，改善网络设置等。</strong>有了这些功能，就可以获得网络是否正常，设置是否有误以及设备有何异常等信息，从而便于进行网络上的问题诊断。不过ICMP时基于尽力而为的IP进行工作的，因此无法保证服务质量，而且在网络安全优先于便利性的环境中往往无法使用ICMP，因此不宜过分依赖于ICMP。</p><p>在IP通信中如果主机A向主机B发送了数据包，由于某种原因，途中的路由器2未能发现主机B的存在，这是，路由器2就会像主机A发送一个ICMP包，说明发往主机B的包未能成功。</p><p>ICMP的这种通知消息会使用IP进行发送，<strong>在ICMP中，包以明文的形式像TCP/UDP一样通过IP进行传输。</strong>然而ICMP所承担大二功能并非传输层的补充，而应该把它考虑为IP的一部分。因此，从路由器2返回的ICMP包会按照往常的路由控制先经过路由器1再转发给主机A。收到该ICMP包的主机A则分解ICMP的首部和数据域以后得知具体发生问题的原因。<br><img src="/posts/15583/TIM%E6%88%AA%E5%9B%BE20191027142714.png" alt></p><p><strong>ICMP的消息大致可以分为两类：一类是通知出错原因的错误消息，另一类是用于诊断的查询消息。</strong><img src="/posts/15583/TIM%E6%88%AA%E5%9B%BE20191027142849.png" alt></p><h2 id="主要的ICMP消息"><a href="#主要的ICMP消息" class="headerlink" title="主要的ICMP消息"></a>主要的ICMP消息</h2><ul><li><strong>ICMP目标不可达消息（类型3）</strong>：IP路由器无法将IP数据包发送给目标地址时，会给发送端主机返回一个目标不可达的ICMP消息，并在这个消息中显示不可达的具体原因。在实际通信中常会遇到错误代码1，表示主机不可达，它是指路由表中没有该主机的信息，或者该主机没有连接到网络的意思；此外错误代码4则用于前面介绍过的MTU探索。</li><li><strong>TCMP重定向消息（类型5）</strong>：如果路由器发现发送端主机使用了次优的路径发送数据，那么它会返回一个ICMP重定向的消息给这个主机。在这个消息中包含了最合适的路由信息和源数据。这主要发生在路由器持有更好的路由信息的情况下。</li><li><strong>ICMP超时消息（类型11）</strong>：IP包中有一个字段叫做TTL，当它的值减到0时该IP包会被丢弃。此时IP路由器将会发送一个ICMP超时的消息（错误号0）给发送端主机，并通知该包已被丢弃。设置IP包生存周期的目的是为了，在路由控制遇到问题发生循环状况时，避免IP包无休止的在网络上被转发。同时也可以控制包的到达范围。</li><li><strong>ICMP回送消息（类型0、8）</strong>：用于进行通信主机或路由器之间，判断所发送的数据包是否以及成功到达对端的一种消息。可以向对端主机发送回送请求的消息（类型8），也可以接收对端主机发回来的回送应答消息（类型0）。网络上最常用的ping命令就是利用这个消息实现的。</li><li><strong>ICMP原点抑制消息（类型4）</strong>：在使用低速广域线路的情况下，连接WAN的路由器可能会遇到网络拥堵的问题，ICMP原点抑制消息的目的就是为了缓和这种拥堵情况。</li><li><strong>ICMP路由器探索消息（类型9、10）</strong>：主要用于发现与自己相连网络中的路由器。</li><li><strong>ICMP地址掩码消息（类型17、18）</strong>：主要用于主机或路由器想要了解子网掩码的情况。</li></ul><h2 id="ICMPv6"><a href="#ICMPv6" class="headerlink" title="ICMPv6"></a>ICMPv6</h2><p>IPv4中ICMP仅作为一个辅助作用支持IPv4，然而在IPV6中，ICMP作用被扩大，如果没有ICMPv6，IPv6就无法进行正常通信。</p><p>在IPv6中，从IP地址定位MAC地址的协议，从ARP转为ICMP的邻居探索消息。这种邻居探索消息融合了IPv4的ARP、TCMP重定向以及ICMP路由器选择消息等功能于一体，甚至还提供自动设置IP地址的功能。</p><p><strong>ICMPv6将ICMP大致分为了两类：错误消息和信息消息。</strong></p><p>ICMP中从类型133至类型137的消息叫做邻居探索消息。邻居请求消息用于查询IPv6的地址与MAC地址的对应关系，并由邻居宣告消息得知MAC地址。</p><p>此外IPv6中实现了即插即用的功能，所以在没有DHCP服务器的情况下也能实现IP地址的自动获取。如果是一个没有路由器的网络，就使用MAC地址作为链路本地单播地址。而在一个有路由器的网络环境中，可以从路由器获得IPv6地址的前面部分，后面部分则由MAC地址进行设置。</p><h1 id="DHCP"><a href="#DHCP" class="headerlink" title="DHCP"></a>DHCP</h1><p>为了实现自动设置IP地址、统一管理IP地址分配，就产生了DHCP协议。有了DHCP，计算机只要连接到网络，就可以进行TCP/IP通信。</p><h2 id="DHCP工作机制"><a href="#DHCP工作机制" class="headerlink" title="DHCP工作机制"></a>DHCP工作机制</h2><p><strong>使用DHCP之前，首先要架设一台DHCP服务器。然后将DHCP所要分配的IP地址设置到服务器上。此外，还需要将相应的子网掩码、路由控制信息以及DNS服务器的地址设置到服务器上。</strong></p><p>DHCP分配IP地址有两种方法，一种是由DHCP服务器在特定的IP地址中自动选出一个进行分配。另一种方法是针对MAC地址分配一个固定的IP地址。而且这两种方法可以并用。<img src="/posts/15583/TIM%E6%88%AA%E5%9B%BE20191027151337.png" alt></p><h2 id="DHCP中继代理"><a href="#DHCP中继代理" class="headerlink" title="DHCP中继代理"></a>DHCP中继代理</h2><p>在一个企业或者学校等大规模组织机构的网络环境中，一般会有多个以太网网段，在这种情况下，若要针对每个网段都设置DHCP服务器将会是个庞大的工程。</p><p>因此在这种网络环境中，往往需要将DHCP统一管理。具体方法可以使用DHCP中继代理来实现。有了DHCP中继代理以后，对不同网段的IP地址分配也可以由一个DHCP服务器统一进行管理和运维。</p><p>这种方法使得在每个网段架设一个DHCP服务器被取代，只需在每个网段设置一个DHCP中继代理即可。它可以设置DHCP服务器的IP地址，从而可以在DHCP服务器上为每个网段注册IP地址的分配范围。</p><p><strong>DHCP客户端会向DHCP中继代理发送DHCP请求包，DHCP中继代理在收到这个广播包以后再以单播的形式发给DHCP服务器。服务端收到该包以后再向DHCP中继代理返回应答，并由DHCP中继代理将此包转发给DHCP客户端。</strong>由此，DHCP服务器即使不在同一个链路上也可以实现统一分配和管理IP地址。<br><img src="/posts/15583/TIM%E6%88%AA%E5%9B%BE20191027152025.png" alt></p><h1 id="NAT"><a href="#NAT" class="headerlink" title="NAT"></a>NAT</h1><p>NAT是用于在本地网络中使用私有地址，在连接互联网时转而使用全局IP地址的技术。除转换IP地址外，还出现了可以转换TCP、UDP端口号的NAPT技术。NAT（NATP）实际上是为了应对正在面临地址枯竭的IPv4而开发的技术。</p><h2 id="NAT工作机制"><a href="#NAT工作机制" class="headerlink" title="NAT工作机制"></a>NAT工作机制</h2><p>如图以10.0.0.10的主机与163.221.120.9的主机进行通信为例。<strong>利用NAT，图中的NAT路由器将发送源地址从10.0.0.10转换为全局的IP地址（202.244.174.37）再发送数据。反之，当包从地址163.221.120.9发过来时，目标地址（202.244.174.37）先被转换成私有IP地址10.0.0.10以后再被转发。</strong><img src="/posts/15583/TIM%E6%88%AA%E5%9B%BE20191027152523.png" alt><br><strong>在NAT（NAPT）路由器的内部，有一张自动生成的用来转换地址的表。当10.0.0.10向163.221.120.9发送第一个包时生成这张表，并按照表中的映射关系进行处理。</strong></p><h2 id="NAT-PT（NAPT-PT）"><a href="#NAT-PT（NAPT-PT）" class="headerlink" title="NAT-PT（NAPT-PT）"></a>NAT-PT（NAPT-PT）</h2><p><strong>为了解决NAT在IPv6中也能正常使用的问题，就产生了NAT-PT（NAPT-PT）规范。NAT-PT（NAPT-PT）是将IPv6的首部转换为IPv4的首部的一种技术。有了这种技术，那些只有IPv6地址的主机也能够与IPv4地址的其他主机进行通信了。</strong><br><img src="/posts/15583/TIM%E6%88%AA%E5%9B%BE20191027152947.png" alt></p><h2 id="NAT的问题与解决方法"><a href="#NAT的问题与解决方法" class="headerlink" title="NAT的问题与解决方法"></a>NAT的问题与解决方法</h2><p>由于NAT（NAPT）都依赖于自己的转换表，因此会有如下几点限制：</p><ul><li>无法从NAT的外部向内部服务器建立连接。</li><li>转换表的生成与转换操作都会产生一定的开销。</li><li>通信过程中一旦NAT遇到异常需重新启动时，所有的TCP连接都将被重置。</li><li>即使备置两台NAT做容灾备份，TCP连接还是会断开。</li></ul><p>解决NAT上述潜在问题有两种方法：</p><ul><li>改用IPv6。</li><li>即使是在一个没有NAT的环境里，根据所制作的应用，用户可以完全忽略NAT的存在而进行通信。</li></ul><h1 id="IP隧道"><a href="#IP隧道" class="headerlink" title="IP隧道"></a>IP隧道</h1><p>在如图所示的网络环境里，网络A、B使用IPv6，如果处于中间的网络C支持使用IPv4的话，网络A与网络B之间将无法直接进行通信。为了让他它们之间正常通信，这时就必须采用IP隧道的功能。<img src="/posts/15583/TIM%E6%88%AA%E5%9B%BE20191027153928.png" alt></p><p>IP隧道中可以将那些从网络A发过来的IPv6的包统和为一个数据，在为之追加一个IPv4的首部以后转发给网络C。这种在网络层的首部后面继续追加网络层首部的通信方法就叫做“IP隧道”。<br><img src="/posts/15583/TIM%E6%88%AA%E5%9B%BE20191027154151.png" alt></p>]]></content>
    
    <summary type="html">
    
      IP旨在让最终目标主机收到数据包，但在这一过程中仅仅有IP是无法实现通信的，必须还有能够解析主机名称和MAC地址的功能，以及数据包在发送过程中异常情况处理的功能。此外，还会涉及IP必不可少的其他功能。
    
    </summary>
    
      <category term="计算机网络" scheme="http://yoursite.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
  </entry>
  
  <entry>
    <title>IP协议</title>
    <link href="http://yoursite.com/posts/18937/"/>
    <id>http://yoursite.com/posts/18937/</id>
    <published>2019-10-24T13:54:27.000Z</published>
    <updated>2019-10-25T14:23:00.182Z</updated>
    
    <content type="html"><![CDATA[<h1 id="IP相当于OSI参考模型的第3层"><a href="#IP相当于OSI参考模型的第3层" class="headerlink" title="IP相当于OSI参考模型的第3层"></a>IP相当于OSI参考模型的第3层</h1><p>IP相当于OSI参考模型中的第3层——网络层。</p><p><strong>网络层的主要作用是“实现终端节点之间的通信”。这种终端节点之间的通信也叫“点对点”通信。</strong></p><p>从前面的章节可知，网络层的下一层是数据链路层，数据链路层的主要作用是再互联同一种数据链路的节点之间进行包传递。而一但快遇多种数据链路，就需要借助网络层。网络层可以跨越不同的数据链路，即使是在不同的数据链路上也能实现两端节点之间的数据包传输。</p><h1 id="IP基础知识"><a href="#IP基础知识" class="headerlink" title="IP基础知识"></a>IP基础知识</h1><p>在计算机通信中，为了识别通信对端，必须要有一个类似于地址的识别码进行标识，<strong>MAC地址正是用来标识同一数据链路中不同计算机的一种识别码；而IP地址用于在“连接到网络中的所有主机中识别出进行通信的目标地址”，因此在TCP/IP通信中所有注解或路由器必须设定自己的IP地址。</strong></p><h2 id="路由控制"><a href="#路由控制" class="headerlink" title="路由控制"></a>路由控制</h2><p>路由控制（Routing）是指将分组数据发送到最终目标地址的功能，即使网络非常复杂，也可以通过路由控制确定到达目标地址的通路。一旦这个路由控制的运行出现异常，分组数据极有可能迷失，无法到达目标地址。因此，一个数据包之所以能成功地到达最终的目标地址，全靠路由控制。</p><p>当某个IP包到达路由器时，路由器首先查找目标地址，从而再决定下一步应该将这个包发往哪个路由器，然后将包发送过去。当这个IP包到达那个路由器以后，会再次经历查找下一目标地址的过程，并由该路由器转发给下一个被找到的路由器。这个过程可能会反复多次，知道找到最终的目标地址，将数据包发送给这个节点。</p><p><strong>为了将数据包发给目标主机，所有主机都维护着一张路由控制表。该表记录IP数据在下一步应该发给哪个路由器。IP包根据这个路由表在各个数据链路上传输。</strong><img src="/posts/18937/TIM%E6%88%AA%E5%9B%BE20191025200434.png" alt></p><h2 id="数据链路的抽象化"><a href="#数据链路的抽象化" class="headerlink" title="数据链路的抽象化"></a>数据链路的抽象化</h2><p>IP是实现多个数据链之间通信的协议。数据链路根据种类的不同各有特点，<strong>不同数据链路有个最大的区别：就是它们各自的最大传输单位（MTU）不同。</strong>MTU的值再以太网是1500字节，再FDDI中是4352字节，而ATM则为9180字节。IP的上一层可能会要求传送比这些MTU更多字节数据，因此必须在线路上传送比包长还要小的MTU。</p><p>为了解决这个问题，IP进行分片处理。顾名思义，所谓分片处理是指，将较大的IP包分成多个较小的IP包。分片的包到了对端目标地址以后会再被组合起来传给上一层。</p><h2 id="IP属于面向无连接型"><a href="#IP属于面向无连接型" class="headerlink" title="IP属于面向无连接型"></a>IP属于面向无连接型</h2><p><strong>IP面向无连接，即在发包之前，不需要建立与对端目标地址之间的连接，上层如果遇到需要发送给IP的数据，该数据会立即被压缩成IP包发送出去。</strong></p><p>IP采用面向无连接的主要原因有两点：</p><ul><li><strong>一是为了简化。</strong>面向连接比起面向无连接处理相对复杂。甚至管理每个连接本身就是一个相当繁琐的事情。</li><li><strong>二是为了提速。</strong>每次通信之前都要事先建立连接，又会降低处理速度。</li></ul><p>需要连接时，可以委托上一层提供此项服务。因此IP为了实现简单化与高速化采用面向无连接的方式。</p><p>IP提供尽力服务，意指“为了把数据包发送到最终目标地址，尽最大努力”。然而，它并不做“最终收到与否的验证”。IP数据包在途中可能会发生丢包、错位以及数据量翻倍等问题。</p><h1 id="IP地址基础知识"><a href="#IP地址基础知识" class="headerlink" title="IP地址基础知识"></a>IP地址基础知识</h1><h2 id="IP地址的定义"><a href="#IP地址的定义" class="headerlink" title="IP地址的定义"></a>IP地址的定义</h2><p>IP（IPv4）地址由32为正整数来表示。TCp/IP通信要求将这样的IP地址分配给每一个参与通信的主机。<strong>采用将32位的IP地址以每8位为一组，分成4组，每组以“.”隔开，再将每组数转换为十进制数。</strong></p><p>IP地址并非是根据主机台数来配置的，而是每一台主机上的每一块网卡都得设置IP地址。通常一块网卡只设置一个IP地址，但其实一块网卡也可以设置多个IP地址。此外，一台路由器通常都会配置两个以上的网卡，因此可以设置两个以上的IP地址。</p><h2 id="IP地址的组成"><a href="#IP地址的组成" class="headerlink" title="IP地址的组成"></a>IP地址的组成</h2><p><strong>IP地址由“网络标识（网络地址）”和“主机标识（主机地址）”两部分组成。</strong></p><p>网络标识必须保证相互连接的每个段的地址不相重复。而相同段内相连的主机必须有相同的网络地址。IP地址的“主机标识”则不允许在同一个网段内重复出现。由此，<strong>可以通过设置网络地址和主机地址，在相互连接的整个网络中保证每台主机的IP地址都不会相互重复。即IP地址具有了唯一性。</strong></p><p>最初二者以分类进行区别，而现在基本以子网掩码（网络前缀）区分。</p><h2 id="IP地址的分类"><a href="#IP地址的分类" class="headerlink" title="IP地址的分类"></a>IP地址的分类</h2><p>IP地址分为四个级别，分别为A类、B类、C类、D类。它根据IP地址中从第1位到第4位的比特列对其网络标识和主机标识进行区分。</p><ul><li><strong>A类地址</strong>：A类IP地址是首位以“0”开头的地址。从第1位到第8位是他的网络标识。用十进制表示的话，0.0.0.0~127.0.0.0是A类的网络地址。A类地址的后24位相当于主机标识。</li><li><strong>B类地址</strong>：B类IP地址是前两位为“10”的地址。从第1位到第16位是它的网络标识。用十进制表示的话，128.0.0.0~191.255.0.0是B类的网络地址。B类地址的后16位相当于主机标识。</li><li><strong>C类地址</strong>：C类IP地址是前三位为“110”的地址。从第1位到第24位是它的网络标识。用十进制表示的话，192.0.0.0~223.255.255.0是C类的网络地址。C类地址的后8位相当于主机标识。</li><li><strong>D类地址</strong>：D类IP地址是前四位为“1110”的地址，从第1为到第32位是它的网络标识。用十进制表示的话，224.0.0.0~239.255.255.255.255是D类的网络地址。D类网络地址没有主机标识，常被用于多播。<br><img src="/posts/18937/TIM%E6%88%AA%E5%9B%BE20191025204003.png" alt><br>在IP地址分配时有一点需要注意，<strong>不可以全部为0或全部为1。</strong>因为全部为0在表示对应的网络地址或IP地址不可获知的情况下才使用。而全部为1的主机地址通常作为广播地址。</li></ul><h2 id="广播地址"><a href="#广播地址" class="headerlink" title="广播地址"></a>广播地址</h2><p><strong>广播地址用于在一个链路中相互连接的主机之间发送数据包。将IP地址中的主机地址部分全部设置为1，就成为了广播地址。</strong></p><p>广播地址分为<strong>本地广播</strong>和<strong>直接广播</strong>两种。<strong>在本网络内的广播叫做本地广播，在不同网络之间的广播叫做直接广播。</strong></p><h2 id="子网掩码"><a href="#子网掩码" class="headerlink" title="子网掩码"></a>子网掩码</h2><p>起初一个IP地址只要确定了其分类，也就确定了它的网络标识和主机标识，网络标识相同的计算机必须同属于同一个链路。但是这样会造成很多的IP地址浪费，因此后来人们改进使用子网掩码进行区分。</p><p>对于子网掩码，目前有两种标识方式。以172.20.100.52的前26位是网络地址的情况为例，以下是其中一种表示方法，它将IP地址与子网掩码的地址分别用两行来表示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">IP地址172.20.100.52</span><br><span class="line">子网掩码255.255.255.192</span><br><span class="line"></span><br><span class="line">网络地址172.20.100.0</span><br><span class="line">子网掩码255.255.255.192</span><br><span class="line"></span><br><span class="line">广播地址172.20.100.63</span><br><span class="line">子网掩码255.255.255.192</span><br></pre></td></tr></table></figure><p>另一种表示方法如下所示，它在每个IP地址后面追加网络地址的位数用“/”隔开。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">IP地址172.20.100.52/26</span><br><span class="line">网络地址172.20.100.0/26</span><br><span class="line">广播地址172.20.100.63/26</span><br></pre></td></tr></table></figure><h1 id="路由控制-1"><a href="#路由控制-1" class="headerlink" title="路由控制"></a>路由控制</h1><p>发送数据包时所使用的地址是网络地址，即IP地址。然而仅仅有IP地址还不足以将数据包发送到对端目标地址，在数据发送过程中还需要类似于“知名路由器或主机”的信息，以便真正的发往目标地址。保存这种信息的就是路由控制表。</p><p><strong>该路由控制表的形成方式有两种：一种是管理员手动设置，另一种是路由器与其他路由器相互交换形信息时自动刷新。前者也叫静态路由控制，后者叫做动态路由控制。</strong></p><h2 id="IP地址与路由控制"><a href="#IP地址与路由控制" class="headerlink" title="IP地址与路由控制"></a>IP地址与路由控制</h2><p>路由控制表中记录着网络地址与下一步应该发送至路由器的地址，在发送IP包时，首先要确定IP包首部中的目标地址，再从路由控制表中找到与该地址具有相同网络地址的记录，根据该记录将IP包转发给相应的下一个路由器。<strong>如果控制表中存在多条相同网络地址的记录，就选择一个最为吻合的网络地址，所谓最为吻合是指相同位数最多的意思。</strong></p><p>如果一张路由表中包含所有的网络及其子网的信息，将会造成无端的浪费，这是，默认路由是不错的选择。默认路由是指路由表中任何一个地址都能与之匹配的记录。默认路由一般标记为0.0.0.0./0或default。</p><p>“IP地址/32”也被称为主机路由。它的意思是整个IP地址的所有位都将参与路由。进行主机路由，意味着基于主机上网卡配置的IP地址本身，而不是基于该地址的网络地址部分进行路由。主机路由多被用于不希望通过网络地址路由的情况。</p><h1 id="IP分割处理与再构成处理"><a href="#IP分割处理与再构成处理" class="headerlink" title="IP分割处理与再构成处理"></a>IP分割处理与再构成处理</h1><p>如前面介绍所说，每种数据链路的最大传输单元（MTU）不尽相同，简与IP数据数据链路上一层，它必须不受限于不同数据链路的MTU大小。</p><h2 id="IP报文的分片与重组"><a href="#IP报文的分片与重组" class="headerlink" title="IP报文的分片与重组"></a>IP报文的分片与重组</h2><p>任何一台主机都有必要对IP分片进行相应的处理。分片往往在网络上遇到比较大的报文无法一下子发送出去时才会进行处理。</p><p><strong>分片默认以8个字节的倍数为单位进行，经过分片之后的IP数据报在被重组的时候，只能由目标主机进行。路由器虽然做分片但是不会进行重组。</strong><br><img src="/posts/18937/TIM%E6%88%AA%E5%9B%BE20191025212713.png" alt></p><h2 id="路径MTU发现"><a href="#路径MTU发现" class="headerlink" title="路径MTU发现"></a>路径MTU发现</h2><p>分片机制也有它的不足，例如路由器的处理符合加重，一旦某个分片丢失，会造成整个IP数据报作废等等。为了应对这些问题，产生了一种新的技术“路径MTU发现”。</p><p><strong>所谓路径MTU是指从发送端主机到接收端主机之间不需要分片时最大的MTU的大小。即路径中存在的所有数据链路中最小的MTU。而路径MTU发现从发送主机按照路径MTU的大小将数据报分片后进行发送，进行路径MTU发现，就可以避免在中途的路由器上进行分片处理，也可以在TCP中发送更大的包。</strong></p><p>路径MTU发现的工作原理如下：<br>首先在发送端主机发送IP数据报时将其首部的分片禁止标志设置为1。根据这个标志位，途中的路由器即使遇到需要分片才能处理的大包，也不会去分片，而是将包丢弃。随后，通过一个ICMP的不可达消息将数据链路上MTU的值给发送主机。</p><p>下一次，从发送给同一目标主机的IP数据报获得ICMP所通知的MTU值以后，将它设置为当前MTU。发送主机根据这个MTU对数据报进行分片处理。如此反复，直到数据报被发送到目标主机为止没有再收到任何ICMP，就认为最后一次ICMP所统治的MTU即是一个合适的MTU值。</p><p>那么，当MTU的值比较多时，最少可以缓存约10分钟。在这10分钟内使用刚刚求得的MTU，但过了这10分钟以后则重新根据链路上的MTU做一次路径MTU发现。</p><p>下面是UDP和TCP的路径MTU发现过程：<img src="/posts/18937/TIM%E6%88%AA%E5%9B%BE20191025214216.png" alt><img src="/posts/18937/TIM%E6%88%AA%E5%9B%BE20191025214237.png" alt></p><h1 id="IPv6"><a href="#IPv6" class="headerlink" title="IPv6"></a>IPv6</h1><p>IPv6是为了根本解决IPv4地址耗尽的问题而被标准化的网络协议。IPv4的地址长度为4个8位字节，即32比特。而IPv6的地址长度则是原来的4倍，即128比特，一般写成8个16字位字节。</p><h2 id="IPv6的特点"><a href="#IPv6的特点" class="headerlink" title="IPv6的特点"></a>IPv6的特点</h2><p>IPv6通过改进IPv4的缺点，减轻了管理员的负担。</p><ul><li>IP地址的扩大与路由控制表的聚合</li><li>IP地址依然适应互联网分层构造。分配与其地址结构相适应的IP地址，尽可能避免路由表膨大</li><li>性能提升</li><li>支持即插即用功能，即使没有DHCP服务器也可以实现自动分配IP地址</li><li>采用认证与加密功能，应对伪造IP地址的网络安全功能以及防止路线窃听的功能</li><li>多播、Mobile IP称为扩展功能</li></ul><h2 id="IPv6在IP地址的标记方法"><a href="#IPv6在IP地址的标记方法" class="headerlink" title="IPv6在IP地址的标记方法"></a>IPv6在IP地址的标记方法</h2><p><strong>一般人们将128比特IP地址以每16为一组，每组用冒号“：”隔开进行标识。而且如果出现连续的0时还可以将这些0省略，并用两个冒号“：：”隔开，但是一个IP地址中只允许出现一次两个连续的冒号。</strong></p><h2 id="IPv6分段处理"><a href="#IPv6分段处理" class="headerlink" title="IPv6分段处理"></a>IPv6分段处理</h2><p><strong>IPv6的分片处理只在作为起点的发送端主机上进行，路由器不参与分片。</strong>这也是为了减少路由器的负荷、提高网速。因此IPv6中的“路径MTU发现”功能必不可少。</p><p><strong>不过IPv6中最小的MTU为1280字节，</strong>因此，在嵌入式系统中对于那些有一定系统资源限制的设备来说，不需要进行“路径MTU发现”，而是在发送IP包时直接以1280字节为单位分片发出。</p><h1 id="IPv4首部"><a href="#IPv4首部" class="headerlink" title="IPv4首部"></a>IPv4首部</h1><p>通过IP进行通信时，需要在数据的前面加入IP首部信息。IP首部中包含用于IP协议进行发包控制时所有的必要信息。<img src="/posts/18937/TIM%E6%88%AA%E5%9B%BE20191025215451.png" alt></p><ul><li><strong>版本</strong>：由4比特构成，表示标识IP首部的版本号，IPv4的版本号为4，因此在这个字段上的值即为“4”，IPv6的版本号为6。</li><li><strong>首部长度</strong>：由4比特构成，表明IP首部的大小，单位为4字节。对于没有可选项的IP包，首部长度则设置为5.</li><li><strong>区分服务</strong>：由8比特构成，用来表明服务质量，如下表：<img src="/posts/18937/TIM%E6%88%AA%E5%9B%BE20191025215837.png" alt></li><li><strong>DSCP段与ECN段</strong>：DSCP（差分服务代码点）是TOS的一部分，用来进行质量控制。ECn（显示拥塞通告）用来报告网络拥堵情况，由两个比特构成。</li><li><strong>总长度</strong>：表示IP首部与数据部分合起来的总字节数，该字段长16比特，<strong>因此IP包的最大长度为65535字节。</strong></li><li><strong>标识（ID）</strong>：由16比特构成，用于分片重组，同一个分片的标识值相同，不同分片的标识值不同。通常每发送一个IP包，它的值也逐渐递增。此外，即使ID相同，如果目标地址、源地址或协议不同的话，也会被认为是不同的分片。</li><li><strong>标志</strong>：由3比特构成，标识包倍分片的相关信息。具体含义如下：<img src="/posts/18937/TIM%E6%88%AA%E5%9B%BE20191025220758.png" alt></li><li><strong>片位移</strong>：由13比特构成，用来标识被分片的每一个分段相对于原始数据的位置。第一个分片对应的位置为0。</li><li><strong>生存时间（TTL）</strong>：由8比特构成，最初意思是以秒为单位记录当前包在网络上应该生存的限期，实际中它是指可以中转多少个路由器的意思，每经过一个路由器，TTL就会减少1，直到变成0则丢弃包。TTl不会超过256，由此可以避免IP包在网络内无限传递的问题。</li><li><strong>协议</strong>：由8比特构成，表示IP包传输层的上层协议编号。</li><li><strong>首部校验和</strong>：由16比特构成，也叫IP首部校验和。盖子都安只校验数据报的首部，不校验数据部分。它主要用来确保IP数据报不被破坏。</li><li><strong>源地址</strong>：由32比特构成，表示发送端IP地址。</li><li><strong>目标地址</strong>：由32比特构成，表示接收端IP地址。</li><li><strong>可选项</strong>：长度可变，通常只在进行实验或诊断时使用，包含信息有如下几点：安全级别、源路径、路径记录和时间戳。</li><li><strong>填充</strong>：也称作填充物，在有可选项的情况下，首部长度可能不是32比特的整数倍，为此，通过向该字段填充0，调整为32比特的整数倍。</li><li><strong>数据</strong>：存入数据。将IP上层协议的首部也为作为数据进行处理。</li></ul><h1 id="IPv6首部格式"><a href="#IPv6首部格式" class="headerlink" title="IPv6首部格式"></a>IPv6首部格式</h1><p>IPv6的IP数据首部格式相比IPv4已经发生巨大变化：<img src="/posts/18937/TIM%E6%88%AA%E5%9B%BE20191025221749.png" alt></p><ul><li><strong>版本</strong>：同IPv4一样。</li><li><strong>通信量类</strong>：相当于IPv4的TOS字段。至今没什么用。</li><li><strong>流标号</strong>：由20比特构成，准备用于服务质量控制，现在也没有用。只有流标号、源地址以及目标地址三项完全一致时，才被认为是一个流。</li><li><strong>有效载荷长度</strong>：有效载荷是指包的数据部分，这里不包括首部，只表示数据部分的长度。</li><li><strong>下一个首部</strong>：相当于IPv4的协议字段，由8比特构成。</li><li><strong>跳数限制</strong>：由8比特构成，相当于IPv4的TTL。</li><li><strong>源地址</strong>：由128比特构成，表示发送端IP地址。</li><li><strong>目标地址</strong>：由128比特构成，表示接收端IP地址。</li></ul><p>IPv6的首部长度固定，无法将可选项加入其中，取而代之的是通过扩展首部对功能进行了有效扩展。</p>]]></content>
    
    <summary type="html">
    
      IP（Internet Protocol，网际协议），IP作为整个TCP/IP中至关重要的协议，主要负责将数据包发送给最终的目标计算机，因此，IP能够让世界上任何两台计算机之间进行通信。
    
    </summary>
    
      <category term="计算机网络" scheme="http://yoursite.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
  </entry>
  
  <entry>
    <title>计算机网络基础知识</title>
    <link href="http://yoursite.com/posts/13182/"/>
    <id>http://yoursite.com/posts/13182/</id>
    <published>2019-10-22T13:36:59.000Z</published>
    <updated>2019-10-23T12:55:58.614Z</updated>
    
    <content type="html"><![CDATA[<h1 id="OSI参考模型"><a href="#OSI参考模型" class="headerlink" title="OSI参考模型"></a>OSI参考模型</h1><p>OSI参考模型将复杂的网络协议整理并分为易于理解的7个分层，对通信中必要的功能做了很好的归纳。不过，OSI参考模型始终是一个模型，它也只是对各层的作用做了一系列粗略的界定，并没有对协议和接口进行详细的定义。<img src="/posts/13182/TIM%E6%88%AA%E5%9B%BE20191022215354.png" alt></p><h2 id="OSI参考模型中各个分层的作用"><a href="#OSI参考模型中各个分层的作用" class="headerlink" title="OSI参考模型中各个分层的作用"></a>OSI参考模型中各个分层的作用</h2><p><img src="/posts/13182/TIM%E6%88%AA%E5%9B%BE20191022215744.png" alt></p><ul><li><strong>应用层</strong>：<strong>为应用程序提供服务并规定应用程序中通信相关的细节，</strong>包括文件传输、电子邮件、远程登录等协议。</li><li><strong>表示层</strong>：<strong>将应用程序的信息转换为适合网络传输的格式，或将来自下一层的数据转换为上层能够处理的格式，因此它主要负责数据格式转换。</strong></li><li><strong>会话层</strong>：<strong>负责建立和断开通信连接（数据流动的逻辑通路），以及数据的分割等数据传输相关的管理。</strong></li><li><strong>传输层</strong>：<strong>起着传输的作用，只在通信双方节点上进行处理，而无需在路由器上处理。</strong></li><li><strong>网络层</strong>：将数据传输到目标地址，目标地址可以是多个网络通过路由器连接而成的某一个地址，因此<strong>这一层主要负责寻址和路由选择。</strong></li><li><strong>数据链路层</strong>：<strong>负责物理层面上互连的、节点之间的通信传输。</strong></li><li><strong>物理层</strong>：<strong>负责0、1比特流与电压的高低、光的闪灭之间的互换。</strong></li></ul><h2 id="OSI参考模型通信处理举例"><a href="#OSI参考模型通信处理举例" class="headerlink" title="OSI参考模型通信处理举例"></a>OSI参考模型通信处理举例</h2><p>下面举例说明7层网络模型的功能，假设使用主机A的用户A要给使用主机B的用户B发送一封电子邮件。</p><h3 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h3><p>用户A在主机A上新建一封电子邮件，指定收件人为B，并输入邮件内容为“早上好”。</p><p><strong>从用户输入完所要发送到内容并点击“发送”按钮的那一刻开始，就进入了应用层协议的处理，该协议会在所要传送数据的前端附加一个首部（标签）信息。</strong>如果主机B上收件人的邮箱空间已满无法接收新的邮件，则会返回一个错误给发送方。<strong>对这类异常的处理也属于应用层要解决的问题。</strong></p><h3 id="表示层"><a href="#表示层" class="headerlink" title="表示层"></a>表示层</h3><p>表示层的“表示”有“表现”、“演示”的意思，因此更关注数据的具体表现形式。此外，所使用的应用软件本身的不同也会导致数据的表现形式截然不同，例如有的字处理软件的文件只能由该字处理厂商所提供的特定版本的软件才来打开读取。</p><p><strong>利用应用层，将数据从“某个计算机特定的数据格式”转换为“网络通用的标准数据格式”后，再发送出去。接收端主机收到数据以后，将这些网络标准格式的数据恢复为“该计算机特定的数据格式”，然后再进行相应处理。</strong></p><h3 id="会话层"><a href="#会话层" class="headerlink" title="会话层"></a>会话层</h3><p><strong>决定采用何种连接方法是会话层的主要责任。会话层也会像应用层或表示层那样，在其收到的数据前端附加首部信息或标签信息后再转发给下一层。而这些首部或标签中记录着数据传送顺序的信息。</strong></p><p><strong>会话层只对何时建立连接、何时发送数据等问题进行管理，并不具有实际传输数据的功能。</strong></p><h3 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h3><p>主机A确保与主机B之间的通信并准备发送数据。这一过程叫“建立连接”。有了这个通信连接就可以使主机A发送的电子邮件到达主机B中，并由主机B的邮件处理程序获取最终数据。此外当通信传输结束后，有必要将连接断开。</p><p>如上，<strong>进行建立连接或断开连接的处理，在两个主机之间创建逻辑上的通信连接即是传输层的主要作用。此处请注意，会话层负责决定建立连接和断开连接的时机，而传输层进行实际的连接和断开处理。</strong></p><p><strong>此外，传输层为确保所传输的数据到达目标地址，会在通信两端的计算机之间进行确认，如果数据没有到达，它会负责重发。</strong>例如，主机A将“早上好”这一数据发送给主机B，期间可能会因为某些原因导致数据被破坏，或由于发生某种网络异常致使只有一部分数据到达目标地址。假设主机B只收到了“早上”这一部分数据，那么会在它收到数据后将自己没有收到“早上”之后那部分数据的事实告知主机A，主机A得知这个情况后就会将后面的“好”重发给主机B，并再次确认对端是否收到。</p><h3 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h3><p><strong>网络层的作用是在网络与网络相互连接的环境中，将数据从发送端主机发送到接收端主机，两端主机之间虽有众多数据链路，但能够将数据从主机A送到主机B也是网络层的功劳。</strong></p><p>在实际发送数据时，目的地址至关重要，这个地址是进行通信的网络中唯一指定的序号。</p><h3 id="数据链路层、物理层"><a href="#数据链路层、物理层" class="headerlink" title="数据链路层、物理层"></a>数据链路层、物理层</h3><p>通信传输实际上是通过物理的传输介质实现的。<strong>数据链路层的作用就是在这些通过传输介质互连的设备之间进行数据处理。</strong></p><p><strong>物理层中，将数据的0、1转换为电压和脉冲光传输给物理的传输介质，</strong>而相互直连的设备之间使用地址实现传输，这种地址被称为MAC地址，也可称为物理地址或硬件地址。<strong>采用MAC地址，目的是为了识别连接到同一传输介质上的设备。</strong>因此，在这一层中将包含MAC地址信息的首部附加到从网络层转发过来的数据上，将其发送给网络。</p><h1 id="传输方式的分类"><a href="#传输方式的分类" class="headerlink" title="传输方式的分类"></a>传输方式的分类</h1><p>网络与通信中可以根据其数据发送方法进行多种分类，分类方法也有很多，下面介绍几种。</p><h2 id="面向有连接型与面向无连接型"><a href="#面向有连接型与面向无连接型" class="headerlink" title="面向有连接型与面向无连接型"></a>面向有连接型与面向无连接型</h2><p>通过网络发送数据，大致可以分为面向有连接与面向无连接两种类型。面向有连接型包括TCP、ATM、帧中继等协议；面向无连接型包括UDP、IP、以太网等协议。</p><ul><li><strong>面向有连接型</strong>：面向有连接型中，在发送数据之前，需要在收发主机之间连接一条通信线路；在通信传输结束之后，专门断开连接。</li><li><strong>面向无连接型</strong>：面向无连接型则不要求建立和断开连接。发送端可于任何时候自由发送数据，反之接收端也永远不知道自己会在何时从哪里收到数据。因此在面向无连接的情况下，接收端需要时常确认是否收到了数据。<strong>面向无连接型采用分组交换的情况要多一些。</strong></li></ul><h2 id="电路交换与分组交换"><a href="#电路交换与分组交换" class="headerlink" title="电路交换与分组交换"></a>电路交换与分组交换</h2><p>在电路交换中，交换机主要负责数据的中转处理。计算机首先被连接到交换机上，而交换机与交换机之间则由众多通信线路再继续连接。因此计算机之间再发送数据时，需要通过交换机与目标主机建立通信电路，我们将连接电路称为建立连接。建立好连接之后，用户就可以一直使用这条电路，知道该链接被断开为止。</p><p>如果某条电路只是用来连接两台计算机的通信线路，就意味着只需要在这两台计算机之间实现通信，因此这两台计算机是可以独占线路进行数据传输的。但是，如果一条电路上连接了多台计算机，而这些计算机之间需要相互传递数据，就会出现新的问题。鉴于一台计算机在收发信息时会独占整个电路，其他计算机只能等待这台计算机处理结束以后才有机会使用这条电路发送数据，并且在此过程中，谁也无法预测某一台计算机的数据传输从何开始又在何时结束。<strong>如果并发用户数超过交换机之间的通信线路数，就意味着通信根本无法实现。</strong></p><p>在分组交换中，由分组交换机（路由器）连接通信线路。分组交换的大致处理过程是：<strong>发送端计算机将数据分组发送给路由器，路由器收到这些分组数据以后，缓存到自己的缓冲区，然后再转发给目标计算机。</strong>因此分组交换也有另一个名称：蓄积交换。<strong>路由器收到数据以后会按照顺序缓存到相应的队列中，再以先进先出的顺序将它们逐一发送出去。</strong></p><p>在分组交换中，计算机与路由器之间以及路由器与路由器之间只有一条通信线路，因此这条线路其实是一条共享线路。在电路交换中，计算机之间的传输速度不变。<strong>然而在分组交换中，通信线路的速度可能会有所不同，根据网络拥堵的情况，数据达到目标地址的时间有长有短。另外，路由器的缓存饱和或溢出时，甚至可能会发生分组数据丢失、无法发送到对端的情况。</strong></p><h2 id="根据接收端数量分类"><a href="#根据接收端数量分类" class="headerlink" title="根据接收端数量分类"></a>根据接收端数量分类</h2><ul><li><strong>单播</strong>：就是一对一通信。</li><li><strong>广播</strong>：它指的是将消息从一台主机发送给与之相连的所有其他主机。广播通信的一个典型例子就是电视播放。</li><li><strong>多播</strong>：多播与广播类似，不同之处子啊与多播要限定某一组主机作为接收端。多播通信最典型的例子就是电视会议。</li><li><strong>任播</strong>：任播是指在特定的多台主机中选出一台作为接收端的一种通信方式。</li></ul><h1 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h1><p>通信传输中，发送端和接收端可以被视为通信主体，他们都能由一个所谓的“地址”的信息加以标识出来。当人们使用电话时，电话号码就相当于“地址”。当地址总数并不是很多的情况下，有了唯一地址就可以定位相互通信的主体。然而当地址的总数越来越多的时候，如何高效的从中找出通信的目标地址将成为一个重要的问题，为此人们发现<strong>地址除了具有唯一性还需要具有层次性。</strong></p><p>MAC地址和IP地址在标识一个通信主体时虽然都具有唯一性，但是它们当中只有IP地址具有层次性。MAC地址由设备的制造厂商针对没块网卡进行分别指定；<strong>IP地址由网络号和主机号两部分组成，即使通信主体的IP地址不同，若主机号不同，网络号相同，说明它们处于同一个网段。</strong></p><p>网络传输中，每个节点会根据分组数据的地址信息，来判断报文应该由哪些网卡发出去。为此，各个地址会参考一个发出接口列表。在这一点上MAC寻址与IP寻址一样。只不过<strong>MAC寻址所参考的这张表叫做地址转发表；而IP寻址中所参考的叫做路由控制表。</strong><img src="/posts/13182/TIM%E6%88%AA%E5%9B%BE20191023200532.png" alt></p><ol><li>主机A先查看自己的路由控制表，在根据此表将发往主机B的数据先发给路由器1。</li><li>接收到该数据的交换机1则根据自己的地址转发表将数据转发给路由器1。</li><li>接收到该数据的路由器1根据自己的路由控制表将数据转发给路由器3。</li><li>接受到该数据的路由器3则根据自己的路由转发表将数据发给交换机3。</li><li>接受到该数据的交换机3再根据自己的地址转发表将数据发给主机B。</li></ol><h1 id="网络构成的要素"><a href="#网络构成的要素" class="headerlink" title="网络构成的要素"></a>网络构成的要素</h1><p>搭建一套网络环境要涉及各种各样的电缆和网络设备，在此仅介绍连接计算机与计算机的硬件设备。<img src="/posts/13182/TIM%E6%88%AA%E5%9B%BE20191023201644.png" alt></p><table><thead><tr><th>设备</th><th>应用</th></tr></thead><tbody><tr><td>网卡</td><td>使计算机连网的设备（Network Interface）</td></tr><tr><td>中继器</td><td>从物理层上延长网络的设备</td></tr><tr><td>网桥/2层交换机</td><td>从数据链路层上延长网络的设备</td></tr><tr><td>路由器/3层交换机</td><td>通过网络层转发分组数据的设备</td></tr><tr><td>4-7层交换机</td><td>处理传输层以上各层网络传输的设备</td></tr><tr><td>网关</td><td>转换协议的设备</td></tr></tbody></table><h2 id="网卡"><a href="#网卡" class="headerlink" title="网卡"></a>网卡</h2><p>任何一台计算机连接网络时，必须要使用网卡（全称为网络接口卡），有时也被称为网络适配器、网络接口卡、LAN卡。</p><h2 id="中继器"><a href="#中继器" class="headerlink" title="中继器"></a>中继器</h2><p>中继器是OSI模型的第一层——物理层面上延长网络的设备。<strong>由电缆传输过来的电信号或光信号经由中继器的波形调整和放大再传给另一个电缆。</strong><img src="/posts/13182/TIM%E6%88%AA%E5%9B%BE20191023202111.png" alt></p><ul><li>中继器是对减弱的信号进行放大和发送的设备。</li><li>中继器通过物理层的连接延长网络。</li><li>即使在数据链路层出现某些错误，中继器仍然转发数据。</li><li>中继器无法改变传输速度。</li></ul><p>一般情况下，中继器的两端连接的是相同的通信媒介，但有的中继器也可以完成不同媒介之间的转接工作，例如可以在同轴电缆与光轴电缆之间调整信号。然而，在这种情况下，<strong>中继器也只是单纯的负责信号在0和1比特流之间的替换，并不负责判断数据是否有错误，也不能在传输速度不同的媒介之间转发。</strong></p><p>通过中继器而进行的网络延长，其距离也并非可以无限扩大，例如一个10Mbps的以太网最多可以用4个中继器分段连接，而一个100Mbps的以太网则最多只能连两个中继器。</p><h2 id="网桥-2层交换机"><a href="#网桥-2层交换机" class="headerlink" title="网桥/2层交换机"></a>网桥/2层交换机</h2><p><img src="/posts/13182/TIM%E6%88%AA%E5%9B%BE20191023202809.png" alt></p><ul><li>网桥根据数据帧的内容转发数据给相邻的其他网络</li><li>网桥没有连接网段个数的限制</li><li>网桥基本上只用于连接相同类型的网络，但是有时也可以连接传输速率不同的网络</li></ul><p>网桥是OSI模型的第2层——数据链路层面上连接两个网络的设备，<strong>它能识别数据链路中的数据帧，并将这些数据帧临时存储于内存，再重新生成信号作为一个全新的帧转发给相连的另一个网段。由于能够存储这些数据帧，网桥能够连接传输速率完全不同的数据链路，并且不限制连接网段的个数。</strong></p><p><strong>数据链路的数据帧中有一个数据为叫做FCS，用以校验数据是否正确送达目的地。网桥通过检查这个域中的值，将那些损坏的数据丢弃，从而避免发送给其他的网段，此外网桥还能通过地址自学机制和过滤功能控制网络流量。</strong></p><p>有些网桥能够判断是否将数据报文转发给相邻的网段，这种网桥被称为自学式网桥，这类网桥会记住曾经自己转发的所有数据帧的MAC地址，并保存到自己的内存中，由此可以判断哪个网段中包含持有哪类MAC地址的设备。</p><h2 id="路由器-3层交换机"><a href="#路由器-3层交换机" class="headerlink" title="路由器/3层交换机"></a>路由器/3层交换机</h2><ul><li>路由器是连接网络与网络的设备</li><li>可以将分组报文发送给另一个目标路由器地址</li><li>基本上可以连接任意两个数据链路</li></ul><p>路由器是在OSI模型的第3层——<strong>网络层面上连接两个网络，并对分组报文进行转发到设备。网桥是根据物理地址（MAC地址）进行处理，而路由器/3层交换机则是根据IP地址进行处理的。</strong></p><p>路由器可以连接不同的数据链路，例如两个以太网，或者一个以太网与一个FDDI。<strong>路由器还有分担网络负荷的作用，甚至有些路由器具备一定的网络安全功能。</strong></p><h2 id="4-7层交换机"><a href="#4-7层交换机" class="headerlink" title="4-7层交换机"></a>4-7层交换机</h2><p><strong>4-7层交换机负责处理OSI模型中从传输层至应用层的数据。</strong>如果用TCP/IP分层模型来表述，4-7层交换机就是以TCP等协议的传输层及其上面的应用层为基础，分析收发数据，并对其进行特定的处理。</p><h2 id="网关"><a href="#网关" class="headerlink" title="网关"></a>网关</h2><p><img src="/posts/13182/TIM%E6%88%AA%E5%9B%BE20191023205136.png" alt></p><ul><li>网关负责协议的转换与数据的转发</li><li>在同一种类型的协议之间转发数据叫做应用网关</li></ul><p><strong>网关是OSI参考模型中负责将传输层到应用层的数据进行转换和转发的设备。它与4-7层交换机都是处理传输层及以上的数据，但是网关不仅转发数据还负责对数据进行转换，它通常会使用一个表示层或应用层网关，在两个不能进行直接通信的协议之间进行翻译，最终实现两者之间的通信。</strong></p><p>为了控制网络流量以及出于安全的考虑，有时会使用代理服务器，这种代理服务器也是网关的一种。</p>]]></content>
    
    <summary type="html">
    
      介绍计算机网络的基本概念，包括OSI参考模型、网络概念的本质、网络构建的设备等。
    
    </summary>
    
      <category term="计算机网络" scheme="http://yoursite.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
  </entry>
  
  <entry>
    <title>面向切面的Spring——AOP</title>
    <link href="http://yoursite.com/posts/5626/"/>
    <id>http://yoursite.com/posts/5626/</id>
    <published>2019-10-19T13:57:41.000Z</published>
    <updated>2019-10-20T09:31:21.020Z</updated>
    
    <content type="html"><![CDATA[<h1 id="什么是面向切面编程"><a href="#什么是面向切面编程" class="headerlink" title="什么是面向切面编程"></a>什么是面向切面编程</h1><p>切面能够帮助我们模块化横切关注点，横切关注点可以被描述为影响应用多处的功能，下图直观的呈现了横切关注点的概念。<br><img src="/posts/5626/TIM%E6%88%AA%E5%9B%BE20191019222640.png" alt><br>每个模块的核心功能都是为特定业务领域提供服务，但是如果要做到通用功能的话，最常见的面向对象技术十集成或委托，但是如果在整个应用程序中都使用相同的基类，继承往往会导致一个脆弱的对象体系；而使用委托可能需要对象进行复杂的调用。</p><p>切面提供了另一种可选方案，而且在很多场景下更清晰简洁。在使用面向切面编程时，我们仍然在一个地方定义通用功能，但是可以通过声明的方式定义这个功能要以何种方式在何处应用，<strong>而无需修改受影响的类。</strong>横切关注点可以被模块化为特殊的类，这些类被称为<strong>切面（aspect）</strong>。<strong>这样做的好处就是每个关注点都集中于一个地方，而不是分散到多处代码中，其次服务模块更加简洁，只需要关注核心代码就行了。</strong></p><h2 id="定义AOP术语"><a href="#定义AOP术语" class="headerlink" title="定义AOP术语"></a>定义AOP术语</h2><ul><li><strong>通知（Advice）</strong>:通知定义了切面是什么以及何时使用。除了描述切面要完成的工作，通知还解决了何时执行这个工作的问题。因此可以说，切面的工作被称为通知。Spring切面可以应用5种类型的通知：<ul><li><strong>前置通知（Before）</strong>：在目标方法被调用之前调用通知功能。</li><li><strong>后置通知（After）</strong>：在目标方法完成之后调用通知，此时不会关心方法的输出。</li><li><strong>返回通知（After-returning）</strong>：在目标方法成功执行之后调用通知。</li><li><strong>异常通知（After-throwing）</strong>：在目标方阿飞抛出异常后调用通知。</li><li><strong>环绕通知（Around）</strong>：通知包裹了被通知的方法，在被通知的方法调用之前和调用之后执行自定义的行为。</li></ul></li><li><strong>连接点（Join point）</strong>：我们的应用可能有数以千计的时机应用通知，这些时机被称为连接点，连接点是在应用程序中能够插入切面的一个点。</li><li><strong>切点（Pointcut）</strong>：如果说通知定义了切面的“什么”和“何时”的话，那么切点就定义了“何处”，切点的定义会匹配通知所要织入的一个或多个连接点。</li><li><strong>切面（Aspect）</strong>：切面是通知和切点的结合。通知和切点共同定义了切面的全部内容：它是什么，在何时和何处完成其功能。</li><li><strong>引入（Introduction）</strong>：引入允许我们向现有的类添加新方法或属性。</li><li><strong>织入（Weaving）</strong>：织入是把切面应用到目标对象并创建新的代理对象的过程。切面在指定的连接点被织入到目标对象中。在目标对象的生命周期里有多个点可以进行织入：<ul><li><strong>编译器</strong>：切面在目标类编译时被织入，AspectJ的织入编译器就是以这种方式织入切面的。</li><li><strong>类加载期</strong>：切面在目标类加载到JVM时被织入。</li><li><strong>运行期</strong>：切面在应用运行的某个时刻被织入。Spring AOP就是以这种方式织入切面的。</li></ul></li></ul><h1 id="通过切点来选择连接点"><a href="#通过切点来选择连接点" class="headerlink" title="通过切点来选择连接点"></a>通过切点来选择连接点</h1><p>切点用于准确定位应该在什么地方应用切面的通知。通知和切点时切面的最基本元素。在Spring AOP中，要使用AspectJ的切点表达式语言来定义切点。下面是Spring AOP所支持的AspectJ切点指示器：<img src="/posts/5626/TIM%E6%88%AA%E5%9B%BE20191020152540.png" alt><br>在Spring中尝试使用AspectJ其它指示器时，将会抛出IllegalArgumentException异常。</p><h2 id="编写切点"><a href="#编写切点" class="headerlink" title="编写切点"></a>编写切点</h2><p>为阐述Spring中的切面，我们需要有个主题来定义切面的切点，为此我们定义一个Performance接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> concert;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Performance</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">perform</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Performance可以代表任何类型的现场表演，假设我们想编写Performance的perform()方法触发的通知，下面展示了一个切点表达式，这个表达式能够设置当perform()方法执行时触发通知的调用：<img src="/posts/5626/TIM%E6%88%AA%E5%9B%BE20191020153047.png" alt><strong>我们使用execution()指示器选择Preformance的perform（）方法。方法表达式以“*”号开始，表明我们不关心方法返回值的类型。然后我们指定了全限定类名和方法名。对于方法参数列表，我们使用两个点号（..）表明切点要选择任意的perform（）方法，无论该方法的入参是什么。假设我们需要配置的切点仅匹配concert包，可以使用within()指示器来限制匹配。使用“&amp;&amp;”来表示与的关系，“||”和“!”也同理：</strong><img src="/posts/5626/TIM%E6%88%AA%E5%9B%BE20191020153621.png" alt></p><h2 id="在切点中选择bean"><a href="#在切点中选择bean" class="headerlink" title="在切点中选择bean"></a>在切点中选择bean</h2><p>Spring引入一个新的bean（）指示器，允许我们在切点表达式中使用bean的ID来标识bean。bean（）使用bean ID或bean名称作为参数来限制切点只匹配特定的bean：<img src="/posts/5626/TIM%E6%88%AA%E5%9B%BE20191020153925.png" alt>在这里我们希望在执行Performance的perform（）方法时应用通知，但限定bean的ID为woodstock。</p><p><img src="/posts/5626/TIM%E6%88%AA%E5%9B%BE20191020154023.png" alt>在此场景下，切面的通知会被编织到所有ID不为woodstock的bean中。</p><h1 id="使用注解创建切面"><a href="#使用注解创建切面" class="headerlink" title="使用注解创建切面"></a>使用注解创建切面</h1><p>我们已经定义了Performance接口，他们是切面中切点的目标对象，现在使用AspectJ注解来定义切面。</p><h2 id="定义切面"><a href="#定义切面" class="headerlink" title="定义切面"></a>定义切面</h2><p>从演出的角度来看，观众是非常重要的，因此，将观众定义为一个切面，并将其应用到演出上：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> concert;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.AfterReturning;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.AfterThrowing;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.Aspect;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.Before;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Audience</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Before</span>(<span class="string">"execution(* concert.Performance.perform(..))"</span>)        <span class="comment">// 表演之前</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">silenceCellPhones</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Silencing cell phones"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Before</span>(<span class="string">"execution(* concert.Performance.perform(..))"</span>)        <span class="comment">// 表演之前</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">takeSeats</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Taking seats"</span>);</span><br><span class="line">    &#125;        </span><br><span class="line">    <span class="meta">@AfterReturning</span>(<span class="string">"execution(* concert.Performance.perform(..))"</span>)        <span class="comment">// 表演之后</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">applause</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"CLAP CLAP CLAP!!!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@AfterThrowing</span>(<span class="string">"execution(* concert.Performance.perform(..))"</span>)        <span class="comment">// 表演失败之后</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">demandRefound</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Demanding a refund"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Audience类使用@Aspect注解标注，该注解表明Audience不仅仅是一个POJO，还是一个切面。</strong></p><p>Audience四个方法定义了一个观众在观看演出时可能会做的事情：手机调至静音、就坐、喝彩鼓掌以及退款。可以看到这些方法都使用通知注解来表明它们应该在什么时候调用，注解都有如下：<img src="/posts/5626/TIM%E6%88%AA%E5%9B%BE20191020160119.png" alt><br>你可能注意到所有的这些注解都给定了一个切点表达式作为它的值，同时这四个方法的切点表达式都是相同的。所以我们可以改进一下，如果我们只定义这个切点一次，然后每次需要的时候引用它，那么这会是一个很好的方案。<strong>@Poincut注解能够在一个@AspectJ切面内定义可重用的切点</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> concert;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.AfterReturning;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.AfterThrowing;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.Aspect;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.Before;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.Pointcut;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Audience</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Pointcut</span>(<span class="string">"execution(* concert.Performance.perform(..))"</span>)        <span class="comment">//定义命名的切点</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">performance</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Before</span>(<span class="string">"performance()"</span>) </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">silenceCellPhones</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Silencing cell phones"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Before</span>(<span class="string">"performance()"</span>)        <span class="comment">// 表演之前</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">takeSeats</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Taking seats"</span>);</span><br><span class="line">    &#125;        </span><br><span class="line">    <span class="meta">@AfterReturning</span>(<span class="string">"performance()"</span>)        <span class="comment">// 表演之后</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">applause</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"CLAP CLAP CLAP!!!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@AfterThrowing</span>(<span class="string">"performance()"</span>)        <span class="comment">// 表演失败之后</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">demandRefound</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Demanding a refund"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要注意的是，除了注解和没有操作的performance（）方法，Audience类依然是一个独立的POJO，只不过它通过注解表明会作为切面使用，像其他类一样，它可以装配为Spring中的bean：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span> </span><br><span class="line"><span class="function"><span class="keyword">public</span> Audience <span class="title">audience</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Audience();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是到此为止的话，@Audience只会是Spring容器中的一个bean，并不会被视为切面，需要将这些注解启用配置到配置文件中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> concert;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.ComponentScan;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.EnableAspectJAutoProxy;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 启动AspectJ自动代理</span></span><br><span class="line"><span class="meta">@Configuration</span>                </span><br><span class="line"><span class="meta">@EnableAspectJAutoProxy</span></span><br><span class="line"><span class="meta">@ComponentScan</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcertConfig</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Audience <span class="title">audience</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Audience();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然使用XML文件配置也是完全可以的：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">/ 在XML中，通过Spring的aop命名空间启用AspectJ自动代理</span><br><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:context</span>=<span class="string">"http://www.springframework.org/schema/context"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:aop</span>=<span class="string">"http://www.springframework.org/schema/aop"</span>        // 声明<span class="attr">Spring</span>的<span class="attr">aop</span>命名空间</span></span><br><span class="line"><span class="tag">    <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/aop</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/context</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/context/spring-context.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/beans/spring-beans.xsd"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span> = <span class="string">"concert"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:aspectj-autoproxy</span> /&gt;</span>                // 启动AspectJ自动代理</span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>= <span class="string">"concert.Audience"</span> /&gt;</span>        // 声明Audience bean</span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="创建环绕通知"><a href="#创建环绕通知" class="headerlink" title="创建环绕通知"></a>创建环绕通知</h2><p>环绕通知是最为强大的通知类型，为了介绍它，我们重写Audiences切面：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用环绕通知重新实现Audience切面</span></span><br><span class="line"><span class="keyword">package</span> concert;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.ProceedingJoinPoint;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.Around;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.Aspect;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.Pointcut;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Audience</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="meta">@Pointcut</span>(<span class="string">"execution(** concert.Performance.perform(..))"</span>)        <span class="comment">//定义命名的切点</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">performance</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Around</span>(<span class="string">"performance()"</span>) </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">watchPerformance</span><span class="params">(ProceedingJoinPoint jp)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"Silencing cell phones"</span>);</span><br><span class="line">            System.out.println(<span class="string">"Taking seats"</span>);</span><br><span class="line">            jp.proceed();</span><br><span class="line">            System.out.println(<span class="string">"CLAP CLAP CLAP!!!"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span>(Throwable e)&#123;</span><br><span class="line">            System.out.println(<span class="string">"Demanding a refund"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，这个通知所达到的效果与之前的前置通知和后置通知是一样的，到那时现在它们处于同一个方法中。关于这个新的通知方法，你首先注意到的可能是它接受ProceedingJoinPoint作为参数，这个对象是必须要有的，因为你要在通知中通过它来调用被通知的方法。<strong>需要注意的是，别忘记调用proceed()方法，如果不调用这个方法，那么你的通知实际上会阻塞对被通知方法的调用。</strong></p><h2 id="处理通知中的参数"><a href="#处理通知中的参数" class="headerlink" title="处理通知中的参数"></a>处理通知中的参数</h2><p>之前的例子中都是没有参数的，但是如果切面所通知的方法有参数怎么办呢？有这样一个例子，play()方法会玄幻播放所有磁道并调用playTreck()方法，假设你想记录每个磁道被播放的次数，我们创建TrackCounter类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用参数化的通知来记录磁道播放的次数</span></span><br><span class="line"><span class="keyword">package</span> soundsystem;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.Aspect;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.Before;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.Pointcut;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TrackCounter</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Map&lt;Integer, Integer&gt; TrackCounts = <span class="keyword">new</span> HashMap&lt;Integer, Integer&gt;();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 通知playTrack()方法</span></span><br><span class="line">    <span class="meta">@Pointcut</span>(</span><br><span class="line">        <span class="string">"execution(* soundsystem.CompactDisc.playTrack(int))"</span> +</span><br><span class="line">        <span class="string">"&amp;&amp; args(trackNumber)"</span> )</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">trackPlayed</span><span class="params">(<span class="keyword">int</span> trackNumber)</span></span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Before</span>(<span class="string">"trackPlayed(trackNumber)"</span>)            <span class="comment">// 在播放前，为该磁道计数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">countTrack</span><span class="params">(<span class="keyword">int</span> trackNumber)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> currentCount = getPlayCount(trackNumber);</span><br><span class="line">        trackCounts.put(trackNumber, currentCount + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getPlayCount</span><span class="params">(<span class="keyword">int</span> trackNumber)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> trackCounts.containsKey(trackNumber) ? trackCounts.get(trackNumber) : <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>与之前不同的是，切点表达式中的args(trackNumber)限定符，它表明传递给playTrack方法的int类型参数也会传递到通知中去，参数的名称trackNumber也与切点方法签名中的参数相匹配。</strong><br><img src="/posts/5626/TIM%E6%88%AA%E5%9B%BE20191020162959.png" alt>现在我们可以在Spring配置中将BlankDisc和TrackCounter定义为bean，并启用AspectJ自动代理：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">/ 配置TrackCount记录每个磁道播放的次数</span><br><span class="line"><span class="keyword">package</span> soundsystem;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.List;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.EnableAspectJAutoProxy;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableAspectJAutoProxy</span>                    <span class="comment">// 启用AspectJ自动代理</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TrackCounterConfig</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> CompactDisc <span class="title">sgtPeppers</span><span class="params">()</span>        <span class="comment">// CompactDisc bean</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        BlankDisc cd = <span class="keyword">new</span> BlankDisc();</span><br><span class="line">        cd.setTitle(<span class="string">"Sgt. Pepper's Lonely Hearts Club Band"</span>);</span><br><span class="line">        cd.setArtist(<span class="string">"The Beales"</span>);</span><br><span class="line">        List&lt;String&gt; tracks = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">        tracks.add(<span class="string">"Sgt. Pepper's Lonely Hearts Club Band"</span>);</span><br><span class="line">        tracks.add(<span class="string">"With a Little Help from My Friends"</span>);</span><br><span class="line">        tracks.add(<span class="string">"Lucy in the Sky with Diamonds"</span>);</span><br><span class="line">        tracks.add(<span class="string">"Getting Better"</span>);</span><br><span class="line">        tracks.add(<span class="string">"Fixing a Hole"</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// ...other tracks omitted for brevity...</span></span><br><span class="line">        cd.setTracks(tracks);</span><br><span class="line">        <span class="keyword">return</span> cd;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TrackCounter <span class="title">trackCounter</span><span class="params">()</span>        <span class="comment">// TrackCounter bean</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> TrackCounter();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="通过注解引入新功能"><a href="#通过注解引入新功能" class="headerlink" title="通过注解引入新功能"></a>通过注解引入新功能</h2><p>静态语言的Java并不能像动态语言那样有开放类的理念，但是我们依旧可以使用切面为Spring bean添加新方法。在Spring中，切面只是实现了它们所包装bean相同接口的代理，如果除了实现这些接口，代理也能暴露新接口的话，会怎样呢？<img src="/posts/5626/TIM%E6%88%AA%E5%9B%BE20191020163646.png" alt>我们想办法使用AOP为示例中的所有Performance实现引入下面的Encoreable接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> concert;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Encoreable</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">performEncore</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为此我们需要创建一个新的切面：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> concert;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.Aspect;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.DeclareParents;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EncoreableIntroducer</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="meta">@DeclareParents</span>(value = <span class="string">"concert.Performance+"</span>, defaultImpl = DefaultEncoreable.class)</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Encoreable encoreable;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到EncoreableIntroducer是一个切面，但是他与我们之前的切面有所不同，使用了@DeclareParents注解，该注解由三部分组成：</p><ul><li><strong>value</strong>：<strong>该属性制定了哪种类型的bean要引入该接口</strong>，在本例中即Performance类型<strong>。标记后面的加号表示是Performance的所有子类型，而不是Performance本身。</strong></li><li><strong>defaultImpl</strong>：该属性指定了为引入功能提供实现的类。</li><li><strong>@DeclarationParents</strong>：该注解所标注的静态属性指明了要引入了接口。</li></ul><p>和其他切面一样，我们需要在Spring应用中将EncoreableIntroducer声明为一个bean：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span> = <span class="string">"concert.EncoreableIntroducer"</span> /&gt;</span></span><br></pre></td></tr></table></figure><h1 id="在XML中声明切面"><a href="#在XML中声明切面" class="headerlink" title="在XML中声明切面"></a>在XML中声明切面</h1><p>除了使用注解的方式，还可以考虑使用XML文件配置的方式。在Spring的aop命名空间中，提供了多个元素用来在XML中声明切面，如下表：<img src="/posts/5626/TIM%E6%88%AA%E5%9B%BE20191020170912.png" alt>在使用XML文件配置方式之前，先把之前在Audience类中的注解全部移除掉。</p><h2 id="声明前置和后置通知"><a href="#声明前置和后置通知" class="headerlink" title="声明前置和后置通知"></a>声明前置和后置通知</h2><p>接着我们在XML文件中配置将没有注解的Audience类转换为切面：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"> <span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">aop:aspect</span> <span class="attr">ref</span>=<span class="string">"audience"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">expression</span>=<span class="string">"execution(* XMLconcert.Performance.perform(..))"</span> <span class="attr">id</span>=<span class="string">"performance"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">aop:before</span> <span class="attr">pointcut-ref</span>=<span class="string">"performance"</span> <span class="attr">method</span>=<span class="string">"silenceCellPhones"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">aop:before</span> <span class="attr">pointcut-ref</span>=<span class="string">"performance"</span> <span class="attr">method</span>=<span class="string">"takeSeats"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">aop:after-returning</span> <span class="attr">pointcut-ref</span>=<span class="string">"performance"</span> <span class="attr">method</span>=<span class="string">"applause"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">aop:after-throwing</span> <span class="attr">pointcut-ref</span>=<span class="string">"performance"</span> <span class="attr">method</span>=<span class="string">"demandRefund"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">aop:aspect</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="声明环绕通知"><a href="#声明环绕通知" class="headerlink" title="声明环绕通知"></a>声明环绕通知</h2><p>将之前的watchPerformance()方法及其类中的注解都移除：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> concert;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.ProceedingJoinPoint;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Audience</span> </span>&#123;</span><br><span class="line">   </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">watchPerformance</span><span class="params">(ProceedingJoinPoint jp)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"手机静音"</span>);</span><br><span class="line">            System.out.println(<span class="string">"得到座位"</span>);</span><br><span class="line">            jp.proceed();</span><br><span class="line">            System.out.println(<span class="string">"鼓掌!!!"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">            System.out.println(<span class="string">"这演的啥啊！退票"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后在XML文件中配置：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">aop:aspect</span> <span class="attr">ref</span>=<span class="string">"audience"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">id</span>=<span class="string">"performance"</span> <span class="attr">expression</span>=<span class="string">"execution(* concert.Performance.perform(..))"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">aop:round</span> <span class="attr">pointcut-ref</span>=<span class="string">"preformance"</span> <span class="attr">method</span>=<span class="string">"watchPerformance"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">aop:aspect</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="为通知传递参数"><a href="#为通知传递参数" class="headerlink" title="为通知传递参数"></a>为通知传递参数</h2><p>将TrackCounter类中的注解都移除掉，然后在XML文件中配置如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">aop:aspect</span> <span class="attr">ref</span>=<span class="string">"trackCounter"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">id</span>=<span class="string">"trackPlayed"</span> <span class="attr">expression</span>=<span class="string">" execution(* com.springinaction.disc.CompactDisc.playTrack(int)) and args(trackNumber)"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">aop:before</span> <span class="attr">pointcut-ref</span>=<span class="string">"trackPlayed"</span> <span class="attr">method</span>=<span class="string">"countTrack"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">aop:aspect</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="通过切面引入新的功能"><a href="#通过切面引入新的功能" class="headerlink" title="通过切面引入新的功能"></a>通过切面引入新的功能</h2><p>依旧将原Encoreable的注解移除掉，然后配置为：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">aop:aspect</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">aop:declare-parents</span> <span class="attr">types-matching</span>=<span class="string">"com.springinaction.perf.Performance+"</span></span></span><br><span class="line"><span class="tag"><span class="attr">implement-interface</span>=<span class="string">"com.springinaction.perf.Encoreable"</span></span></span><br><span class="line"><span class="tag">                            <span class="attr">default-impl</span>=<span class="string">"com.springinaction.perf.DefaultEncoreable"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">aop:aspect</span>&gt;</span></span><br></pre></td></tr></table></figure><p>我们还可以使用delegate-ref属性来标识：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">aop:aspect</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">aop:declare-parents</span> <span class="attr">types-matching</span>=<span class="string">"com.springinaction.perf.Performance+"</span></span></span><br><span class="line"><span class="tag"><span class="attr">implement-interface</span>=<span class="string">"com.springinaction.perf.Encoreable"</span></span></span><br><span class="line"><span class="tag"><span class="attr">delegate-ref</span>=<span class="string">"defaultEncoreable"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">aop:aspect</span>&gt;</span></span><br></pre></td></tr></table></figure><p>delegate-ref属性引入了一个Spring的bean作为引入的委托：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"defaultEncoreable"</span> <span class="attr">class</span>=<span class="string">"com.springinaction.perf.DefaultEncoreable"</span> /&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      日志、安全和事务管理的确都很重要，但他们是否为应用程序对象主动参与的行为？AOP可以实现横切关注点与它们所影响的对象之间的解耦。
    
    </summary>
    
      <category term="Spring" scheme="http://yoursite.com/categories/Spring/"/>
    
    
  </entry>
  
  <entry>
    <title>@Autowired和@Resource</title>
    <link href="http://yoursite.com/posts/13512/"/>
    <id>http://yoursite.com/posts/13512/</id>
    <published>2019-10-19T06:32:32.000Z</published>
    <updated>2019-10-19T12:12:59.077Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Spring的-Autowired"><a href="#Spring的-Autowired" class="headerlink" title="Spring的@Autowired"></a>Spring的@Autowired</h1><h2 id="注解版的自动绑定（-Autowired）"><a href="#注解版的自动绑定（-Autowired）" class="headerlink" title="注解版的自动绑定（@Autowired）"></a>注解版的自动绑定（@Autowired）</h2><p>在之前的学习中，为了减少配置量，我们可以采用Spring的IoC容器提供的自动绑定功能：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">default-autowire</span>=<span class="string">"byType"</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"newsProvider"</span>    <span class="attr">class</span>=<span class="string">"..FXNewsProvider"</span> <span class="attr">autowire</span>=<span class="string">"byType"</span>/&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"djNewsListener"</span>  <span class="attr">class</span>=<span class="string">"..DowJonesNewsListener"</span>/&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"djNewsPersister"</span> <span class="attr">class</span>=<span class="string">"..DowJonesNewsPersister"</span>/&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>可以通过default-autowired或者autowired来指定每个bean定义的自动绑定方式，Spring2.5之后提供了一个更加方便的方式：@Autowired注解，它可以让容器知道需要为当前类注入哪些依赖。</strong>例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FXNewsProvider</span>  </span>&#123;  </span><br><span class="line"><span class="keyword">private</span> IFXNewsListener  newsListener; </span><br><span class="line"><span class="keyword">private</span> IFXNewsPersister newPersistener; </span><br><span class="line"></span><br><span class="line"><span class="meta">@Autowired</span>  </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">FXNewsProvider</span><span class="params">(IFXNewsListener newsListner,IFXNewsPersister newsPersister)</span>  </span>&#123;   </span><br><span class="line"><span class="keyword">this</span>.newsListener = newsListner;   </span><br><span class="line"><span class="keyword">this</span>.newPersistener = newsPersister;  </span><br><span class="line">&#125;  </span><br><span class="line">... </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>与原有的byType类型的自动绑定方式类似，@Autowired也是按照类型匹配进行依赖注入的,当按照类型找不到时，则会使用标注的属性名称，按byName的方式查找。</strong>但是@Autowired也更加灵活更加强大，它可以标注于类定义的多个位置。包括如下几个：</p><ul><li><strong>域或者说属性（Property）</strong>：<strong>不管它们声明的访问限制符是private还是public等等，只要标注@Autowired了，它们所需要的依赖注入需求就都能够被满足。</strong></li><li><strong>构造方法定义</strong>：<strong>标注于类的构造方法之上的@Autowired，相当于抢夺了原有自动绑定功能中“constructor”方式的权力，它将更具构造方法参数类型，来决定将什么样的依赖对象注入给当前对象，</strong>就如上面的代码演示一样。</li><li><strong>方法定义</strong>：<strong>@Autowired不光可以标注于传统的setter方法之上，而且还可以标注于任意名称的方法定义之上，只要该方法定义了需要被注入的参数。</strong></li></ul><p>接下来只需要在容器的配置文件中定义bean就行了：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span>&gt;</span>   </span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"newsProvider"</span>    <span class="attr">class</span>=<span class="string">"..FXNewsProvider"</span>/&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"djNewsListener"</span>  <span class="attr">class</span>=<span class="string">"..DowJonesNewsListener"</span>/&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"djNewsPersister"</span> <span class="attr">class</span>=<span class="string">"..DowJonesNewsPersister"</span>/&gt;</span> </span><br><span class="line"><span class="tag">&lt; /<span class="attr">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>为了给容器中定义的每个bean对应的实例注入依赖，可以遍历它们，然后通过反射，检查每个bean定义对应的类上各种可能位置上的@Autowired。如果存在的话，就可以从当前容器管理的对象中获取符合条件的对象，设置给@Autowired所标注的对象。</strong></p><p>那么如果仅仅只是一个注解，在Spring容器中并不能起作用，联想到之前的BeanPostProcessor自定义实现，让这个BeanPostProcessor在实例化bean定义的过程中，来检查当前对象是否有@Autowired标注的依赖需要注入，AutowiredAnnotationBeanPostProcessor就是Spring提供用于这一目的的BeanPostProcesser实现，所以只需要在配置文件中注册一下它就可以了：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor"</span>/&gt;</span>   </span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"newsProvider"</span>    <span class="attr">class</span>=<span class="string">"..FXNewsProvider"</span>/&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"djNewsListener"</span>  <span class="attr">class</span>=<span class="string">"..DowJonesNewsListener"</span>/&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"djNewsPersister"</span> <span class="attr">class</span>=<span class="string">"..DowJonesNewsPersister"</span>/&gt;</span> </span><br><span class="line"><span class="tag">&lt; /<span class="attr">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="Qualifier的陪伴"><a href="#Qualifier的陪伴" class="headerlink" title="@Qualifier的陪伴"></a>@Qualifier的陪伴</h2><p>@Autowired是按照类型进行匹配，如果当前@Autowired标注的依赖在容器中只能找到一个实例与之对应的话还好，可以是若能够同时找到多个同一类型的实例对象又该怎么办？这时候就可以使用@Qualifier对依赖注入的条件做进一步限定。</p><p><strong>@Qualifier实际上是byName自动绑定的注解版，既然IoC容器无法自己从多个同一类型的实例中选取我们真正想要的那个，那么我们就可以使用@Qualifier直接点名需要哪个。</strong>假设FXNewsProvider使用的IFNewsListener有两个实现类DowJonesNewsListener和ReutersNewsListener：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor"</span>/&gt;</span>    </span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"newsProvider"</span>    <span class="attr">class</span>=<span class="string">"..FXNewsProvider"</span>/&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"djNewsListener"</span>  <span class="attr">class</span>=<span class="string">"..DowJonesNewsListener"</span>/&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"reutersNewsListner"</span> <span class="attr">class</span>=<span class="string">"..ReutersNewsListener"</span>/&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"djNewsPersister"</span> <span class="attr">class</span>=<span class="string">"..DowJonesNewsPersister"</span>/&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><p>如果我们想让FXNewsProvider使用ReutersNewsListener，那么就可以使用@Qulifier指定选择：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FXNewsProvider</span>  </span>&#123;  </span><br><span class="line"><span class="meta">@Autowired</span>  </span><br><span class="line"><span class="meta">@Qualifier</span>(<span class="string">"reutersNewsListner"</span>)  </span><br><span class="line"><span class="keyword">private</span> IFXNewsListener  newsListener;  </span><br><span class="line"></span><br><span class="line"><span class="meta">@Autowired</span>  </span><br><span class="line"><span class="keyword">private</span> IFXNewsPersister newPersistener;  </span><br><span class="line"></span><br><span class="line">... </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="JavaEE的-Resource"><a href="#JavaEE的-Resource" class="headerlink" title="JavaEE的@Resource"></a>JavaEE的@Resource</h1><p>除了使用Spring提供的@Autowired和@Qulifier之外，还可以使用JavaEE提供的@Resource。<strong>@Resource与@Autowired不同，它遵循的是byName自动绑定的行为准则，也就是说，IoC容器将更具@Resource所指定的名称，到容器中查找beanName与之对应的实例，然后将查找到的对象实例注入给@Resource所标注的对象。</strong>如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FXNewsProvider</span>  </span>&#123;   </span><br><span class="line"><span class="meta">@Resource</span>(name=<span class="string">"djNewsListener"</span>)  </span><br><span class="line"><span class="keyword">private</span> IFXNewsListener  newsListener;  </span><br><span class="line"></span><br><span class="line"><span class="meta">@Resource</span>(name=<span class="string">"djNewsPersister"</span>) </span><br><span class="line"><span class="keyword">private</span> IFXNewsPersister newPersistener;  </span><br><span class="line">... </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>除了标注于属性之上外，还可以与@Autowired一样标注于方法或者构造方法之上，此处与@Autowired大致一样。</strong></p><h2 id="PostConstruct和-PreDestroy"><a href="#PostConstruct和-PreDestroy" class="headerlink" title="@PostConstruct和@PreDestroy"></a>@PostConstruct和@PreDestroy</h2><p><strong>确切的说，@PostConstruct和@PreDestroy不是服务于依赖注入的，他们主要用于标注对象生命周期管理相关方法，这与Spring的InitializingBean和DisposableBean接口，以及配置项中的init-method和destroy-method起到类似作用。</strong></p><p>如果想某个方法在对象实例化之后被调用，以做某些准备工作，或者想在对象销毁之前调用某个方法做清理工作，可以像如下这样：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LifecycleEnabledClass</span> </span>&#123; </span><br><span class="line"><span class="meta">@PostConstruct</span>  </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUp</span><span class="params">()</span>  </span>&#123;   </span><br><span class="line">...  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="meta">@PreDestroy</span>  </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span>  </span>&#123;   </span><br><span class="line">...  </span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="annotation-config"><a href="#annotation-config" class="headerlink" title="annotation-config"></a>annotation-config</h2><p>就像@AutoWired需要AutowiredAnnotationBeanPostProcessor为它与IoC容器牵线搭桥一样，JavaEE同样有这样的配置方法，可以帮助这些注解发挥它们的作用,那就是annotation-config，如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span> </span></span><br><span class="line"><span class="tag"><span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span> </span></span><br><span class="line"><span class="tag"><span class="attr">xmlns:context</span>=<span class="string">"http://www.springframework.org/schema/context"</span> </span></span><br><span class="line"><span class="tag"><span class="attr">xmlns:p</span>=<span class="string">"http://www.springframework.org/schema/p"</span> </span></span><br><span class="line"><span class="tag"><span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans </span></span></span><br><span class="line"><span class="tag"><span class="string">http://www.springframework.org/schema/beans/spring-beans-2.5.xsd </span></span></span><br><span class="line"><span class="tag"><span class="string">http://www.springframework.org/schema/context </span></span></span><br><span class="line"><span class="tag"><span class="string">http://www.springframework.org/schema/context/spring-context-2.5.xsd"</span>&gt;</span>     </span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">context:annotation-config</span>/&gt;</span>    </span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"newsProvider"</span>    <span class="attr">class</span>=<span class="string">"..FXNewsProvider"</span>/&gt;</span>  </span><br><span class="line"><span class="comment">&lt;!--其他bean定义--&gt;</span>  </span><br><span class="line">... </span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>&lt;context:annotation-config/&gt;不但帮我们把AutowiredAnnotationBeanPostProcessor和 CommonAnnotationBeanPostProcessor注册到容器，还把PersistenceAnnotationBeanPostProcessor和RequiredAnnotationBeanPostProcessor一并注册，可谓一举四得。</strong></p><h1 id="classpath-scanning介绍"><a href="#classpath-scanning介绍" class="headerlink" title="classpath-scanning介绍"></a>classpath-scanning介绍</h1><p>到现在为止，我们还是需要将相应对象的bean定义，一个个的添加到IoC容器的配置文件中，唯一与之前的区别就是，不用在配置文件中明确指定依赖关系了，那么既然注解做都做了，为了不做添加bean的注解呢》Spring的classpath-scanning就是因此而生的。</p><p><strong>使用相应的注解对组成应用程序的相关类进行标注后，classpath-scanning功能可以从某一顶层包开始扫描，当扫描到某个类标注了相应的注解之后，就会提取该类的相关信息，构建对应的BeanDefinition，然后把构建完成的BeanDefinition注册到容器，这之后的事情就不用多说了。</strong></p><p>classpath-scanning功能的触发是由&lt;context:component-scan&gt;决定的，只需要配置如下代码即可生效：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span>  </span></span><br><span class="line"><span class="tag"><span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span> </span></span><br><span class="line"><span class="tag"><span class="attr">xmlns:context</span>=<span class="string">"http://www.springframework.org/schema/context"</span> </span></span><br><span class="line"><span class="tag"><span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans </span></span></span><br><span class="line"><span class="tag"><span class="string">http://www.springframework.org/schema/beans/spring-beans-2.5.xsd </span></span></span><br><span class="line"><span class="tag"><span class="string">http://www.springframework.org/schema/context  </span></span></span><br><span class="line"><span class="tag"><span class="string">http://www.springframework.org/schema/context/spring-context-2.5.xsd"</span>&gt;</span> </span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">"org.spring21"</span>/&gt;</span> </span><br><span class="line"><span class="tag">&lt; /<span class="attr">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><p>现在&lt;context:component-scan&gt;将扫描org.spring21路径下的所有类型定义，寻找标注了相应注解的类，并添加到IoC容器。</p><p><strong>&lt;context:component-scan&gt;默认扫描的注解类型是@Component，不过在@Component语义基础上细化后的@Repository、@Service和@Controller也同样可以获得&lt;context:component-scan&gt;的青睐。</strong></p><p><strong>&lt;context:component-scan&gt;在扫描相关类定义并将它们添加到容器的时候，会使用一种默认的命名规则，来生成那些添加到容器的bean的名称（beanName）。比如DowJonesNewsPersister通过默认命名规则将获得dowJonesNewsPersister。如果想改变这种命名规则，就可以在@Component中制定一个自定义的名称。</strong></p><p>当在配置文件中添加&lt;context:component-scan&gt;之后，&lt;context:component-scan&gt;将多管闲事，同时会将AutowiredAnnotationBeanPostProcessor和CommonAnnotationBeanPostProcessor一并注入到容器中。</p><p>&lt;context:component-scan&gt;还会进一步定制扫描范围，默认情况下他只关系@Component、@Repository、@Service和@Controller四位大员。但是我们可以通过include-filtering和exclude-filtering定制扫描范围，例子如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span> </span></span><br><span class="line"><span class="tag"><span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span> </span></span><br><span class="line"><span class="tag"><span class="attr">xmlns:context</span>=<span class="string">"http://www.springframework.org/schema/context"</span> </span></span><br><span class="line"><span class="tag"><span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans </span></span></span><br><span class="line"><span class="tag"><span class="string">http://www.springframework.org/schema/beans/spring-beans-2.5.xsd </span></span></span><br><span class="line"><span class="tag"><span class="string">http://www.springframework.org/schema/context </span></span></span><br><span class="line"><span class="tag"><span class="string">http://www.springframework.org/ schema/context/spring-context-2.5.xsd"</span>&gt;</span> </span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">"org.spring21"</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">context:include-filter</span> <span class="attr">type</span>=<span class="string">"annotation"</span> <span class="attr">expression</span>=<span class="string">"cn.spring21.annotation.FXService"</span>/&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">context:exclude-filter</span> <span class="attr">type</span>=<span class="string">"aspectj"</span> <span class="attr">expression</span>=<span class="string">".."</span>/&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">context:component-scan</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt; /<span class="attr">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>include-filtering和exclude-filtering可以使用的type类型由annotation、assignable、regex和aspectj四种。</strong></p>]]></content>
    
    <summary type="html">
    
      在复杂的XML文件配置bean的方式之后，产生了@Autowired和@Resource这两个注解的，它们作用都是提供依赖注入、自动绑定的功能，那么它们之间的联系和区别又有什么呢？
    
    </summary>
    
      <category term="Spring" scheme="http://yoursite.com/categories/Spring/"/>
    
    
  </entry>
  
  <entry>
    <title>IoC容器之ApplicationContext</title>
    <link href="http://yoursite.com/posts/30205/"/>
    <id>http://yoursite.com/posts/30205/</id>
    <published>2019-10-19T05:33:24.000Z</published>
    <updated>2019-10-19T06:14:40.229Z</updated>
    
    <content type="html"><![CDATA[<h1 id="统一资源加载策略"><a href="#统一资源加载策略" class="headerlink" title="统一资源加载策略"></a>统一资源加载策略</h1><p>ApplicationContext既然要加载配置文件，就需要一个工具可以用来加载这些资源，因此而出现了ResourceLoader。ApplicationContext实则间接继承了ResourceLoader接口，可以用来对Spring内的资源做一个统一的加载。</p><p>在使用中最常用的两个加载器就是<strong>ClassPathXmlApplicationContext</strong>和<strong>FileSystemXmlApplicationContext</strong>。简单的使用代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ResourceLoader resourceLoader = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"配置文件路径"</span>); </span><br><span class="line"><span class="comment">// 或者 </span></span><br><span class="line"><span class="comment">// ResourceLoader resourceLoader = new FileSystemXmlApplicationContext("配置文件路径"); </span></span><br><span class="line">Resource fileResource = resourceLoader.getResource(<span class="string">"D:/spring21site/README"</span>);</span><br></pre></td></tr></table></figure><p><strong>ResourceLoader中增加了一种新的资源路径协议：classpath：和classpath<em>：，classpath</em>：与classpath：的唯一区别在于，如果能够在classpath中找到多个指定的资源，则返回多个。</strong></p><p><strong>ClassPathXmlApplicationContext和FileSystemXmlApplicationContext在处理资源在记得默认行为上有所不用。当ClassPathXmlApplicationContext在实例化的时候，即使没有执行classpath：或者classpath*：等前缀，它会默认从classpath中加载bean定义配置文件。而FileSystemXmlApplicationContext会默认从文件系统中加载bean定义文件。</strong></p><h1 id="其他特性"><a href="#其他特性" class="headerlink" title="其他特性"></a>其他特性</h1><p>ApplicationContext还提供了一些其他特性，这里就简单介绍一下，不过多描述。</p><ul><li><strong>国际化信息支持</strong>：ApplicationContext有两种国际化支持的方式，一个是Locale结合ResourceBundle，它可以绑定地区。另外一个就是MessageSource可以统一国际化信息的访问方式。</li><li><strong>容器内部事件发布</strong>：JavaSE提供了实现自定义时间发布功能的基础类，即EventListener和EventObject。</li><li><strong>多配置模块加载的简化</strong>：在配置应用的时候，为了更好的划分逻辑层次和分工，而延伸到个让容器同时读入划分到不同配置文件的信息。</li></ul>]]></content>
    
    <summary type="html">
    
      ApplicationContext作为较BeanFacory更先进的IoC容器实现，除了拥有BeanFactory支持的所有功能之外，还进一步扩展了基本容器的功能。下面就简单介绍一下这些新的特性吧。
    
    </summary>
    
      <category term="Spring" scheme="http://yoursite.com/categories/Spring/"/>
    
    
  </entry>
  
  <entry>
    <title>IoC容器之BeanFactory</title>
    <link href="http://yoursite.com/posts/37871/"/>
    <id>http://yoursite.com/posts/37871/</id>
    <published>2019-10-17T08:11:12.000Z</published>
    <updated>2019-10-18T14:36:48.377Z</updated>
    
    <content type="html"><![CDATA[<p>Spring提供了两种容器类型：<strong>BeanFactory</strong>和<strong>ApplicationContext</strong>。</p><ul><li><strong>BeanFactory</strong>：基础类型的Ioc容器，提供完整的IoC服务支持。<strong>如果没有特殊指定，默认采用延迟初始化策略。即只有当客户端对象需要访问容器中的某个受管对象时，才对该受管对象进行初始化以及依赖注入操作。</strong>所以相对来说，该容器启动初期速度较快，所需要的资源有限，因此BeanFactroy比较适合用于资源有限，并且功能要求不是很严格的场景。</li><li><strong>ApplicationContext</strong>：<strong>ApplicationContext是在BeanFactory的基础上构建的</strong>，是相对于高级的容器实现，因此ApplicationContext还提供了一些例如事件发布、国际化信息支持的高级特性。<strong>ApplicationContext所管理的对象，在该容器启动之后，默认全部初始化并绑定完成。</strong>所以相对BeanFactory来说，ApplicationContext要求更多的系统资源，同时启动时间也会长一些。因此ApplicationContext更适合于资源充足并且要求更多功能的场景中。</li></ul><p>通过下图可以对BeanFactory和ApplicationContext之间的关系有一个更清晰的认知。<img src="/posts/37871/TIM%E6%88%AA%E5%9B%BE20191017164208.png" alt></p><p>BeanFactory，顾名思义就是生产Bean的工厂，而Spring提倡使用POJO，所以可以把每个业务对象看作一个JavaBean对象。BeanFactory可以完成作为IoC Service Provider的所有职责，包括业务对象的注册和对象间依赖关系的绑定。</p><p>BeanFactory就像一个汽车生产厂。你从其他汽车零件厂商或者自己的零件生产部门取得汽车零件送入这个汽车生产厂，最后只需要从生产线的终点取得汽车成品就可以了。相似的，将应用程序所需的所有业务对象交给BeanFactory之后，剩下的就是直接从BeanFactory取得最终组装完成并且可用的对象。至于这个最终业务对象如何组装，你不需要担心，BeanFactory会帮你搞定。</p><h1 id="拥有BeanFactory之后的生活"><a href="#拥有BeanFactory之后的生活" class="headerlink" title="拥有BeanFactory之后的生活"></a>拥有BeanFactory之后的生活</h1><p>确切的说，拥有BeanFactory之后的生活没有太大的变化，有变化的也在只是一些拉拉扯扯的事情，客观一点就是对象之间依赖关系的解决方式改变了。之前系统业务对象需要自己去“拉”所依赖的业务对象，有了BeanFactory之类的IoC之后，需要依赖什么，让BeanFactory为我们推过来就行啦。以一个FX新闻系统的例子来说，FX新闻应用设计和实现框架代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>-设计FXNewsProvider类用于普遍的新闻处理 </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FXNewsProvider</span> </span>&#123;  ... &#125;   </span><br><span class="line"> </span><br><span class="line"><span class="number">2</span>-设计IFXNewsListener接口抽象各个新闻社不同的新闻获取方式，并给出相应实现类 </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IFXNewsListener</span> </span>&#123;  ... &#125; </span><br><span class="line">以及 </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DowJonesNewsListener</span> <span class="keyword">implements</span> <span class="title">IFXNewsListener</span></span>&#123;  ... &#125; </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="number">3</span>-设计IFXNewsPersister接口抽象不同数据访问方式，并实现相应的实现类 </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IFXNewsPersister</span> </span>&#123;  ...  &#125;   </span><br><span class="line">以及 </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DowJonesNewsPersister</span> <span class="keyword">implements</span> <span class="title">IFXNewsPersister</span> </span>&#123;  ... &#125;</span><br></pre></td></tr></table></figure><p>BeanFactory会说，这些都让我来干吧！此时BeanFactory说这些事情让他来做，但是它并不知道该怎么做，所以就需要你来教它怎么做。通常情况下，会使用XML文件配置的方式来教它，也就是告诉BeanFactory如何来注册并管理各个业务对象之间的依赖关系。下面是BeanFactory的XML配置方式实现业务对象间的依赖关系的一个例子代码：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span>&gt;</span>   </span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"djNewsProvider"</span> <span class="attr">class</span>=<span class="string">"..FXNewsProvider"</span>&gt;</span>   </span><br><span class="line"><span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">"0"</span>&gt;</span>    </span><br><span class="line"><span class="tag">&lt;<span class="name">ref</span> <span class="attr">bean</span>=<span class="string">"djNewsListener"</span>/&gt;</span>   </span><br><span class="line"><span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span>    </span><br><span class="line"><span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">"1"</span>&gt;</span>    </span><br><span class="line"><span class="tag">&lt;<span class="name">ref</span> <span class="attr">bean</span>=<span class="string">"djNewsPersister"</span>/&gt;</span>   </span><br><span class="line"><span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span>   </span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span>  </span><br><span class="line">... </span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在BeanFactory出现之前，我们通常会直接在应用程序的入口类的main方法中，自己动手实例化相应的对象并调用，如以下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">FXNewsProvider newsProvider = <span class="keyword">new</span> FXNewsProvider();  </span><br><span class="line">newsProvider.getAndPersistNews();</span><br></pre></td></tr></table></figure><p>不过现在有了BeanFactory，通过xml文件这张“图纸”告诉BeanFactory怎么做之后，让BeanFactory为我们生产一个FXNewsProvider，如以下代码所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">BeanFactory container = <span class="keyword">new</span> XmlBeanFactory(<span class="keyword">new</span> ClassPathResource(<span class="string">"配置文件路径"</span>)); </span><br><span class="line">FXNewsProvider newsProvider = (FXNewsProvider)container.getBean(<span class="string">"djNewsProvider"</span>); </span><br><span class="line">newsProvider.getAndPersistNews();</span><br><span class="line"></span><br><span class="line"><span class="comment">/*或者如以下代码所示*/</span> </span><br><span class="line">ApplicationContext container = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"配置文件路径"</span>); </span><br><span class="line">FXNewsProvider newsProvider = (FXNewsProvider)container.getBean(<span class="string">"djNewsProvider"</span>);  </span><br><span class="line">newsProvider.getAndPersistNews(); </span><br><span class="line"></span><br><span class="line"><span class="comment">/*也可以如以下代码所示*/</span></span><br><span class="line">ApplicationContext container = <span class="keyword">new</span> FileSystemXmlApplicationContext(<span class="string">"配置文件路径"</span>); </span><br><span class="line">FXNewsProvider newsProvider = (FXNewsProvider)container.getBean(<span class="string">"djNewsProvider"</span>); </span><br><span class="line">newsProvider.getAndPersistNews();</span><br></pre></td></tr></table></figure><h1 id="BeanFactory的对象注册与依赖绑定方式"><a href="#BeanFactory的对象注册与依赖绑定方式" class="headerlink" title="BeanFactory的对象注册与依赖绑定方式"></a>BeanFactory的对象注册与依赖绑定方式</h1><p>为了让BeanFactory能够明确管理各个业务对象以及业务对象之间的依赖绑定关系，同样需要需要某种途径来记录和管理这些信息。与上一章的IoC Service Provider提到的三种方式，BeanFactory几乎支持所有这些方式。</p><h2 id="直接编码方式"><a href="#直接编码方式" class="headerlink" title="直接编码方式"></a>直接编码方式</h2><p>先看一下使用直接编码方式FX新闻系统相关类是如何注册并绑定的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span>  </span>&#123;   </span><br><span class="line">DefaultListableBeanFactory beanRegistry = <span class="keyword">new</span> DefaultListableBeanFactory();  </span><br><span class="line">BeanFactory container = (BeanFactory)bindViaCode(beanRegistry);  </span><br><span class="line">FXNewsProvider newsProvider = (FXNewsProvider)container.getBean(<span class="string">"djNewsProvider"</span>);  </span><br><span class="line">newsProvider.getAndPersistNews(); </span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> BeanFactory <span class="title">bindViaCode</span><span class="params">(BeanDefinitionRegistry registry)</span> </span>&#123;     </span><br><span class="line">AbstractBeanDefinition newsProvider = <span class="keyword">new</span> RootBeanDefinition(FXNewsProvider.class,<span class="keyword">true</span>);     AbstractBeanDefinition newsListener = <span class="keyword">new</span> RootBeanDefinition(DowJonesNewsListener.class,<span class="keyword">true</span>);     AbstractBeanDefinition newsPersister = <span class="keyword">new</span> RootBeanDefinition(DowJonesNewsPersister.class,<span class="keyword">true</span>);     </span><br><span class="line"></span><br><span class="line"><span class="comment">// 将bean定义注册到容器中     </span></span><br><span class="line">registry.registerBeanDefinition(<span class="string">"djNewsProvider"</span>, newsProvider);     </span><br><span class="line">registry.registerBeanDefinition(<span class="string">"djListener"</span>, newsListener);     </span><br><span class="line">registry.registerBeanDefinition(<span class="string">"djPersister"</span>, newsPersister); </span><br><span class="line"></span><br><span class="line"><span class="comment">// 指定依赖关系     </span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. 可以通过构造方法注入方式     </span></span><br><span class="line">ConstructorArgumentValues argValues = <span class="keyword">new</span> ConstructorArgumentValues();   </span><br><span class="line">  argValues.addIndexedArgumentValue(<span class="number">0</span>, newsListener);     </span><br><span class="line">argValues.addIndexedArgumentValue(<span class="number">1</span>, newsPersister);     </span><br><span class="line">newsProvider.setConstructorArgumentValues(argValues);     </span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 或者通过setter方法注入方式</span></span><br><span class="line"> MutablePropertyValues propertyValues = <span class="keyword">new</span> MutablePropertyValues();     propertyValues.addPropertyValue(<span class="keyword">new</span> ropertyValue(<span class="string">"newsListener"</span>,newsListener));     propertyValues.addPropertyValue(<span class="keyword">new</span> PropertyValue(<span class="string">"newPersistener"</span>,newsPersister)); </span><br><span class="line">    newsProvider.setPropertyValues(propertyValues);    </span><br><span class="line"></span><br><span class="line"><span class="comment">// 绑定完成     </span></span><br><span class="line"><span class="keyword">return</span> (BeanFactory)registry; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>BeanFactory只是一个接口，我们最终需要一个该接口的实现来进行实际的Bean管理，DefaultListableBeanFactory就是这么一个比较通用的BeanFactory实现类。具体关系可以看下图：<img src="/posts/37871/TIM%E6%88%AA%E5%9B%BE20191017174425.png" alt>BeanDefaultListableBeanFactory除了间接的实现了BeanFactory接口，还实现了BeanDefinitionRegistry接口，该接口才是现在BeanFactory的实现中担当Bean注册管理的角色。打个比方说，BeanDefinitionRegistry就像图书馆的数加，所有的书是放在书架上的，虽然你还书借书都是跟图书馆（也就是BeanFactory）打交道，但书架才是图书馆存放各类图书的地方。</p><p>基本上BeanFactory接口只定义如何访问容器内管理Bean的方法，各个BeanFactory的实现类才负责具体Bean的注册以及管理工作。BeanDefinitionRegistry接口定义抽象了Bean的注册逻辑。通常情况下，具体的BeanFactory实现类会实现这个接口来管理Bean的注册。</p><p>每一个受管的对象，在容器中都会有一个BeanDefinition的实例与之相对应，该BeanDefinition的实例负责保存对象的所有必要信息，包括其对应的对象的class类型、是否是抽象类、构造方法参数以及其他属性等。当客户端向BeanFactory请求相对应对象的时候，BeanFactory会通过这些信息为客户端返回一个完备可用的对象实例。</p><p>所以现在可以回到上面的代码中了，上面代码大致可以分为三个步骤：</p><ol><li>在main方法中，首先构造一个DefaultListableBeanFactory作为BeanDefinitionRegistry，然后将其交给bindViaCode方式进行具体的对象注册和相关逻辑管理，然后就可以通过该方法返回的BeanFactory取得需要的对象。</li><li>在bindViaCode方法中，首先针对相应的业务对象构造与其相对应的BeanDefinition，使用了RootBeanDefinition作为BeanDefinition的实现类。构造完成后，将这些BeanDefinite注册到通过方法参数传进来的BeanDefinitionRegistry中。</li><li>之后我们可以通过构造方法，或者setter方法，为其注入相关依赖。最后以BeanFactory的形式返回已经注册并绑定了所有相关业务对象的BeanDefinitionRegistry实例。</li></ol><h2 id="外部配置文件方式"><a href="#外部配置文件方式" class="headerlink" title="外部配置文件方式"></a>外部配置文件方式</h2><p>Spring的IoC容器支持两种配置文件格式：<strong>Properties文件格式</strong>和<strong>XML文件格式</strong>。</p><p>采用外部配置文件时，Spring的IoC荣有一个统一的处理方式。通常情况下，需根据不同的外部配置文件格式，给出相应的BeanDefinitionReader实现类，由BeanDefinitionReader的相应实现类负责将相应的配置文件的内容读取并映射到BeanDefinition，然后将映射后的BeanDefinition注册到一个BeanDefinitionRegistry，之后BeanDefinitionRegistry即完成Bean的注册和加载。</p><h3 id="Properties配置格式的加载"><a href="#Properties配置格式的加载" class="headerlink" title="Properties配置格式的加载"></a>Properties配置格式的加载</h3><p>Spring提供了PropertiesBeanDefiniteReader类用于Properties格式配置文件的加载，只需要根据该类的读取规则，提供相应的配置文件即可，示例代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">djNewsProvider.(class)=..FXNewsProvider </span><br><span class="line">djListener.(class)=..impl.DowJonesNewsListener </span><br><span class="line">djPersister.(class)=..impl.DowJonesNewsPersister </span><br><span class="line"></span><br><span class="line"># ----------通过构造方法注入的时候------------- </span><br><span class="line">djNewsProvider.$0(ref)=djListener </span><br><span class="line">djNewsProvider.$1(ref)=djPersister </span><br><span class="line"></span><br><span class="line"># ----------通过setter方法注入的时候---------  </span><br><span class="line">djNewsProvider.newsListener(ref)=djListener  </span><br><span class="line">djNewsProvider.newPersistener(ref)=djPersister</span><br></pre></td></tr></table></figure><p>这些内容都是特定于Spring的PropertiesBeanDefinitionReader的，下面是简单的语法介绍：</p><ul><li>djNewsProvider作为beanName，后面通过（class）表明对应的实现类是什么，实际上使用djNewsProvider.class=…的形式也是可以的，但是不提倡。</li><li>通过在表示beanName的名称后添加.$[number]后缀的形式，来表示当前beanName对应的对象需要通过构造方法注入的方式注入相应依赖对象。$0和1$1后面的（ref）用来表示所依赖的是引用对象，而不是普通的类型。如果不加（ref），则会将djListener和djPersister作为简单的String类型进行注入，异常也是自然不可避免了。</li><li>setter方法注入与构造方法注入最大的区别就是，它不使用数字顺序来指定注入的位置，而使用相应的属性名称来指定注入，同样也不要忘掉（ref）。</li></ul><p>在使用Properties文件配置完后，就可以使用了，下面是一个使用演示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span>  </span>&#123;   </span><br><span class="line">DefaultListableBeanFactory beanRegistry = <span class="keyword">new</span> DefaultListableBeanFactory();  </span><br><span class="line">BeanFactory container = (BeanFactory)bindViaPropertiesFile(beanRegistry);  </span><br><span class="line">FXNewsProvider newsProvider = (FXNewsProvider)container.getBean(<span class="string">"djNewsProvider"</span>);  </span><br><span class="line">newsProvider.getAndPersistNews(); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> BeanFactory <span class="title">bindViaPropertiesFile</span><span class="params">(BeanDefinitionRegistry registry)</span> </span>&#123;  </span><br><span class="line">PropertiesBeanDefinitionReader reader =  <span class="keyword">new</span> PropertiesBeanDefinitionReader(registry);  </span><br><span class="line">reader.loadBeanDefinitions(<span class="string">"classpath:../../binding-config.properties"</span>);  </span><br><span class="line"><span class="keyword">return</span> (BeanFactory)registry; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="XML配置格式的加载"><a href="#XML配置格式的加载" class="headerlink" title="XML配置格式的加载"></a>XML配置格式的加载</h3><p>XML配置格式是Spring支持最完整，功能最强大，也是使用最频繁的表达方式。例子如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span> </span><br><span class="line"><span class="meta">&lt;!DOCTYPE beans PUBLIC "-//SPRING//DTD BEAN//EN" "http://www.springframework.org/dtd/spring-beans.dtd"&gt;</span> </span><br><span class="line"> </span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"djNewsProvider"</span> <span class="attr">class</span>=<span class="string">"..FXNewsProvider"</span>&gt;</span>   </span><br><span class="line"><span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">"0"</span>&gt;</span>    </span><br><span class="line"><span class="tag">&lt;<span class="name">ref</span> <span class="attr">bean</span>=<span class="string">"djNewsListener"</span>/&gt;</span>   </span><br><span class="line"><span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span>   </span><br><span class="line"><span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">"1"</span>&gt;</span>    </span><br><span class="line"><span class="tag">&lt;<span class="name">ref</span> <span class="attr">bean</span>=<span class="string">"djNewsPersister"</span>/&gt;</span>   </span><br><span class="line"><span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span>    </span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"djNewsListener"</span> <span class="attr">class</span>=<span class="string">"..impl.DowJonesNewsListener"</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span>  </span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"djNewsPersister"</span> <span class="attr">class</span>=<span class="string">"..impl.DowJonesNewsPersister"</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><p>相对应的加载XML配置文件的BeanFactory的使用演示如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span>  </span>&#123; </span><br><span class="line">DefaultListableBeanFactory beanRegistry = <span class="keyword">new</span> DefaultListableBeanFactory();  </span><br><span class="line">BeanFactory container = (BeanFactory)bindViaXMLFile(beanRegistry);  </span><br><span class="line">FXNewsProvider newsProvider = (FXNewsProvider)container.getBean(<span class="string">"djNewsProvider"</span>); </span><br><span class="line">newsProvider.getAndPersistNews(); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> BeanFactory <span class="title">bindViaXMLFile</span><span class="params">(BeanDefinitionRegistry registry)</span>  </span>&#123;  </span><br><span class="line">XmlBeanDefinitionReader reader = <span class="keyword">new</span> XmlBeanDefinitionReader(registry);  </span><br><span class="line">reader.loadBeanDefinitions(<span class="string">"classpath:../news-config.xml"</span>); </span><br><span class="line"><span class="keyword">return</span> (BeanFactory)registry;  </span><br><span class="line"><span class="comment">// 或者直接  </span></span><br><span class="line"><span class="comment">//return new XmlBeanFactory(new ClassPathResource("../news-config.xml")); </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>与Properties一样，XML同样有Spring提供的现成的BeanDefinitionReader实现，即XmlBeanDefinitionReader。</p><h2 id="注解方式"><a href="#注解方式" class="headerlink" title="注解方式"></a>注解方式</h2><p>注解是Java5之后才引入的，所以相对来说也更加简洁方便一些，使用注解的方式为FXNewsProvider注入所需要的依赖，现在可以使用@Autowired以及@Component对相关类进行标记。下面是FXNews使用注解标注后的情况。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FXNewsProvider</span>  </span>&#123;  </span><br><span class="line"><span class="meta">@Autowired</span>  </span><br><span class="line"><span class="keyword">private</span> IFXNewsListener  newsListener;  </span><br><span class="line"><span class="meta">@Autowired</span>  </span><br><span class="line"><span class="keyword">private</span> IFXNewsPersister newPersistener;    </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">FXNewsProvider</span><span class="params">(IFXNewsListener newsListner,IFXNewsPersister newsPersister)</span>  </span>&#123;   </span><br><span class="line"><span class="keyword">this</span>.newsListener   = newsListner;   </span><br><span class="line"><span class="keyword">this</span>.newPersistener = newsPersister;  </span><br><span class="line">&#125;  </span><br><span class="line">... </span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line"><span class="meta">@Component</span> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DowJonesNewsListener</span> <span class="keyword">implements</span> <span class="title">IFXNewsListener</span>  </span>&#123;  ... &#125; </span><br><span class="line"> </span><br><span class="line"><span class="meta">@Component</span> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DowJonesNewsPersister</span> <span class="keyword">implements</span> <span class="title">IFXNewsPersister</span>  </span>&#123;  ... &#125;</span><br></pre></td></tr></table></figure><p><strong>@Autowired是这里的主角，它的存在将告知Spring容器需要为当前对象注入哪些依赖对象。而@Component则是配合Spring中的classpath-scanning功能使用。现在我们只要再向Spring的配置文件中增加一个“触发器”，使用@Autowired和@Component标注的类就能获得依赖对象的注入了。</strong>下面是在配置文件中配置的方法：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span> </span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span> </span></span><br><span class="line"><span class="tag"><span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span> </span></span><br><span class="line"><span class="tag"><span class="attr">xmlns:context</span>=<span class="string">"http://www.springframework.org/schema/context"</span> </span></span><br><span class="line"><span class="tag"><span class="attr">xmlns:tx</span>=<span class="string">"http://www.springframework.org/schema/tx"</span> </span></span><br><span class="line"><span class="tag"><span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans </span></span></span><br><span class="line"><span class="tag"><span class="string">http://www.springframework.org/schema/beans/spring-beans-2.5.xsd </span></span></span><br><span class="line"><span class="tag"><span class="string">http://www.springframework.org/schema/context </span></span></span><br><span class="line"><span class="tag"><span class="string">http://www.springframework.org/schema/context/spring-context-2.5.xsd </span></span></span><br><span class="line"><span class="tag"><span class="string">http://www.springframework.org/schema/tx </span></span></span><br><span class="line"><span class="tag"><span class="string">http://www.springframework.org/schema/tx/spring-tx-2.5.xsd"</span>&gt;</span> </span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">"cn.spring21.project.base.package"</span>/&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong><a href="context:component-scan" target="_blank" rel="noopener">context:component-scan</a>会到指定的包下面扫描有@Component的类，如果找到，则将他们添加到容器进行管理，并根据它们所标注的@Autowired为这些类注入符合条件的依赖对象。</strong>所以在做完上面的工作之后，就可以使用了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;  </span><br><span class="line">ApplicationContext ctx = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"配置文件路径"</span>);  </span><br><span class="line">FXNewsProvider newsProvider = (FXNewsProvider)container.getBean(<span class="string">"FXNewsProvider"</span>); </span><br><span class="line">newsProvider.getAndPersistNews(); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="XML配置方法"><a href="#XML配置方法" class="headerlink" title="XML配置方法"></a>XML配置方法</h1><p>XML格式的容器信息管理方式是Spring提供的最为强大、支持最为全面的方式，因此在这里讲述一下XML文件的以标签和一些属性。</p><h2 id="lt-beans-gt-和-lt-bean-gt"><a href="#lt-beans-gt-和-lt-bean-gt" class="headerlink" title="&lt;beans&gt;和&lt;bean&gt;"></a>&lt;beans&gt;和&lt;bean&gt;</h2><p>所有的Spring容器加载的XML配置文件的头部，都需要基于文档声明，而DTD和XSD的声明方式不一样，下面是一个对比：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- DTD方式 --&gt;</span></span><br><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span>  </span><br><span class="line"><span class="meta">&lt;!DOCTYPE beans PUBLIC "-//SPRING//DTD BEAN//EN" ➥ "http://www.springframework.org/dtd/spring-beans.dtd"&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span>&gt;</span>  ... <span class="tag">&lt;/<span class="name">beans</span>&gt;</span> </span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- XSD方式 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span> </span></span><br><span class="line"><span class="tag"><span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span> </span></span><br><span class="line"><span class="tag"><span class="attr">xmlns:util</span>=<span class="string">"http://www.springframework.org/schema/util"</span> </span></span><br><span class="line"><span class="tag"><span class="attr">xmlns:jee</span>=<span class="string">"http://www.springframework.org/schema/jee"</span>  </span></span><br><span class="line"><span class="tag"><span class="attr">xmlns:lang</span>=<span class="string">"http://www.springframework.org/schema/lang"</span>  </span></span><br><span class="line"><span class="tag"><span class="attr">xmlns:aop</span>=<span class="string">"http://www.springframework.org/schema/aop"</span>  </span></span><br><span class="line"><span class="tag"><span class="attr">xmlns:tx</span>=<span class="string">"http://www.springframework.org/schema/tx"</span>  </span></span><br><span class="line"><span class="tag"><span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans  </span></span></span><br><span class="line"><span class="tag"><span class="string">http://www.springframework.org/schema/beans/spring-beans-2.0.xsd  </span></span></span><br><span class="line"><span class="tag"><span class="string">http://www.springframework.org/schema/util </span></span></span><br><span class="line"><span class="tag"><span class="string">http://www.springframework.org/schema/util/spring-util-2.0.xsd  </span></span></span><br><span class="line"><span class="tag"><span class="string">http://www.springframework.org/schema/jee </span></span></span><br><span class="line"><span class="tag"><span class="string">http://www.springframework.org/schema/jee/spring-jee-2.0.xsd </span></span></span><br><span class="line"><span class="tag"><span class="string">http://www.springframework.org/schema/lang </span></span></span><br><span class="line"><span class="tag"><span class="string">http://www.springframework.org/schema/lang/spring-lang-2.0.xsd </span></span></span><br><span class="line"><span class="tag"><span class="string">http://www.springframework.org/schema/aop </span></span></span><br><span class="line"><span class="tag"><span class="string">http://www.springframework.org/schema/aop/spring-aop-2.0.xsd  </span></span></span><br><span class="line"><span class="tag"><span class="string">http://www.springframework.org/schema/tx </span></span></span><br><span class="line"><span class="tag"><span class="string">http://www.springframework.org/schema/tx/spring-tx-2.0.xsd"</span>&gt;</span>   </span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><p>所有注册到容器的业务对象，在Spring中称之为Bean。所以，每一个对象在XML的映射中也自然而然的对应一个&lt;bean&gt;。既然容器最终可以管理所有的业务对象，那么XML中把这些叫做&lt;bean&gt;的元素组织起来，就叫做&lt;beans&gt;。</p><h3 id="lt-beans-gt-之唯我独尊"><a href="#lt-beans-gt-之唯我独尊" class="headerlink" title="&lt;beans&gt;之唯我独尊"></a>&lt;beans&gt;之唯我独尊</h3><p>&lt;beans&gt;是XML配置我呢见中最顶层的元素，它下面可以包含0或者1个&lt;description&gt;和多个&lt;bean&gt;以及&lt;import&gt;或者&lt;alias&gt;。&lt;beans&gt;作为所有<bean>的“统帅”，它拥有相应的属性对所辖的&lt;bean&gt;进行统一的默认行为设置，包括如下几个：</bean></p><ul><li><strong>default-lazy-init</strong>:其值可以指定为true或者false，默认值为false。用来标志是否对所有的&lt;bean&gt;进行延迟初始化，但是指定为true时并不一定会延迟初始化，如果某个非延迟的bean依赖于该bean，那么该bean就不会延迟初始化。</li><li><strong>default-autowire</strong>：可以取值为no-不采取任何形式的自动绑定，完全依赖于手工明确配置、byName-与XML文件中声明的bean定义的beanName的值进行匹配、byType-会根据当前bean定义类型，按类型匹配、constructor-同样是按类型绑定，但是是匹配构造放的参数类型，而不是实例属性的类型，以及autodetect-byTye和constructor的结合体，如果是无参构造方法则是由byType，否则使用constructor模式。默认为no。如果使用自动绑定的话，用来标志全体bean使用哪一种默认绑定方式。</li><li><strong>default-dependency-check</strong>：可以取值为none-不检查、objects-只对对象引用类型依赖进行检查、simple-对简单属性类型以及相关的collection进行依赖检查，对象引用类型的依赖除外，以及all-simple和objects的结合，默认为none，即不做检查。</li><li><strong>default-init-method</strong>：如果所管辖的所有&lt;bean&gt;都有同样名称的初始化方法，可以在这里统一指定这个初始化方法名，而不用每一个单独指定。</li><li><strong>default-destroy-method</strong>：与default-init-method相对应，如果所管辖的所有&lt;bean&gt;都有同样名称的销毁方法，可以在这里统一指定这个销毁方法名，而不用每一个单独指定。</li></ul><h3 id="lt-description-gt-、-lt-import-gt-和-lt-alias-gt"><a href="#lt-description-gt-、-lt-import-gt-和-lt-alias-gt" class="headerlink" title="&lt;description&gt;、&lt;import&gt;和&lt;alias&gt;"></a>&lt;description&gt;、&lt;import&gt;和&lt;alias&gt;</h3><p>这几个元素通常情况下不是必须的，这里只是了解一下。</p><ul><li><strong>&lt;description&gt;</strong>：在配置文件中指定一些描述性的信息。</li><li><strong>&lt;import&gt;</strong>：可以在主要的配置文件中通过这个标签元素对其所依赖的配置文件引用，例如在A文件中&lt;import resource=”B.xml”&gt;</li><li><strong>&lt;alias&gt;</strong>：为某些&lt;bean&gt;起一些别名，通常情况下是为了减少输入。</li></ul><h2 id="孤孤单单的id和class"><a href="#孤孤单单的id和class" class="headerlink" title="孤孤单单的id和class"></a>孤孤单单的id和class</h2><h3 id="id属性"><a href="#id属性" class="headerlink" title="id属性"></a>id属性</h3><p>通常，每个注册到容器的对象都需要一个唯一标志来将其与同处一室的bean兄弟们区分开来，通过id属性来指定当前注册对象的beanName是什么。实际上并非任何情况下都需要指定每个&lt;bean&gt;的id，有些情况下可以省略，会在后面提到。</p><p>除了使用id来指定&lt;bean&gt;在容器中的标志，还可以使用name属性来指定&lt;bean&gt;的别名。name比id灵活之处在于，name可以使用id不能使用的一些字符，比如、。而且还可以通过逗号、空格或者冒号分割指定多个name。name的作用和alias的作用基本相同。</p><h3 id="class属性"><a href="#class属性" class="headerlink" title="class属性"></a>class属性</h3><p>每个注册到容器的对象都需要通过&lt;bean&gt;元素的class属性指定其类型。在大部分情况下该属性都是必须的，仅在少数情况下不需要指定，后面会提到。</p><h2 id="XML中的继承"><a href="#XML中的继承" class="headerlink" title="XML中的继承"></a>XML中的继承</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"newsProviderTemplate"</span> <span class="attr">abstract</span>=<span class="string">"true"</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"newPersistener"</span>&gt;</span>    </span><br><span class="line"><span class="tag">&lt;<span class="name">ref</span> <span class="attr">bean</span>=<span class="string">"djNewsPersister"</span>/&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span>  </span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"superNewsProvider"</span> <span class="attr">parent</span>=<span class="string">"newsProviderTemplate"</span>   <span class="attr">class</span>=<span class="string">"..FXNewsProvider"</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"newsListener"</span>&gt;</span>   </span><br><span class="line"><span class="tag">&lt;<span class="name">ref</span> <span class="attr">bean</span>=<span class="string">"djNewsListener"</span>/&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"> </span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"subNewsProvider"</span> <span class="attr">parent</span>=<span class="string">"newsProviderTemplate"</span>   <span class="attr">class</span>=<span class="string">"..SpecificFXNewsProvider"</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"newsListener"</span>&gt;</span>   </span><br><span class="line"><span class="tag">&lt;<span class="name">ref</span> <span class="attr">bean</span>=<span class="string">"specificNewsListener"</span>/&gt;</span>   </span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt; /<span class="attr">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>根据上面的代码可以看出，我们在声明superNewsProvider和subNewsProvider的时候，使用了parent属性，将其值指定为newsProviderTemplate，这样我们就继承了newsProviderTemplate定义的默认值，只需要将指定的属性进行更改，而不要全部又重新定义一遍。</p><p>parent属性还可以与abstract属性结合使用，达到将相应bean定义模板化的目的。newsProviderTemplate的bean定义通过abstract属性声明为true，说明这个bean定义不需要实例化，<strong>这就是之前提到的可以不指定class属性的少数场景之一。</strong>该bean只是配置一个模板，不对应任何对象，superNewsProvider和subNewsProvider通过parent指向这个模板定义，就拥有了该模板定义的所有属性配置。</p><p><strong>容器在初始化对象实例的时候，不会关注abstract的bean。如果你不想容器在初始化对象实例的时候，那么可以将其abstract属性赋值为true，以避免容器将其实例化。同样对于ApplicationContext也是如此。</strong></p><h2 id="bean的scope（作用域）"><a href="#bean的scope（作用域）" class="headerlink" title="bean的scope（作用域）"></a>bean的scope（作用域）</h2><p>scope用来声明容器中的对象所应该处的限定场景或者说该对象的存活时间，即容器在对象进入相应的scope之前，生产并装配这些对象，在该对象不在处于这些scope的限定之后，容器通常会销毁这些对象。</p><p>Spring最初提供了两种bean的scope类型：singleton和prototype，但是2.0发布之后，又引入了另外三种scope类型，即request、session和globa session类型，对应这三种类型只能在Web应用中使用。</p><h3 id="singleton"><a href="#singleton" class="headerlink" title="singleton"></a>singleton</h3><p><strong>标记为拥有singleton scope的对象定义，在Spring的IoC容器中只存在一个实例，所有对该对象的引用将共享这个实例，也就是说它与IoC容器的寿命“几乎”相同。</strong></p><p><strong>不要将这里的singleton与设计模式中的singleton相混淆。二者的语义是不同的：标记为singleton的bean是由容器来保证这种类型的bean在同一个容器中只存在一个共享实例；而Singleton模式则是保证在同一个Classloader中只存在一个这种类型的实例。</strong></p><p>可以从两个方面看singleton的bean所具有的特性：</p><ul><li><strong>对象实例数量</strong>：singleton的bean定义，在一个容器中只存在一个共享实例，所有对该类型bean的依赖都引用这一单一实例。</li><li><strong>对象存活时间</strong>：singleton类型bean定义，从容器启动，到它第一次被请求而实例化开始，只要容器不销毁或者退出，该类型bean的单一实例就会一直存活。</li></ul><p><strong>通常情况下，如果你不指定bean的scope，singleton便是容器默认的scope。</strong></p><h3 id="prototype"><a href="#prototype" class="headerlink" title="prototype"></a>prototype</h3><p><strong>针对声明为拥有prototype scope的bean定义，容器在接到该类型对象的请求的时候，会每次都重新生成一个新的对象实例给请求方。虽然这种类型的对象的实例化以及属性设置等工作都是由容器负责的，但是只要准备完毕，并且对象实例返回给请求方之后，容器就不再拥有当前返回对象的引用，请求方需要自己负责当前返回对象的后继生命周期的管理工具，包括销毁。</strong></p><p>所以对于那些请求不能共享使用的对象类型，应该将其bean定义的scope设置为prototype，这样可以用它来保存一些用户的状态信息。</p><h3 id="request"><a href="#request" class="headerlink" title="request"></a>request</h3><p><strong>Spring容器，即XmlWebApplicationContext会为每一个HTTP请求创建一个全新的RequestProcessor对象供当前请求使用，当请求结束后，该对象实例的生命周期即告结束。</strong></p><h3 id="session"><a href="#session" class="headerlink" title="session"></a>session</h3><p>Spring容器会为每个独立的session创建属于它们自己的全新的UserPreferences对象实例。与request相比，除了可能有更长的存活时间，其它方面真是没什么区别。</p><h3 id="global-session"><a href="#global-session" class="headerlink" title="global session"></a>global session</h3><p>global session只应用于基于porlet的Web应用程序中才有意义，在普通的基于servlet的Web应用中使用了这个类型的scope，容器会将其作为普通的session类型对待。</p><h3 id="自定义scope"><a href="#自定义scope" class="headerlink" title="自定义scope"></a>自定义scope</h3><p>默认的singleton和prototype是硬编码到代码中的，而request、session和globa session，包括自定义scope类型，都实现了Scope接口，该接口定义如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Scope</span> </span>&#123;    </span><br><span class="line"><span class="function">Object <span class="title">get</span><span class="params">(String name, ObjectFactory objectFactory)</span></span>; </span><br><span class="line"></span><br><span class="line"><span class="function">Object <span class="title">remove</span><span class="params">(String name)</span></span>;  </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">registerDestructionCallback</span><span class="params">(String name, Runnable callback)</span></span>; </span><br><span class="line"> </span><br><span class="line"><span class="function">String <span class="title">getConversationId</span><span class="params">()</span></span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>要实现自己的scope类型，首先要给出一个Scope接口的实现类，并非4个方法都是必须的，<strong>但get和remove方法必须实现。</strong>下面是一个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadScope</span> <span class="keyword">implements</span> <span class="title">Scope</span> </span>&#123; </span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ThreadLocal threadScope = <span class="keyword">new</span> ThreadLocal() &#123;       </span><br><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">initialValue</span><span class="params">()</span> </span>&#123;         </span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> HashMap();       </span><br><span class="line">&#125;      </span><br><span class="line">&#125;;      </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">get</span><span class="params">(String name, ObjectFactory objectFactory)</span> </span>&#123;     </span><br><span class="line">Map scope = (Map) threadScope.get();     </span><br><span class="line">Object object = scope.get(name);     </span><br><span class="line"><span class="keyword">if</span>(object==<span class="keyword">null</span>) &#123;       </span><br><span class="line">object = objectFactory.getObject();        </span><br><span class="line">scope.put(name, object);     </span><br><span class="line">&#125;     </span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> object;    </span><br><span class="line">&#125; </span><br><span class="line">   </span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">remove</span><span class="params">(String name)</span> </span>&#123;     </span><br><span class="line">Map scope = (Map) threadScope.get();     </span><br><span class="line"><span class="keyword">return</span> scope.remove(name);   </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerDestructionCallback</span><span class="params">(String name, Runnable callback)</span> </span>&#123;   </span><br><span class="line">&#125;   </span><br><span class="line">... </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来就是把这个新定义的scope注册到容器中，才能供相应的bean使用。我们有两种方式可以注册。</p><p>一种就是我们可以使用ConfigurableBeanFactory的以下方法去注册：<code>void registerScope(String scopeName, Scope scope)</code>，其中参数scopeName就是使用的bean定义可以指定的名称，参数scope就是我们提供的scope实现类实例。注册例子如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Scope threadScope = <span class="keyword">new</span> ThreadScope(); </span><br><span class="line">beanFactory.registerScope(<span class="string">"thread"</span>,threadScope);</span><br></pre></td></tr></table></figure><p>另一种方式就是可以在xml文件中配置CustomScopeConfigurer来注册scope。例如“</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.springframework.beans.factory.config.CustomScopeConfigurer"</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"scopes"</span>&gt;</span>   </span><br><span class="line"><span class="tag">&lt;<span class="name">map</span>&gt;</span>    </span><br><span class="line"><span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">"thread"</span> <span class="attr">value</span>=<span class="string">"com.foo.ThreadScope"</span>/&gt;</span>   </span><br><span class="line"><span class="tag">&lt;/<span class="name">map</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>接下来就可以使用这个自定义的scope了，例如：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"beanName"</span> <span class="attr">class</span>=<span class="string">"..."</span> <span class="attr">scope</span>=<span class="string">"thread"</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">aop:scoped-proxy</span>/&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="工厂方法与FactoryBean"><a href="#工厂方法与FactoryBean" class="headerlink" title="工厂方法与FactoryBean"></a>工厂方法与FactoryBean</h2><p>工厂方法（Factory Method）模式，提供一个工厂类来实例化具体的接口实现类，这样主体对象只需要依赖工厂类，具体使用的实现类有变更的话，只是变更工厂类，而主体对象不需要做任何变动，这样就避免了接口与实现类的耦合性。</p><p>针对这种方式，Spring的IoC容器同样提供了对应的集成支持，我们要做的，只是将工厂类所返回的具体的接口实现类注入给主体对象。</p><h3 id="静态工厂方法"><a href="#静态工厂方法" class="headerlink" title="静态工厂方法"></a>静态工厂方法</h3><p>假设现在有一个接口BarInterface，为了向使用该接口的客户端对象屏蔽以后可能对BarInterface实现类的变动，因此还提供了一个静态的工厂方法实现类StaticBarInterfaceFactory，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticBarInterfaceFactory</span> </span>&#123;  </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> BarInterface <span class="title">getInstance</span><span class="params">()</span>  </span>&#123;  </span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> BarInterfaceImpl();  </span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了将该静态方法类返回的实现注入Foo，我们使用以下方式进行配置：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"foo"</span> <span class="attr">class</span>=<span class="string">"...Foo"</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"barInterface"</span>&gt;</span>   </span><br><span class="line"><span class="tag">&lt;<span class="name">ref</span> <span class="attr">bean</span>=<span class="string">"bar"</span>/&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span> </span><br><span class="line"> </span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"bar"</span> <span class="attr">class</span>=<span class="string">"...StaticBarInterfaceFactory"</span> <span class="attr">factory-method</span>=<span class="string">"getInstance"</span>/&gt;</span></span><br></pre></td></tr></table></figure><p><strong>class指定静态方法工厂类，factory-method指定工厂方法名称，然后，容器调用该静态方法工厂类的指定工厂方法，并返回方法调用后的结果，即BarInterfaceImpl的实例。</strong></p><p>某些时候，有的工厂类的工厂方法需要参数来返回相应实例，可以通过&lt;constructor-arg&gt;来指定工厂方法需要的参数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticBarInterfaceFactory</span> </span>&#123;  </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> BarInterface <span class="title">getInstance</span><span class="params">(Foobar foobar)</span>  </span>&#123;   </span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> BarInterfaceImpl(foobar);  </span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"foo"</span> <span class="attr">class</span>=<span class="string">"...Foo"</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"barInterface"</span>&gt;</span>   </span><br><span class="line"><span class="tag">&lt;<span class="name">ref</span> <span class="attr">bean</span>=<span class="string">"bar"</span>/&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span> </span><br><span class="line"> </span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"bar"</span> <span class="attr">class</span>=<span class="string">"...StaticBarInterfaceFactory"</span> <span class="attr">factory-method</span>=<span class="string">"getInstance"</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">constructor-arg</span>&gt;</span>   </span><br><span class="line"><span class="tag">&lt;<span class="name">ref</span> <span class="attr">bean</span>=<span class="string">"foobar"</span>/&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span> </span><br><span class="line"> </span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"foobar"</span> <span class="attr">class</span>=<span class="string">"...FooBar"</span>/&gt;</span></span><br></pre></td></tr></table></figure><p><strong>唯一需要注意的是，针对静态工厂方法实现类的bean定义，使用&lt;constructor-arg&gt;传入的是工厂方法的参数，而不是静态工厂方法的构造方法的参数，况且，静态工厂方法实现类也没有提供显式的构造方法。</strong></p><h3 id="非静态工厂方法"><a href="#非静态工厂方法" class="headerlink" title="非静态工厂方法"></a>非静态工厂方法</h3><p>针对非静态方法的调用方式也很简单，只是需要稍微该变一下代码即可：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NonStaticBarInterfaceFactory</span>  </span>&#123;  </span><br><span class="line"><span class="function"><span class="keyword">public</span> BarInterface <span class="title">getInstance</span><span class="params">()</span>  </span>&#123;   </span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> BarInterfaceImpl();   </span><br><span class="line">&#125;  </span><br><span class="line">... </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"foo"</span> <span class="attr">class</span>=<span class="string">"...Foo"</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"barInterface"</span>&gt;</span>   </span><br><span class="line"><span class="tag">&lt;<span class="name">ref</span> <span class="attr">bean</span>=<span class="string">"bar"</span>/&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span> </span><br><span class="line"> </span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"barFactory"</span> <span class="attr">class</span>=<span class="string">"...NonStaticBarInterfaceFactory"</span>/&gt;</span>   </span><br><span class="line"></span><br><span class="line"><span class="tag">&lt; <span class="attr">bean</span> <span class="attr">id</span>=<span class="string">"bar"</span> <span class="attr">factory-bean</span>=<span class="string">"barFactory"</span> <span class="attr">factory-method</span>=<span class="string">"getInstance"</span>/&gt;</span></span><br></pre></td></tr></table></figure><p><strong>现在的最主要不同就在于是使用factory-bean属性来指定工厂方法所在的工厂类实例，而不是通过class属性来指定工厂方法所在类的类型。</strong>如果需要参数的话，配置方法同静态工厂方法一样。</p><h3 id="FactoryBean"><a href="#FactoryBean" class="headerlink" title="FactoryBean"></a>FactoryBean</h3><p>当某些对象的实例化过程因为繁琐，使用XML配置过于复杂时，就可以考虑通过代码的方式来完成这个实例化过程，FactoryBean接口就是为此而生的。FactoryBean接口只定义了三个方法，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">FactoryBean</span> </span>&#123; </span><br><span class="line"><span class="function">Object <span class="title">getObject</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>;  </span><br><span class="line"><span class="function">Class <span class="title">getObjectType</span><span class="params">()</span></span>;  </span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isSingleton</span><span class="params">()</span></span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>getObject()方法会返回该FactoryBean生产的对象实例，我们需要实现该方法以给出自己的对象实例化逻辑；</strong></li><li><strong>getObjectType()方法仅返回getObject()方法所返回的对象的类型，如果预先无法确定，则返回null；</strong></li><li><strong>isSingleton()方法返回结果用于表明是否为单例实例。</strong></li></ul><p>这是一个例子，得到第二天的日期：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NextDayDateFactoryBean</span> <span class="keyword">implements</span> <span class="title">FactoryBean</span> </span>&#123; </span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getObject</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;   </span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> DateTime().plusDays(<span class="number">1</span>);  </span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">public</span> Class <span class="title">getObjectType</span><span class="params">()</span> </span>&#123;   </span><br><span class="line"><span class="keyword">return</span> DateTime.class;  </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSingleton</span><span class="params">()</span> </span>&#123;   </span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;  </span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来只需要将其注册到容器中即可：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"nextDayDateDisplayer"</span> <span class="attr">class</span>=<span class="string">"...NextDayDateDisplayer"</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"dateOfNextDay"</span>&gt;</span>   </span><br><span class="line"><span class="tag">&lt;<span class="name">ref</span> <span class="attr">bean</span>=<span class="string">"nextDayDate"</span>/&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span>         </span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"nextDayDate"</span> <span class="attr">class</span>=<span class="string">"...NextDayDateFactoryBean"</span>&gt;</span> <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>接下来就是最重要的地方，来看看NextDayDateDisplayer的定义：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NextDayDateDisplayer</span> </span>&#123;  </span><br><span class="line"><span class="keyword">private</span> DateTime dateOfNextDay;  </span><br><span class="line"><span class="comment">// 相应的setter方法  </span></span><br><span class="line"><span class="comment">// ... </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>NextDayDateDisplayer所声明的依赖dateOfNextDay的类型为DateTime，而不是NextDayDateFactoryBean，也就是说FactoryBean类型的bean定义，通过正常id引用，容器返回的时FactoryBean所生产的对象类型，而非其本身。当然如果一定要取得FactoryBean本身的话，可以通过bean定义的id之前加前缀“&amp;”来达到目的。</strong></p><h2 id="方法注入以及方法替换"><a href="#方法注入以及方法替换" class="headerlink" title="方法注入以及方法替换"></a>方法注入以及方法替换</h2><p>在引出标题内容之前，需要先提一下有关bean的scope的prototype属性的陷阱，我们知道，拥有prototype类型scope的bean，在请求方法每次向容器请求该类型对象的时候，容器都会返回一个全新的该对象实例，下面看看这个情况：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MockNewsPersister</span> <span class="keyword">implements</span> <span class="title">IFXNewsPersister</span> </span>&#123;  </span><br><span class="line"><span class="keyword">private</span> FXNewsBean newsBean;    </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">persistNews</span><span class="params">(FXNewsBean bean)</span> </span>&#123;   </span><br><span class="line">persistNewes();  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">persistNews</span><span class="params">()</span>  </span>&#123;   </span><br><span class="line">System.out.println(<span class="string">"persist bean:"</span>+getNewsBean());  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="function"><span class="keyword">public</span> FXNewsBean <span class="title">getNewsBean</span><span class="params">()</span> </span>&#123;  </span><br><span class="line"><span class="keyword">return</span> newsBean;  </span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setNewsBean</span><span class="params">(FXNewsBean newsBean)</span> </span>&#123;   </span><br><span class="line"><span class="keyword">this</span>.newsBean = newsBean;  </span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>配置为：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"newsBean"</span> <span class="attr">class</span>=<span class="string">"..domain.FXNewsBean"</span> <span class="attr">singleton</span>=<span class="string">"false"</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span> </span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"mockPersister"</span> <span class="attr">class</span>=<span class="string">"..impl.MockNewsPersister"</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"newsBean"</span>&gt;</span>   </span><br><span class="line"><span class="tag">&lt;<span class="name">ref</span> <span class="attr">bean</span>=<span class="string">"newsBean"</span>/&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>当我们多次调用MockNewsPersister的persistNews时，看看结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">BeanFactory container = <span class="keyword">new</span> XmlBeanFactory(<span class="keyword">new</span> ClassPathResource(<span class="string">".."</span>)); </span><br><span class="line">MockNewsPersister persister = (MockNewsPersister)container.getBean(<span class="string">"mockPersister"</span>); </span><br><span class="line">persister.persistNews(); persister.persistNews(); </span><br><span class="line"></span><br><span class="line">输出： </span><br><span class="line">persist bean:..domain.FXNewsBean@<span class="number">1662</span>dc8 </span><br><span class="line">persist bean:..domain.FXNewsBean@<span class="number">1662</span>dc8</span><br></pre></td></tr></table></figure><p>从输出看对象实例是相同的，而这与我们的初衷时相悖的。问题实际上不出在FXNewsBean的scope类型是否是prototype的，而是出在实例的取得方式上面。<strong>虽然FXNewsBean拥有prototype类型的scope，但当容器将一个FXNewsBean的实例注入MockNewsPersister之后，MockNewsPersister就会一直持有这个FXNewsBean实例的引用。虽然每次输出都调用了getNewBean()方法并返回一个FXNewsBean的实例，但实际上每次返回的都是MockNewsPersister持有的容器第一次注入的实例。这就是问题之所在</strong>。</p><p><strong>换句话说，第一个实例注入后，MockNewsPersister再也没有重新想容器申请新的实例，所以容器也不会重新为其注入新的FXNewsBean类型的实例。</strong></p><p>下面就是介绍解决这个问题的方法了。</p><h3 id="方法注入"><a href="#方法注入" class="headerlink" title="方法注入"></a>方法注入</h3><p><strong>若要使用方法注入的方式，该方法必须能够被子类实现或者覆写，因为容器会为我们要进行方法注入的对象使用Cglib动态生成一个子类实现，从而代替当前对象，</strong>既然我们的getNewsBean()方法已经满足以上方法声明要求，就只需要正确配置该类了：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"newsBean"</span> <span class="attr">class</span>=<span class="string">"..domain.FXNewsBean"</span> <span class="attr">singleton</span>=<span class="string">"false"</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span> </span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"mockPersister"</span> <span class="attr">class</span>=<span class="string">"..impl.MockNewsPersister"</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">lookup-method</span> <span class="attr">name</span>=<span class="string">"getNewsBean"</span> <span class="attr">bean</span>=<span class="string">"newsBean"</span>/&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>通过&lt;lookup-method&gt;的name属性指定需要注入的方法名，bean属性指定需要注入的对象，当getNewsBean方法被调用的时候，容器可以每次返回一个新的FXNewsBean类型的实例。所以这个时候再次检查执行结果，输出的实例引用就是不同的了。</strong></p><h3 id="殊途同归"><a href="#殊途同归" class="headerlink" title="殊途同归"></a>殊途同归</h3><p>除了使用方法注入来达到“每次调用都让容器返回新的对象实例”的目的，还可以使用其他方式达到相同的目的：</p><ul><li><strong>使用BeanFactoryAware</strong>：我们知道，即使没有方法注入，只要在实现getNewsBean()方法的时候，能够保证每次调用BeanFactory的getBean(“newsBean”)，就同样可以每次都取得新的FXNewsBean对象实例。BeanFactoryAware接口就可以帮我们完成这一步，其定义如下：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BeanFactoryAware</span> </span>&#123;   </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setBeanFactory</span><span class="params">(BeanFactory beanFactory)</span> <span class="keyword">throws</span> BeansException</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>实现BeanFactoryAware接口和配置的代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MockNewsPersister</span> <span class="keyword">implements</span> <span class="title">IFXNewsPersister</span>,<span class="title">BeanFactoryAware</span> </span>&#123;  </span><br><span class="line"><span class="keyword">private</span> BeanFactory beanFactory;    </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBeanFactory</span><span class="params">(BeanFactory bf)</span> <span class="keyword">throws</span> BeansException </span>&#123;   </span><br><span class="line"><span class="keyword">this</span>.beanFactory = bf;  </span><br><span class="line">&#125;   </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">persistNews</span><span class="params">(FXNewsBean bean)</span> </span>&#123;   </span><br><span class="line">persistNews();  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">persistNews</span><span class="params">()</span> </span>&#123;   </span><br><span class="line">System.out.println(<span class="string">"persist bean:"</span>+getNewsBean());  </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> FXNewsBean <span class="title">getNewsBean</span><span class="params">()</span> </span>&#123;   </span><br><span class="line"><span class="keyword">return</span> beanFactory.getBean(<span class="string">"newsBean"</span>);</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"newsBean"</span> <span class="attr">class</span>=<span class="string">"..domain.FXNewsBean"</span> <span class="attr">singleton</span>=<span class="string">"false"</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span> </span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"mockPersister"</span> <span class="attr">class</span>=<span class="string">"..impl.MockNewsPersister"</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li><strong>使用ObjectFatoryCreatingFatoryBean</strong>：实际上ObjectFatoryCreatingFatoryBean实现了BeanFactoryAware接口，它返回的ObjectFactory实例这是特定于与Spring容器进行交互的一个实现而已。<strong>使用它的好处就是，隔离了客户端对象对BeanFactory的直接引用。</strong><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MockNewsPersister</span> <span class="keyword">implements</span> <span class="title">IFXNewsPersister</span> </span>&#123;  </span><br><span class="line"><span class="keyword">private</span> ObjectFactory newsBeanFactory;     </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">persistNews</span><span class="params">(FXNewsBean bean)</span> </span>&#123;   </span><br><span class="line">persistNews();  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">persistNews</span><span class="params">()</span>  </span>&#123;   </span><br><span class="line">System.out.println(<span class="string">"persist bean:"</span>+getNewsBean());  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="function"><span class="keyword">public</span> FXNewsBean <span class="title">getNewsBean</span><span class="params">()</span> </span>&#123;   </span><br><span class="line"><span class="keyword">return</span> newsBeanFactory.getObject();  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setNewsBeanFactory</span><span class="params">(ObjectFactory newsBeanFactory)</span> </span>&#123;   </span><br><span class="line"><span class="keyword">this</span>.newsBeanFactory = newsBeanFactory;  </span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"newsBean"</span> <span class="attr">class</span>=<span class="string">"..domain.FXNewsBean"</span> <span class="attr">singleton</span>=<span class="string">"false"</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span> </span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"newsBeanFactory"</span> <span class="attr">class</span>=<span class="string">"org.springframework.beans.factory.config.ObjectFactoryCreatingFactoryBean"</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"targetBeanName"</span>&gt;</span>   </span><br><span class="line"><span class="tag">&lt;<span class="name">idref</span> <span class="attr">bean</span>=<span class="string">"newsBean"</span>/&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span> </span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"mockPersister"</span> <span class="attr">class</span>=<span class="string">"..impl.MockNewsPersister"</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"newsBeanFactory"</span>&gt;</span>   </span><br><span class="line"><span class="tag">&lt;<span class="name">ref</span> <span class="attr">bean</span>=<span class="string">"newsBeanFactory"</span>/&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="方法替换"><a href="#方法替换" class="headerlink" title="方法替换"></a>方法替换</h3><p>基本上可以认为，方法替换可以帮助我们实现简单的方法拦截功能。假设某天我看FXNewsProvider不爽，想替换掉它的getAndPersistNews方法默认逻辑，这是我就可以用方法替换将它的原有逻辑给替换掉。</p><p>替换的方法就是实现一个叫做MethodReplacer接口，简单的实现例子如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FXNewsProviderMethodReplacer</span> <span class="keyword">implements</span> <span class="title">MethodReplacer</span> </span>&#123; </span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">transient</span> Log logger = LogFactory.getLog(FXNewsProviderMethodReplacer.class);    </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">reimplement</span><span class="params">(Object target, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;   </span><br><span class="line">logger.info(<span class="string">"before executing method["</span>+method.getName()+ <span class="string">"] on Object["</span>+target.getClass().getName()+<span class="string">"]."</span>);      </span><br><span class="line">System.out.println(<span class="string">"sorry,We will do nothing this time."</span>);    </span><br><span class="line">logger.info(<span class="string">"end of executing method["</span>+method.getName()+ <span class="string">"] on Object["</span>+target.getClass().getName()+<span class="string">"]."</span>);   </span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;   </span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来把它配置到xml文件中就可以了：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"djNewsProvider"</span> <span class="attr">class</span>=<span class="string">"..FXNewsProvider"</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">"0"</span>&gt;</span>   </span><br><span class="line"><span class="tag">&lt;<span class="name">ref</span> <span class="attr">bean</span>=<span class="string">"djNewsListener"</span>/&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">"1"</span>&gt;</span>   </span><br><span class="line"><span class="tag">&lt;<span class="name">ref</span> <span class="attr">bean</span>=<span class="string">"djNewsPersister"</span>/&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span>  </span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">replaced-method</span> <span class="attr">name</span>=<span class="string">"getAndPersistNews"</span> <span class="attr">replacer</span>=<span class="string">"providerReplacer"</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">replaced-method</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span> </span><br><span class="line"> </span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"providerReplacer"</span> <span class="attr">class</span>=<span class="string">"..FXNewsProviderMethodReplacer"</span>&gt;</span> <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><h1 id="容器加载过程"><a href="#容器加载过程" class="headerlink" title="容器加载过程"></a>容器加载过程</h1><p>先看一张IoC容器的工作框图：<img src="/posts/37871/TIM%E6%88%AA%E5%9B%BE20191018205518.png" alt></p><h2 id="两大阶段"><a href="#两大阶段" class="headerlink" title="两大阶段"></a>两大阶段</h2><p>IoC容器所起的作用就如上图所展示的那样，<strong>他会以某种方式加载Configuration MetaData（通常为XML配置文件），然后根据这些信息绑定整个系统对象，最终组装成一个可用的基于轻量级容器的应用系统。</strong></p><p>Spring的IoC容器实现以上功能的过程，基本上分为两个阶段：<strong>容器启动阶段</strong>和<strong>Bean的实例化阶段</strong>。<br><img src="/posts/37871/TIM%E6%88%AA%E5%9B%BE20191018205833.png" alt></p><h3 id="容器启动阶段"><a href="#容器启动阶段" class="headerlink" title="容器启动阶段"></a>容器启动阶段</h3><p><strong>容器启动伊始，首先会通过某种途径加载Configuration MetaData。除了代码方式比较直接，大部分情况下都会依赖于工具类BeanDefinitionReader对加载的配置文件进行解析和分析，并将分析后的信息编组为相应的BeanDefinition，最后把这些保存了bean定义必要信息的BeanDefinition，注册到相应的BeanDefinitionRegistry，</strong>这样启动阶段就完成了。<br><img src="/posts/37871/TIM%E6%88%AA%E5%9B%BE20191018210226.png" alt></p><h3 id="Bean实例化阶段"><a href="#Bean实例化阶段" class="headerlink" title="Bean实例化阶段"></a>Bean实例化阶段</h3><p><strong>该阶段，容器会首先检查所请求的对象之前是否已经实例化。如果没有，则会根据注册的BeanDefinition所提供的信息实例化被请求对象，并为其注入依赖。如果该对象实现了某些回调接口，也会根据回调接口的要求来装配它。当该对象装配完毕后，容器会立即将其返回请求方使用。</strong></p><h2 id="插手两大阶段"><a href="#插手两大阶段" class="headerlink" title="插手两大阶段"></a>插手两大阶段</h2><p><strong>Spring提供了一种叫做BeanFactoryPostProcessor的容器扩展机制，该机制允许我们在容器实例化相应对象之前，对注册到容器的BeanDefinition所保存的信息做相应的修改。这就相当于在容器第一阶段结束之后，第二阶段开始之前，加入一道工序，让我们对最终的BeanDefinition做一些额外的操作，</strong>比如修改其中bean定义的某些属性，为bean定义增加其他信息等。</p><p>如果自定义实现BeanFactoryPostProcessor，通常实现接口BeanFactoryPostProcessor就可以了，如果有多个自定义实现的类，则实现Order接口来规定它们的顺序。</p><p>但是Spring为我们提供了三种常用的已经实现好的BeanFactoryPostProcessor实现类，它们分别是 PropertyPlaceholderConfigurer、PropertyOverrideConfigurer和CustomEditorConfigure。在介绍这三种实现类之前，先需要了解它们的配置方法是什么，很简单，只需要在XML配置文件中加入以下代码即可：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">... </span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.springframework.beans.factory.config.PropertyPlaceholderConfigurer"</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"locations"</span>&gt;</span>    </span><br><span class="line"><span class="tag">&lt;<span class="name">list</span>&gt;</span>     </span><br><span class="line"><span class="tag">&lt;<span class="name">value</span>&gt;</span>conf/jdbc.properties<span class="tag">&lt;/<span class="name">value</span>&gt;</span>     </span><br><span class="line"><span class="tag">&lt;<span class="name">value</span>&gt;</span>conf/mail.properties<span class="tag">&lt;/<span class="name">value</span>&gt;</span>    </span><br><span class="line"><span class="tag">&lt;/<span class="name">list</span>&gt;</span>   </span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span>   </span><br><span class="line">... </span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="PropertyPlaceholderConfigurer"><a href="#PropertyPlaceholderConfigurer" class="headerlink" title="PropertyPlaceholderConfigurer"></a>PropertyPlaceholderConfigurer</h3><p>通常情况下，对于MySQL数据库或者Redis数据库之类的配置，为了不将这些系统管理信息相关的信息与业务对象相关的信息混杂到XML文件中，会单独把这些信息配置到一个.properties文件中。<strong>PropertyPlaceholderConfigurer允许我们在XML配置文件中使用占位符，并将这些占位符所代表的资源单独配置到见简单的properties文件中来加载，</strong>例如最常见的：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"dataSource"</span> <span class="attr">class</span>=<span class="string">"org.apache.commons.dbcp.BasicDataSource"</span> <span class="attr">destroy-method</span>=<span class="string">"close"</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"url"</span>&gt;</span>   </span><br><span class="line"><span class="tag">&lt;<span class="name">value</span>&gt;</span>$&#123;jdbc.url&#125;<span class="tag">&lt;/<span class="name">value</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"driverClassName"</span>&gt;</span>   </span><br><span class="line"><span class="tag">&lt;<span class="name">value</span>&gt;</span>$&#123;jdbc.driver&#125;<span class="tag">&lt;/<span class="name">value</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"username"</span>&gt;</span>   </span><br><span class="line"><span class="tag">&lt;<span class="name">value</span>&gt;</span>$&#123;jdbc.username&#125;<span class="tag">&lt;/<span class="name">value</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"password"</span>&gt;</span>   </span><br><span class="line"><span class="tag">&lt;<span class="name">value</span>&gt;</span>$&#123;jdbc.password&#125;<span class="tag">&lt;/<span class="name">value</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"maxActive"</span>&gt;</span>   </span><br><span class="line"><span class="tag">&lt;<span class="name">value</span>&gt;</span>100<span class="tag">&lt;/<span class="name">value</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span> </span><br><span class="line">...</span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>对应的properties文件内容则为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">jdbc.url=jdbc:mysql://server/MAIN?useUnicode=true&amp;characterEncoding=ms932&amp;failOverReadOnly=false&amp;roundRobinLoadBalance=true </span><br><span class="line">jdbc.driver=com.mysql.jdbc.Driver </span><br><span class="line">jdbc.username=your username</span><br><span class="line">jdbc.password=your password</span><br></pre></td></tr></table></figure><p><strong>基本就如上面所说的那样，当BeanFactory完成第一阶段加载完成所有配置信息之后，BeanFactory中保存的对象的属性信息还只是以占位符的形式存在，如”${jdbc.url}”。当PropertyPlaceholderConfigurer被应用时，他会使用properties配置文件中的配置信息来替换相应的BeanDefintion中占位符所表示的属性值。</strong>PropertyPlaceholderConfigurer不单会从其配置的properties文件中加载配置项，同时还会检查Java的System类中的Properties。</p><h3 id="PropertyOverrideConfigurer"><a href="#PropertyOverrideConfigurer" class="headerlink" title="PropertyOverrideConfigurer"></a>PropertyOverrideConfigurer</h3><p><strong>PropertyOverrideConfigurer的作用就是，通过它可以对容器中篇日志的任何你想处理的bean定义的property信息进行覆盖替换。</strong>比如之前的dataSource定义中，maxActive的值为100，如果我们觉得不合适，那么可以通过PropertyOverrideConfigurer将其覆盖为200：<code>dataSource.maxActive=200</code>。</p><p>如果要对容器中的某些bean定义的property信息进行覆盖，我们需要按照如下规则提供一个PropertyOverrideConfigurer使用的配置文件：<code>beanName.propertyName=value</code>。然后通过以下方法将PropertyOverrideConfigurer注册到容器即可：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.springframework.beans.factory.config.PropertyOverrideConfigurer"</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"location"</span> <span class="attr">value</span>=<span class="string">"pool-adjustment.properties"</span>/&gt;</span> </span><br><span class="line"><span class="tag">&lt; /<span class="attr">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>当容器中配置的多个PropertyOverrideConfigurer对同一个bean定义的同一个property值进行处理的时候，最后一个会生效。</strong></p><h3 id="CustomEditorConfigure"><a href="#CustomEditorConfigure" class="headerlink" title="CustomEditorConfigure"></a>CustomEditorConfigure</h3><p><strong>因为我们配置XML文件都是String类型，即容器从XML格式的文件中读取的都是字符串形式，最终应用程序却是由各种类型的对象所构成的。要想完成这种由字符串到具体对象的转换，都需要这种转换规则相关的信息，而CustomEditorConfigure就是帮我们传达类似信息的。</strong></p><h2 id="bean的生命周期"><a href="#bean的生命周期" class="headerlink" title="bean的生命周期"></a>bean的生命周期</h2><p>接下来就是第二大阶段了，即bean实例化阶段的实现逻辑。这里还需要再提一次BeanFactory和ApplicationContext对于bean加载的区别：</p><ul><li><strong>BeanFactory对象实例化默认采用延迟初始化</strong>。</li><li><strong>ApplicationContext启动之后会实例化所有的bean定义</strong>。</li></ul><p>当调用getBean()方法时，内部发现该bean定义之前还没有被实例化之后，会通过createBean()方法来进行具体的对象实例化，实例化过程如图所示：<img src="/posts/37871/TIM%E6%88%AA%E5%9B%BE20191018215127.png" alt>下面就来详细看看其中的步骤。</p><h3 id="Bean的实例化与BeanWrapper"><a href="#Bean的实例化与BeanWrapper" class="headerlink" title="Bean的实例化与BeanWrapper"></a>Bean的实例化与BeanWrapper</h3><p>容器在内部实现的时候，采用“策略模式”来决定采用何种方式初始化bean实例。通常，可以通过反射或者CGLIB动态字节码生成来初始化相应的bean实例或者动态生成其子类。</p><h4 id="第一步"><a href="#第一步" class="headerlink" title="第一步"></a>第一步</h4><p><strong>容器只要根据相应的bean定义的BeanDefintion取得实例化信息，结合CglibSubclassingInstantiationStrategy通过反射的方式，以及不同的bean定义类型，就可以返回实例化完成的对象实例。但是，返回的不是构造完成的对象实例，而是以BeanWrapper对构造完成的对象实例进行包括，返回相应的BeanWrapper实例。</strong></p><h4 id="第二步"><a href="#第二步" class="headerlink" title="第二步"></a>第二步</h4><p><strong>第一步结束后返回BeanWrapper实例而不是原先的对象实例，就是为了第二步“设置对象属性”。</strong>使用BeanWrapper对bean实例操作很方便，可以免去直接使用Java反射API操作对象实力的反锁，看一段代码就知道Spring容器内部时如何设置对象属性的了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Object provider = Class.forName(<span class="string">"package.name.FXNewsProvider"</span>).newInstance(); </span><br><span class="line">Object listener = Class.forName(<span class="string">"package.name.DowJonesNewsListener"</span>).newInstance(); </span><br><span class="line">Object persister = Class.forName(<span class="string">"package.name.DowJonesNewsPersister"</span>).newInstance();  </span><br><span class="line"></span><br><span class="line">BeanWrapper newsProvider = <span class="keyword">new</span> BeanWrapperImpl(provider); </span><br><span class="line">newsProvider.setPropertyValue(<span class="string">"newsListener"</span>, listener); </span><br><span class="line">newsProvider.setPropertyValue(<span class="string">"newPersistener"</span>, persister);</span><br></pre></td></tr></table></figure><h3 id="各色的Aware接口"><a href="#各色的Aware接口" class="headerlink" title="各色的Aware接口"></a>各色的Aware接口</h3><p><strong>当对象实例化完成后并且相关属性以及依赖设置完成之后，Spring容器会检查当前对象实例是否实现了一系列的以Aware命名结尾的接口定义，如果是，则将这些Aware接口定义中规定的依赖注入给当前对象实例。</strong>下面介绍几个重要的Aware接口：</p><ul><li><strong>ApplicationContextAware</strong>: 获得ApplicationContext对象,可以用来获取所有Bean definition的名字。</li><li><strong>BeanFactoryAware</strong>:获得BeanFactory对象，可以用来检测Bean的作用域。</li><li><strong>BeanNameAware</strong>:获得Bean在配置文件中定义的名字。</li><li><strong>ResourceLoaderAware</strong>:获得ResourceLoader对象，可以获得classpath中某个文件。</li><li><strong>ServletContextAware</strong>:在一个MVC应用中可以获取ServletContext对象，可以读取context中的参数。</li><li><strong>ServletConfigAware</strong>： 在一个MVC应用中可以获取ServletConfig对象，可以读取config中的参数。</li></ul><h3 id="BeanPostProcessor"><a href="#BeanPostProcessor" class="headerlink" title="BeanPostProcessor"></a>BeanPostProcessor</h3><p>BeanPostProcessor会处理容器内所有符合条件的实例化后的对象实例，该接口声明了两个方法，分别在不同的时机执行：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BeanPostProcessor</span>  </span>&#123;  </span><br><span class="line"><span class="function">Object <span class="title">postProcessBeforeInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException</span>; </span><br><span class="line"><span class="function">Object <span class="title">postProcessAfterInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>postProcessBeforeInitialization()方法是上图中BeanPostProcessor前置处理这一步将会执行的方法，postProcessAfterInitialization()则是对应图中BeanPostProcessor后置处理那一步将会执行的方法。</strong>BeanPostProcessor的两个方法中都传入了原来的对象实例的引用，这位我们操作扩展容器的对象实例化过程中的行为提供了极大的便利。</p><h3 id="InitializingBean和init-method"><a href="#InitializingBean和init-method" class="headerlink" title="InitializingBean和init-method"></a>InitializingBean和init-method</h3><p>InitializingBean是容器内部广泛使用的一个对象生命周期表示接口，其定义如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">InitializingBean</span> </span>&#123;   </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">afterPropertiesSet</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>其作用在于，在对象实例化过程调用过“BeanPostProcessor”的前置处理之后，会接着检测当前对象是否实现了InitializingBean接口，如果是，则回到调用其afterPropertiesSet()方法进一步调整对象实例的状态。</strong></p><p><strong>通过init-method，系统中业务对象的自定义初始化操作可以以任何方式命名。而不再受制于InitializingBean的afterPropertiesSet()。</strong>在自己定义init方法后，只需要在XML文件中简单配置一下就好了：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"tradeDateCalculator"</span> <span class="attr">class</span>=<span class="string">"FXTradeDateCalculator"</span> <span class="attr">init-method</span>=<span class="string">"setupHolidays"</span> &gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">constructor-arg</span>&gt;</span>    </span><br><span class="line"><span class="tag">&lt;<span class="name">ref</span> <span class="attr">bean</span>=<span class="string">"sqlMapClientTemplate"</span>/&gt;</span>   </span><br><span class="line"><span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"sqlMapClientTemplate"</span> <span class="attr">class</span>=<span class="string">"org.springframework.orm.ibatis.SqlMapClientTemplate"</span>&gt;</span>   </span><br><span class="line">...  </span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span>    </span><br><span class="line">... </span><br><span class="line"><span class="tag">&lt; /<span class="attr">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这样FXTradeDateCalculator类中的setupHolidays方法就是会在该阶段执行的方法了。</p><h3 id="DisposableBean与destroy-method"><a href="#DisposableBean与destroy-method" class="headerlink" title="DisposableBean与destroy-method"></a>DisposableBean与destroy-method</h3><p><strong>当所有的一切，该设置的设置，该注入的注入，该调用的调用之后，容器将检查singleton类型的bean实例，看其是否实现了DisposableBean接口。或者其对应的bean定义是否通过&lt;bean&gt;的destroy-method属性制定了自定义的对象销毁方法，如果是，就会为该实例注册一个用于对象销毁的回调，以及在这些singleton类型的对象实例销毁之前，执行销毁逻辑。</strong></p><p><strong>不过这些自定义的对象销毁逻辑，在对象实例初始化完成并注册了相关的回调方法之后，并不会马上执行。回调方法注册后，在使用完成后，只有在执行回调方法之后，才会执行销毁操作。</strong></p><p>对于BeanFactory注册回调方法的方式为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">((ConfigurableListableBeanFactory)container).destroySingletons();</span><br></pre></td></tr></table></figure><p>对于ApplicationContext注册回调方法的方式为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">((AbstractApplicationContext)container).registerShutdownHook();</span><br></pre></td></tr></table></figure><p>至此为止，bean就算走完了它在容器中“光荣”的一生。</p>]]></content>
    
    <summary type="html">
    
      根据之前说过的，Spring的IoC容器是一个IoC Service Provider，但是我们只是知道了IoC Service Provider是什么，还不是知道其“庐山真面目”中的“容器”到底是什么，这里就介绍IoC容器之中一BeanFactory。
    
    </summary>
    
      <category term="Spring" scheme="http://yoursite.com/categories/Spring/"/>
    
    
  </entry>
  
  <entry>
    <title>IoC容器和IoC Service Provider</title>
    <link href="http://yoursite.com/posts/10510/"/>
    <id>http://yoursite.com/posts/10510/</id>
    <published>2019-10-10T11:21:28.000Z</published>
    <updated>2019-10-10T13:57:50.132Z</updated>
    
    <content type="html"><![CDATA[<h1 id="IoC的基本概念"><a href="#IoC的基本概念" class="headerlink" title="IoC的基本概念"></a>IoC的基本概念</h1><p>Ioc的作用简单说就是创建对象由以前的程序员自己new构造方法来调用，变成了交由Spring创建对象。举个例子，出门之前得先穿件外套吧？以前，你得自己跑到衣柜面前取出衣服这一依赖对象，然后自己穿上再出门。而现在，你只要跟你的“另一半”使个眼色或者一句话，她就会心领神会地到衣柜那里为你取出衣服，然后再给你穿上，现在你就可以出门了。<img src="/posts/10510/TIM%E6%88%AA%E5%9B%BE20191010194249.png" alt></p><p>通常情况下，被注入对象会直接依赖于被依赖对象。但是，在IoC的场景中，二者之间通过IoC Service Provider（例子中你的另一半）来打交道，素有的被注入对象和依赖对象现在由IoC Service Provider统一管理。被注入对象需要什么，直接跟IoC Service Provider招呼一声，后者就会把相应的被依赖对象注入到被注入对象中。<img src="/posts/10510/TIM%E6%88%AA%E5%9B%BE20191010194655.png" alt></p><h2 id="依赖注入的方式"><a href="#依赖注入的方式" class="headerlink" title="依赖注入的方式"></a>依赖注入的方式</h2><p>IoC有三种依赖注入的方式，即<strong>构造方法注入、setter方法注入以及接口注入</strong>。</p><h3 id="构造方法注入"><a href="#构造方法注入" class="headerlink" title="构造方法注入"></a>构造方法注入</h3><p>构造方法注入，就是<strong>被注入对象可以通过在其构造方法中声明依赖对象的参数列表，让外部（通常是Ioc容器）知道它需要哪些依赖对象</strong>，例子如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">FXNewsProvider</span><span class="params">(IFXNewsListener newsListner,IFXNewsPersister newsPersister&#123;  </span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">this</span>.newsListener = newsListner;  </span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">this</span>.newPersistener = newsPersister; </span></span></span><br><span class="line"><span class="function"><span class="params">&#125;</span></span></span><br></pre></td></tr></table></figure><p>IoC Service Provider会检查被注入对象的构造方法，取得它所需要的依赖对象列表，进而为其注入相应的对象。<strong>同一个对象是不可能被构造两次的，因此，被注入对象的构造乃至整个生命周期，应该是由IoC Service Provider来管理的。</strong></p><p>构造方法注入方式比较直观，<strong>对象被构造完，即进入就绪状态，可以马上使用。</strong></p><h3 id="setter方法注入"><a href="#setter方法注入" class="headerlink" title="setter方法注入"></a>setter方法注入</h3><p>对应Java Bean对象来说，通过setter方法，可以更改相应的对象属性；通过getter方法，可以获得相应属性的状态。所以当前对象只要为其依赖对象所对应的属性添加setter方法，就可以<strong>通过setter方法将相对应的依赖对象设置到被注入对象中。</strong>。例子如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FXNewsProvider</span> </span>&#123;  </span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> IFXNewsListener  newsListener;  </span><br><span class="line"><span class="keyword">private</span> IFXNewsPersister newPersistener;    </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> IFXNewsListener <span class="title">getNewsListener</span><span class="params">()</span> </span>&#123;   </span><br><span class="line"><span class="keyword">return</span> newsListener;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setNewsListener</span><span class="params">(IFXNewsListener newsListener)</span> </span>&#123;   </span><br><span class="line"><span class="keyword">this</span>.newsListener = newsListener;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="function"><span class="keyword">public</span> IFXNewsPersister <span class="title">getNewPersistener</span><span class="params">()</span> </span>&#123;   </span><br><span class="line"><span class="keyword">return</span> newPersistener;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setNewPersistener</span><span class="params">(IFXNewsPersister newPersistener)</span> </span>&#123;   </span><br><span class="line"><span class="keyword">this</span>.newPersistener = newPersistener;  </span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样外界就可以通过调用setNewsListener和setNewPersistener方法为FXNewsProvider对象注入所依赖的对象了。</p><p><strong>setter方法注入相对更宽松一些，可以在对象构造完成后在诸如。</strong></p><h3 id="接口注入"><a href="#接口注入" class="headerlink" title="接口注入"></a>接口注入</h3><p>相对于前两种方式来说，接口注入就没有那么简单明了了。<strong>被注入对象如果想要IoC Service Provider为其注入依赖对象，就必须实现某个接口。这个接口提供一个方法，用来为其注入依赖对象。</strong></p><p><img src="/posts/10510/TIM%E6%88%AA%E5%9B%BE20191010200755.png" alt></p><p>如上图，FXNewsProvider为了让IoC Service Provider为其注入所依赖的IFXNewsListener，首先需要实现IFXNewsListenerCallable接口，这个接口会声明一个injectNewsListner方法（方法名随意），该方法的参数，就是所依赖对象的类型。这样，InjectionServiceContainer对象，即对应IoC Service Provider就可以通过这个接口方法将依赖对象注入到被注入对象FXNewsProvider中。</p><p>相对于前两种依赖注入方式，<strong>接口注入比较死板和繁琐。如果需要注入依赖对象，被注入对象就必须声明和实现另外的接口。</strong></p><h3 id="三种注入方式比较"><a href="#三种注入方式比较" class="headerlink" title="三种注入方式比较"></a>三种注入方式比较</h3><ul><li><strong>接口注入</strong>：从使用上来说，<strong>接口注入是现在不提倡的一种方式，因为它强制被注入对象实现不必要的接口，带有侵入性。</strong>而构造方法注入和setter方法注入则不需要如此。</li><li><strong>构造方法注入</strong>：这种注入方法的<strong>优点就是，对象在构造完后，即进入就绪状态，可以马上使用。**</strong>缺点就是，当依赖对象比较多的时候，构造方法的参数列表会比较长。而通过反射构造对象的时候，对相同类型的参数的处理会比较困难，维护和使用上也比较麻烦。而且在Java方法中，构造方法无法被继承，无法设置默认值。对于非必须的依赖处理，可能需要引入多个构造方法，而参数列表的变动可能造成维护上的不便。**</li><li><strong>setter方法注入</strong>：因为方法可以命名，所以setter方法注入在描述上要比构造方法注入好一些。另外<strong>setter方法可以被继承，允许设置默认值，而且有良好IDE支持。缺点就是对象无法再构造完成马上进入就绪状态。</strong></li></ul><h1 id="IoC-Service-Provider简介"><a href="#IoC-Service-Provider简介" class="headerlink" title="IoC Service Provider简介"></a>IoC Service Provider简介</h1><p>Ioc Service Provider是一个抽象出来的概念，它可以指代任何将IoC场景中的业务对象绑定到一起的实现方式。它可以是一段代码，也可以是一组相关的类，甚至可以是比较通用的IoC框架或者IoC容器。</p><h2 id="Ioc-Service-Provider的职责"><a href="#Ioc-Service-Provider的职责" class="headerlink" title="Ioc Service Provider的职责"></a>Ioc Service Provider的职责</h2><p>IoC Service Provider的职责相对来说比较简单，主要有两个：<strong>业务对象的构建管理和业务对象间的依赖绑定。</strong></p><ul><li><strong>业务对象的构建管理</strong>：在IoC场景中，业务对象无需关心所依赖的对象如何构建如何取得，但这部分工作始终需要有人来做，所以IoC Service Provider需要将对象的构建逻辑从客户端对象那里剥离出来，以免这部分逻辑污染业务对象的实现。</li><li><strong>业务对象间的绑定</strong>：Ioc Service Provider通过结合之前构建和管理的所有业务对象，以及各个业务对象间可以识别的依赖关系，<strong>将这些对象所依赖的对象注入绑定，从而保证每个业务对象在使用的时候，可以处于就绪状态。</strong></li></ul><h2 id="IoC-Service-Provider如何管理对象间的依赖关系"><a href="#IoC-Service-Provider如何管理对象间的依赖关系" class="headerlink" title="IoC Service Provider如何管理对象间的依赖关系"></a>IoC Service Provider如何管理对象间的依赖关系</h2><p>介绍归纳当前流行的IoC Service Provider产品使用的注册对象管理信息的方式主要有以下几种。</p><h3 id="直接编码方式"><a href="#直接编码方式" class="headerlink" title="直接编码方式"></a>直接编码方式</h3><p>当前大部分的IoC容器都应该支持直接编码方式，包括Spring。<strong>在容器启动之前，我们就可以通过程序编码的方式将被注入对象和依赖对象注册到容器中，并明确它们相互之间的依赖注入关系。</strong>下面代码演示了这样的一个过程：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">IoContainer container = ...;</span><br><span class="line">container.register(FXNewsProvider.class,<span class="keyword">new</span> FXNewsProvider());</span><br><span class="line">container.register(IFXNewsListener.class,<span class="keyword">new</span> DowJonesNewsListener());</span><br><span class="line">... </span><br><span class="line"></span><br><span class="line">FXNewsProvider newsProvider = (FXNewsProvider)container.get(FXNewsProvider.class); </span><br><span class="line">newProvider.getAndPersistNews();</span><br></pre></td></tr></table></figure><p>通过为相应的类指定对应的具体实例，可以告知IoC容器，当我们要这种类型的对象实例时，请将容器中注册的、对应的那个具体实例返回给我们。</p><p>如果是接口注入方式，可能伪代码要多一些，但是本质的道理上是一样的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">IoContainer container = ...;</span><br><span class="line">container.register(FXNewsProvider.class,<span class="keyword">new</span> FXNewsProvider()); </span><br><span class="line">container.register(IFXNewsListener.class,<span class="keyword">new</span> DowJonesNewsListener());</span><br><span class="line">... </span><br><span class="line"></span><br><span class="line">container.bind(IFXNewsListenerCallable.class, container.get(IFXNewsListener.class));</span><br><span class="line">... </span><br><span class="line"></span><br><span class="line">FXNewsProvider newsProvider = (FXNewsProvider)container.get(FXNewsProvider.class);  </span><br><span class="line">newProvider.getAndPersistNews();</span><br></pre></td></tr></table></figure><p>通过bind方法将“被注入对象”所依赖的对象，绑定为容器中注册过的IFXNewsListener类型的对象实例。</p><h3 id="配置文件方式"><a href="#配置文件方式" class="headerlink" title="配置文件方式"></a>配置文件方式</h3><p>这是一种较为普遍的依赖注入关系管理方式，像properties文件、XML文件等，都可以成为管理依赖注入关系的载体，其中最为常见的就是XML文件的方式。代码例子如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"newsProvider"</span> <span class="attr">class</span>=<span class="string">"..FXNewsProvider"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"newsListener"</span>&gt;</span>   </span><br><span class="line"><span class="tag">&lt;<span class="name">ref</span> <span class="attr">bean</span>=<span class="string">"djNewsListener"</span>/&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"newPersistener"</span>&gt;</span>   </span><br><span class="line"><span class="tag">&lt;<span class="name">ref</span> <span class="attr">bean</span>=<span class="string">"djNewsPersister"</span>/&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span> </span><br><span class="line"> </span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"djNewsListener"</span>   <span class="attr">class</span>=<span class="string">"..impl.DowJonesNewsListener"</span>&gt;</span> <span class="tag">&lt;/<span class="name">bean</span>&gt;</span> </span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"djNewsPersister"</span>   <span class="attr">class</span>=<span class="string">"..impl.DowJonesNewsPersister"</span>&gt;</span> <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>最后，在代码中通过“newProvider”这个名字，即可从容器中取得已经组装好的FXNewsProvider并直接使用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">... </span><br><span class="line">container.readConfigurationFiles(...); </span><br><span class="line">FXNewsProvider newsProvider = (FXNewsProvider)container.getBean(<span class="string">"newsProvider"</span>); </span><br><span class="line">newsProvider.getAndPersistNews();</span><br></pre></td></tr></table></figure><h3 id="元数据方式"><a href="#元数据方式" class="headerlink" title="元数据方式"></a>元数据方式</h3><p>这种方式使用Google Guice实现的一种注解方式，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FXNewsProvider</span> </span>&#123;  </span><br><span class="line"><span class="keyword">private</span> IFXNewsListener  newsListener;  </span><br><span class="line"><span class="keyword">private</span> IFXNewsPersister newPersistener;  </span><br><span class="line"></span><br><span class="line"><span class="meta">@Inject</span> <span class="number">5</span>  </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">FXNewsProvider</span><span class="params">(IFXNewsListener listener,IFXNewsPersister persister)</span></span>&#123;   </span><br><span class="line"><span class="keyword">this</span>.newsListener   = listener;   </span><br><span class="line"><span class="keyword">this</span>.newPersistener = persister;   </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line">... </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>通过@Inject，我们指明需要IoC Service Provider通过构造方法注入方式，为FXNewsProvider注入其所依赖的对象。</strong>至于余下的依赖信息，在Guice中是由相应的Module来提供的。下面是FXNewsProvider所使用的Module实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NewsBindingModule</span> <span class="keyword">extends</span> <span class="title">AbstractModule</span>  </span>&#123;  </span><br><span class="line"><span class="meta">@Override</span>  </span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">()</span> </span>&#123;    </span><br><span class="line">bind(IFXNewsListener.class) ➥   </span><br><span class="line">.to(DowJonesNewsListener.class).in(Scopes.SINGLETON);   </span><br><span class="line">bind(IFXNewsPersister.class) ➥   </span><br><span class="line">.to(DowJonesNewsPersister.class).in(Scopes.SINGLETON);  </span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过Module指定进一步的依赖注入相关信息之后，就可以直接从Guice那里取得最终已经注入完毕，并且直接可用的对象了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Injector injector = Guice.createInjector(<span class="keyword">new</span> NewsBindingModule()); </span><br><span class="line">FXNewsProvider newsProvider = injector.getInstance(FXNewsProvider.class); </span><br><span class="line">newsProvider.getAndPersistNews();</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      Ioc的全称为Inversion of Control，中文通常翻译为“控制反转”，他还有一个别名叫做依赖注入（Dependency Injection）。好莱坞原则“Don&#39;t call us,we will call you”恰如其分地表达了“反转”的意味。
    
    </summary>
    
      <category term="Spring" scheme="http://yoursite.com/categories/Spring/"/>
    
    
  </entry>
  
  <entry>
    <title>查询性能优化</title>
    <link href="http://yoursite.com/posts/39035/"/>
    <id>http://yoursite.com/posts/39035/</id>
    <published>2019-09-26T13:10:55.000Z</published>
    <updated>2019-09-30T13:23:19.072Z</updated>
    
    <content type="html"><![CDATA[<h1 id="为什么查询速度会慢"><a href="#为什么查询速度会慢" class="headerlink" title="为什么查询速度会慢"></a>为什么查询速度会慢</h1><p>在尝试编写快速的查询之前，需要清楚的一点就是，真正重要的是响应时间。如果把查询看作是一个任务，那么它由一系列子任务组成，每个字任务都会消耗一定的时间。如果要优化查询，实际上要优化其子任务，要么消除其中一些子任务，要么减少子任务的执行次数，要么让子任务运行的更快。</p><p>通常来说，<strong>查询的生命周期大致可按照顺序来看：从客户端，到服务器，然后在服务器上进行解析，生成执行计划，执行，并返回结果给客户端。</strong>其中“执行”可以认为是整个生命周期中最重要的阶段，这其中包括了大量为了检索数据到存储引擎的调用以及调用后的数据处理，包括排序、分组等。 对于一个查询的全部生命周期，上面列的并不完整，这里只是想说明，了解查询的生命周期，清楚查询的时间消耗情况对于优化查询有很大的意义。</p><h1 id="慢查询基础：优化数据访问"><a href="#慢查询基础：优化数据访问" class="headerlink" title="慢查询基础：优化数据访问"></a>慢查询基础：优化数据访问</h1><p>查询性能低下最基本的原因是访问的数据太多，大部分性能低下的查询都可以通过减少访问的数据量的方式进行优化。对于低效的查询，通过下面两个步骤来分析总是很有效的：</p><ul><li>确认应用程序是否在检索大量超过需要的数据。这通常意味着访问了太多的行，但有时候也有可能是访问了太多的列。</li><li>确认MySQL服务器是否在分析大量超过需要的数据行。</li></ul><h2 id="是否向数据库请求了不需要的数据"><a href="#是否向数据库请求了不需要的数据" class="headerlink" title="是否向数据库请求了不需要的数据"></a>是否向数据库请求了不需要的数据</h2><p>有些查询会请求超过实际需要的数据，然后这些多余的数据会被应用程序丢弃，这会给MySQL服务器带来额外的负担，并增加网络开销，另外也会消耗应用服务器的CPU和内存资源。下面是一些典型的案例：</p><ul><li><strong>查询不需要的记录：</strong>一个常见的错误是常常会误以为MySQL会只返回需要的数据，实际上MySQL确实先返回全部结果集再进行计算。最简单有效的解决方法就是在这样的查询后面加上LIMIT。</li><li><strong>多表关联时返回全部列：</strong>例如你想查询所有在电影Academy Dinosaur中出现的演员，千万不要下面这种写法编写查询：<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> actor</span><br><span class="line"><span class="keyword">INNER</span> <span class="keyword">JOIN</span> film_actor <span class="keyword">USING</span>(actor_id)</span><br><span class="line"><span class="keyword">INNER</span> <span class="keyword">JOIN</span> film <span class="keyword">USING</span>(film_id)</span><br><span class="line"><span class="keyword">WHERE</span> fime.title = <span class="string">'Academy Dinosaur'</span>;</span><br></pre></td></tr></table></figure></li></ul><p><strong>这将返回这三个表的全部数据列。</strong>正确的方式应该是像下面这样只取需要的列：<code>SELECT actor.* FROM actor...</code>。</p><ul><li><strong>总是取出全部列：</strong>每次看到SELECT * 的时候都需要用怀疑的眼光审视，是不是真的需要返回全部的列？这无疑会增加额外的消耗。但是如果这种有点浪费数据库资源的方式可以简化开发，因为提高相同代码片段的复用性，如果清楚这样做的性能影响，那么这种做法也是值得考虑的。如果应用程序使用了某种缓存机制也可以，获取并缓存所有的列的查询，相比多个独立的只获取部分列的查询可能就更有好处。</li><li><strong>重复查询相同的数据：</strong>如果不断地重复执行相同的查询，然后每次都返回相同的数据，这样是完全没有必要的。比较好的方案是，当初次查询的时候将这个数据缓存起来，需要的时候从缓存中取出，这样的性能显然会更好。</li></ul><h2 id="MySQL是否在扫描额外的记录"><a href="#MySQL是否在扫描额外的记录" class="headerlink" title="MySQL是否在扫描额外的记录"></a>MySQL是否在扫描额外的记录</h2><p>在确定查询只返回需要的数据以后，接下来该看看查询为了返回结果是否扫描了过多的数据。对于MySQL，最简单的衡量查询开销的三个指标如下：</p><blockquote><ul><li>响应时间</li><li>扫描的行数</li><li>返回的行数</li></ul></blockquote><h3 id="响应时间"><a href="#响应时间" class="headerlink" title="响应时间"></a>响应时间</h3><p>响应时间只是一个表面上的值，但是响应时间仍然是最重要的指标。响应时间是两个部分之和：<strong>服务时间</strong>和<strong>排队时间</strong>。<strong>服务时间是指数据库处理这个查询真正花了多长时间；排队时间是指服务器因为等待某些资源而没有真正执行查询的时间，一般最常见和重要的是I/O等待和锁等待。</strong></p><p>当你看到一个查询的响应时间的时候，首先需要问问自己，这个响应时间是否是一个合理的值。实际上可以使用“快速上限估计”法来估算查询的响应时间，概括地说，了解这个查询需要哪些索引以及它的执行计划是什么，然后计算大概需要多少个顺序和随机I/O，再用其乘以在具体硬件条件下一次I/O的消耗时间，最后把这些消耗都加起来，就可以获得一个大概参考值来判断当前响应时间是不是一个合理的值。</p><h3 id="扫描的行数和返回的行数"><a href="#扫描的行数和返回的行数" class="headerlink" title="扫描的行数和返回的行数"></a>扫描的行数和返回的行数</h3><p>分析查询时，查看该查询扫描的行数是非常有效的，这在一定程度上能说明该查询找到需要的数据和效率高不高。并不是所有的行的访问代价都是相同的，较短的行的访问速度更快，内存中的行比磁盘中的行的访问速度要快得多。</p><p>理想情况下扫描的行数和返回的行数应该是相同的，但实际中这种情况并不多，扫描的行数对返回的行数的比率通常很小，一般在1：1和10：1之间，不过有时候这个值也可能非常大。</p><h3 id="扫描的行数和访问类型"><a href="#扫描的行数和访问类型" class="headerlink" title="扫描的行数和访问类型"></a>扫描的行数和访问类型</h3><p>在评估查询开销的时候，需要考虑一下从表中找到某一行数据的成本。MySQL的好几种访问类型，有些方式可能需要扫描很多行才能返回一行，也有些方式可能无需扫描就能返回结果。</p><p>在EXPLAIN语句中的type列反应了访问类型，访问类型有很多种，<strong>从全表扫描到索引扫描、范围扫描、唯一索引查询、常数索引等，这里列的这些，速度是从慢到快，扫描的行数也是从多到少的。</strong></p><p><strong>如果查询没有办法找到合适的访问类型，那么解决的最好办法通常就是增加一个合适的索引</strong>，索引让MySQL以最高效、扫描行数最少的访问找到需要的记录。</p><p>一般MySQL能够使用如下三种方式应用WHERE条件，<strong>从好到坏依次为</strong>：</p><ul><li><strong>在索引中使用WHERE条件来过滤不匹配的记录。这是在存储引擎层完成的。</strong></li><li><strong>使用索引覆盖扫描（在Extra中出现了Using index）来返回记录，</strong>直接从索引中过滤不需要的记录并返回命中的结果。这是在MySQL服务层完成的，但无须再回表查询记录。</li><li>从数据表中返回数据，然后过滤不满足条件的记录（在Extra列中出现Using Where）。这在MySQL服务器层完成，MySQL需要先从数据表读出记录然后过滤。</li></ul><p>好的索引很重要，可以让查询使用合适的访问类型，尽可能的只扫描需要的数据行，但也不是说增加索引就能让扫描的行数等于返回的行数。如果发现查询需要扫描大量的数据但只返回少数的行，那么通常可以尝试下面的技巧去优化：</p><ul><li><strong>使用索引覆盖扫描</strong>，把所有需要用的列都放到索引中，这样存储引擎就无须回表获取对应行就可以返回结果了。</li><li><strong>改变库表结构</strong>，例如使用单独的汇总表。</li><li><strong>重写这个复杂的查询</strong>，让MySQL优化器能以更优化的方式执行这个查询。</li></ul><h1 id="重构查询的方式"><a href="#重构查询的方式" class="headerlink" title="重构查询的方式"></a>重构查询的方式</h1><p>在优化有问题的查询时，目标应该是找到一个更优的方法获得实际需要的结果，而不一定总是需要从MySQL获取一模一样的结果集，有时可以将查询转换一种写法让其返回一样的结果，但是性能更好。</p><h2 id="一个复杂查询还是多个简单查询"><a href="#一个复杂查询还是多个简单查询" class="headerlink" title="一个复杂查询还是多个简单查询"></a>一个复杂查询还是多个简单查询</h2><p>在传统实现中，总是强调需要数据库层完成尽可能多的工作，这样做的逻辑在于以前总是认为网络通信、查询解析和优化时是一件代价很高的事情。但是这样的想法对于MySQL并不适用，MySQL从设计上让连接和断开连接都很轻量级，在返回一个小的查询结果方面很高效。</p><p>MySQL内部每秒能扫描内存中上百万行数据，相比之下，MySQL响应数据给客户端就慢得多了。在其他条件都相同的时候，使用尽可能少的查询当然是最好的。但是有时候将一个大查询分解为多个小查询是很有必要的。</p><h2 id="切分查询"><a href="#切分查询" class="headerlink" title="切分查询"></a>切分查询</h2><p>有时候对于一个大查询我们需要“分而治之”，将大查询切分成小查询，每个查询功能完全一样，只完成一小部分，每次只返回一小部分查询结果。</p><p>例如在删除旧的数据时，定期清除大量数据时，如果用一个大的语句一次性完成的话，则可能需要一次锁住很多数据，占满整个事务日志，耗尽系统资源、阻塞很多小的但是重要的查询。将一个大的DELETE语句切分成多个较小的查询可以尽可能小的影响MySQL性能，同时还可以减少MySQL复制的延迟。例如我们可以每次只删除一部分数据，每次删除数据后都暂停一会在做下一次删除，这样也<strong>可以将服务器上原本一次性的压力分散到一个很长的时间段中，就可以大大降低对服务器的影响，还可以大大减少删除时锁的持有时间。</strong></p><h2 id="分解关联查询"><a href="#分解关联查询" class="headerlink" title="分解关联查询"></a>分解关联查询</h2><p>很多高性能的应用都会对关联查询进行分解，简单地，可以对每一个表进行一次单表查询，然后将结果在应用程序中进行关联。例如下面这个查询：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> tag </span><br><span class="line"><span class="keyword">JOIN</span> tag_post <span class="keyword">ON</span> tag_post.tag_id = tag.id</span><br><span class="line"><span class="keyword">JOIN</span> post <span class="keyword">ON</span> tag_post.post_id = post.id</span><br><span class="line"><span class="keyword">WHERE</span> tag.tag = <span class="string">'mysql'</span>;</span><br></pre></td></tr></table></figure><p>可以分解成下面这些语句来代替：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> tag <span class="keyword">WHERE</span> tag = <span class="string">'mysql'</span>;</span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> tag_post <span class="keyword">WHERE</span> tag_id = <span class="number">1234</span>;</span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> post <span class="keyword">WHERE</span> post.id <span class="keyword">in</span>(<span class="number">123</span>,<span class="number">456</span>,<span class="number">567</span>,<span class="number">9098</span>,<span class="number">8904</span>);</span><br></pre></td></tr></table></figure><p>用分解关联查询有如下优势：</p><ul><li><strong>让缓存的效率更高。</strong>许多应用程序可以方便地缓存单表查询对应的结果对象，对MySQL的查询缓存来说，如果关联中的某个表发生了变化，那么就无法使用查询缓存了，而拆分后，如果某个表很少改变，那么基于该表的查询就可以重复利用查询缓存结果了。</li><li><strong>将查询分解后，执行单个查询可以减少锁的竞争。</strong></li><li><strong>在应用层做关联，可以更容易对数据库进行拆分，更容易做到高性能和可扩展。</strong></li><li><strong>查询本身效率也可能会有所提升</strong>，例如用IN()代替关联查询，可以让MySQL按照ID顺序进行查询，这可能比随机的关联更高效。</li><li><strong>可以减少冗余记录的查询。</strong>在应用层做关联查询，意味着对于某条记录应用只需要查询一次，而在数据库中做关联查询，则可能需要重复地访问一部分数据，所以这样的重构还可能会减少网络和内存的消耗。</li><li>更进一步，<strong>这样相对于在应用中实现了哈希关联，而不是使用MySQL的嵌套循环关联。</strong></li></ul><p>在很多场景下，通过重构查询将关联放在应用程序中将会更加高效，比如：当应用能够方便的缓存单个查询的结果的时候、当可以将数据分不到不同的MySQL服务器上的时候、当能够使用IN（）的方式代替关联查询的时候、当查询中使用同一个数据表的时候。</p><h1 id="查询执行的基础"><a href="#查询执行的基础" class="headerlink" title="查询执行的基础"></a>查询执行的基础</h1><p>下图可以看出当向MySQL发送一个请求的时候，MySQL到底做了些什么：<img src="/posts/39035/SQLRunProcess.png" alt></p><ol><li>客户端先发送一条查询给服务器。</li><li>服务器先检查缓存，<strong>如果命中缓存，则立刻返回存储在缓存中的结果。</strong>否则进入下一阶段。</li><li><strong>服务端进行SQL解析、预处理，再由优化器生成对应的执行计划。</strong></li><li><strong>MySQL根据优化器生成的执行计划，调用存储引擎的API来执行查询。</strong></li><li>将结果返回给客户端。</li></ol><h2 id="MySQL客户端-服务器通信协议"><a href="#MySQL客户端-服务器通信协议" class="headerlink" title="MySQL客户端/服务器通信协议"></a>MySQL客户端/服务器通信协议</h2><p>MySQL客户端和服务器之间的通信协议是<strong>半双工</strong>的，这意味着，在任何一个时刻，要么是由服务器向客户端发送数据，要么是由客户端向服务器发送数据，这两个动作不能同时发生。所以，<strong>无法也无需将一个消息切成小块独立来发送。</strong>这种协议虽然让MySQL通信简单快速，但是一个明显的限制就是<strong>没法进行流量控制</strong>，一旦一端开始发送消息，另一端要接收完整个消息才能响应它。即一旦客户端发送了请求，它能做的事情就只是等待结果了。</p><p>相反的，一般服务器相应给客户的数据很多，由多个数据包组成。当服务器开始响应客户端请求时，客户端必须完整地接收整个返回结果，而不能简单地只取几条结果。这也是在必要时侯一定要在查询中加上LIMIT限制的原因。</p><p>多数连接MySQL的库函数都可以获得全部结果集并缓存到内存里，还可以逐行获取需要的数据。默认一般是获得全部结果集并缓存到内存中。MySQL通常需要等所有的数据都已经发送给客户端才能释放这条查询所占用的资源，所以接受全部结果并缓存通常可以减少服务器的压力，早点释放相应的资源。</p><h3 id="查询状态"><a href="#查询状态" class="headerlink" title="查询状态"></a>查询状态</h3><p>对于一个MySQL连接，或者说一个线程，任何一个时刻都有一个状态，该状态标识了MySQL当前正在做什么。最简单的查看方式是使用SHOW FULL PROCESSLIST命令，在一个查询生命周期中的状态有这么几种：</p><ul><li><strong>Sleep</strong>：线程正在等待客户端发送新的请求。</li><li><strong>Query</strong>：线程正在执行查询或者正在将结果发送给客户端。</li><li><strong>Locked</strong>：在MySQL服务层，该线程正在等待表锁。<strong>在存储引擎级别实现的锁，例如InnoDB的行锁并不会体现在线程装态中。</strong>对于MyISAM来说这是一个比较典型的状态，但在其他没有行锁的引擎中也会经常出现。</li><li><strong>Analyzing and statistics</strong>：线程正在收集存储引擎的统计信息，并生成查询的执行计划。</li><li><strong>Copying to tmp table [on disk]</strong>：线程正在执行查询，并且将其结果集都复制到一个临时表中，<strong>这种状态一般要么是在做GROUP BY操作，要么是文件排序操作，或者UNION操作。</strong>如果这个状态后面还有“on disk”标记，那么表示MySQL正在将一个内存临时表放在磁盘上。</li><li><strong>Sorting result</strong>：线程正在对结果集进行排序。</li><li><strong>Sending data</strong>：这种情况下线程可能在多个状态之间传送数据，或者在生成结果集，或者在向客户端返回数据。</li></ul><h2 id="查询缓存"><a href="#查询缓存" class="headerlink" title="查询缓存"></a>查询缓存</h2><p><strong>在解析一个查询语句之前，如果查询缓存是打开的，那么MySQL会优先检查这个查询是否命中查询缓存的数据。这个查询时通过一个对大小写敏感的哈希查找实现的。</strong></p><p><strong>如果当前查询恰好命中查询缓存，那么在返回查询结果之前MySQL会检查一次用户权限。</strong>这仍然是无须解析查询SQL语句的。如果没有权限问题，MySQL会直接从缓存中拿到结果并返回给客户端。这总情况下，查询不会解析，不用生成执行计划，不会被执行。</p><h2 id="查询优化处理"><a href="#查询优化处理" class="headerlink" title="查询优化处理"></a>查询优化处理</h2><p><strong>查询的生命周期的下一步是将一个SQL转换成一个执行计划，MySQL再按照这个执行计划和存储引擎进行交互。这包括多个子阶段：解析SQL、预处理、优化SQL执行计划。这个过程中出现任何错误都可能终止查询。</strong></p><h3 id="语法解析器和预处理"><a href="#语法解析器和预处理" class="headerlink" title="语法解析器和预处理"></a>语法解析器和预处理</h3><p><strong>首先MySQL通过关键字将SQL语句进行解析，并生成一颗对应的“解析树”。MySQL解析器将使用MySQL语法规则验证和查询解析。</strong>例如验证是否使用错误的关键字，关键字顺序是否正确等。</p><p><strong>预处理器则根据一些MySQL规则进一步检查树是否合法。</strong>例如检查数据表和列是否存在、名字和别名是否有歧义等待。</p><p><strong>下一步预处理器会验证权限。</strong>这通常很快，除非服务器上有非常多的权限配置。</p><h3 id="查询优化器"><a href="#查询优化器" class="headerlink" title="查询优化器"></a>查询优化器</h3><p><strong>在语法树被验证合法以后，将由优化器将其转化成执行计划。一条查询可以有很多种执行方式，最后都返回相同的结果。优化器的作用就是找到这其中最好的执行计划。</strong></p><p><strong>MySQL使用基于成本的优化器，它将尝试预测一个查询使用某种执行计划时的成本，并选择其中成本最小的一个。</strong>当然优化器并不能完全保证所选择的执行计划是最优的，有很多种原因会导致MySQL优化器选择错误的执行计划：</p><ul><li><strong>统计信息不准确。</strong>MySQL依赖存储引擎提供的统计信息来评估成本，但有的存储引擎提供的信息是不准确的，例如<strong>InnoBD因为其MVCC的架构，并不能维护一个数据表的精确统计信息。</strong></li><li><strong>执行计划的成本估算不等同于实际执行的成本。</strong>例如MySQL层面并不知道哪些页面在内存中，哪些在磁盘上，所以执行的I/O时间也无从得知。<strong>所以我们看到的执行成本来选择执行计划并不是完美的模型。</strong></li><li><strong>MySQL从不考虑其他并发执行的查询。</strong></li><li><strong>MySQL也并不完全是基于成本的优化，优势也会基于一些固定的规则。</strong>例如，如果存在MATCH()子句，则在全文索引的时候就使用全文索引。即使有时候使用别的索引和WHERE条件可以远比这种方式要快。</li><li><strong>MySQL不会考虑不受其控制的操作的成本。</strong>例如执行存储过程或用户自定义函数的成本。</li><li><strong>优化器有时候无法去估算所有可能的执行计划，</strong>所以可能错过实际上最优的执行计划。</li></ul><p>MySQL的查询优化器使用了很多优化策略生成一个最优的执行计划。优化策略可以简单的分为两种：<strong>静态优化和动态优化。</strong></p><blockquote><ul><li><strong>静态优化可以直接对解析树进行分析，并完成优化。</strong>例如优化器可以通过一些简单的代数变换将WHERE条件转换成另一种等价形式。静态优化不依赖于特别的数值，如WHERE条件中带入的一些常数等。<strong>静态优化在第一次完成之后一直有效，</strong>即使使用了不同的参数重复查询也不会发生变化，可以认为这是一种“编译时优化”。</li><li><strong>动态优化和查询的上下文有关，也可能和很多其他因素有关。</strong>例如WHERE条件的中的取值、索引中条目对应的数据行数等。这<strong>需要在每次查询的时候都重新评估</strong>，可以认为这是“运行时优化”。</li></ul></blockquote><p>MySQL对查询的静态优化只需要做一次，但对查询的动态优化规则在每次运行时都需要重新评估，有时甚至在查询的执行过程中也会重新优化。</p><p>下面是一些MySQL能够处理的优化类型：</p><ul><li><strong>重新定义关联表的顺序：**</strong>数据表的关联并不总是按照在查询中指定的顺序进行。**决定关联的顺序是优化器很重要的一部分功能。</li><li><strong>将外连接转化成内连接：</strong>并不是所有的OUTER JOIN语句都必须以外连接的方式执行。例如WHERE条件、库表结构都可能会让外连接等价于一个内连接，MySQL可以自动识别这一点并重写查询，让其调整关联顺序。</li><li><strong>使用等价变换规则：**</strong>MySQL可以使用一些等价变换来简化并规范表达式。**它可以合并和减少一些比较，还可以移除一些恒成立和一些恒不成立的判断。</li><li><strong>优化COUNT(*)、MIN()和MAX()：</strong>索引和列是否可为空通常可以帮助MySQL优化这类表达式。例如，<strong>要找到某一列的最小值，只需要查询对应的B-Tree索引最左端的记录，MySQL可以直接获取索引的第一行记录。</strong>如果MySQL使用了这种类型的优化，那么在EXPLAIN中就可以看到“Select tables optimized away”，从字面意思可以看出来，他表示优化器已经从执行计划中移除了该表，并以一个常数代替。</li><li><strong>预估并转化为常数表达式：**</strong>当MySQL检测到一个表达式可以转化为常数的时候，就会一直把该表达式作为常数进行优化处理。**</li><li><strong>索引覆盖扫描：</strong>当索引中的列包含所有查询中需要使用的列的时候，MySQL就可以使用索引返回需要的数据，而无需查询对应的数据行。</li><li><strong>子查询优化：</strong>MySQL在某些情况下可以将子查询转换一种效率更高的形式，从而减少多个查询多次对数据进行访问。</li><li><strong>提前终止查询：**</strong>在发现已经满足查询需求的时候，MySQL总是能够立刻终止查询。**例如当使用了LIMIT的时候、发现了一个不成立的条件等。</li><li><strong>等值传播：</strong>如果两个列的值通过等式关联，那么MySQL能够把其中一个列的WHERE条件传递到另一个列上。</li><li><strong>列表IN()的比较：</strong>在很多数据库系统中，IN()完全等同于多个OR条件的子句，因为这二者完全等价。但是在MySQL中这点是不成立的，<strong>MySQL将IN()列表中的数据先进行排序，然后通过二分查找的方式来确定列表中的值是否满足条件，这是一个O(log n)复杂度的操作</strong>，等价的变换成OR查询的复杂度为O(n)，对IN()列表中有大量取值的时候，MySQL的处理将会更快。</li></ul><h3 id="数据和索引的统计信息"><a href="#数据和索引的统计信息" class="headerlink" title="数据和索引的统计信息"></a>数据和索引的统计信息</h3><p><strong>MySQL服务层没有任何统计信息，所以MySQL查询优化器在生成查询的计划时，需要向存储引擎获取相应的统计信息。存储引擎则提供给优化器对应的统计信息，</strong>包括：每个表或者索引有多少个页面、每个表的每个索引的基数是多少、数据行和索引长度、索引的分布信息等。优化器根据这些信息来选择一个最优的执行计划。</p><h3 id="MySQL如何执行关联查询"><a href="#MySQL如何执行关联查询" class="headerlink" title="MySQL如何执行关联查询"></a>MySQL如何执行关联查询</h3><p>MySQL认为任何一个查询都是一次“关联”，并不仅仅是一个查询需要到两个表匹配才叫关联，所以在MySQL中，每一次查询，每一个片段都可能是关联。</p><p>举一个UNION查询的例子，<strong>对于UNION查询，MySQL先将一系列的单个查询结果放在一个临时表中，然后再重新读出临时表数据来完成UNION查询，所以读取结果临时也是一次关联。</strong></p><p>当前MySQL关联执行的策略很简单：<strong>MySQL对任何关联都执行嵌套循环关联操作，即MySQL先在一个表中循环取出单条数据，然后再嵌套循环到下一个表中寻找匹配的行，依次下去，直到找到所有表中匹配的行为止。然后根据各个表匹配的行，返回查询中需要的各个列。MySQL会先尝试在最后一个关联表中找到所有匹配的行，如果最后一个关联表无法找到更多的行以后，MySQL返回到上一层关联表，看是否能找到更多的匹配记录，依次类推迭代执行。</strong></p><p>从本质上来说，MySQL对所有的类型的查询都以同样的方式运行。例如，MySQL在FROM子句中遇到子查询时，先执行子查询并将其结果放在一个临时表中，然后将这个临时表当作一个普通表对待（正如其名“派生表”）。MySQL在执行UNION查询时也是用类似的临时表。<strong>在遇到右外连接的时候，MySQL将其改写成等价的左外连接。</strong>但是全外连接无法通过嵌套循环和回溯的方式完成，这大概也是MySQL并不支持全外连接的原因。</p><h3 id="执行计划"><a href="#执行计划" class="headerlink" title="执行计划"></a>执行计划</h3><p>和很多其他关系数据库不同，MySQL并不会生成查询字节码来执行查询，<strong>MySQL生成查询一棵指令树，然后通过存储引擎执行完成这棵指令树并返回结果。</strong>MySQL总是从一个表开始一直嵌套循环、回溯完成所有表关联。所以MySQL的执行计划总是如下图所示，是一棵左侧深度优先的树：<img src="/posts/39035/findTree.png" alt></p><h3 id="关联查询优化器"><a href="#关联查询优化器" class="headerlink" title="关联查询优化器"></a>关联查询优化器</h3><p>MySQL优化器最重要的一部分就是关联查询优化，他决定了多个表关联时的顺序。通常多表关联的时候，可以有多种不同的关联顺序来获得相同的执行顺序，关联查询优化器则通过评估不同顺序时的成本来选择一个代价最小的关联顺序。</p><p>关联优化器会尝试再所有的关联顺序中选择一个成本最小的来生成执行计划，<strong>尽量保证每次关联查询后，能排除掉更多的无用数据。</strong>如果可能，优化器会遍历每一个表然后逐个做嵌套循环计算每一棵可能的执行计划树的成本，最后返回一个最优的执行计划。</p><p>不过糟糕的是，如果有超过n个表的关联，那么需要检查n的阶乘种关联计划。我们称之为所有可能的执行计划的“搜索空间”，搜索空间的增长速度非常快，例如若10个表的关联，那么共有3628800种不同的关联顺序。</p><h3 id="排序优化"><a href="#排序优化" class="headerlink" title="排序优化"></a>排序优化</h3><p><strong>无论如何排序都是一个成本很高的操作，所以从性能考虑，应尽可能避免排序或者尽可能对大量数据进行排序。</strong></p><p>当不能使用索引生成排序结果的时候，MySQL需要自己进行排序，<strong>如果数据量小则在内存中进行，如果数据量大则需要使用磁盘，不过MySQL将这个过程统一称为文件排序（filesort）。</strong></p><p><strong>如果需要排序的数据量小于“排序缓冲区”，MySQL使用内存进行“快速排序”操作。如果内存不够排序，那么MySQL会先将数据分块，对每个独立的块使用“快速排序”进行排序，并将各个块的排序结果存放在磁盘上，然后将各个排好序的块进行合并，最后返回排序结果。</strong></p><p>MySQL有两种排序算法：</p><blockquote><ul><li><strong>两次传输排序（旧版本使用）：**</strong>读取行指针和需要排序的字段，对其进行排序，然后再根据排序结果读取所需要的数据行。** <strong>这需要进行两次数据传输</strong>，即需要从数据表中读取两次数据，第二次读取数据的时候，因为是读取排序列进行排序后的所有记录，这<strong>会产生大量的随机I/O，所以两次数据传输的成本非常高。</strong></li><li><strong>单次传输排序（新版本使用）：**</strong>先读取所需要的所有列，然后再根据给定列进行排序，最后直接返回排序结果。<strong>因为不需要从数据表中读取两次数据，</strong>对于I/O密集型的应用，这样做的效率高了很多。<strong>但是</strong>缺点是如果需要返回的列非常多、非常大，会额外占用大量的空间，**而这些列对排序操作本身来说是没有任何作用的。</li></ul></blockquote><p><strong>MySQL在进行文件排序的时候需要使用的临时存储空间可能会比想象的要大很多，原因在于MySQL在排序时，对每一个排序记录都会分配一个足够长的定长空间来存放。这个定长空间必须足够长以容纳其中最长的字符串，</strong>如果使用UTF-8字符集，那么MySQL将会为每个字符预留三个字节。因此排序消耗的临时空间可能会比磁盘上的原表要大很多倍。</p><p>在关联查询的时候如果需要排序，MySQL会分两种情况来处理这样的文件排序。<strong>如ORDER BY子句中所有的列都来自关联的第一个表，那么MySQL在关联处理第一个表的时候就进行文件排序，</strong>这种情况MySQL在EXPLAIN结果中的Extra字段会有“Using filesort”。<strong>除此之外所有情况，MySQL都会先将关联的结果存放到一个临时表中，然后在所有的关联都结束后，再进行文件排序，</strong>这种情况MySQL在EXPLAIN结果中的Extra字段会有“Using temporary；Using filesort”。<strong>如果查询中有LIMIT的话，LIMIT也会在排序之后应用。</strong></p><p>MySQL5.6后，当只需要返回部分排序结果的时候，例如使用了LIMIT子句，MySQL不再对所有的结果进行排序，而是根据实际情况，选择抛弃不满足条件的结果，然后再进行排序。</p><h2 id="查询执行引擎"><a href="#查询执行引擎" class="headerlink" title="查询执行引擎"></a>查询执行引擎</h2><p>在解析和优化阶段，MySQL将生成查询对应的执行计划，MySQL的查询执行引擎则根据这个执行计划来完成整个查询。这里执行计划是一个数据结构，而不是和很多其他关系型数据库那样会生成对应的字节码。</p><p><strong>MySQL只是简单的根据执行计划给出的指令逐行执行，在根据执行计划逐步执行的过程中，有大量的操作需要通过调用存储引擎实现的接口来完成。</strong></p><h2 id="返回结果给客户端"><a href="#返回结果给客户端" class="headerlink" title="返回结果给客户端"></a>返回结果给客户端</h2><p>查询执行的最后一个阶段是将结果返回给客户端。即使查询不需要返回结果集给客户端，MySQL仍然会返回这个查询的一些信息，如该查询影响到的行数。</p><p><strong>如果查询可以被缓存，那么MySQL在这个阶段也会将结果存放到查询缓存中。</strong></p><p>MySQL将结果集返回给客户端是一个增量、逐步返回的过程，<strong>一旦服务器处理完最后一个关联表，开始生成第一条结果时，MySQL就可以开始向客户端逐步返回结果集了。</strong></p><p><strong>这样处理有两个好处：服务器无须存储太多的结果，也就不会因为要返回太多的结果而消耗太多内存。另外这样的处理也让MySQL客户端第一时间获得返回的结果。</strong></p>]]></content>
    
    <summary type="html">
    
      如何设计最优的库表结构、如何建立最好的索引，这些对于高性能来说是必不可少的东西。但是这些还不够，还需要合理的设计查询。深刻地理解MySQL如何真正地执行查询，并明白高效和低效的原因何在，这样才能充分发挥MySQL的优势，并避开它的弱点。
    
    </summary>
    
      <category term="MySQL数据库" scheme="http://yoursite.com/categories/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
  </entry>
  
  <entry>
    <title>创建高性能索引</title>
    <link href="http://yoursite.com/posts/28327/"/>
    <id>http://yoursite.com/posts/28327/</id>
    <published>2019-09-18T11:58:01.000Z</published>
    <updated>2019-09-26T11:54:57.160Z</updated>
    
    <content type="html"><![CDATA[<p>索引（也叫做“键（key）”）是存储引擎用于快速找到记录的一种数据结构。索引对于良好的性能非常关键，尤其是当表中的数据量越来越大时，索引对性能的影响越发重要。其外索引优化也很重要，索引优化应该是对查询性能优化最有效的手段了，索引能轻易将查询性能提高几个数量级。</p><h1 id="索引基础"><a href="#索引基础" class="headerlink" title="索引基础"></a>索引基础</h1><p>要理解MySQL中索引时如何工作的，最简单的方法就是去看看一本书的“索引”部分：如果想在一本书中找到某个特定主题，一般会先看书的“索引”，找到对应的页码。</p><p>在MySQL中，存储引擎用类似的方法使用索引，<strong>其先在索引中找到对应值，然后根据匹配的索引记录找到对应的数据行。也就是说，MySQL先在索引上按值进行查找，然后返回所有包含该值的数据行。</strong></p><p>索引可以包含一个或多个列的值。如果索引包含多个列，那么列的顺序也十分重要，因为<strong>MySQL只能高效的使用索引的最左前缀列。</strong></p><h2 id="索引的类型"><a href="#索引的类型" class="headerlink" title="索引的类型"></a>索引的类型</h2><p>在MySQL中，<strong>索引是在存储引擎层</strong>而不是服务层<strong>实现的</strong>。索引不同存储引擎的索引的工作方式不一样，也不是所有的存储引擎都支持所有类型的索引。下面是MySQL支持的索引类型，以及它们的优点和缺点。</p><h3 id="B-Tree索引"><a href="#B-Tree索引" class="headerlink" title="B-Tree索引"></a>B-Tree索引</h3><p>如果没有特别说明索引类型，默认是B-Tree索引，它使用B-Tree数据结构来存储数据，大多数MySQL引擎都支持这种索引（Archive除外）。不过底层的存储引擎也可能使用不同的数据结构，例如<strong>InnoDB则使用的是B+Tree。</strong></p><p>存储引擎以不用的方式使用B-Tree索引，性能也各有不同，各有优势。例如：<strong>MyISAM使用前缀压缩技术使得索引更小，但InnoDB则按照原数据格式进行存储。再如MyISAM索引通过数据的物理位置引用被索引的行，而InnoDB则根据主键引用被索引的行。</strong></p><p><strong>B-Tree通常意味着所有的值都是按顺序存储的，并且每一个叶子页到根的距离相同。</strong>下图展示B-Tree索引的抽象表示：<br><img src="/posts/28327/B-Tree%E7%BB%93%E6%9E%84.png" alt></p><p><strong>B-Tree索引能加快访问数据的速度，因为存储引擎不再需要进行全表扫描来获取需要的数据，取而代之的是从索引的根节点开始进行搜索。根节点的槽中存放了指向子节点的指针，存储引擎根据这些指针向下层查找。通过比较节点页的值和要查找的值可以找到合适的指针进入下层子节点，这些指针实际上定义了子节点中值的上限和下限。最终存储引擎要么是找到对应的值，要么该记录不存在。</strong>叶子节点比较特别，它们的指针指向的是被索引的数据，而不是其他的节点页。</p><p><strong>B-Tree对索引列是顺序组织存储的，所以很适合查找范围数据。</strong>例如，在一个基于文本域的索引树上，按字母顺序传递连续的值进行查找是非常合适的，所以像“找出所有以I到K开头的名字”这样的查找效率会非常高。</p><p>建立如下表：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">CREATE TABLE <span class="title">people</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">last_name varchar(<span class="number">50</span>)</span> not <span class="keyword">null</span>,</span></span><br><span class="line"><span class="function">first_name <span class="title">varchar</span><span class="params">(<span class="number">50</span>)</span> not <span class="keyword">null</span>,</span></span><br><span class="line"><span class="function">dob date not <span class="keyword">null</span>,</span></span><br><span class="line"><span class="function">gender <span class="title">enum</span><span class="params">(<span class="string">'m'</span>,<span class="string">'f'</span>)</span> not <span class="keyword">null</span>,</span></span><br><span class="line"><span class="function"><span class="title">key</span><span class="params">(last_name,first_name,dob)</span></span></span><br><span class="line"><span class="function">)</span>;</span><br></pre></td></tr></table></figure><p><img src="/posts/28327/B-Tree%E8%A1%A8%E4%BE%8B%E5%AD%90.png" alt><br><strong>索引对多个值进行排序的依据是CREATE TABLE语句中定义索引时列的顺序。</strong>例如上图中，最后两个条目中，两个人的姓和名都一样，则根据他们的出生日期来排序。</p><p>可以使用B-Tree索引的查询类型。<strong>B-Tree索引适用于全键值、键值范围或前缀查询。其中键前缀查找只适用于根据最左前缀的查找。</strong>故所述的索引对如下类型的查询有效：</p><ul><li><strong>全值匹配</strong>：<strong>全值匹配指的是和索引中的所有列进行匹配。</strong>例如上图中，索引可用于查找姓名为Cuba Allen、同时出生于1960-01-01的人。</li><li><strong>匹配最左前缀</strong>：索引可用于查询所有姓为Allen的人，<strong>即只使用索引的第一列。</strong></li><li><strong>匹配列前缀</strong>：也可以<strong>只匹配某一列的值的开头部分。</strong>例如可以查找所有以J开头的性的人，这里也只使用了索引的第一列。</li><li><strong>匹配范围值</strong>：例如索引可用于查找姓在Allen和Barrymore之间的人，这里也只使用了索引的第一列。</li><li><strong>精确匹配某一列并范围匹配另外一列</strong>：例如可以查找所有姓为Allen，并且名字是字母K开头的人。即第一列全匹配，第二列范围匹配。</li><li><strong>只访问索引的查询</strong>：B-Tree通常可以支持“只访问索引的查询”，<strong>即查询只需要访问索引，而无须访问数据行。</strong></li></ul><p>因为索引树中的节点是有序的，所以除了按值查找之外，<strong>索引还可以用于查询中的ORDER BY操作</strong>。一般来说，如果B-Tree可以按照这种方式用于排序。</p><p>但是B-Tree索引也有一些限制：</p><ul><li><strong>如果不是按照索引的最左列开始查找，则无法使用索引。</strong>即最左列不能跳过，例如上面例子中的索引无法用于查找名字为Bill的人，也无法查找某个特定生日的人，因为这两列都不是最左数据列。</li><li><strong>不能跳过索引中的列。</strong>也就是说不能查找姓名为Smith并且某个特定日期出生的人。如果不指定名，则MySQL只能使用索引的第一列。</li><li><strong>如果查询中有某个列的范围查找，则其右边所有列都无法使用索引优化查找。</strong></li></ul><p>总而言之这些限制都和索引列的顺序有关。在优化性能的时候，可能需要使用相同的列但顺序不同的索引来满足不同类型的查询需求。</p><h3 id="哈希索引"><a href="#哈希索引" class="headerlink" title="哈希索引"></a>哈希索引</h3><p><strong>哈希索引基于哈希表实现，只有精确匹配索引所有列的查询才有效。</strong>对于每一行数据，存储引擎哦都会对所有的索引列计算一个哈希码，哈希码是一个较小的值，并且不同键值的行计算出来的哈希码也不一样。<strong>哈希索引将所有的哈希码存储在索引中，同时在哈希表中保存指向每个数据行的指针。</strong></p><p>假设有如下表：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> testhash (  </span><br><span class="line">    fname <span class="built_in">VARCHAR</span>(<span class="number">50</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">    lname <span class="built_in">VARCHAR</span>(<span class="number">50</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">    <span class="keyword">KEY</span> <span class="keyword">USING</span> <span class="keyword">HASH</span>(fname)</span><br><span class="line">)<span class="keyword">ENGINE</span>= <span class="keyword">MEMORY</span>;</span><br></pre></td></tr></table></figure><p>表中包含数据：<img src="/posts/28327/hashdata.png" alt><br>假设索引使用假想的哈希函数f()，它返回下面的值（以下为实例数据）：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">f('Arjen') = 2323</span><br><span class="line">f('Baron') = 7437</span><br><span class="line">f('Peter') = 8784</span><br><span class="line">f('Vadim') = 2458</span><br></pre></td></tr></table></figure><p>则哈希索引的数据结构如下：<img src="/posts/28327/hashdata2.png" alt><br><strong>注意，每个槽的编号是顺序的，但是数据行不是。</strong></p><p>因为索引自身只需存储对应的哈希值，所以索引的结构十分紧凑，这也让哈希索引查找到速度非常快。但是哈希索引也有它的限制：</p><ul><li><strong>哈希索引只包含哈希值和行指针，而不存储字段值，所以不能使用索引中的值来避免读取行。</strong>不过访问内存中的行的速度很快，所以大部分情况下这一点对性能的影响并不明显。</li><li>哈希索引值并不是按照索引值顺序存储的，所以也就<strong>无法用于排序。</strong></li><li><strong>哈希索引也不支持部分索引列匹配查找，因为哈希索引始终是使用索引列的全部内存容来计算哈希值的。</strong></li><li><strong>哈希索引只支持等值比较查询</strong>，包括=、IN()、&lt;=&gt;，也不支持任何范围查询。</li><li>访问哈希索引的数据非常快，除非有很多哈希冲突。当出现哈希冲突的时候，存储引擎会遍历链表中所有的行指针，逐行进行比较查找。</li><li>如果哈希冲突很多的话，一些索引维护操作的代价也会很高，冲突越多，代价越高。</li></ul><p>因为这些限制，哈希索引只适用于某些特定的场合，而一旦适合哈希索引，则它带来的性能提升将非常明显。</p><p>InnoDB引擎有一个特殊的功能叫做“<strong>自适应哈希索引</strong>”。当InnoDB注意到某些索引值被使用的非常频繁时，它会在内存中基于B-Tree所以之上再创建一个哈希索引。这是一个完全自动的、内部的行为，用户无法控制或者配置，但是可以关闭。</p><p><strong>自定义哈希索引时，记住不要使用SHA1()和MD5()作为哈希函数</strong>，因为这两个函数计算出来的哈希值时非常长的字符出阿奴，会浪费大量空间，比较时也会更慢。使用简单哈希函数导致的冲突在一个可以接受的范围，同时又能提供更好的性能。<strong>自定义哈希函数要返回整数，而不是字符串，一个简单的方法可以使用MD5()函数返回值的一部分来作为哈希函数。</strong></p><p><strong>当使用哈希索引进行查找的时候，要避免冲突问题，必须在WHERE条件中带入哈希值和对应列值。</strong>例如<code>SELECT * FROM words WHERE crc = CRC32(&#39;gnu&#39;) AND word = &#39;gnu&#39;;</code>。如果只是统计记录数（不精确的），则可以不带入列值。</p><h3 id="其他索引"><a href="#其他索引" class="headerlink" title="其他索引"></a>其他索引</h3><ul><li><strong>空间数据索引（R-Tree）</strong>：MyISAM表支持空间索引，可以用作地理数据存储。不同于B-Tree索引，这类索引无须前缀查询。<strong>空间索引会从所有维度来索引数据。查询时，可以有效地使用任意维度来组合查询。</strong></li><li><strong>全文索引</strong>：<strong>全文索引是一种特殊类型的索引，它查找的时文本中的关键字，而不是直接比较索引中的值。</strong>全文索引更类似于搜索引擎做的事情。<strong>在相同的列上同时创建全文索引和基于值的B-Tree索引不会有冲突</strong>，全文索引适用于MATCH AGAINST操作，而不是普通的WHERE条件操作。</li></ul><h1 id="索引的优点"><a href="#索引的优点" class="headerlink" title="索引的优点"></a>索引的优点</h1><p>索引可以让服务器快速地定位到表的指定位置，但这不是索引的唯一作用，因为根据创建索引的数据结构不同，索引也有一些其他的附加作用。</p><p>最常见的B-Tree索引，按照顺序存储数据，所以MySQL可以用来做ORDER BY和GROUP BY操作；因为数据是有序的，所以B-Tree也就会将相关的列值都存储在一起；因为索引中存储了实际的列值，所以某些查询只使用索引就能完成全部查询。所以总结下来索引有如下三个优点：</p><ul><li><strong>索引大大减少了服务器需要描述的数据量</strong></li><li><strong>索引可以帮助服务器避免排序和临时表</strong></li><li><strong>索引可以将随机I/O变为顺序I/O</strong></li></ul><p>有一个简单评价一个索引是否适合某个查询的方法叫做“三星系统”：<strong>索引将相关的记录放在一起则获得一星；如果索引中的数据顺序和查找中的排列顺序一致则获得二星；如果索引的列包含了查询中需要的全部列则获得三星。</strong></p><h1 id="高性能的索引策略"><a href="#高性能的索引策略" class="headerlink" title="高性能的索引策略"></a>高性能的索引策略</h1><h2 id="独立的列"><a href="#独立的列" class="headerlink" title="独立的列"></a>独立的列</h2><p>如果查询时不当的使用索引，或使得MySQL无法使用已有的索引。<strong>如果查询中的列不是独立的，则MySQL就不会使用索引。“独立的列”是指索引列不能是表达式的一部分，也不能是函数的参数。</strong><br>例如：<code>SELECT actor_id FROM sakila.actor WHERE actor_id+1 = 5;</code>和<code>SELECT ... WHERE TO_DAYS(CURRENT_DATE) - TO_DAYS(data_col) &lt;= 10;</code></p><p>所以我们应该养成简化WHERE条件的习惯，<strong>始终将索引列单独放在符号的一侧。</strong></p><h2 id="前缀索引和索引选择性"><a href="#前缀索引和索引选择性" class="headerlink" title="前缀索引和索引选择性"></a>前缀索引和索引选择性</h2><p>通常可以索引开始的部分字符，这样可以大大节约索引空间，从而提高索引效率。但是这样也会降低索引的选择性。<strong>索引的选择性是指：不重复的索引值（也称为基数）和数据表的记录总数（#T）的比值，范围从 1/#T 到 1 之间。</strong>索引的选择性越高则查询效率越高，因为选择性高的索引可以让MySQL在查找时过滤掉更多的行，唯一索引的选择性是1，即选择性最好，性能也最好。</p><p>对于BLOB、TEXT或者很长的VARCHAR类型的列，必须使用前缀索引，因为MySQL不允许索引这些列的完整长度。</p><p>诀窍在于要选择足够长的前缀以保证较高的选择性，同时又不能太长，以便节约空间。</p><p>为了决定前缀的合适长度，需要找到最常见的值的列表，然后和最常见的前缀列表进行比较，<strong>适当增加前缀长度，直到这个前缀的选择性接近完整列的选择性。</strong>另外一个方法就是计算完整列的选择性，并使前缀的选择性接近于完整列的选择性，计算方法如下：<code>SELECT COUNT(DISTINCT city)/COUNT(*) FROM city_demo</code>。通常来说，如果前缀的选择性能够接近<strong>0.031</strong>，基本上就可用了。</p><p><strong>前缀索引是一种能使索引更小、更快的有效办法，但另一方面也有其缺点：MySQL无法使用前缀索引做ORDER BY和GROUP BY，也无法使用前缀索引做覆盖扫描。</strong></p><h2 id="多列索引"><a href="#多列索引" class="headerlink" title="多列索引"></a>多列索引</h2><p>很多人对多列索引的理解一个常见的错误就是：为每个列创建独立的索引，或者按照错误的顺序创建多列索引。在多个列上建立独立的单独索引大部分情况下并不能提高MySQL的查询性能。</p><p>MySQL5.0和最新版本引入了一种叫“<strong>索引合并</strong>”的策略，一定程度上可以使用表上的多个单列索引来定位指定的行。这种算法有三个变种：OR条件的联合（union），AND条件的相交，组合前两种情况的联合及相交。</p><p><strong>索引合并策略有时候是一种优化的结果，但实际上更多时候说明了表上的索引建的很差。</strong>如果使用EXPLAIN语句中看到有索引合并，应该好好检查一下查询和表的结构，有无优化的余地。</p><h2 id="选择合适的索引列顺序"><a href="#选择合适的索引列顺序" class="headerlink" title="选择合适的索引列顺序"></a>选择合适的索引列顺序</h2><p>正确的索引顺序依赖于使用该索引的查询，并且同时需要考虑如何更好地满足排序和分组的需要。</p><p>在一个多列的B-Tree索引中，<strong>索引列的顺序意味着索引首先按照最左列进行排序，其次是第二列，等等。所以索引可以按照升序或者降序进行扫描，以满足精确符合列顺序的ORDER BY、GROUP BY和DISTINCT等子句的查询需求。所以多列索引的列顺序至关重要。</strong></p><p><strong>对于如何选择索引的列顺序有一个经验法则：将选择性最高的列放在索引最前列。</strong>但不需要考虑排序和分组时，将选择性最高的列放在前面通常是很好的。这时候索引的作用只是用于优化WHERE条件的查找。</p><h2 id="聚簇索引"><a href="#聚簇索引" class="headerlink" title="聚簇索引"></a>聚簇索引</h2><p>聚簇索引并不是一种单独的索引类型，而是一种数据存储方式，具体的细节依赖于其实现方式，<strong>InnoDB的聚簇索引实际上在同一个结构中保存了B-Tree索引的数据行。**</strong>当表有聚簇索引时，它的数据行实际上存放在索引的叶子页中。<strong>“聚簇”表示数据行和相邻的键值紧凑的存储在一起。因为无法同时把数据行存放在两个不同的地方，所以</strong>一个表只能有一个聚簇索引。**</p><p>下图展示聚簇索引中的记录是如何存放的：<img src="/posts/28327/%E8%81%9A%E7%B0%87%E7%B4%A2%E5%BC%95.png" alt>注意到，叶子页中包含了行的全部数据，但是节点页只包含了索引列。<strong>InnoDB通过主键聚集数据，也就是说上图中的“被索引的列”就是主键列。</strong>如果没有定义主键，InnoDB会选择一个唯一非空索引代替。如果没有这样的索引，InnoDB会隐式定义一个主键来作为聚簇索引。下面讨论一些聚簇索引的优缺点。</p><p><strong>优点：</strong></p><blockquote><ul><li><strong>可以把相关的数据保存在一起。</strong></li><li><strong>数据访问更快。</strong>聚簇索引将索引和数据保存在同一个B-Tree中，因此从聚簇索引中获取数据通常比在非聚簇索引中查找更快。</li><li><strong>使用覆盖索引扫描的查询可以直接使用页节点的主键值。</strong></li></ul></blockquote><p><strong>缺点：</strong></p><blockquote><ul><li><strong>聚簇索引最大限度的提高了I/O密集型应用的性能</strong>，但如果全部数据都放在内存中，那么访问的顺序就没有关系了，因此也就无法体现出什么优势了。</li><li><strong>插入速度严重依赖于插入顺序。</strong>按照主键的顺序插入是数据加载到InnoDB表中最快速度的方式；但如果不是按照主键顺序加载数据，那么在加载完成后最好<strong>使用OPTIMIZE TABLE命令重新组织一下表。</strong></li><li><strong>更新聚簇索引列的代价很高，因为会强制InnoDB将每个被更新的行移动到新的位置。</strong></li><li><strong>基于聚簇索引的表在插入新行，或者主键被更新导致需要移动行的时候，可能面临“页分裂”的问题，页分裂会导致表占用更多的磁盘空间</strong>。当行的主键值要求必须将这一行插入到某个已满的页中时，存储引擎会将该页分裂成两个页面来容纳改行，这就是一次页分裂操作。</li><li><strong>聚簇索引可能导致全表扫描变慢，尤其是行比较稀疏，或者由于页分裂导致数据存储不连续的时候。</strong></li><li><strong>二级索引（非聚簇索引）可能比想象的要更大，因为在二级索引的叶子节点包含了引用行的主键列。</strong></li><li><strong>二级索引访问需要两次索引查找，而不是一次。</strong>导致这个问题的原因在于二级索引中保存的“行指针”的实质。<strong>二级索引叶子节点保存的不是指向行的物理位置的指针，而是行的主键值。</strong>这意味着<strong>通过二级索引查找行，存储引擎需要找到二级索引的叶子节点获得对应的主键值，然后根据这个值去聚簇索引中查找到对应的行。</strong>对于InnoDB自适应哈希索引可以减少这样的重复工作。</li></ul></blockquote><p>在InnoDB和MyISAM中，对于聚簇索引和非聚簇索引的实现有区别，所以就以下表为例对比二者的区别：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> layout_test(</span><br><span class="line">col1 <span class="built_in">int</span> <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">col2 <span class="built_in">int</span> <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">PRIMARY <span class="keyword">KEY</span>(col1),</span><br><span class="line"><span class="keyword">KEY</span>(col2)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>假设该表的主键取值为1<del>10000，并且数据在磁盘上的存储方式已经最优，但行的顺序是随机的；列col2的值是从1</del>100之间随机复制，可能有很多重复值。</p><h3 id="MyISAM的数据分布"><a href="#MyISAM的数据分布" class="headerlink" title="MyISAM的数据分布"></a>MyISAM的数据分布</h3><p>MyISAM的数据分布非常简单，<strong>它按照数据插入的顺序存储在磁盘上</strong>，如图所示：<img src="/posts/28327/MyISAM%E8%81%9A%E7%B0%87%E7%B4%A2%E5%BC%95%E6%95%B0%E6%8D%AE%E5%88%86%E5%B8%83.png" alt>在行的旁边显示了行号，从0开始递增。因为行是定长的，索引MyISAM可以从表的开头跳过所需的字节知道需要的行。这种分布方式很容易创建索引，如图：<img src="/posts/28327/TIM%E6%88%AA%E5%9B%BE20190923193723.png" alt></p><p><strong>MyISAM中主键索引和其他索引在结构上没什么不同</strong>，因此列col2的索引分布和col1一样。<strong>主键索引就是一个名为PRIMARY的唯一非空索引。</strong></p><h3 id="InnoDB的数据分布"><a href="#InnoDB的数据分布" class="headerlink" title="InnoDB的数据分布"></a>InnoDB的数据分布</h3><p><img src="/posts/28327/InnoDB%E8%81%9A%E7%B0%87%E7%B4%A2%E5%BC%95%E4%B8%BB%E9%94%AE%E5%88%86%E5%B8%83.png" alt><br>可以看到该图显示了整张表，而不只有索引，因为在InnoDB中，聚簇索引就是表，所以不需要像MyISAM那样需要独立的行存储。<strong>聚簇索引的每一个叶子节点都包含了主键值、事务ID、用于事务和MVCC的回滚指针以及所有的剩余列。</strong></p><p>还有一点与MyISAM不同的是，InnoDB的二级索引和聚簇索引很不相同。<strong>InnoDB二级索引的叶子节点中存储的不是“行指针”，而是主键值，并以此作为指向行的“指针”。这样的好处就是减少了当出现行移动或者数据页分裂时二级索引的维护工作，因此InnoDB在移动行时无需更新二级索引的这个“指针”。</strong>下图是InnoDB中的二级索引分布：<img src="/posts/28327/InnoDB%E4%BA%8C%E7%BA%A7%E7%B4%A2%E5%BC%95%E5%88%86%E5%B8%83.png" alt></p><p>聚簇和非聚簇对比如图：<img src="/posts/28327/%E8%81%9A%E7%B0%87%E9%9D%9E%E8%81%9A%E7%B0%87%E5%AF%B9%E6%AF%94.png" alt></p><h3 id="在InnoDB表中按主键顺序插入行"><a href="#在InnoDB表中按主键顺序插入行" class="headerlink" title="在InnoDB表中按主键顺序插入行"></a>在InnoDB表中按主键顺序插入行</h3><p>如果正在使用的InnoDB表没有什么数据需要聚集，那么可以定义一个与数据无关的代理键作为主键，<strong>最简单方法就是使用AUTO_INCREMENT自增列，这样可以保证数据行是按顺序写入，对于根据主键做关联的性能也会更好。</strong>最好避免随机的聚簇索引，下面对比以自增的整数ID作为主键和以随机字符串UUID作为主键的情况。<img src="/posts/28327/InnoDB%E6%8F%92%E5%85%A5.png" alt><strong>可以注意到UUID主键插入不仅花费时间更长，而且索引占用的空间也更大。这一方面是由于主键字段更长，另一方面毫无疑问是因为页分裂和碎片导致的。</strong><br><img src="/posts/28327/%E5%90%91%E8%81%9A%E7%B0%87%E7%B4%A2%E5%BC%95%E6%8F%92%E5%85%A5%E9%A1%BA%E5%BA%8F%E7%9A%84%E7%B4%A2%E5%BC%95%E5%80%BC.png" alt>如图所示，因为主键的值是顺序的，所以InnoDB把每一条记录都存储在上一条记录的后面。当达到页的最大填充因子时（InnoDB默认的最大填充因子是页大小的15/19，留出部分空间用于以后修改），下一条记录就会写入新的页中。一旦数据按照这种顺序的方式加载，主键页就会近似于被顺序的记录填满，这也正是所期望的结果。</p><p><img src="/posts/28327/%E5%90%91%E8%81%9A%E7%B0%87%E7%B4%A2%E5%BC%95%E6%8F%92%E5%85%A5%E6%97%A0%E5%BA%8F%E5%80%BC.png" alt><br>但是对比使用UUID聚簇索引的表插入数据，<strong>因为新行的主键值不一定比之前的插入大，所以InnoDB无法简单的总是把新行插入到索引的最后，而是需要为新的行寻找合适的位置————通常是已有数据的中间位置————并且分配空间。这会增加很多的额外工作，并导致数据分布不够优化，</strong>下面是总结的一些缺点：</p><blockquote><ul><li>写入到目标页可能已经刷到磁盘上并从缓存中移除，或者是还没有被加载到缓存中，InnoDB再插入之前不得不先找到并从磁盘读取目标页到内存中，这将<strong>导致大量的随机I/O。</strong></li><li><strong>因为写入是乱序的，InnoDB不得不频繁的做分页操作，以便为新的行分配空间。页分裂会导致移动大量数据，一次插入最少需要修改三个页面而不是一个页面。</strong></li><li>由于频繁的页分裂，页会变得稀疏并被不规则地填充，所以<strong>最终数据会有碎片。</strong></li></ul></blockquote><p>所以总结结论就是，<strong>使用InnoDB时应该尽可能的按主键顺序插入数据，并且尽可能地使用单调增加的聚簇键的值来插入新行。</strong></p><h2 id="索引覆盖"><a href="#索引覆盖" class="headerlink" title="索引覆盖"></a>索引覆盖</h2><p>索引确实是一种查找数据的高效方式，但是MySQL也可以使用索引来直接获取列的数据，这样就不再需要读取数据行。<strong>如果一个索引包含（或者说覆盖）所有需要的字段的值，我们就称之为“索引覆盖”。</strong>索引覆盖是非常有效的工具，能够极大地提高性能，如果查询只需要扫描索引而无需回表，会带来多少好处：</p><ul><li><strong>索引条目通常远小于数据行的大小，所以如果只需要读取索引，那MySQL就会极大的减少数据访问量。</strong>这对缓存的负载非常重要，因为这种情况下响应时间大部分花费在数据拷贝上。</li><li><strong>因为索引是按照列值的顺序存储的，所以对于I/O密集型的范围查找会比随机从磁盘读取每一行的I/O要少得多。</strong>对于MyISAM甚至可以通过OPTIMIZE命令使得索引完全顺序排列，这让简单的范围查询能完全顺序的索引访问。</li><li>一些存储引擎存储引擎入MyISAM在内存中只缓存索引，数据则依赖于操作系统来缓存，因此访问数据需要一次系统调用，所以这里<strong>减少了因调用系统导致的开销。</strong></li><li>由于InnoDB二级索引在叶子节点中保存了行的主键值，所以<strong>如果二级主键能够覆盖查询，则可以避免主键索引的二次查询。</strong></li></ul><p>不是所有类型的索引都可为成为覆盖索引，覆盖索引必须存储索引列的值，而哈希索引、空间索引和全文索引等都不存储索引列的值，所以<strong>MySQL只能使用B-Tree索引做覆盖索引。</strong>另外也不是所有的索引都支持覆盖索引。</p><p>当发起一个被索引覆盖的查询（也叫做索引覆盖查询）时，<strong>在EXPLAIN的Extra列可以看到“Using index”的信息。</strong>索引覆盖查询还有很多陷阱可能导致无法实现优化。<strong>MySQL查询优化器会在执行查询前判断是否有一个索引能进行覆盖。加入索引覆盖了WHERE条件中的字段，但是不是整个查询涉及的字段。如果条件为假，MySQL5.5及更早总是会回表获取数据行，尽管并不需要这一行且最终会被过滤掉。</strong></p><p>如下例子：<img src="/posts/28327/beforesql.png" alt><br>这里索引无法覆盖该查询，有两个原因：</p><blockquote><ul><li>没有任何索引能够覆盖这个查询，因为查询从表中选择了所有的列，而每一任何索引覆盖了所有列。</li><li>MySQL不能在索引中执行LIKE操作。这是底层存储引擎API的限制，MySQL5.5及更早版本只允许在索引中做简单比较操作。<strong>MySQL能在索引中做最左前缀匹配的LIKE比较，因为该操作可以转换为简单的比较操作，但是如果时通配符开头的LIKE查询，存储器引擎就无法做比较匹配。</strong></li></ul></blockquote><p>也有办法解决上面说的问题，需重写查询并巧妙的设计索引。先将索引拓展至覆盖三个数据列，然后按如下方式重写查询：<br><img src="/posts/28327/aftersql.png" alt><br><strong>这种方式叫做“延迟关联”，因为延迟了对列的访问。</strong>在查询的第一阶段MySQL可以使用覆盖索引，在FROM子句的子查询中找到匹配的prod_id，然后根据这些prod_id值在外层查询匹配获取需要的所有列值。虽无法完全使用覆盖查询，但总比不使用覆盖查询好。</p><p><strong>这样的优化效果取决于WHERE条件匹配返回的数据行。</strong><img src="/posts/28327/%E8%A6%86%E7%9B%96%E6%B5%8B%E8%AF%95.png" alt><br>在示例3中，因为索引过滤时符合第一个条件的结果集已经很小，所以子查询带来的成本反而比从表中直接提取完整行更高。</p><p>可以考虑更进一步优化InnoDB：InnoDB的二级索引的叶子节点都包含了主键的值，这意味着InnoDB的二级索引可以有效地利用这些“额外”的主键列来覆盖查询。</p><h2 id="使用索引扫描扫描来做排序"><a href="#使用索引扫描扫描来做排序" class="headerlink" title="使用索引扫描扫描来做排序"></a>使用索引扫描扫描来做排序</h2><p>MySQL有两种方式可以生成有序的结果：通过<strong>排序操作</strong>或者<strong>按索引顺序扫描</strong>。如果EXPLAIN出来的type列的值为“index”，则说明MySQL使用了索引扫描来做排序。扫描索引本身是很快的，但是如果索引不能覆盖所需的全部列，那就不得不每扫描一条索引记录都回表查询一次对应的行，这基本上都是随机I/O，因此按索引顺序读取数据的速度通常要比顺序地全表扫描。</p><p>MySQL可以使用同一个索引既满足排序又用于查找行，因此，如果可能，设计索引时应该尽可能地满足这两种任务。<strong>只有当索引的列顺序和ORDER BY子句的顺序完全一致，并且所有列的排序方向都一样时，MySQL才能使用索引来对结果做排序。**</strong>如果查询时需要关联多张表，则只有当ORDER BY子句引用的字段全部为第一个表时，才能使用索引来做排序<strong>，，ORDER BY子句和查找型查询的限制是一样的：</strong>需要满足索引的最左前缀的要求；否则MySQL都需要执行排序操作，而无法利用索引排序。<strong>有一种情况下ORDER BY子句可以不满足索引的最左前缀的要求：</strong>前导列为常量的时候。**如果WHERE子句或者JOIN子句种对这些列指定了常量，就可以弥补索引的不足。例如有如下表：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">(retal_date,inventory_id,customer_id):</span><br><span class="line"><span class="function">CREATE TABLE <span class="title">retal</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">...</span></span></span><br><span class="line"><span class="function"><span class="params">PRIMARY KEY (retal_id)</span>,</span></span><br><span class="line"><span class="function">UNIQUE KEY <span class="title">retal_date</span><span class="params">(retal_date,inventory_id,customer_id)</span>,</span></span><br><span class="line"><span class="function">KEY <span class="title">idx_fk_inverntory_id</span><span class="params">(inventory_id)</span>,</span></span><br><span class="line"><span class="function">KEY <span class="title">idx_fk_customer_id</span><span class="params">(customer_id)</span>,</span></span><br><span class="line"><span class="function">KEY <span class="title">idx_fk_staff_id</span><span class="params">(staff_id)</span>,</span></span><br><span class="line"><span class="function">...</span></span><br><span class="line"><span class="function">)</span>;</span><br></pre></td></tr></table></figure><p>MySQL可以在使用retal_date索引为下面的查询做排序，从EXPLAIN中可以看到没有出现文件排序（filesort）操作：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">EXPLAIN</span> <span class="keyword">SELECT</span> retal_id,staff_id <span class="keyword">FROM</span> sakila.rental</span><br><span class="line"><span class="keyword">WHERE</span> retal_date = <span class="string">'2005-05-25'</span></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> inventory_id,customer_id\G</span><br></pre></td></tr></table></figure><p>即使ORDER BY子句不满足索引的最左前缀要求，也可以用于查询查询排序，这是因为<strong>索引的第一列被指定为一个常数。</strong>还有更多可以使用索引做排序的查询示例。下面这个查询可以利用查询排序，是因为<strong>查询为索引的第一列提供了常量条件，而使用第二列进行排序，将两列组合在一起，就形成了索引的最左前缀</strong>：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">...WHERE retal_date = '2005-05-25' ORDER BY inventory_id DESC;</span><br></pre></td></tr></table></figure><p>下面这个查询也可以，<strong>因为ORDER BY使用的两列就是索引的最左前缀：</strong></p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">...WHERE retal_date &gt; '2005-05-25' ORDER BY retal_date,inventory_id;</span><br></pre></td></tr></table></figure><p>下面是一些不能使用索引做排序的查询：</p><ul><li>查询使用两种不同的排序方向，但是索引列都是正序排序的。</li><li>查询的ORDER BY子句中引用了一个不在索引中的列。</li><li>查询的WHERE 和ORDER BY中的列无法组合成索引的最左前缀。</li><li>查询在索引列的第一列上使范围条件，MySQL无法使用索引的其余列。</li><li>在某一列上有多个等于条件，对于排序来说，这也是一种范围查询。</li></ul><p>使用索引做排序的一个最重要的用法是当查询同时有ORDER BY和LIMIT子句的时候。</p><h2 id="压缩（前缀压缩）索引"><a href="#压缩（前缀压缩）索引" class="headerlink" title="压缩（前缀压缩）索引"></a>压缩（前缀压缩）索引</h2><p>MyISAM使用前缀压缩来减少索引的大小，从而让更多的索引可以放入内存中，这在某些情况下能极大的提高性能。<strong>默认只压缩字符串，也可以设置对整数压缩。</strong>MyISAM压缩每个索引块的方法是：<strong>先完全保存索引块中的第一个值，然后将其他值和第一个值进行比较得到相同前缀的字节数和剩余的不同后缀部分，把这部分存储起来即可。</strong>例如索引块中的第一个值是“perform”，第二个值是“performance”，那么这个值的前缀压缩后存储的是类似“7.ance”这样的形式，同样MyISAM对行指针也采用类似的前缀压缩方式。</p><p>压缩块使用更少的空间，代价是某些操作可能更慢。因为<strong>每个值的压缩前缀都依赖前面的值，所以MyISAM查找时无法在索引块使用二分查找而只能从头开始扫描</strong>。正序的扫描速度还不错，但是倒序就不是很好了。对于CPU密集型应用，因为扫描需要随机查找，压缩索引使得MyISAM在索引查找上要慢好几倍；但如果是I/O密集型应用，对某些查询带来的好处会比成本多很多。</p><h2 id="冗余和重复索引"><a href="#冗余和重复索引" class="headerlink" title="冗余和重复索引"></a>冗余和重复索引</h2><p>MySQL允许在相同列上创建多个索引，MySQL需要单独与维护重复的索引，并且优化器在优化查询的时候也需要逐个地进行考虑，这会影响性能。</p><p><strong>重复索引是指在相同的列上按照相同的顺序创建的相同类型的索引。</strong>应该避免这样创建重复索引。</p><p><strong>冗余索引和重复索引有一些不同。如果创建了索引（A，B），在创建索引（A）就是冗余索引，因为这是前一个索引的前缀索引。因此索引（A，B）也可以当作索引（A）来使用。但是如果再创建索引（B，A）则不是冗余索引，因为B不是索引（A，B）的最左前缀列。</strong></p><p>冗余索引通常发生在为表添加新索引的时候。例如，可能会增加一个新的索引（A,B）而不是扩展已有的索引（A），还有一种情况是将一个索引扩展为（A，ID），其中ID是主键，对于InnoDB来说主键列已经包含在二级索引中了，所以这也是冗余的。大多数情况下都不需要冗余索引，<strong>应该尽量扩展已有的索引而不是创建新索引。</strong>但也有时候出于性能方面考虑需要冗余索引，因为扩展已有的索引会太大导致影响性能。</p><p>有多个索引的缺点是索引成本更高，表中的索引越多插入速度会越慢，一般来说，增加新索引将导致INSERT、UPDATE、DELETE等操作速度变慢。解决冗余索引和重复索引的方法很简单，删除这些索引就可以。</p><h2 id="未使用的索引"><a href="#未使用的索引" class="headerlink" title="未使用的索引"></a>未使用的索引</h2><p>除了冗余索引和重复索引，可能还会有一些服务器永远不用的索引，这样的索引完全是累赘，建议考虑删除。</p><h2 id="索引和锁"><a href="#索引和锁" class="headerlink" title="索引和锁"></a>索引和锁</h2><p><strong>索引可以让查询锁定更少的行。</strong>InnoDB只有在访问行的时候才会对其进行加锁，而索引能够减少InnoDB访问的行数，从而减少锁的行数，但这只有当InnoDB在存储引擎层能够过滤掉索引不需要的行时才有效。</p><p>关于InnoDB、索引和锁有一些细节很少有人知道：<strong>InnoDB在二级索引上使用共享（读）锁，但访问主键索引需要排他（写）锁。这消除使用覆盖索引的可能性，并且使得SELECT FOR UPDATE比LOCK IN SHARE MODE或非锁定查询要慢的多。</strong></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>在MySQL中，大多数情况下都会使用B-Tree索引。其他类型的索引大多只适用于特殊的目的。如果在合适的场景中，将大大提高查询的响应时间。在选择索引和编写利用这些索引的查询时有如下三个原则始终需要记住：</p><ul><li><strong>单行访问是很慢的。</strong>特别是在机械硬盘存储中，如果服务器从存储中读取一个数据块只是为了获取其中一行，那么就浪费了很多工作。最好读取的块中能包含尽可能多所需要的行。使用索引可以创建位置引用以提升效率。</li><li><strong>按顺序访问范围数据是很快的，</strong>这有两个原因：<strong>第一，I/O不需要多次磁盘寻道，所以比随机I/O要快很多；第二，如果服务器能够按需要顺序读取数据，那么就不再需要额外的排序操作，并且GROUP BY查询也无须再做排序和将行按组进行聚合计算了。</strong></li><li><strong>索引覆盖查询是很快的。</strong>如果一个索引包含了查询的所有列，那么存储引擎就不需要再回表查找行，这避免了大量的单行访问。</li></ul>]]></content>
    
    <summary type="html">
    
      索引（也叫做“键（key）”）是存储引擎用于快速找到记录的一种数据结构。这里介绍了索引的基础知识、基本功能和优化，还讨论索引其它一些方面有用的属性。
    
    </summary>
    
      <category term="MySQL数据库" scheme="http://yoursite.com/categories/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
  </entry>
  
  <entry>
    <title>Schema与数据类型优化</title>
    <link href="http://yoursite.com/posts/64582/"/>
    <id>http://yoursite.com/posts/64582/</id>
    <published>2019-09-15T07:26:55.000Z</published>
    <updated>2019-09-18T11:59:17.260Z</updated>
    
    <content type="html"><![CDATA[<h1 id="选择优化的数据类型"><a href="#选择优化的数据类型" class="headerlink" title="选择优化的数据类型"></a>选择优化的数据类型</h1><p>MySQL支持的数据类型非常多，选择正确的数据类型对于获得高性能至关重要。不管存储哪种类型的数据库，下面几个简单的原则都有助于做出更好的选择：</p><ul><li><strong>更小的通常更好</strong>：<strong>一般情况下，应该尽量使用可以正确存储数据的最小数据类型。更小的数据类型通常更快，占用更少的磁盘、内存和CPU缓存，处理时需要的CPU周期更少。</strong>但是要在保证没有低估需要存储的值的范围的前提下，如果无法确定哪个数据类型是最好的，就选择你认为不会超过范围的最小类型。</li><li><strong>简单就好</strong>：<strong>简单数据类型的操作通常需要更少的CPU周期。</strong>有两个例子：一个应该使用MySQL内建的类型而不是字符串来存储日期和时间；另外一个是应该用整型存储IP地址。</li><li><strong>尽量避免NULL</strong>：很多表都包含可唯NULL的列，这是因为<strong>NULL是列的默认属性</strong>。通常情况下最好指定列为NOT NULL，除非真的需要存储NULL值。因为如果查询中包含可为NULL的列，对MySQL来说更难优化，因为可为NULL的列使得索引、索引统计和值比较都复杂。<strong>可为NULL的列会使用更多的存储空间，在MySQL中也需要特殊处理。当可为NULL的列被索引时，每个索引记录需要一个额外字节，在MyISAM里甚至还可能会导致固定大小的索引变成可变大小的索引。</strong></li></ul><p>在为列选择数据类型时，第一步需要确定合适的大类型：数字、字符串、时间等，下一步是选择具体类型，很多MySQL的数据类型可以存储相同类型的数据，只是存储的长度和范围不一样、允许的精度不同，或需要的物理空间不同等等。</p><p>例如DATETIME和TIMESTAMP都可以存储时间和日期，精确到秒，然而TIMESTAMP只是用DATETIME一半的存储空间，并且会根据时区变化，具有特殊的自动更新能力。但是另一方面，TIMESTAMP允许的时间范围要小得多。</p><h2 id="整数类型"><a href="#整数类型" class="headerlink" title="整数类型"></a>整数类型</h2><p>有两种类型的数字：<strong>整数</strong>和<strong>实数</strong>，如果存储整数，可以使用这几种整数类型：TINYINT、SMALLINT、MEDIUMINT、INT和BIGINT，分别使用8、16、24、32、64位存储空间。</p><p>整数类型又可选的UNSIGNED属性，表示不允许负值，这大致可以使正数的上限提高一倍。例如TINYINT的存储范围是-128 ~ 127，而TINYINT UNSIGNED可以存储的范围是0 ~ 255。</p><p><strong>有符号和无符号类型使用相同的存储空间，并且具有相同的性能。</strong>整数计算一般使用64位的BIGINT整数，即使在32位环境下也是如此。</p><p><strong>MySQL可以为整数类型指定宽度，但是对于大多数应用没有意义:它不会限制值的合法范围，只是规定了MySQL一些交互工具用来显示字符的个数。</strong>因此对于存储和计算来说，INT(1)和INT(20)是相同的。</p><h2 id="实数类型"><a href="#实数类型" class="headerlink" title="实数类型"></a>实数类型</h2><p>实数是带有小数部分的数字。但是它们不只是为了存储小数部分，也可以使用DECIMAL存储比BIGINT还大的整数。MySQL既支持精确类型，也支持不精确类型。</p><p>FLOAT和DOUBLE类型支持使用标准的浮点运算进行近似计算。</p><p>DECIMAL类型用于存储精确的小数，支持精确计算。因为CPU不支持对DECIMAL的直接计算，所以MySQL服务器自身实现了DECIMAL的高精度计算，相对而言，<strong>CPU直接支持原生浮点计算，所以浮点运算明显更快。</strong></p><p>浮点和DECIMAL类型都可以指定精度。对于DECIMAL列，可以指定小数点前后所允许的最大位数，这会影响列的空间消耗。MySQL中将数字打包到一个二进制字符串中（每4个字节存9个数字），例如：<strong>DECIMAL（18，9）小数点两边各存储9个数字，一共使用9个字节：小数点前的数字同4个字节，小数点后的数字用4个字节，小数点本身占1个字节。</strong>DECIMAL类型允许最多65个数字，因为DECIMAL只是一种存储格式，在计算中DECIMAL会转换为DOUBLE类型。</p><p>浮点类型在存储同样范围的值时，通常比DECIMAL使用更少的空间。FLOAT使用4个字节存储；DOUBLE占用8个字节，相比FLOAT有更高的精度和更大的范围。</p><p><strong>因为需要额外的空间和计算开销，所以应该尽量只在对小数进行精确计算时才使用DECIMAL</strong>，例如存储财务数据。<strong>在数据量比较大的时候，可以考虑使用BIGINT代替DECIMAL，将需要存储的货币单位根据小数的位数乘以相应的倍数即可。</strong></p><h2 id="字符串类型"><a href="#字符串类型" class="headerlink" title="字符串类型"></a>字符串类型</h2><p>VARCHAR和CHAR两种最主要的字符串类型，存储的具体方式与存储引擎的实现有关，所以下面描述的内容，假设存储引擎是InnoDB或者MyISAM。</p><h3 id="VARCHAR类型"><a href="#VARCHAR类型" class="headerlink" title="VARCHAR类型"></a>VARCHAR类型</h3><p>VARCHAR用于存储可变长字符串，是最常见的字符串数据类型。它更加节省空间，因为它仅使用必要的空间（即越短的字符串使用越少的空间）。但是如果表使用<code>ROW_FORMAT = FIXED</code>创建的话每一行都会使用定长存储，这样很浪费空间。</p><p><strong>VARCHAR需要使用1或2个额外字节记录字符串的长度：如果列的最大长度小于或等于255字节，则只使用1个字节表示，否则使用2个字节。</strong></p><p>由于行是变长的，在UPDATE时可能使行变得更长，这就导致需要做额外的工作。<strong>如果一个行占用的空间增长，并且在页内没有更多的空间可以存储，MyISAM会将行拆成不同的片段存储，InnoDB则需要分裂页来使行可以放进页内。</strong></p><p>下面这些情况下使用VARCHAR是合适的：字符串列的最大长度比平均长度大很多；列的更新很少，所以碎片不是问题；使用了像UTF-8这样复杂的字符集，每个字符都使用不同的字节数进行存储。</p><p>MySQL在存储和检索时会保留末尾空格，但是在4.1或者老版本中则会剔除末尾空格。<strong>InnoDB则更为灵活，它可以把过长的VARCHAR存储为BLOB。</strong></p><h3 id="CHAR类型"><a href="#CHAR类型" class="headerlink" title="CHAR类型"></a>CHAR类型</h3><p>CHAR类型是定长的：MySQL总是根据定义的字符串长度分配足够的空间。当存储CHAR值时，<strong>MySQL会删除所有的末尾空格。</strong></p><p><strong>CHAR适合存储很短的字符串，或者所有值都接近同一个长度。</strong>对于经常变更的数据，CHAR也比VARCHAR更好，因为定长的CHAR类型不容易产生碎片</p><p>与CHAR和VARCHAR类似的类型还有BINARY和VARBINARY，它们存储的是二进制字符串，<strong>二进制字符串存储的是字节码而不是字符，填充也不一样：MySQL填充BINARY采用的是“\0”而不是空格，在检索时也不会去掉填充。</strong>二进制的优势并不仅仅体现在大小写敏感上，MySQL比较BINARY字符串时，每次按一个字节，并且根据该字节的数值进行比较。因此，二进制比较比字符比较简单很多，所以也就更快。</p><p>在使用VARCHAR时，更长的列会消耗更多的内存，因为MySQL通常会分配固定大小的内存块来保存内部值。尤其是使用内存临时表进行排序或操作是会特别糟糕，<strong>所以最好的策略是只分配真正需要的空间。</strong></p><h3 id="BLOB和TEXT类型"><a href="#BLOB和TEXT类型" class="headerlink" title="BLOB和TEXT类型"></a>BLOB和TEXT类型</h3><p>BLOB和TEXT都是为存储很大的数据而设计的字符串数据类型，分别采用二进制和字符方式存储。字符类型是TINYTEXT、SMALLTEXT、TEXT、MEDIUMTEXT和LONGTEXT；二进制类型是TINYBLOB、SMALLBLOB、BLOB、MEDIUMBLOB、LONGBLOB。BLOB是SMALLBLOB的同义词，TEXT是SMALLTEXT的同义词。</p><p>MySQL把每个BLOB和TEXT值当作一个独立的对象处理，存储引擎在存储时通常会做特殊处理，<strong>当BLOB和TEXT值太大时，InnoDB会使用专门的“外部”存储区域来进行存储，此时每个值在行内需要1~4个字节存储一个指针，然后再外部存储区域存储实际的值。</strong></p><p>BLOB没有排序规则或字符集，而TEXT类型有字符集和排序规则。MySQL对BLOB和TEXT列进行排序与其他类型是不同的：它只对每个列的最前面max_sort_length字节而不是整个字符串做排序。如果只需要排序前面一小部分的字符，则可以减小max_sort_length的配置，或者使用ORDER BY SUBSTRING(column,length)。</p><p>MySQL不能将BLOB和TEXT列全部长度的字符串进行索引，也不能使用这些索引消除排序。</p><h3 id="使用枚举（ENUM）代替字符串类型"><a href="#使用枚举（ENUM）代替字符串类型" class="headerlink" title="使用枚举（ENUM）代替字符串类型"></a>使用枚举（ENUM）代替字符串类型</h3><p>有时可以使用枚举代替常用的字符串类型。<strong>枚举列可以把一些不重复的字符串存储成一个预定义的集合。</strong>MySQL在存储枚举时非常紧凑，会根据列表值的数量压缩到一个或者两个字节中。</p><p>MySQL在内部会将每个值在列表中的位置保存为整数，所以实际存储为整数，而不是字符串。所以使用数字作为ENUM枚举常量，这种双重性很容易导致混乱。而且<strong>枚举字段是按照内部存储的整数而不是定义的字符串进行排序的。</strong>因此一种绕过这种限制的方式是按照需要的顺序来定义枚举列，另外也可以在查询中使用FIELD()函数显示地指定排序顺序，但是这会导致MySQL无法利用索引消除排序。</p><p><strong>枚举最不好的地方就是：字符串列表是固定的，添加或删除字符串必须使用ALTER TABLE，除非能接受只在列表末尾添加元素。</strong></p><p>因此一个通用的设计实践：<strong>在查找表时采用整数主键而避免采用基于字符串的值进行关联</strong>。ENUM可以让表的大小缩小，因此它可以更加节省内存。</p><h2 id="日期和时间类型"><a href="#日期和时间类型" class="headerlink" title="日期和时间类型"></a>日期和时间类型</h2><p>MySQL能存储的最小时间粒度为秒，但是MySQL也可以使用微秒级的粒度进行临时运算：可以使用BIGINT类型存储微秒级别的时间戳，或者使用DOUBLE存储秒之后的小数部分。</p><p>MySQL提供两种相似的日期类型：<strong>DATETIME</strong>和<strong>TIMESTAMP</strong>。</p><ul><li><strong>DATETIME</strong>：这个类型能保存大范围的值<strong>，从1001到9999年，精度为秒。</strong>它把日期和时间封装到格式为YYYYMMDDHHMMSS的整数中，与时区无关。使用8个字节的存储空间。默认情况下，MySQL以一种可排序的、无歧义的格式显示DATETIME值。</li><li><strong>TIMESTAMP</strong>：TIMESTAMP类型保存了从1970年1月1日以来的秒数，他和UNIX时间戳相同。TIMESTAMP只使用4个字节的存储空间，因此它的范围比DATETIME小得多：<strong>只能从1970年到2038年。**</strong>MySQL按照DATETIME的方式格式化TIMESTAMP的值，但是这仅仅是显示格式上的区别，TIMESTAMP的存储格式在各个版本都是一样的。TIMESTAMP显式的值也依赖于时区。<strong>默认情况下，如果插入时没有指定第一个TIMESTAMP列的值，MySQL则设置这个列的值为当前时间，再插入一行记录时，MySQL默认也会更新第一个TIMESTAMP列的值。</strong>TIMESTAMP列默认为NOT NULL。**</li></ul><p><strong>除了特殊行为之外，通常也应该尽量使用TIMESTAMP，因为它比DATETIME空间效率更高。</strong></p><h2 id="位数据类型"><a href="#位数据类型" class="headerlink" title="位数据类型"></a>位数据类型</h2><p>MySQL有少数几种存储类型使用紧凑的位存储数据，所以这些存储类型，不管底层存储格式和处理方式如何，从技术上讲都是字符串类型。</p><ul><li><strong>BIT</strong>：可以使用BIT列在一列中存储一个或多个true/false值。BIT(1)定义一个包含单个位的字段，BIT(2)存出2个位，以此类推。BIT列的最大长度位64个位。BIT在MyISAM中会打包存储所有的BIT列，所以更加节省空间；但是在InnoDB中，为每个BIT列使用一个足够存储的最小整数类型来存放，<strong>所以不能节省空间</strong>。MySQL把BIT当作字符串类型，而不是数字类型。所以对于大部分应用，最好避免使用这种类型。</li><li><strong>SET</strong>：它在MySQL内部以一系列打包的位的集合来表的，这样就有效的利用了存储空间。可以使用一个整数包装一系列的位。</li></ul><h2 id="选择标识符-identifier"><a href="#选择标识符-identifier" class="headerlink" title="选择标识符(identifier)"></a>选择标识符(identifier)</h2><p>为标识列选择合适的数据类型非常重要。一般来说更有可能用标识列与其他值进行比较，或者通过标识列寻找其他列。</p><ul><li><strong>整数类型</strong>：整数通常是标识列最好的选择，因为它们很快并且可以使用AUTO_INCREMENT。</li><li><strong>ENUM和SET</strong>：对于标识列来说，ENUM和SET类型通常是一个糟糕的选择，所以大部分情况下都要避免这么做。</li><li><strong>字符串类型</strong>：应该尽量避免使用字符串类型作为标识列，因为它们很消耗空间，并且通常比数字类型慢。</li></ul><h2 id="特殊数据类型"><a href="#特殊数据类型" class="headerlink" title="特殊数据类型"></a>特殊数据类型</h2><p>人们通常使用VARCHAR（15）列来存储IP地址，然而，它们<strong>实际上是32位无符号整数，不是字符串。</strong>用小数点将地址分成四段的表示方法只是为了让人们容易阅读，所以应该用无符号整数存储IP地址。<strong>MySQL提供INET_ATON()和INET_NTOA()函数在这两种表示方法之间转换。</strong></p><h1 id="Schema设计中的陷阱"><a href="#Schema设计中的陷阱" class="headerlink" title="Schema设计中的陷阱"></a>Schema设计中的陷阱</h1><p>有一些问题是由MySQL的实现机制导致的，所以这里讨论一下MySQL的schema的设计上的问题。</p><ul><li><strong>太多的列</strong>：<strong>MySQL的存储引擎API工作时需要在服务器层和存储引擎层之间通过行缓冲格式拷贝数据，然后再服务器曾将缓冲解码成各个列。从行缓冲中将编码过的列转换成行数据结构的操作代价非常高，转换的代价依赖于列的数量。</strong>如果一个非常宽的表，然而只有一小部分列会实际用到，这时转换的代价就非常高。</li><li><strong>太多的关联</strong>：关联操作会导致MySQL解析和优化查询的代价非常高。<strong>MySQL限制了每个关联操作最多只能有61张表，如果希望查询执行得快速且并发性能好，单个查询最好在12个表以内做关联。</strong></li><li><strong>全能的枚举</strong>：注意防止过度使用枚举（ENUM）。</li><li><strong>变相的枚举</strong>：枚举列允许在列中存储一组定义值中的单个值，集合列则允许在列中存储一组定义值中的一个或多个值，有时候这可能比较容易导致混乱。</li><li><strong>非此发明的NULL</strong>：之前说过建议尽可能地考虑替代NULL的方案，例如可以使用0、某个特殊值或空字符串作为替代。但是<strong>遵循这个原则也不要走极端，当确实需要表示未知值时也不要害怕使用NULL。</strong>值得一提的是，<strong>MySQL会在索引中存储NULL值，而Oracle不会。</strong></li></ul><h1 id="范式和反范式"><a href="#范式和反范式" class="headerlink" title="范式和反范式"></a>范式和反范式</h1><h2 id="范式的优点和缺点"><a href="#范式的优点和缺点" class="headerlink" title="范式的优点和缺点"></a>范式的优点和缺点</h2><p><strong>优点：</strong></p><blockquote><ul><li><strong>范式化的更新操作通常比反范式化要快。</strong></li><li>当数据较好地范式化时，就只有很少或者没有重复度的数据，所以<strong>只需要修改更少的数据。</strong></li><li><strong>范式化的表通常更小</strong>，可以更好地放在内存里，所以<strong>执行操作会更快。</strong></li><li><strong>很少有多余的数据意味着检索列表数据会更少需要DISTINCT或者GROUP BY语句</strong>，而在非范式化的结构中必须使用DISTINCT或者GROUP BY才能获得一份唯一的列表。</li></ul></blockquote><p><strong>缺点：</strong></p><blockquote><ul><li>范式化的设计表的缺点是通常需要关联，这不但<strong>代价昂贵，也可能使一些索引策略无效。</strong></li></ul></blockquote><h2 id="反范式的优点和缺点"><a href="#反范式的优点和缺点" class="headerlink" title="反范式的优点和缺点"></a>反范式的优点和缺点</h2><p><strong>优点：</strong></p><blockquote><ul><li>反范式化的schema因为所有数据都在一张表中，可以更好地放在内存里，所以<strong>执行操作会更快。</strong></li><li>如果不需要关联表，则对大部分查询最差的情况————即使表没有索引————是全表扫描。可以更好地放在内存里，所以<strong>执行操作会更快。</strong></li><li><strong>单独的表也能使用更有效的索引策略。</strong></li></ul></blockquote><p>缺点见范式化的优点部分。</p><h2 id="混用范式化和反范式化"><a href="#混用范式化和反范式化" class="headerlink" title="混用范式化和反范式化"></a>混用范式化和反范式化</h2><p>完全的范式化和完全的反范式化schema都是实验室才有的东西，在真实世界中很少会这么极端地使用。<strong>在实际应用中经常需要混用。</strong></p><p>最常见的反范式化数据的方法是复制或者缓存，在不同的表中存储相同的特定列。在MySQL5.0和更新版本中，可以使用触发器更新缓存值。</p><h1 id="缓存表和汇总表"><a href="#缓存表和汇总表" class="headerlink" title="缓存表和汇总表"></a>缓存表和汇总表</h1><p>有时提升性能最好的方法是在同一张表中保存衍生的冗余数据，然而有时也需要创建一张完全独立的汇总表或缓存表（特别是为满足检索到需求时）。</p><p><strong>我们用术语“缓存表”来表示存储那些可以简单地从schema其他表获取、但是每次获取的速度比较慢的数据的表；而术语“汇总表”则保存的是使用GROUP BY语句聚合数据的表。</strong></p><p>实时计算统计值是很昂贵的操作，因为要么需要扫描表中大部分数据，要么查询语句只能在某些特定的索引上才能有效运行，而这类特定索引一般会对UPDATE操作有影响，所以一般不希望创建这样的索引。<strong>而缓存表则相反，其对优化搜索和检索查询语句很有效。</strong></p><p><strong>一个有用的技巧是对缓存表使用不同的存储引擎。</strong>例如，如果主表使用InnoDB，用MyISAM作为缓存表的引擎将会得到更小的索引占用空间，并且可以做全文搜索。</p><p>在使用缓存表和汇总表时，必须决定是实时维护数据还是定期重建。哪个更好依赖于应用程序，但是<strong>定期重建并不只是节省资源，也可以保持表不会有很多碎片，以及有完全顺序组织的索引，这会更高效。</strong></p><p>当重建汇总表和缓存表时，通常需要保证数据在操作时依然可用，这就需要通过使用“影子表”来实现。<strong>“影子表”指的是一张在真实的表背后创建的表，当完成了建表操作后，可以通过一个原子的重命名操作切换影子表和原表。</strong>而且如果新表有问题，则可以很容易地进行快速回滚操作。</p><h2 id="物化视图"><a href="#物化视图" class="headerlink" title="物化视图"></a>物化视图</h2><p><strong>物化视图实际上是预先计算并且存储在磁盘上的表，可以通过各种各样的策略刷新和更新。</strong>在第七章会详细探讨物化方法。</p><h2 id="计数器表"><a href="#计数器表" class="headerlink" title="计数器表"></a>计数器表</h2><p>如果在应用中保存计数器，则在更新计数器时可能碰到并发问题。这时<strong>可以创建一张独立的表存储计时器，这样可使计数器表小并且快，使用独立的表可以避免查询缓存失效。</strong></p><p>然而问题在于，对于任何想要更新这一行的事务来说，这条记录都有一个全局的互斥锁。这会使这些事务只能串行执行。<strong>要获得更高的并发性能，也可以将计数器保存在多行中，每次随机选择一行进行更新操作。</strong></p><h2 id="更快的读，更慢的写"><a href="#更快的读，更慢的写" class="headerlink" title="更快的读，更慢的写"></a>更快的读，更慢的写</h2><p>为了提升读查询的速度，经常会需要建一些额外索引，增加冗余列，甚至是创建缓存表和汇总表。这些方法会增加写查询到负担，但是<strong>虽然写操作变慢了，但更显著地提高了读操作的性能。</strong></p><h1 id="加快ALTER-TABLE操作的速度"><a href="#加快ALTER-TABLE操作的速度" class="headerlink" title="加快ALTER TABLE操作的速度"></a>加快ALTER TABLE操作的速度</h1><p>MySQL执行<strong>大部分</strong>修改表结构操作的方法是用新的结构常见一个空表，从旧表中查出所有数据插入新表，然后删除旧表。问题是这样的操作可能需要很长时间。</p><p>一般而言，大部分ALTER TABLE操作将导致MySQL服务中断，但是能使用两种技巧进行改善：</p><ul><li>一种是先在一台不提供服务的机器上执行ALTER TABLE操作，然后和提供服务端主库进行切换。</li><li>另外一种是“影子拷贝”，是用要求的表结构创建一张和源表无关的新表，然后通过重命名和删表操作交换两张表。</li></ul><p><strong>不是所有的ALTER TABLE操作都会引起表重建。</strong>例如修改一个列的默认值：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> film</span><br><span class="line"><span class="keyword">MODIFY</span> <span class="keyword">COLUMN</span> rental_duration <span class="built_in">TINYINT</span>(<span class="number">3</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="number">5</span>;</span><br></pre></td></tr></table></figure><p>这个语句会拷贝整张表到一张新表，但是甚至列的类型、大小和可否为NULL属性都没改变。<strong>因为所有的MODIFY COLUMN 操作都会导致表重建。</strong>另一种方法是通过ALTER COLUMN操作来改变列的默认值：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> film</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">COLUMN</span> rental_duration <span class="keyword">SET</span> <span class="keyword">DEFAULT</span> <span class="number">5</span>;</span><br></pre></td></tr></table></figure><p><strong>这个语句会直接修改.frm文件而不涉及表数据。</strong>所以这个操作是非常快的。</p><h2 id="只修改-frm文件"><a href="#只修改-frm文件" class="headerlink" title="只修改.frm文件"></a>只修改.frm文件</h2><p>从上面的例子可以看出修改表的.frm文件是很快的。下面这些操作是<strong>有可能</strong>不需要重建表的：</p><ul><li>移除（不是增加）一个列的AUTO_INCREMENT属性。</li><li>增加、溢出，或更改ENUM和SET常量，如果移除的是已有行数据用到其值的变量，查询将会返回一个空字符串。</li></ul><p><strong>基本的技术是为想要的表结构创建一个新的.frm文件，然后用它替换掉已经存在的那张表的.frm文件。</strong></p><h2 id="快速创建MyISAM索引"><a href="#快速创建MyISAM索引" class="headerlink" title="快速创建MyISAM索引"></a>快速创建MyISAM索引</h2><p>为了高效地载入数据到MyISAM表中，<strong>有一个常用的技巧是：先禁用索引、载入数据，然后重新启用索引。</strong></p><p>因为构建索引的工作被延迟到数据完全载入之后，这个时候已经可以通过排序来构建索引饿了。这样做会快很多，并且使得索引树的碎片更少、更紧凑。</p><p><strong>不幸的是，这个方法对唯一索引无效，因为DISABLE KEYS只对非唯一索引有效。</strong></p><p><strong>因此在InnoDB中有一个类似的技巧：先删除所有非唯一索引，然后增加新的列，最后重新创建删除掉的索引。</strong>Percona Server可以自动完成这些操作步骤。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>总之来说，尽可能保持任何东西小而简单总是好的。MySQL喜欢简单，需要使用数据库的人也会同样喜欢简单的原则：</p><ul><li><strong>尽量避免过度设计。</strong>例如会导致极其复杂查询的schema设计，或者有很多列的表设计。</li><li><strong>使用小而简单的合适数据类型，除非真实数据模型中有确切需要，否则应该尽可能地避免使用NULL。</strong></li><li><strong>尽量使用相同的数据类型存储相似或相关的值，尤其是要在关联条件中使用的列。</strong></li><li><strong>注意可变长字符串，其在临时表和排序时可能导致悲观的按最大长度分配内存。</strong></li><li><strong>尽量使用整型定义标识列。</strong></li><li><strong>避免使用MySQL已经遗弃的特性，例如指定浮点数的精度，或者整数的显示宽度。</strong></li><li><strong>小心使用ENUM和SET，最好避免使用BIT</strong></li></ul>]]></content>
    
    <summary type="html">
    
      这章关注MySQL数据库的设计，主要介绍MySQL数据库设计与其他关系型数据库管理系统的区别。
    
    </summary>
    
      <category term="MySQL数据库" scheme="http://yoursite.com/categories/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
  </entry>
  
  <entry>
    <title>LinkedList源码阅读</title>
    <link href="http://yoursite.com/posts/44983/"/>
    <id>http://yoursite.com/posts/44983/</id>
    <published>2019-09-13T11:49:58.000Z</published>
    <updated>2019-09-14T12:37:12.186Z</updated>
    
    <content type="html"><![CDATA[<h1 id="LinkedList的数据结构"><a href="#LinkedList的数据结构" class="headerlink" title="LinkedList的数据结构"></a>LinkedList的数据结构</h1><p>LinkedList的底层数据结构是基于双向链表实现的，如图：<img src="/posts/44983/dbb44aed2e738bd49c4d031de4ce9ed3277ff97c.jpeg" alt><br>因为链表在物理内存上可以是不连续的，所以理论上，只要计算机的内存足够大的情况下，LinkedList的长度可以无限长。</p><h1 id="顶部注释"><a href="#顶部注释" class="headerlink" title="顶部注释"></a>顶部注释</h1><blockquote><p>双向链表实现了List和Deque接口。 实现所有可选列表操作，并允许所有元素（包括null ）。<br>所有的操作都能像双向列表一样预期。 索引到列表中的操作将从开始或结束遍历列表，以更接近指定的索引为准。 </p><p>请注意，此实现不同步。 如果多个线程同时访问链接列表，并且至少有一个线程在结构上修改列表，则必须在外部进行同步。 （结构修改是添加或删除一个或多个元素的任何操作;仅设置元素的值不是结构修改。）这通常通过在自然封装列表的对象上进行同步来实现。 如果没有这样的对象存在，列表应该使用Collections.synchronizedList方法“包装”。 这最好在创建时完成，以防止意外的不同步访问列表：<br><code>List list = Collections.synchronizedList(new LinkedList(...));</code></p><p>该类的iterator和listIterator方法返回的迭代器是fail-fast的 ：如果列表在迭代器创建后的任何时间进行结构修改，除了通过Iterator自己的remove或add方法外，迭代器将抛出一个ConcurrentModificationException 。 因此，面对并发修改，迭代器将快速而干净地失败，而不是在未来未确定的时间冒着任意的非确定性行为。 </p><p>请注意，迭代器的故障快速行为无法保证，因为一般来说，在不同步并发修改的情况下，无法做出任何硬性保证。 失败快速的迭代器ConcurrentModificationException扔掉ConcurrentModificationException 。 因此，编写依赖于此异常的程序的正确性将是错误的： 迭代器的故障快速行为应仅用于检测错误。 </p></blockquote><p>从上面LinkedList的源码顶部注释可以总结以下几点：</p><ul><li><strong>底部实现</strong>：双向链表。</li><li><strong>是否允许null值</strong>：允许所有元素，包括null。</li><li><strong>线程安全</strong>：线程不安全。</li><li><strong>迭代器</strong>：迭代器是fast-fail，但是迭代器的快速失败行为不能得到保证。</li><li><strong>运行时间</strong>：因为是链表的实现，所以任何需要查询到操作都需要遍历链表，即O(n)的时间。</li></ul><h1 id="LinkedList的定义"><a href="#LinkedList的定义" class="headerlink" title="LinkedList的定义"></a>LinkedList的定义</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedList</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">extends</span> <span class="title">AbstractSequentialList</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">List</span>&lt;<span class="title">E</span>&gt;, <span class="title">Deque</span>&lt;<span class="title">E</span>&gt;, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span></span></span><br></pre></td></tr></table></figure><ul><li><strong>LinkedList<e></e></strong>：支持泛型的存储模式。</li><li><strong>extends AbstractSequentialList<e></e></strong>：继承于AbstractSequentialList，继承了其中的方法，方便操作。</li><li><strong>implements List<e></e></strong>：实现了List接口，实现该接口提供的方法，方便了实现。</li><li><strong>implements Deque<e></e></strong>：实现了双端队列的接口，因此双向链表操作起来更方便。</li><li><strong>implements Cloneable</strong>：实现了Cloneable接口，内部可以调用clone()方法来返回实例的浅拷贝(shallow copy)。</li><li><strong>implements Serializable</strong>：实现了Serializable接口，表明该类是可以序列化的。</li></ul><h1 id="全局变量"><a href="#全局变量" class="headerlink" title="全局变量"></a>全局变量</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//记录元素个数的常量</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">int</span> size = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//静态内部类Node，即存储每个数据的节点</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 内存保存的内容有三个，分别是：</span></span><br><span class="line"><span class="comment">* item:储存的元素</span></span><br><span class="line"><span class="comment">* next:该节点后面一个节点</span></span><br><span class="line"><span class="comment">* prev:该节点前面一个节点</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">       E item;</span><br><span class="line">       Node&lt;E&gt; next;</span><br><span class="line">       Node&lt;E&gt; prev;</span><br><span class="line"></span><br><span class="line">       Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123;</span><br><span class="line">           <span class="keyword">this</span>.item = element;</span><br><span class="line">           <span class="keyword">this</span>.next = next;</span><br><span class="line">           <span class="keyword">this</span>.prev = prev;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 指向第一个节点的指针。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">transient</span> Node&lt;E&gt; first;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 指向最后一个节点的指针。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">transient</span> Node&lt;E&gt; last;</span><br></pre></td></tr></table></figure><h1 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h1><p>LinkedList只有两个构造方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 构造一个空列表。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">LinkedList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 构造包含指定集合的元素的列表，按集合的迭代器返回元素的顺序排列。</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span>  c 要将其元素放入此列表的集合</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@throws</span> NullPointerException 如果指定的集合为空</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">LinkedList</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">this</span>();</span><br><span class="line">       addAll(c);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>可以从上面的代码中看出，两个构造方法分别是无参方法和传入一个集合的方法。</p><p>无参方法的方法体为空，因为是链表结构，而链表的头指针和尾指针已经在上面定义过了，而且不同于数组结构，不需要指定大小和扩容，所以方便很多，因此无参方法什么都不需要做。</p><p>传入一个集合的构造方法使用addAll()方法将传入的集合按顺序添加到链表的尾部，addAll()方法可以的具体实现可以看下面的核心方法部分。</p><h1 id="核心方法"><a href="#核心方法" class="headerlink" title="核心方法"></a>核心方法</h1><h2 id="getFirst和getLast方法"><a href="#getFirst和getLast方法" class="headerlink" title="getFirst和getLast方法"></a>getFirst和getLast方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 返回列表中的第一个元素。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 列表中的第一个元素</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> NoSuchElementException 如果这个列表是空的</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">getFirst</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; f = first;</span><br><span class="line">    <span class="keyword">if</span> (f == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">    <span class="keyword">return</span> f.item;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据代码可以看出，获取到first节点，如果列表中没有元素，所以列表是空的，first节点自然是null，所以抛出NoSuchElementException异常；否则返回first节点的数据。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 返回列表中的最后一个元素。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 列表中的最后一个元素</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> NoSuchElementException 如果这个列表是空的</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">getLast</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; l = last;</span><br><span class="line">    <span class="keyword">if</span> (l == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">    <span class="keyword">return</span> l.item;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同getFirst方法很相似，获取到last节点的值，依旧判断last是否为空，为空则抛出异常；否则返回最后一个节点last的值。</p><h2 id="removeFirst方法"><a href="#removeFirst方法" class="headerlink" title="removeFirst方法"></a>removeFirst方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 从列表中移除并返回第一个元素。.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 列表中的第一个元素</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> NoSuchElementException 如果这个列表是空的</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">removeFirst</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; f = first;</span><br><span class="line">    <span class="keyword">if</span> (f == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">    <span class="keyword">return</span> unlinkFirst(f);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 断开第一个非空节点f的链接。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> E <span class="title">unlinkFirst</span><span class="params">(Node&lt;E&gt; f)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 判断 f == first &amp;&amp; f != null;</span></span><br><span class="line">    <span class="keyword">final</span> E element = f.item;</span><br><span class="line">    <span class="comment">//头节点的下一个节点，当头节点移除后，它就是头节点</span></span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; next = f.next;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 因为头节点是第一个节点，所以它的prev自然为null</span></span><br><span class="line"><span class="comment">     * 把头结点的值和next字段赋值为null，有助于GC回收</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    f.item = <span class="keyword">null</span>;</span><br><span class="line">    f.next = <span class="keyword">null</span>; <span class="comment">// 有助于 GC</span></span><br><span class="line">    <span class="comment">//然后把next作为头节点</span></span><br><span class="line">    first = next;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 如果头节点的下一个节点是null，那么说明列表中只有一个节点</span></span><br><span class="line"><span class="comment">     * 因此把last也赋值为null，说明至此链表中已无元素</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * 否则把头结点的prev字段置为null，说明该节点是头节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (next == <span class="keyword">null</span>)</span><br><span class="line">        last = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        next.prev = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 列表中元素数量减一</span></span><br><span class="line"><span class="comment">     * 修改次数加一</span></span><br><span class="line"><span class="comment">     * 返回被删除节点的值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    size--;</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="keyword">return</span> element;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="removeLast方法"><a href="#removeLast方法" class="headerlink" title="removeLast方法"></a>removeLast方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 从列表中移除并返回最后一个元素。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 列表中的最后一个元素</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> NoSuchElementException 如果这个列表是空的</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">removeLast</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; l = last;</span><br><span class="line">    <span class="keyword">if</span> (l == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">    <span class="keyword">return</span> unlinkLast(l);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 断开最后非空的一个节点l。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> E <span class="title">unlinkLast</span><span class="params">(Node&lt;E&gt; l)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 判断 l == last &amp;&amp; l != null;</span></span><br><span class="line">    <span class="keyword">final</span> E element = l.item;</span><br><span class="line">    <span class="comment">//尾节点的前一个节点，当尾节点移除后，它就是尾节点</span></span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; prev = l.prev;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 因为尾节点是第一个节点，所以它的next自然为null</span></span><br><span class="line"><span class="comment">     * 把头结点的值和prev字段赋值为null，有助于GC回收</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    l.item = <span class="keyword">null</span>;</span><br><span class="line">    l.prev = <span class="keyword">null</span>; <span class="comment">// 有助于 GC</span></span><br><span class="line">  <span class="comment">//然后把prev作为头节点</span></span><br><span class="line">    last = prev;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 如果尾节点的前一个节点是null，那么说明列表中只有一个节点</span></span><br><span class="line"><span class="comment">     * 因此把first也赋值为null，说明至此链表中已无元素</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * 否则把尾结点的next字段置为null，说明该节点是尾节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (prev == <span class="keyword">null</span>)</span><br><span class="line">        first = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        prev.next = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 列表中元素数量减一</span></span><br><span class="line"><span class="comment">     * 修改次数加一</span></span><br><span class="line"><span class="comment">     * 返回被删除节点的值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    size--;</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="keyword">return</span> element;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="addFirst方法"><a href="#addFirst方法" class="headerlink" title="addFirst方法"></a>addFirst方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 在列表的开头插入指定的元素。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> e 要添加的元素</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addFirst</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    linkFirst(e);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 链接e作为第一个元素。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">linkFirst</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; f = first;</span><br><span class="line">    <span class="comment">//调用Node的构造方法，定义一个prev字段为null、next字段为f的newNode节点</span></span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; newNode = <span class="keyword">new</span> Node&lt;&gt;(<span class="keyword">null</span>, e, f);</span><br><span class="line">    <span class="comment">//然后把newNode作为头节点</span></span><br><span class="line">    first = newNode;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 如果原来的头节点f为空的话，说明列表中原来没有任何元素</span></span><br><span class="line"><span class="comment">     * 所以现在插入了一个新的节点，自然头节点和尾节点都是它，所以尾节点也是它。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (f == <span class="keyword">null</span>)</span><br><span class="line">        last = newNode;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *否则列表中原来不为空，只需要把新节点和原来的头节点连起来就好了</span></span><br><span class="line"><span class="comment">     *连起来的方法就是把原结点f的prev字段赋为现在的新头节点即可</span></span><br><span class="line"><span class="comment">     *即f节点是链表中第二个节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">        f.prev = newNode;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 元素数量加一</span></span><br><span class="line"><span class="comment">     * 修改次数加一</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    size++;</span><br><span class="line">    modCount++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="add和addLast方法"><a href="#add和addLast方法" class="headerlink" title="add和addLast方法"></a>add和addLast方法</h2><p>add和addLast方法中同是调用了linkLast方法，将新的元素添加到链表的尾部，二者的唯一却别就是add方法添加成功的话，会返回true表示插入成功，而addLast方法则无返回值，在内部实现上无任何区别。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *将指定的元素追加到此列表的末尾。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;这个方法相当于 addLast() 方法</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> e 要附加到此列表中的元素</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> true （由 Collection.add(E)指定） </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    linkLast(e);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将指定的元素追加到此列表的末尾。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;这个方法相当于 add() 方法</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> e 要添加的元素</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addLast</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    linkLast(e);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 链接e作为最后一个元素。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">linkLast</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; l = last;</span><br><span class="line">    <span class="comment">//定义一个前驱节点是last、后置节点是null的节点newNode，即将作为尾节点</span></span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; newNode = <span class="keyword">new</span> Node&lt;&gt;(l, e, <span class="keyword">null</span>);</span><br><span class="line">    <span class="comment">//把刚刚新定义的节点作为新的尾节点</span></span><br><span class="line">    last = newNode;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *如果原来的尾节点是null的话，说明原来列表中无元素，所以first自然也为null</span></span><br><span class="line"><span class="comment">     *所以这里新插入一个元素后，first和last节点同时指向仅有的一个元素节点</span></span><br><span class="line"><span class="comment">     *仅有的该元素节点既是头节点，也是尾节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (l == <span class="keyword">null</span>)</span><br><span class="line">        first = newNode;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 如果原来列表中元素不为空，就把新的尾节点和旧的尾节点连接起来</span></span><br><span class="line"><span class="comment">     * 方法就是把旧的尾节点的next字段置为新的尾节点，即l节点是倒数第二个节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">        l.next = newNode;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 元素数量加一</span></span><br><span class="line"><span class="comment">     * 修改次数加一</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    size++;</span><br><span class="line">    modCount++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="contains和indexOf方法"><a href="#contains和indexOf方法" class="headerlink" title="contains和indexOf方法"></a>contains和indexOf方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 如果此列表包含指定的元素，则返回true。更正式地说，当且仅当此列表包含至少一个元素e，使得Objects.equals(o, e)。</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> o 其在此列表中的存在性将被测试的元素</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; 如果此列表包含指定的元素</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *内部则调用indexOf方法，判断该元素的下标是否大于等于零</span></span><br><span class="line"><span class="comment"> *下标大于等于零则表示元素存在，如果不存在，indexOf方法会返回-1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">    <span class="keyword">return</span> indexOf(o) &gt;= <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *返回此列表中指定元素的第一个出现项的索引，如果该列表不包含该元素，则返回-1。</span></span><br><span class="line"><span class="comment"> *更正式地说，返回最低索引i满足Objects.equals(o, get(i))，如果没有这样的索引，则为-1。</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> o 要搜索的元素</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 此列表中指定元素的首次出现的索引，如果此列表不包含元素，则为-1 </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *因为LinkedList允许元素为null，所以要分开判断元素是null和非null的情况</span></span><br><span class="line"><span class="comment">     *因为null的判定方法是 == 号，而非null的元素则使用Objects.equals(o, get(i))方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (o == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *当要查找的元素是null的时候，从头节点first节点开始遍历</span></span><br><span class="line"><span class="comment">     *直到找到值为null或者节点为null为止，节点为null的也就是last之后的那个节点为止</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">        <span class="keyword">for</span> (Node&lt;E&gt; x = first; x != <span class="keyword">null</span>; x = x.next) &#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         *如果节点中的值为null，则返回其下标</span></span><br><span class="line"><span class="comment">         *否则继续向后遍历，下标加一</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">            <span class="keyword">if</span> (x.item == <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">return</span> index;</span><br><span class="line">            index++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *当要查找的元素是非null的时候，从头节点first节点开始遍历</span></span><br><span class="line"><span class="comment">     *直到找到o.equals(x.item)或者节点为空为止，也就是last之后的那个节点为止</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">        <span class="keyword">for</span> (Node&lt;E&gt; x = first; x != <span class="keyword">null</span>; x = x.next) &#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         *如果节点中的值为与要查找的节点一致，则返回其下标</span></span><br><span class="line"><span class="comment">         *否则继续向后遍历，下标加一</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">            <span class="keyword">if</span> (o.equals(x.item))</span><br><span class="line">                <span class="keyword">return</span> index;</span><br><span class="line">            index++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果遍历过整个链表都没有找到符合要求的节点的话，就返回-1</span></span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="size方法"><a href="#size方法" class="headerlink" title="size方法"></a>size方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 返回此列表中的元素数量。</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> 列表中元素的数量</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//即返回记录链表中元素数量的遍历size</span></span><br><span class="line">       <span class="keyword">return</span> size;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h2 id="remove方法"><a href="#remove方法" class="headerlink" title="remove方法"></a>remove方法</h2><p>remove方法有三个重载方法，分别是无参方法、传入下标和传入指定对象的方法。</p><h3 id="remove-Object-o"><a href="#remove-Object-o" class="headerlink" title="remove(Object o)"></a>remove(Object o)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  *从列表中删除指定元素的第一个出现项(如果存在)。如果这个列表不包含这个元素，它将保持不变。</span></span><br><span class="line"><span class="comment">  *更正式地说，删除索引i最低的元素，使得Objects.equals(o, get(i)) (如果存在这样一个元素)。</span></span><br><span class="line"><span class="comment">  *如果此列表包含指定的元素，则返回true(如果此列表由于调用而更改，则返回true)。</span></span><br><span class="line"><span class="comment">  * </span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> o 元素，如果存在，则从该列表中删除</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; 如果此列表包含指定的元素</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">if</span> (o == <span class="keyword">null</span>) &#123;</span><br><span class="line">     <span class="comment">/**</span></span><br><span class="line"><span class="comment">      *如果传入的对象是null，则遍历链表，找到第一个值为null的节点</span></span><br><span class="line"><span class="comment">      *然后调用unlink方法将其删除</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">         <span class="keyword">for</span> (Node&lt;E&gt; x = first; x != <span class="keyword">null</span>; x = x.next) &#123;</span><br><span class="line">             <span class="keyword">if</span> (x.item == <span class="keyword">null</span>) &#123;</span><br><span class="line">                 unlink(x);</span><br><span class="line">                 <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">     <span class="comment">/**</span></span><br><span class="line"><span class="comment">      *如果传入的对象是非null的，则遍历链表，找到第一个符合o.equals(x.item)的节点</span></span><br><span class="line"><span class="comment">      *然后调用unlink方法将其删除</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">         <span class="keyword">for</span> (Node&lt;E&gt; x = first; x != <span class="keyword">null</span>; x = x.next) &#123;</span><br><span class="line">             <span class="keyword">if</span> (o.equals(x.item)) &#123;</span><br><span class="line">                 unlink(x);</span><br><span class="line">                 <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">//如果删除成功，则返回true，否则返回false。</span></span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  *断开非空节点x的链接。</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="function">E <span class="title">unlink</span><span class="params">(Node&lt;E&gt; x)</span> </span>&#123;</span><br><span class="line">     <span class="comment">/**</span></span><br><span class="line"><span class="comment">      * 判断 x != null</span></span><br><span class="line"><span class="comment">      * 记录要删除的节点和其前驱节点和后置节点</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">     <span class="keyword">final</span> E element = x.item;</span><br><span class="line">     <span class="keyword">final</span> Node&lt;E&gt; next = x.next;</span><br><span class="line">     <span class="keyword">final</span> Node&lt;E&gt; prev = x.prev;</span><br><span class="line">     <span class="comment">/**</span></span><br><span class="line"><span class="comment">      *如果前驱节点是null的话，说明要删除的节点就是第一个节点</span></span><br><span class="line"><span class="comment">      *故删除后就把它的后置节点（也就是第二节点）作为新的头节点</span></span><br><span class="line"><span class="comment">      *</span></span><br><span class="line"><span class="comment">      *否则把前驱节点的下一个节点赋为当前节点的后一个节点</span></span><br><span class="line"><span class="comment">      *然后把当前节点的前驱节点置为null</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">     <span class="keyword">if</span> (prev == <span class="keyword">null</span>) &#123;</span><br><span class="line">         first = next;</span><br><span class="line">     &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         prev.next = next;</span><br><span class="line">         x.prev = <span class="keyword">null</span>;</span><br><span class="line">     &#125;</span><br><span class="line">     </span><br><span class="line">     <span class="comment">/**</span></span><br><span class="line"><span class="comment">      *如果后置节点是null的话，说明要删除的节点就是最后一个节点</span></span><br><span class="line"><span class="comment">      *故删除后就把它的前驱节点（也就是倒数第二个节点）作为新的头节点</span></span><br><span class="line"><span class="comment">      *</span></span><br><span class="line"><span class="comment">      *否则把后置节点的前一个节点赋为当前节点的前一个节点</span></span><br><span class="line"><span class="comment">      *然后把当前节点的后置节点置为null</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">     <span class="keyword">if</span> (next == <span class="keyword">null</span>) &#123;</span><br><span class="line">         last = prev;</span><br><span class="line">     &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         next.prev = prev;</span><br><span class="line">         x.next = <span class="keyword">null</span>;</span><br><span class="line">     &#125;</span><br><span class="line">     </span><br><span class="line">     <span class="comment">/**</span></span><br><span class="line"><span class="comment">      *经过上面两个if判断，当前节点的前驱节点和后置节点已经全部赋值为null</span></span><br><span class="line"><span class="comment">      *并且已经把它的前驱节点和后置节点相互连接了</span></span><br><span class="line"><span class="comment">      *这里当前节点把值赋为null，就意味着删除了，然后等待GC回收即可</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">     x.item = <span class="keyword">null</span>;</span><br><span class="line">     <span class="comment">/**</span></span><br><span class="line"><span class="comment">      *元素数量减一</span></span><br><span class="line"><span class="comment">      *修改次数加一</span></span><br><span class="line"><span class="comment">      *返回被删除的节点的值</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">     size--;</span><br><span class="line">     modCount++;</span><br><span class="line">     <span class="keyword">return</span> element;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h3 id="remove-int-index"><a href="#remove-int-index" class="headerlink" title="remove(int index)"></a>remove(int index)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 移除列表中指定位置的元素。将任何后续元素向左移动(从它们的索引中减去一个)。返回从列表中删除的元素。 </span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> index 要删除的元素的索引</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 先前位于指定位置的元素</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IndexOutOfBoundsException 表示某种索引(如数组索引、收敛索引或向量索引)超出范围。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 这里先对传入的下标进行检查，判断是否越界</span></span><br><span class="line"><span class="comment"> * 如果没有越界则使用node(index)方法找到指定位置的结点</span></span><br><span class="line"><span class="comment"> * 然后使用unlink方法将这个节点删除</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">    checkElementIndex(index);</span><br><span class="line">    <span class="keyword">return</span> unlink(node(index));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先看以下判断下标是否越界的checkElementIndex方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">checkElementIndex</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!isElementIndex(index))</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException(outOfBoundsMsg(index));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * checkElementIndex 方法实际调用了这个方法判断下标是否越界</span></span><br><span class="line"><span class="comment"> * 如果越界则抛出异常</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> index</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isElementIndex</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> index &gt;= <span class="number">0</span> &amp;&amp; index &lt; size;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在下标符合要求后，使用node方法查找到指定位置的节点：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 返回指定元素索引处的(非空)节点。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">Node&lt;E&gt; <span class="title">node</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 这里先判断要查找的下标是在链表的前半部分还是后半部分</span></span><br><span class="line"><span class="comment"> * 如果是在前半部分就从头指针开始查找</span></span><br><span class="line"><span class="comment"> * 如果是在后半部分就从尾指针开始查找</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">    <span class="keyword">if</span> (index &lt; (size &gt;&gt; <span class="number">1</span>)) &#123;</span><br><span class="line">    <span class="comment">//在前半部分，从头指针开始查找</span></span><br><span class="line">        Node&lt;E&gt; x = first;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; index; i++)</span><br><span class="line">            x = x.next;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">//在后半部分，从尾指针开始查找</span></span><br><span class="line">        Node&lt;E&gt; x = last;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = size - <span class="number">1</span>; i &gt; index; i--)</span><br><span class="line">            x = x.prev;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在使用node方法找到指定下标位置的节点之后，使用unlink方法将该节点删除掉，unlink方法在上面remove(Object o)方法中有讲过。</p><h3 id="remove"><a href="#remove" class="headerlink" title="remove()"></a>remove()</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 检索并删除此列表的头部(第一个元素)。</span></span><br><span class="line"><span class="comment"> * 该方法与removeFirst无差别，不多赘述，二者一模一样。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 这个列表的头</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> NoSuchElementException 如果这个列表是空的</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 1.5</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> removeFirst();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="lastIndexOf方法"><a href="#lastIndexOf方法" class="headerlink" title="lastIndexOf方法"></a>lastIndexOf方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 返回此列表中指定元素的最后一次出现的索引，如果该列表不包含该元素，则返回-1。</span></span><br><span class="line"><span class="comment"> * 更正式地说，返回最高索引i，满足Objects.equals(o, get(i))，如果没有这样的索引，则为-1。</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> o 要搜索的元素</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 此列表中指定元素的最后一次出现的索引，如果该列表不包含该元素，则为-1     </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lastIndexOf</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 这个方法实现indexOf方法唯一的区别就是：这个方法从后向前查找，而indexOf方法从前向后查找，其余部分无区别</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">    <span class="keyword">int</span> index = size;</span><br><span class="line">    <span class="keyword">if</span> (o == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (Node&lt;E&gt; x = last; x != <span class="keyword">null</span>; x = x.prev) &#123;</span><br><span class="line">            index--;</span><br><span class="line">            <span class="keyword">if</span> (x.item == <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">return</span> index;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (Node&lt;E&gt; x = last; x != <span class="keyword">null</span>; x = x.prev) &#123;</span><br><span class="line">            index--;</span><br><span class="line">            <span class="keyword">if</span> (o.equals(x.item))</span><br><span class="line">                <span class="keyword">return</span> index;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="toArray方法"><a href="#toArray方法" class="headerlink" title="toArray方法"></a>toArray方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 返回一个数组，该数组按适当的顺序(从第一个元素到最后一个元素)包含列表中的所有元素。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 返回的数组将是“安全的”，因为这个列表不维护对它的引用。(换句话说，这个方法必须分配一个新的数组)。</span></span><br><span class="line"><span class="comment"> * 因此，调用者可以自由地修改返回的数组。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 此方法充当基于数组和基于集合的api之间的桥梁。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 一个数组，按适当的顺序包含列表中的所有元素</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> Object[] toArray() &#123;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 实现方法就是先创建一个与size大小相等的数组</span></span><br><span class="line"><span class="comment"> * 然后从头结点开始遍历整个链表，把链表中的每个节点的值存入数组中</span></span><br><span class="line"><span class="comment"> * 最后把数组返回</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">    Object[] result = <span class="keyword">new</span> Object[size];</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (Node&lt;E&gt; x = first; x != <span class="keyword">null</span>; x = x.next)</span><br><span class="line">        result[i++] = x.item;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 以正确的顺序返回一个包含此列表中所有元素的数组（从第一个到最后一个元素）; </span></span><br><span class="line"><span class="comment"> * 返回的数组的运行时类型是指定数组的运行时类型。</span></span><br><span class="line"><span class="comment"> * 如果列表适合指定的数组，则返回其中。 否则，将为指定数组的运行时类型和此列表的大小分配一个新数组。 </span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 如果列表适用于指定的数组，并有空余余地（即数组的列表null更多），</span></span><br><span class="line"><span class="comment"> * 则紧跟在列表末尾的数组中的元素设置为null 。 （这仅在调用者知道列表不包含任何空元素的情况下才能确定列表的长度。） </span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 像toArray()方法一样，此方法充当基于阵列和基于集合的API之间的桥梁。 </span></span><br><span class="line"><span class="comment"> * 此外，该方法允许精确地控制输出阵列的运行时类型，并且在某些情况下可以用于节省分配成本。 </span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 假设x是一个已知只包含字符串的列表。 以下代码可用于将列表转储到新分配的String数组中： </span></span><br><span class="line"><span class="comment"> * String[] y = x.toArray(new String[0]); </span></span><br><span class="line"><span class="comment"> * 请注意， toArray(new Object[0])功能与toArray()相同。 </span></span><br><span class="line"><span class="comment"> *   </span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> a  要存储列表的元素的数组，如果它足够大; 否则，为此目的分配相同运行时类型的新数组。 </span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 一个包含列表元素的数组 </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> ArrayStoreException 如果指定数组的运行时类型不是此列表中每个元素的运行时类型的父类型 </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> NullPointerException 如果指定的数组为空</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; T[] toArray(T[] a) &#123;</span><br><span class="line"><span class="comment">//先检查传入的数组长度是否足够，如果不够就将数组扩容为size大小</span></span><br><span class="line">    <span class="keyword">if</span> (a.length &lt; size)</span><br><span class="line">        a = (T[])java.lang.reflect.Array.newInstance(</span><br><span class="line">                            a.getClass().getComponentType(), size);</span><br><span class="line">    <span class="comment">//在容量足够的前提下，将链表中的元素按顺序放入数组中</span></span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    Object[] result = a;</span><br><span class="line">    <span class="keyword">for</span> (Node&lt;E&gt; x = first; x != <span class="keyword">null</span>; x = x.next)</span><br><span class="line">        result[i++] = x.item;</span><br><span class="line">    <span class="comment">//将第一个空出来的位置赋值为null，表示无元素</span></span><br><span class="line">    <span class="keyword">if</span> (a.length &gt; size)</span><br><span class="line">        a[size] = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="队列操作的方法"><a href="#队列操作的方法" class="headerlink" title="队列操作的方法"></a>队列操作的方法</h2><p>因为Queue和Deque都是使用LinkedList实现的，所以这里也顺便提一下把，但是实际上有关队列操作的方法实则都是使用上面的核心方法实现的，所以这里就列一个表格对比一下：</p><ul><li>peek() ：等于getFirst()方法，唯一区别就是当链表为空时，peek方法返回null，getFirst抛出异常。</li><li>element()：等于getFirst()方法。</li><li>poll()：等于removeFirst()方法，唯一区别就是当链表为空时，poll方法返回null，removeFirst抛出异常。</li><li>remove():等于removeFirst()方法。</li><li>offer()：等于add()方法。</li><li>offerFirst()：等于addFirst()方法。</li><li>offerLast()：等于addLas()方法。</li><li>peekFirst()：等于peek()方法。</li><li>peekLast()：等于getLast()方法，唯一区别就是当链表为空时，peekLast方法返回null，getLast抛出异常。</li><li>pollFirst()：等于removeFirst()方法，唯一区别就是当链表为空时，pollFirst方法返回null，removeFirst抛出异常。</li><li>pollLast()：等于removeLast()方法，唯一区别就是当链表为空时，pollLast方法返回null，removeLast抛出异常。</li><li>push()：等于addFirst()方法.</li><li>pop()：等于removeFirst()方法。</li><li>removeFirstOccurrence()：等于remove()方法。</li><li>removeLastOccurrence()：等于removeLast()方法。</li></ul><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>总体来说，LinkedList的源码十分简单，从源码中可以简单得出以下几点：</p><ul><li>LinkedList的底层是双向链表。</li><li>有序。链表是有序的。</li><li>元素可重复，元素可为null。</li><li>随机访问效率低，增删效率高。</li></ul>]]></content>
    
    <summary type="html">
    
      在List接口实现的类中，最常用的一个类：LinkedList，常被用来实现队列和类似于ArrayList的数据结构。
    
    </summary>
    
      <category term="Java容器" scheme="http://yoursite.com/categories/Java%E5%AE%B9%E5%99%A8/"/>
    
    
  </entry>
  
  <entry>
    <title>MySQL整体架构</title>
    <link href="http://yoursite.com/posts/10568/"/>
    <id>http://yoursite.com/posts/10568/</id>
    <published>2019-09-10T12:19:13.000Z</published>
    <updated>2019-09-18T11:59:25.108Z</updated>
    
    <content type="html"><![CDATA[<h1 id="MySQL逻辑架构"><a href="#MySQL逻辑架构" class="headerlink" title="MySQL逻辑架构"></a>MySQL逻辑架构</h1><p>MySQL服务器逻辑架构图<br><img src="/posts/10568/838913-fb7f263a0d00afe7.webp" alt><br>如图所示，MySQL的架构是三层架构，具体介绍如下：</p><ul><li>最上层的服务（层）并不是MySQL独有的，大多数基于网络的客户端/服务器的工具或者服务都有类似的架构。这层的主要作用是连接处理、授权认证、安全等等。</li><li>第二层架构的是MySQL核心服务层，大多数MySQL的核心服务功能都在这一层，包括查询解析、分析、优化、缓存以及所有的内置函数，所有的跨存储引擎的功能都在这一层实现：存储过程、触发器、视图等。</li><li>第三层包括了存储引擎。存储引擎负责MySQL中数据的存储和提取。存储引擎不会去解析SQL（InnoDB例外，它会解析外键定义，因为MySQL服务器本身没有实现该功能），不同的存储引擎之间也不会相互通信，而只是简单地响应上层服务器的请求。</li></ul><h2 id="连接管理与安全性"><a href="#连接管理与安全性" class="headerlink" title="连接管理与安全性"></a>连接管理与安全性</h2><p>每个客户端都会在服务器进程中拥有一个线程，这个连接的查询只会在这个单独的线程中执行，该线程只能轮流在某个CPU核心或者CPU中运行。服务器会负责缓存线程，因此不需要为每一个新建的连接创建或者销毁线程。</p><p>当客户端连接到MySQL服务器时，服务器需要对其进行认证，认证基于用户名、原始主机信息和密码。</p><h2 id="优化与执行"><a href="#优化与执行" class="headerlink" title="优化与执行"></a>优化与执行</h2><p>MySQL会<strong>解析查询</strong>，并创建内部数据结构———解析树，然后对其进行各种优化，包括重写查询，决定表的读取顺序、以及选择合适的索引等。</p><p>用户可以通过特殊的关键字提示优化器，影响它的决策过程；也可以请求优化器解释优化过程的各个因素，使用户可以知道服务器是如何进行优化决策的，并提供一个参考基准，便于用户重构优化。</p><p>对于SELECT语句，在解析查询之前，<strong>服务器会先检查查询缓存</strong>，如果能在其中找到对应的查询，服务器就不必再执行<strong>查询解析、优化、和执行整个过程</strong>，而是直接返回查询缓存中的结果集。</p><h1 id="并发控制"><a href="#并发控制" class="headerlink" title="并发控制"></a>并发控制</h1><p>这里讨论MySQL在两个层面的并发控制：服务器层和存储引擎层。</p><h2 id="读写锁"><a href="#读写锁" class="headerlink" title="读写锁"></a>读写锁</h2><p>在处理并发或者写时，可以通过实现一个由两种类型的锁组成的锁系统来解决问题。这两种类型的锁通常被称为<strong>共享锁（shared lock）</strong>和<strong>排他锁（exclusive lock）</strong>，也叫<strong>读锁（read lock）</strong>和<strong>写锁（write lock）</strong>。</p><ul><li>读锁：是共享的，也就是相互不阻塞的。多个客户端在同一时刻可以同时读取同一个资源，而互不干扰。</li><li>写锁：是排他的，也就是一个写锁会阻塞其他的写锁和读锁，确保在给定的时间里，只有一个用户能执行写入，并防止其他用户读取正在写入的同一资源。</li></ul><h2 id="锁粒度"><a href="#锁粒度" class="headerlink" title="锁粒度"></a>锁粒度</h2><p>一种提高共享资源并发性的方式就是让锁定对象更有选择性。尽量只锁定需要修改的部分数据，而不是所有的资源。更理想的方式是：只对会修改的数据片进行精确的锁定。下面是两种最重要的锁策略：<strong>表锁和行级锁。</strong></p><h3 id="表锁"><a href="#表锁" class="headerlink" title="表锁"></a>表锁</h3><p><strong>表锁（table lock）是MySQL中最基本的锁策略，并且是开销最小的策略：它会锁定整张表。</strong></p><p>在特定场景表锁可能有良好的性能。另外，<strong>写锁也比读锁有更高的优先级</strong>，因此一个写锁请求可能会被插入到读锁列表的前面，反之读锁则不能插入到写锁的前面。</p><p>尽管存储引擎可以管理自己的锁，MySQL本身还是会使用各种有效的表锁来实现不同的目的。例如服务器会为ALTER TABLE之类的语句使用表锁，而忽略存储引擎的锁机制。</p><h3 id="行级锁"><a href="#行级锁" class="headerlink" title="行级锁"></a>行级锁</h3><p>行级锁可以最大程度的支持并发，同时开销也最大。</p><p>行级锁只在存储引擎层实现，而MySQL服务层没有实现。</p><h1 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h1><p><strong>事务就是一组原子性的SQL查询，或者说一个独立的工作单元。</strong>如果数据库引擎能够成功的对数据库应用该组查询的全部语句，那么就执行该组查询。如果其中有任何一条语句因为崩溃或其他原因无法执行，那么所有的语句都不会执行。也就是说，<strong>事务内的语句，要么全部执行成功，要么全部执行失败。</strong></p><p>可以同<code>START TRANSACTION</code>开始一个事务，然后要么用<code>COMMIT</code>提交事务将修改的数据持久保留，要么使用<code>ROLLBACK</code>撤销所有的修改。</p><p><strong>数据库的特性有四条，简称为ACID，分别是：原子性（atomicity）、一致性（consistency）、隔离性（isolated）和持久性（durability）。</strong></p><ul><li><strong>原子性（atomicity）</strong>：<strong>一个事务必须被视为一个不可分割的最小工作单元</strong>，整个事务操作要么全部提交成功，要么全部失败回滚，对于一个事务来说，不可能只执行其中一部分操作，这就是事务的原子性。</li><li><strong>一致性（consistency）</strong>：<strong>数据库总是从一个一致性的状态转换到另一个一致性的状态。</strong></li><li><strong>隔离性（isolated）</strong>：<strong>通常来说，一个事务所做的修改在最终提交以前，对其他事务是不可见的。</strong>这里的“通常来说”与隔离级别有关。</li><li><strong>持久性（durability）</strong>：<strong>一旦事务提交，则其所做的修改就会永久保存到数据库中。</strong>此时即使系统崩溃，修改的数据也不会丢失。</li></ul><h2 id="隔离级别"><a href="#隔离级别" class="headerlink" title="隔离级别"></a>隔离级别</h2><p>在SQL标准中，定义了四种隔离级别。较低级别的隔离通常可以执行更高的并发，系统的开销也更低。</p><ul><li><strong>READ UNCOMMITED（未提交读）</strong>：在READ UNCOMMITTED级别，事务中的修改，即使没有提交，对其他事务也都是可见的。事务可以读取未提交的数据，这也称为<strong>脏读（Dirty Read）</strong>。这个级别会导致很多问题，而从性能上来讲却并不会比其他级别好太多，但缺少其他级别的很多好处，在实际使用中很少使用。</li><li><strong>READ COMMITTED（提交读）</strong>：大多数数据库系统的默认隔离级别都是READ COMMITTED（但MySQL不是）。这个级别满足隔离性。这个级别有时候也叫做不可重复读，因为两次执行同样的查询，可能会得到不一样的结果。</li><li><strong>REPEATABLE READ（可重复读）</strong>：这一级别解决了脏读的问题，该级别保证了在同一个事务中多次读取同样记录的结果是一致的。但是理论上，可重复读级别还是无法结局<strong>幻读</strong>问题：当某个事务再次读取某个范围内的记录时，另外一个事务又在该范围内插入了新的记录，当之前的事务再次读取该范围内的记录时，会产生幻行。InnoDB和XtraDB存储引擎通过多版本并发控制（MVCC）解决了幻读问题。<strong>可重复读是MySQL的默认事务隔离级别。</strong></li><li><strong>SERIALIZABLE（可串行化）</strong>：<strong>这个级别是最高的隔离级别，通过强制事务串行执行，避免了幻读问题。</strong>即会再读取的每一行数据上都加上锁，所以可能导致大量的超时和锁争用问题，只要在非常需要确保数据一致性而且可以接受没有并发的情况下，才考虑使用该级别。</li></ul><p><img src="/posts/10568/TIM%E5%9B%BE%E7%89%8720190910214739.png" alt></p><h2 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h2><p><strong>死锁是指两个或者多个事务在同一资源上相互占用，并请求锁定对方占用的资源，从而导致恶性循环的现象。</strong></p><p>为了解决这种问题，数据库实现了各种死锁检测和死锁超时机制。一种解决方式是当查询的时间达到锁等待超时的设定后放弃锁请求，这种方式通常来说不太友好。<strong>InnoDB目前处理死锁的方法是：将持有最少行级排他锁的事务进行回滚。</strong></p><p>死锁产生有双重原因：有些是因为真正的数据冲突，但有些则完全由于存储引擎的实现方式导致的。死锁发生以后，只有部分或者完全回滚其中一个事务，才能打破死锁。</p><h2 id="事务日志"><a href="#事务日志" class="headerlink" title="事务日志"></a>事务日志</h2><p><strong>使用事务日志在修改表的数据时只需要修改其内存拷贝，再把该修改行为记录到持久在硬盘上的事务日志中，而不用每次都将修改的数据本身持久到磁盘。</strong></p><p>事务日志采用的是追加的方式，因此写日志的操作是磁盘上一小块区域的顺序I/O，所以采用事务日志的方式相对来说要快很多。</p><p>事务日志持久化以后，内存中被修改的数据在后台可以慢慢地刷回到磁盘。因此通常称之为预写式日志，修改数据需要写两次磁盘。</p><p><strong>如果数据的修改已经记录到事务日志并持久化，但数据本身还没有写回磁盘，此时系统崩溃，存储引擎在重启时能够自动恢复这部分修改等数据。</strong></p><h2 id="MySQL中的事务"><a href="#MySQL中的事务" class="headerlink" title="MySQL中的事务"></a>MySQL中的事务</h2><p>MySQL提供了两种事务型的存储引擎：InnDB和NDB Cluster。另外还有一些第三方的存储引擎也支持事务，例如XtraDB和PBXT。</p><h3 id="自动提交"><a href="#自动提交" class="headerlink" title="自动提交"></a>自动提交</h3><p>MySQL默认采用自动提交（AUTOCOMMIT）模式，也就是说，如果不是显式地开始一个事务，则每个查询都被当作一个事务执行提交操作。可以通过<code>SET AUTOCOMMIT = ON/OFF</code>来 开启/关闭 自动提交模式。</p><p>MySQL可以通过执行<br><code>SET [GLOBAL | SESSION] TRANSATION ISOLATION LEVEL  READ UNCOMMITTED| READ COMMITTED| REPEATABLE READ| SERIALIZABLE</code>来设置全局/当前会话的隔离级别，新的隔离级别会在下一个事务开始的时候生效。</p><h3 id="隐式和显式锁定"><a href="#隐式和显式锁定" class="headerlink" title="隐式和显式锁定"></a>隐式和显式锁定</h3><p>InnoDB采用的是<strong>两阶段锁定协议</strong>。<strong>在执行过程中，随时都可以执行锁定，锁只有在执行COMMIT或者ROLLBACK的时候才会释放，并且所有的锁都是在同一时刻被释放。</strong>这就是隐式锁定。</p><p>InnoDB也支持通过特定的语句进行显式锁定：<code>SELECT ... LOCK IN SHARE MODE</code> 和 <code>SELECT ... FOR UPDATE</code>,MySQL也支持<code>LOCK TABLES</code>和<code>UNLOCK TABLES</code>语句，这是在服务层实现的，和存储引擎无关。</p><p>显示的使用这些语句不但没有必要，还会严重影响性能，实际上InnoDB的行级锁工作的更好，<strong>所以应当尽量避免使用LOCK TABLES。</strong></p><h1 id="多版本并发控制"><a href="#多版本并发控制" class="headerlink" title="多版本并发控制"></a>多版本并发控制</h1><p>MySQL的大多数事务型存储引擎实现的都不是简单的行级锁，基于提升并发性能的考虑，它们一般都同时实现了<strong>多版本并发控制（MVCC）</strong>。可以认为MVCC是行级锁的一个变种，但是它在很多情况下避免了加锁操作，因此开销更低。虽然实现机制有可能不同，但大都<strong>实现了非阻塞的读操作，写操作也只锁定必要的行。</strong></p><p><strong>MVCC的实现是通过保存数据在某个时间点的快照来实现的。</strong>也就是说，不管需要执行多长时间，每个事务看到的数据都是一致的。根据事务开始的时间不同，每个事务对同一张表，同一时刻看到的数据可能是不一样的。</p><p><strong>InnoDB的MVCC是通过在每行记录后面保存两个隐藏的列来实现的。这两个列，一个保存了行的创建时间，一个保存行的过期时间（或删除时间）。当然存储的不是实际的时间值，而是系统版本号。每开始一个新的事务，系统版本号都会递增。事务开始时刻的系统版本号会作为事务的版本号，用来和查询到的每行记录的版本号进行比较。</strong></p><ul><li><p><strong>SELECT</strong>：InnoDB会根据以下两个条件检查每行记录： </p><blockquote><ul><li><strong>InnoDB只查找早于当前事务版本的数据行</strong>（即行的系统版本号小于或等于事务的系统版本号），这样可以确保读取的行要么在事务开始前已经存在，要么是事务自身插入或者修改过的。</li><li><strong>行的删除要么未定义，要么大于当前事务版本号。</strong>这样可以确保读取的行在事务开始之前未被删除。</li></ul></blockquote></li><li><p><strong>INSERT</strong>：InnoDB为新插入的每一行保存当前系统版本号作为行版本号。</p></li><li><p><strong>DELETE</strong>：InnoDB为删除的每一行保存当前系统版本号作为行删除标识。</p></li><li><p><strong>UPDATE</strong>：<strong>InnoDB为插入一行新记录，</strong>保存当前系统版本号作为行版本号，<strong>同时保存当前系统版本号到原来的行作为行删除标识。</strong></p></li></ul><p><strong>保存这两个额外系统版本号，优点就是使大多数读操作都可以不用加锁，读数据操作很简单，性能很好，并且也能保证只会读取到符合标准的行。缺点就是每行记录都需要额外的存储空间，需要做更多的行检查工作，以及一些额外的维护工作。</strong></p><p><strong>MVCC只在 REPEATABLE READ（可重复读）和READ COMMITTED（提交读）两个隔离级别下工作</strong>，因为READ UNCOMMITTED总是读取最新的数据行，而SERIALIZABLE则会对所有读取的行加锁。</p><h1 id="MySQL的存储引擎"><a href="#MySQL的存储引擎" class="headerlink" title="MySQL的存储引擎"></a>MySQL的存储引擎</h1><p>可以使用<code>SHOW TABLE STATUS</code> 命令显示表的相关信息。例如：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show table status like 'user' \G</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">           Name: user//表名</span><br><span class="line">         Engine: InnoDB//表引擎</span><br><span class="line">        Version: 10//版本</span><br><span class="line">     Row_format: Dynamic//行的格式。Dynamic的行长度是可变的，一般包含可变长度的字段，如VARCHAR</span><br><span class="line">//；Fixed的行长度则是固定的，只包含固定长度的列，如CHAR。Compressed的行只在压缩</span><br><span class="line">//表中存在。</span><br><span class="line">           Rows: 5//表中的行数，MyISAM和其他一些存储引擎是精确值，但InnoDB是估计值。</span><br><span class="line"> Avg_row_length: 59//平均每行包含的字节数</span><br><span class="line">    Data_length: 16384//表数据的大小（字节）</span><br><span class="line">Max_data_length: 0//表的最大数据容量，该值与存储引擎关</span><br><span class="line">   Index_length: 0//索引的大小</span><br><span class="line">      Data_free: 0//对于MyISAM表，表示已分配但目前没有使用的空间</span><br><span class="line"> Auto_increment: 6//下一个AUTO_INCREMENT的值</span><br><span class="line">    Create_time: 2018-11-19 20:58:21//表的创建时间</span><br><span class="line">    Update_time: NULL//表数据的最后修改时间</span><br><span class="line">     Check_time: NULL//使用<span class="keyword">CHECK</span> <span class="keyword">TABLE</span>命令或者myisamchk工具最后一次检查表的时间</span><br><span class="line">      <span class="keyword">Collation</span>: utf8_general_ci//表的默认字符集和字符列排序规则</span><br><span class="line">       <span class="keyword">Checksum</span>: <span class="literal">NULL</span>//如果启用，保存的是整个表的实时校验和</span><br><span class="line"> Create_options://创建表时指定的其他选项</span><br><span class="line">        <span class="keyword">Comment</span>://建表时的备注</span><br><span class="line"><span class="number">1</span> <span class="keyword">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure><h2 id="InnoDB存储引擎"><a href="#InnoDB存储引擎" class="headerlink" title="InnoDB存储引擎"></a>InnoDB存储引擎</h2><p>InnoDB是MySQL的默认事务型引擎，也是最重要、使用最广泛的存储引擎。它被设计用来处理大量的短期事务，短期事务大部分情况是正常提交的，很少会回滚。InnoDB的性能和自动崩溃恢复特性，使得它在非事务型存储的需求中也很流行。</p><p>InnoDB的数据存储在表空间长，表空间是由InnoDB管理的一个黑盒子，有一系列的数据文件组成，InnoDB可以将每个表的数据和索引存放在单独的文件中。</p><p>InnoDB采用MVCC来支持高并发，并且实现了四个标准的隔离级别，默认为REPATABLE READ，并且通过<strong>间隙锁（next-key locking）</strong>策略防止幻读的出现。间隙锁使得InnoDB不仅仅锁定查询涉及的行，还会对索引中的间隙进行锁定，以防止幻影行的插入。</p><p>InnoDB表是基于聚簇索引建立的，聚簇索引对主键查询有很高的性能，不过它的二级索引中必须包含主键列。因此若表上的索引较多的话，主键应当尽可能的小。InnoDB是平台独立的，可以将数据和索引文件在平台之间拷贝。</p><p>InnoDB内部做了很多优化，包括从磁盘读取数据时采用的可预测性预读，能够自动在内存中创建hash索引以及加速读操作的自适应哈希索引，以及能够加速插入操作的插入缓冲区等。</p><h2 id="MyISAM存储引擎"><a href="#MyISAM存储引擎" class="headerlink" title="MyISAM存储引擎"></a>MyISAM存储引擎</h2><p>M有IASM是MySQL5.1之前的默认存储引擎。MyISAM提供了大量的特性，包括全文索引、压缩、空间函数等，但MyIASM不支持事务和行级锁，而且有一个<strong>最大的缺陷就是崩溃后无法安全恢复。</strong></p><h3 id="存储"><a href="#存储" class="headerlink" title="存储"></a>存储</h3><p>MyIASM会将表存储在两个文件中：<strong>数据文件和索引文件</strong>，分别以.MYD和.MYI为扩展名。MyIASM表可以包含动态或者静态行。MySQL会根据表的定义来决定采用何种行格式。MyIASM表可以存储的行记录数，一般<strong>受限于可用的磁盘空间，或者操作系统中单个文件的最大尺寸。</strong></p><p>在MySQL5.0中，MyIASM表如果是可变行，则默认配置只能处理256TB的数据，可以通过修改表单<code>MAX_ROWS</code>和<code>AVG_ROW_lENGTH</code>选项的值来实现，两者相乘就是表可能达到的最大大小。修改这两个参数会导致重建整个表和表的所有索引，这可能需要很长的时间才能完成。</p><h3 id="MyIASM特性"><a href="#MyIASM特性" class="headerlink" title="MyIASM特性"></a>MyIASM特性</h3><ul><li><strong>加锁与并发</strong>：<strong>MyIASM对整张表加锁</strong>，而不是针对行。<strong>读取时会对需要读到的表加共享锁，写入时则对表加排他锁。但是在表有读取查询的同时，也可以往表中插入新的记录（也被称为并发插入）</strong>。</li><li><strong>修复</strong>：对于MyIASM表，<strong>MySQL可以手工或者自动检查和修复操作。</strong>执行表的修复可能导致一些数据的丢失，而且修复操作是非常慢的。可以通过<code>CHECK TABLE mytable</code>检查表的错误，如果有错误可以通过执行<code>REPAIR TABLE mytable</code>来修复，或者使用myiasmchk命令行工具也可以。</li><li><strong>索引特性</strong>：对于MyIASM表，即使是BLOB和TEXT等长字段，也可以基于其前500个字符创建索引。MyIASM也支持全文索引，这是一种基于分词创建的索引。</li><li><strong>延迟更新索引键（Delayed Key Write）</strong>：如果在创建MyIASM表时指定了<code>DELAY_KEY_WRITE</code>选项，在每次修改执行完时，不会立刻将修改的索引数据写入磁盘，而是会写到内存中的<strong>键缓冲区</strong>，只有在清理键缓冲区或者关闭表的时候才会将对应的索引块写入到磁盘。这种方式可以极大的提升写入性能。</li></ul><h3 id="MyIASM压缩表"><a href="#MyIASM压缩表" class="headerlink" title="MyIASM压缩表"></a>MyIASM压缩表</h3><p>如果表在创建并导入以后，不会再进行修改操作，那么这样得表更适合采用MyIASM压缩表。</p><p>可以使用myiaspack对MyIASM表进行压缩。<strong>压缩表是不能进行修改的（除非先将表解压、修改数据、然后再次压缩）</strong>。压缩表可以极大的减少磁盘空间占用，减少磁盘I/O，从而提升查询性能。压缩表也支持索引，但索引也是只读的。</p><h3 id="MyIASM性能"><a href="#MyIASM性能" class="headerlink" title="MyIASM性能"></a>MyIASM性能</h3><p><strong>MyIASM引擎数据以紧密格式存储</strong>，所以在默写场景下的性能很好。</p><p>MyIASM有一些服务器级别的性能扩展限制，比如对索引键缓冲区的Mutex锁，MariaDB基于段的索引键缓冲区机制来避免该问题，性能上的表锁问题。</p><h2 id="选择合适的引擎"><a href="#选择合适的引擎" class="headerlink" title="选择合适的引擎"></a>选择合适的引擎</h2><p>对于如何选择存储引擎，可以简单的归纳为一句话：<strong>除非需要用到某些InnoDB不具备的特性，并且没有其他办法可以代替，否则都应该优先选择InnoDB引擎</strong>。</p><p><strong>除非万不得已，否则建议不要混合使用多种存储引擎，佛祖额可能带来一系列复杂的问题，以及一些潜在的bug和边界问题。</strong></p><p>如果需要不同的存储引擎，应先考虑以下几个因素：</p><ul><li>事务：如果应用到事务，那么InnoDB是目前最稳定并且经过沿着轨道选择。如果不需要事务，并且主要是SELECT和INSERT操作，那么MyISAM是不错的选择。</li><li>备份：如果需要在线热备份，那么选择InnoDB就是基本的要求。</li><li>崩溃恢复：建议选择InnoDB，因为拥有自动恢复功能。</li><li>特有的特性：有些应用可能依赖一些存储引擎所独有的特性或者优化，比如聚簇索引的优化，应该综合各种情况考虑，选择满足特殊情况下最优的引擎。</li></ul><h2 id="转换表的引擎"><a href="#转换表的引擎" class="headerlink" title="转换表的引擎"></a>转换表的引擎</h2><p>转换表的引擎有三种方法：</p><ul><li><strong>ALTER TABLE</strong>：将表从一个引擎修改为另一个引擎最简单的办法是使用<code>ALTER TABLE</code>语句。例如：<code>ALTER TABLE mytable ENGINE = InnoDB</code>。<strong>这种语法是用于任何存储引擎，但是有一个缺点：需要执行很长时间。</strong>MySQL会按照行将数据从原表复制到一张新的表，在复制期间可能会消耗系统所有的I/O能力，同时原表会加上锁。<strong>同时如果转换表的存储引擎，将会失去和引擎相关的所有特性.</strong></li><li><strong>导出与导入</strong>：可以使用mysqldump工具将数据导出到文件，然后修改文件中<code>CREATE TABLE</code>语句的存储引擎选项。</li><li><strong>创建与查询</strong>：这种方法不需要导出整个表，而是先创建一个新的存储引擎的表，然后利用INSERT–SELECT语法来导数据。<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> innodb_table <span class="keyword">LIKE</span> myisam_table;</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> innodb_table <span class="keyword">ENGINE</span> = <span class="keyword">InnoDB</span>;</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> innodb_table (<span class="keyword">SELECT</span> * <span class="keyword">FROM</span> myisam_table);</span><br></pre></td></tr></table></figure></li></ul><p>当然如果数据量很大的情况下，可以采用分批导入的方法。</p>]]></content>
    
    <summary type="html">
    
      概要地描述了MySQL的服务器架构、各种存储引擎之间的主要区别，以及这些区别的重要性。
    
    </summary>
    
      <category term="MySQL数据库" scheme="http://yoursite.com/categories/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
  </entry>
  
  <entry>
    <title>类加载器</title>
    <link href="http://yoursite.com/posts/16040/"/>
    <id>http://yoursite.com/posts/16040/</id>
    <published>2019-09-06T09:19:20.000Z</published>
    <updated>2019-09-14T12:59:05.315Z</updated>
    
    <content type="html"><![CDATA[<h1 id="类与类加载器"><a href="#类与类加载器" class="headerlink" title="类与类加载器"></a>类与类加载器</h1><p><strong>对于任意一个类，都需要由加载它的类加载器和这个类本身一同确立其在Java虚拟机中的唯一性，每一个类加载器，都拥有一个独立的类名称空间。</strong></p><p>上面这句话的意思即：<strong>比较两个类是否“相等”，只有在这两个类是由同一个类加载器加载的前提下才有意义，否则，即使这两个类来源于同一个Class文件，被同一个虚拟机加载，只要加载它们的类加载器不同，那这两个类就必定不相等。</strong></p><h1 id="双亲委派模型"><a href="#双亲委派模型" class="headerlink" title="双亲委派模型"></a>双亲委派模型</h1><p>从Java虚拟机的角度来讲，只存在两种不同的类加载器：<strong>一种是启动类加载器（Bootstrap ClassLoader），这个类加载器使用C++语言实现，是虚拟机自身的一部分；另一种就是所有其他的类加载器，这些加载器都由Java语言实现，独立于虚拟机外部，并且全都继承自抽象类java.lang.ClassLoader。</strong></p><p>以下是三种系统提供的主要的类加载器：</p><ul><li><strong>启动类加载器（Bootstrap ClassLoader）</strong>：这个类加载器负责将存放在<java_home>\lib目录中的，或者被<code>-Xbootclasspath</code>参数所指定的路径中的，并且是虚拟机识别的类库加载到虚拟机内存中。启动类加载器无法被Java程序直接引用。</java_home></li><li><strong>扩展类加载器（Extension ClassLoader）</strong>：这个加载器它负责加载<java_home>\lib\ext目录中的，或者被java.ext.dirs系统变量所指定的路径中的所有类库，开发者可以直接使用扩展类加载器。</java_home></li><li><strong>应用程序类加载器（Application ClassLoader）</strong>：由于这个类加载器是ClassLoader中的getSystemClassLoader()方法的返回值，所以一般也称它为系统类加载器。它负责加载用户类路径（ClassPath）上所指定的类库，开发者可以直接使用这个类加载器。一般情况下这个就是应用程序中默认的类加载器。</li></ul><p>下图展示的类加载器之间的这种层次关系，称为类加载器的双亲委派模型。<img src="/posts/16040/classloader_WPS%E5%9B%BE%E7%89%87.png" alt></p><p><strong>双亲委派模型要求除了顶层的启动类加载器之外，其余的类加载器都应当有自己的父类加载器，</strong>这里类加载器之间的父子关系一般不会以继承的关系来实现，而是都使用组合关系来复用父加载器的代码。</p><p>双亲委派模型并不是一个强制性的约束模型，而是Java设计者推荐给开发者的一种类加载器实现方式。</p><p>每个类加载都有一个父类加载器，通过下面的程序来验证。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassLoaderDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"ClassLodarDemo's ClassLoader is "</span> + ClassLoaderDemo.class.getClassLoader());</span><br><span class="line">        System.out.println(<span class="string">"The Parent of ClassLodarDemo's ClassLoader is "</span> + ClassLoaderDemo.class.getClassLoader().getParent());</span><br><span class="line">        System.out.println(<span class="string">"The GrandParent of ClassLodarDemo's ClassLoader is "</span> + ClassLoaderDemo.class.getClassLoader().getParent().getParent());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ClassLodarDemo<span class="string">'s ClassLoader is sun.misc.Launcher$AppClassLoader@18b4aac2</span></span><br><span class="line"><span class="string">The Parent of ClassLodarDemo'</span>s ClassLoader is sun.misc.Launcher$ExtClassLoader@<span class="number">1</span>b6d3586</span><br><span class="line">The GrandParent of ClassLodarDemo<span class="string">'s ClassLoader is null</span></span><br></pre></td></tr></table></figure><p>由结果可以看出AppClassLoader的父类加载器为ExtClassLoader，ExtClassLoader的类父加载器为null，但是null并不代表没有父类加载，而是BootstrapClassLoader。</p><p>双亲委派模型这里的<code>双亲</code>更多的表达的是“父母这一辈人而已，并不是说真的有一个Mother ClassLoader和一个Father ClassLoader”。</p><p>双亲委派模型的工作过程是：<strong>如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成，每一层次的类加载器都是如此，因此所有的加载请求最终都应该传送到顶层的类加载器中，只有当父类加载器反馈自己无法完成这个请求（它的搜索范围中没有找到所需的类）时，子加载器才会尝试自己去加载。</strong></p><p>双亲委派模型的源码实现如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ClassLoader parent; </span><br><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; loadClass(String name, <span class="keyword">boolean</span> resolve)</span><br><span class="line">        <span class="keyword">throws</span> ClassNotFoundException</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (getClassLoadingLock(name)) &#123;</span><br><span class="line">            <span class="comment">// 首先，检查请求的类是否已经被加载过</span></span><br><span class="line">            Class&lt;?&gt; c = findLoadedClass(name);</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">long</span> t0 = System.nanoTime();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (parent != <span class="keyword">null</span>) &#123;<span class="comment">//父加载器不为空，调用父加载器loadClass()方法处理</span></span><br><span class="line">                        c = parent.loadClass(name, <span class="keyword">false</span>);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;<span class="comment">//父加载器为空，使用启动类加载器 BootstrapClassLoader 加载</span></span><br><span class="line">                        c = findBootstrapClassOrNull(name);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">                   <span class="comment">//抛出异常说明父类加载器无法完成加载请求</span></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">long</span> t1 = System.nanoTime();</span><br><span class="line">                    <span class="comment">//自己尝试加载</span></span><br><span class="line">                    c = findClass(name);</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// this is the defining class loader; record the stats</span></span><br><span class="line">                    sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0);</span><br><span class="line">                    sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);</span><br><span class="line">                    sun.misc.PerfCounter.getFindClasses().increment();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (resolve) &#123;</span><br><span class="line">                resolveClass(c);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> c;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>这个过程为：先检查是否已经被加载过，若没有加载则调用父加载器的loadClass()方法，若父加载器为空，则默认使用启动类加载器作为父加载器。如果父加载器加载失败，抛出ClassNotFoundException异常后，再调用自己的findClass()方法去加载。</p><p><strong>双亲委派模型的好处：</strong>Java类锁着它的类加载器一起具备了一种带有优先级的层次关系，保证了Java程序的稳定运行，可以避免类的重复加载，同时也保证了Java的核心API不被篡改。</p><p><strong>破坏双亲委派模型的三种方式：</strong></p><ol><li>我们可以自己定义一个类加载器，然后重载loadClass()即可。</li><li>Java设计团队引入的线程上下文类加载器（Thread Context ClassLoader）。这个类加载器可以通过java.lang.Thread类的setContextClassLoader()方法进行设置，如果创建线程时还未设置，它将会从父线程中继承一个，如果再应用程序的全部范围内都没有设置过的化，那这个类的加载器默认就是应用程序类加载器。</li><li>OSGi环境下的网状结构类加载过程。</li></ol>]]></content>
    
    <summary type="html">
    
      虚拟机设计团队把类加载过程中的“通过一个类的全限定名来获取描述此类的二进制字节流”这个动作放到Java虚拟机外部去实现，以便让应用程序自己决定如何去获取所需要的类。实现这个动作的代码模块称为“类加载器”。
    
    </summary>
    
      <category term="Java虚拟机" scheme="http://yoursite.com/categories/Java%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    
    
  </entry>
  
  <entry>
    <title>虚拟机类加载过程</title>
    <link href="http://yoursite.com/posts/2708/"/>
    <id>http://yoursite.com/posts/2708/</id>
    <published>2019-09-05T10:47:25.000Z</published>
    <updated>2019-09-14T12:59:44.100Z</updated>
    
    <content type="html"><![CDATA[<p> 虚拟机把描述类的数据从Class文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的Java类型，这就是虚拟机的类加载机制。</p><p>在Java语言里面，类型的加载、连接和初始化都是在程序运行期间完成的，这种策略虽然会令加载时稍微增加一些性能开销，但是会为Java应用程序提供高度的灵活性。</p><h1 id="类加载的时机"><a href="#类加载的时机" class="headerlink" title="类加载的时机"></a>类加载的时机</h1><p><strong>类从被加载到虚拟机内存中开始，到卸载出内存为止，它的整个生命周期包括：加载（Loading）、验证（Verification）、准备（Preparation）、解析（Resolution）、初始化（Initialization）、使用（Using）和卸载（Unloading）7个阶段，其中验证、准备、解析3个部分通称为连接。</strong><br><img src="/posts/2708/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B.jpg" alt><br>图中加载、验证、准备、初始化和卸载这5个阶段的顺序是确定的，类的加载过程必须按照这种顺序按部就班的<strong>开始</strong>（而不是完成，因为通常会在一个阶段执行的过程中调用、激活另外一个阶段），而解析阶段则不一定：它在某些情况下可以在初始化阶段之后再开始，这是为了支持Java语言的运行时绑定（也成为动态绑定或晚期绑定）。</p><p>对于初始化阶段，虚拟机规范严格指定了有且只有5种情况必须立即对类进行“初始化”：</p><blockquote><ol><li>遇到new、getstatic、putstatic或invokestatic这4条字节码指令时，如果类没有进行过初始化，则需要先触发其初始化。生成这4条指令最常见的Java代码场景是：使用new关键字实例化对象、读取或设置一个类的静态字段（被final修饰、已在编译期把结果放入常量池的静态字段除外），以及调用一个类的静态方法的时候。</li><li>使用java.lang.reflect包的方法对类进行反射调用的时候，如果类没有进行过初始化，则需要先触发其初始化。</li><li>当初始化一个类的时候，如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化。</li><li>当虚拟机启动时，用户需要指定一个要执行的主类（包括main（）方法的那个类），虚拟机会先初始化这个主类。</li><li>当使用JDK1.7的动态语言支持时，如果一个java.lang.invoke.MethodHandle实例最后的解析结果REF_getStatic、REF_putStatic、REF_invokeStatic的方法句柄，并且这个方法句柄所对应的类没有进行过初始化，则需要先触发其初始化。</li></ol></blockquote><p><strong>“有且只有”</strong>这5种场景中的行为称为对一个类进行主动引用。除此之外，所有引用类的方式都不会触发初始化，称为被动引用。被动引用的场景例如：</p><ul><li>通过子类引用父类的静态字段，不会导致子类初始化。</li><li>通过数组来定义引用类，不会触发此类的初始化。</li><li>常量在编译阶段会存入调用类的常量池中，本质上并没有直接引用到定义常量的类。因此不会触发定义常量的类的初始化。</li></ul><p><strong>接口与类真正有所区别的是有且仅有需要开始初始化的5种场景中的第三种：当一个类在初始化时，要求其父类全部都已经初始化过了，但是一个接口在初始化时，并不要求其父接口全部完成了初始化，只有在真正使用到父接口的时候才会初始化。</strong></p><h1 id="类加载的过程"><a href="#类加载的过程" class="headerlink" title="类加载的过程"></a>类加载的过程</h1><p>接下来详细讲解一下Java虚拟机中类加载的全过程，也就是加载、验证、准备、解析、初始化这5个阶段所执行的具体操作。</p><h2 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h2><p>在加载阶段，虚拟机需要完成以下3件事情：</p><ol><li>通过一个类的全限定名来获取定义此类的二进制字节流。</li><li>将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。</li><li>在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口。</li></ol><p>虚拟机规范对上面这3点并不具体，因此是非常灵活的。比如：”通过全类名获取定义此类的二进制字节流” 并没有指明具体从哪里获取、怎样获取。比如：比较常见的就是从 ZIP 包中读取（日后出现的JAR、EAR、WAR格式的基础）、其他文件生成（典型应用就是JSP）等等。</p><p>一个非数组类的加载阶段（加载阶段中获取类的二进制字节流的动作）是开发人员可控性最强的，因为加载阶段既可以通过使用系统提供的引导类加载器来完成，也可以由用户自动移动类加载器去完成（即重写一个loadClass（）方法）。</p><p>对于数组类而言，数组类本身不通过类加载器创建，它是由Java虚拟机直接创建的。一个数组类（称为C）的创建过程遵循以下规则：</p><blockquote><ul><li>如果数组的组件类型（即数组去掉一个维度的类型）是引用类型，那就递归采用本节中定义的加载过程去加载这个组件类型，数组C将在加载该组件类型的类加载器的类名称空间上被标识。</li><li>如果数组的组件类型不是引用类型（例如int[]数组）,Java虚拟机将会把数组C标记为与引导类加载器关联。</li><li>数组类的可见性与它的组件类型的可见性一致；如果数组的组件类型不是引用类型，那数组类的可见性将默认为public。</li></ul></blockquote><p>加载阶段完成后，虚拟机外部的二进制字节流就按照虚拟机所需的格式存储在方法区之中，然后再内存中实例化一个java.lang.Class类的对象。</p><p>加载阶段与连接阶段的部分内容（如一部分字节码文件格式验证动作）是交叉进行的。加载阶段尚未完成，连接阶段可能已经开始，在这些夹在加载阶段之中进行的动作，仍然属于连接阶段的内容，这两个阶段的开始时间仍然保持着固定的先后顺序。</p><h2 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h2><p>验证这一阶段的目的是为了确保Class文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。</p><p>Java语言本身是相对安全的语言，但Class文件并不一定要求用Java源码编译而来，，在字节码层面上，有些Java代码无法做到的时区都是可能实现的，至少语义上可能表达出来。</p><p>对于虚拟机的类加载机制来说，验证阶段是一个非常重要的、但是不一定必要的阶段。如果运行的全部代码都已经被反复使用和验证过，那么在实施阶段就可以考虑使用<code>-Xverify:none</code>参数来关闭大部分的类验证措施，以缩短虚拟机类加载的时间。</p><p><strong>验证阶段大致会完成下面4个阶段的校验工作：文件格式验证、元数据验证、字节码验证、符号引用验证。</strong><br><img src="/posts/2708/%E9%AA%8C%E8%AF%81%E9%98%B6%E6%AE%B5.png" alt></p><h3 id="文件格式验证"><a href="#文件格式验证" class="headerlink" title="文件格式验证"></a>文件格式验证</h3><p><strong>第一阶段要验证字节流是否符合Class文件格式的规范，并且能够被当前版本的虚拟机处理。</strong>这一阶段可能包括验证是否以魔数0xCAFEBABE开头、主、次版本号是否在当前虚拟机处理范围之内等等。</p><p>该阶段的主要目的是为了保证输入的字节流能正确地解析并存储于方法区之内，格式上符合描述一个Java类型信息的要求。</p><h3 id="元数据验证"><a href="#元数据验证" class="headerlink" title="元数据验证"></a>元数据验证</h3><p><strong>第二阶段是对字节码描述的信息进行语义分析，以保证其描述的信息符合Java语言规范的要求。</strong>这个阶段可能包括但验证例如：这个类是否有父类、这个类的父类是否继承了不允许被继承的类等等。</p><p>这个阶段的主要目的是对类的元数据信息进行语义校验，保证不存在不符合Java语言规范的元数据信息。</p><h3 id="字节码验证"><a href="#字节码验证" class="headerlink" title="字节码验证"></a>字节码验证</h3><p><strong>这阶段是整个验证过程中最复杂的一个阶段，主要目的是通过数据流和控制流分析，确定程序语义是合法的。</strong>在这个阶段对类的方法体进行校验分析，保证被校验类的方法在运行时不会做出危害虚拟机安全的事件，例如：保证任意时刻操作数栈的数据类型与指令代码序列都能配合工作，例如不会出现在操作栈放置了一个int类型的数据，使用时却按long类型来加载入本地变量表等等。</p><p>在JDK1.6之后的javac编译器和Java虚拟机中进行了一项优化，给方法体的Code属性表中增加了一项名为“StackMapTable”的属性，这项属性描述了方法体中所有的基本快开始时本地变量表和操作栈应有的状态，在字节码验证期间，就不需要根据程序推导这些状态的合法性，只需检查StackMapTable属性中的记录是否合法即可，这样可以节省时间。</p><h3 id="符号引用验证"><a href="#符号引用验证" class="headerlink" title="符号引用验证"></a>符号引用验证</h3><p>最后一个阶段的校验发生在虚拟机将符号引用转化为直接引用的时候，这个转化动作将在连接的第三阶段（解析阶段）中发生。符号引用的目的是确保解析动作能正常执行。</p><h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><p><strong>准备阶段是正式为<code>类变量</code>（被static修饰的变量）分配内存并设置初始值的阶段</strong>，这些变量所使用的内存都将在方法区中进行分配，这阶段不包括实例变量，实例变量将会在对象实例化时随对象一起分配在Java堆中。</p><p>其次这里说的初始值<strong>通常情况</strong>下是数据类型的零值。假设一个类变量的定义为：<code>public static int value = 123；</code>，那变量value在准备阶段后的初始值是0而不是123，而赋值为123的指令putstatic被程序编译后，存放于类构造器<clinit>方法中。</clinit></p><p>基本数据类型的零值：<br><img src="/posts/2708/%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%9A%84%E9%9B%B6%E5%80%BC.png" alt></p><p>相对于通常情况的特殊情况就是：如果类字段的字段属性表中存在ConstantValue属性，那在准备阶段变量value就会被初始化为ConstantValue属性所指定的值，例如<code>public static final int value = 123;</code>，在准备阶段会根据ConstantValue的设置将value赋值为123。</p><h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><p>解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程。</p><blockquote><ul><li>符号引用：以一组符号来描述所引用的目标，符号可以是任何形式的字面量，只要使用时能无歧义的定位到目标即可。与虚拟机实现的内存布局无关，引用的目标不一定已经加载到内存中。</li><li>直接引用：可以是直接指向目标的指针、相对偏移量或是一个能间件定位到目标的的句柄。和虚拟你实现的内存布局相关，引用到目标必定已经在内存中存在了。</li></ul></blockquote><p>虚拟机规范之中并未规定解析阶段发生的具体实现，只要求了在执行anewarray、checkcast、getfield、getstatic、instanceof、invokedynamic、invokeinterface、invokespecial、invokestatic、invokevirtual、ldc、ldc_w、multianewarray、new、putfield和putstatic这16个用于操作符号引用的字节码指令之前，先对他们所使用的符号引用进行解析。<strong>所以虚拟机实现可以根据需要来判断到底是在类被加载器加载时就对常量池中的符号引用进行解析，还是等到一个符号引用将要被使用前才去解析它。</strong></p><p>对同一个符号引用进行多次解析请求是很常见的事情，虚拟机可以对第一次解析的结果进行缓存，从而避免解析动作重复进行。</p><p>解析动作主要针对类、接口、字段、类方法、接口方法、方法类型、方法句柄和调用点限定符7类符号引用进行，分别对应常量池中的CONSTANT_Class_info、CONSTANT_Fieldref_info、CONSTANT_Methodref_info、CONSTANT_InterfaceMethodref_info、CONSTANT_MethodType_info、CONSTANT_MethodHandle_info和CONSTANT_InvokeDynamic_info 7种常量类型。下面讲解前四种静态符号引用的过程。</p><h3 id="类或接口的解析"><a href="#类或接口的解析" class="headerlink" title="类或接口的解析"></a>类或接口的解析</h3><p>加色和当前代码所处的类为D，如果要把一个从未解析过的符号引用N解析为一个类或接口C的直接引用，虚拟机解析过程如下三个步骤：</p><ol><li>如果C不是一个数组类型，那虚拟机将会把代表N的全限定名传递给D的类加载器去加载这个类C。在加载过程中，由于元数据验证、字节码验证的需要，又可能触发其他相关类的加载动作，例如加载这个类的父类或实现的接口。一旦这个加载过程出现了任何异常，解析过程就宣告失败。</li><li>如果C视野更数组类型，并且数组的元素类型为对象，，那将会按照第1步的规则加载数组的元素类型。</li><li>解析完成之前进行符号引用验证，确认D是否已具备对C的访问权限，如果不具备访问权限，将抛出IllegalAccessError异常。</li></ol><h3 id="字段解析"><a href="#字段解析" class="headerlink" title="字段解析"></a>字段解析</h3><p>首先将会对字段表内class_index项中索引的CONSTAN_Class_info符号引用进行解析，也就是字段所属的类或接口的符号引用。如果解析成功，拿奖这个字段所属的类或接口用C表示，后续解析步骤如下：</p><ol><li>如果C本身就包含了简单名称和字段描述符都与目标相匹配的字段，则返回这个字段的直接引用，解析结束。</li><li>否则，如果在C中实现了接口，将会按照继承关系从下往上递归搜索各个接口和它的父接口，如果接口中包含了简单名称和字段描述符都与目标相匹配的字段，则返回这个字段的直接引用，查找结束。</li><li>否则，如果C不是java.lang.Object的话，将会按照继承关系从下往上递归搜索其父类，如果在父类中包含了简单名称和字段描述符都与目标相匹配的字段，则返回这个字段直接引用，查找失败。</li><li>否则查找失败，抛出NoSuchFieldError异常。</li><li>如果查找过程成功返回了引用，将会对这个字段进行权限验证，如果发现具备对字段的访问权限，将抛出IllegalAccessError异常。</li></ol><p>如果有一个同名字段同时存在于C的接口和父类中，或者同时在自己或父类的多个接口中出现，那编译器将可能拒绝编译。</p><h3 id="类方法解析"><a href="#类方法解析" class="headerlink" title="类方法解析"></a>类方法解析</h3><p>类方法解析的第一个步骤与字段解析一样，也需要先解析出类方法表的class_index项中索引的方法所属的类或接口的符号引用，如果解析成功，用C表示这个类。后续步骤如下：</p><ol><li>类方法和接口方法符号引用的常量类型定义是分开的，如果在类方法表中发现class_index中索引的C是个接口，那就直接抛出java.lang.IncompatibleClassChangeError异常。</li><li>如果通过了第1步，在类C中查找是否有简单名称和描述符都与目标相匹配的方法，如果有则返回这个方法的直接引用，查找结束。</li><li>否则，在类C的父类中递归查找是否有简单名称和描述符都与目标相匹配的方法，如果有则返回这个方法的直接引用，查找结束。</li><li>否则，在类C实现的接口列表及他们的父接口之中递归查找是否有简单名称和描述符都与目标相匹配的方法，如果存在匹配的方法，说明类C是一个抽象，这时查找结束，抛出java.lang.AbstractMethodError异常。</li><li>否则，宣告方法查找失败，抛出java.lang.NoSuchMethodError。</li><li>最后，如果查找过程成功返回了直接引用，将会对这个方法进行权限验证，如果发现不具备对此方法的访问权限，将抛出java.lang.IllegalAccessError异常。</li></ol><h3 id="接口方法解析"><a href="#接口方法解析" class="headerlink" title="接口方法解析"></a>接口方法解析</h3><p>接口方法也需要先解析出接口方法表的class_index项中索引的方法所属的类或接口的符号引用，如果解析成功，依然用C表示这个接口，接下来虚拟机将会按照如下步骤进行后续的接口方法搜索。</p><ol><li>与类方法解析不同，如果在接口方法表中发现class_index中的索引C是个类而不是接口，那就直接抛出java.lang.IncompatibleClassChangeError异常。</li><li>否则，在接口C中查找是否有简单名称和描述符都与目标相匹配的方法，如果有则返回这个方法的直接引用，查找结束。</li><li>否则，在接口C的父接口中递归查找，直到java.lang.Object（查找范围会包括Object类）为止，看是否有简单名称和描述符都与目标相匹配的方法，如果有则返回这个方法的直接引用，查找结束。</li><li>否则，宣告方法查找失败，抛出java.lang.NoSuchMethodError异常。</li></ol><p>由于接口中的所有方法默认都是public，所以不存在访问权限的问题，因此接口方法的符号解析应当不会抛出java.lang.IllegalAccessError异常。</p><h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><p>到了初始化阶段，才真正开始执行类中定义的Java程序代码（或者说字节码）。也可以说初始化阶段是执行类的<clinit>方法的过程。</clinit></p><ol><li><clinit>方法是由编译器自动收集类中的所有<strong>类变量</strong>的复制动作和<strong>静态语句块</strong>中的语句合并产生的，编译器收集的顺序是由语句在源文件中出现的顺序所决定的，静态语句块中只能访问到定义在静态语句块之前的变量；定义i在它之后的变量，在前面的静态语句块可以赋值，但是不能访问。</clinit></li><li><strong><clinit>方法不许需要显式的调用父类的构造器，虚拟机会保证在子类的<clinit>方法执行之前，父类的<clinit>方法已经执行完毕。</clinit></clinit></clinit></strong>因此在虚拟机中第一个被执行的<clinit>方法的类肯定是java.lang.Object。</clinit></li><li><strong>由于父类的<clinit>方法先执行，因此父类中定义的静态语句块要优先于子类的变量赋值操作。</clinit></strong></li><li><strong><clinit>方法对于类或接口来说不是必须的</clinit></strong>，一个类中没有没有静态语句块，也没有对变量的赋值操作，那么编译器就可以不为这个类生成<clinit>方法。</clinit></li><li>接口中不能使用静态语句块，但仍然有变量初始化的赋值操作，因此也会生出<clinit>方法。<strong>但是与类不同，执行接口的<clinit>方法不需要先执行父接口的<clinit>方法，只有当父接口中定义的变量使用时，父接口才会被初始化，接口的实现类在初始化时也一样不会执行接口的<clinit>方法。</clinit></clinit></clinit></strong></clinit></li><li><strong>虚拟机会保证一个类的<clinit>方法在多线程环境中被正确的加锁、同步。</clinit></strong>如果多个线程同时去初始化一个类，那么只会有一个线程去执行这个类的<clinit>方法，其他线程都需要阻塞等待，直到活动线程执行<clinit>方法完毕。</clinit></clinit></li></ol>]]></content>
    
    <summary type="html">
    
      在Class文件中描述的各种信息，最终都需要加载到虚拟机中之后才能运行和使用，而虚拟机如何加载这些Class文件？
    
    </summary>
    
      <category term="Java虚拟机" scheme="http://yoursite.com/categories/Java%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    
    
  </entry>
  
  <entry>
    <title>类文件结构</title>
    <link href="http://yoursite.com/posts/31580/"/>
    <id>http://yoursite.com/posts/31580/</id>
    <published>2019-09-03T09:56:59.000Z</published>
    <updated>2019-09-14T12:58:50.380Z</updated>
    
    <content type="html"><![CDATA[<p>Java虚拟机不和包括Java在内的任何语言绑定，它只与“Class”文件这种特定的二进制文件格式所关联，Class文件中包含了Java虚拟机指令集和符号表以及若干其他辅助信息。</p><p>可以说Class文件是不同的语言在Java虚拟机之间的重要桥梁，同时也是支持Java跨平台很重要的一个原因。</p><h1 id="Class类文件结构总览"><a href="#Class类文件结构总览" class="headerlink" title="Class类文件结构总览"></a>Class类文件结构总览</h1><p>Class文件是一组以8位字节为基础单位的二进制流，各个数据项目严格地按照顺序紧凑地排列在Class文件之中，中间没有添加任何分隔符，当遇到需要占用8位字节以上空间的数据项时，则会按照高位在前的方式分割成若干个8位子节进行存储。</p><p>任何一个Class文件都对应着唯一一个类或接口的定义信息，但反过来说，类或接口并不一定都得定义在文件里（譬如类或接口也可以通过类加载器直接生成）。</p><p>Class文件格式采用一种类似于C语言结构体的伪结构来存储数据，这种伪结构中<strong>只有两种数据类型：无符号数和表。</strong></p><ul><li>无符号数属于基本的数据类型，以u1、u2、u4、u8来分别代表1个字节、2个字节、4个字节和8个字节的无符号数，无符号数可以用来描述数字、索引引用、数量值或者按照UTF-8编码构成字符串值。</li><li>表是由多个无符号数或者其他表作为数据项构成的复合数据类型，所以表都习惯性地以”_info”结尾，表用于描述有层次关系的复合结构的数据，整个Class文件本质上就是一张表。</li></ul><p><strong>Class文件格式：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">u4             magic; <span class="comment">//Class 文件的标志</span></span><br><span class="line">u2             minor_version;<span class="comment">//Class 的小版本号</span></span><br><span class="line">u2             major_version;<span class="comment">//Class 的大版本号</span></span><br><span class="line">u2             constant_pool_count;<span class="comment">//常量池的数量</span></span><br><span class="line">cp_info        constant_pool[constant_pool_count-<span class="number">1</span>];<span class="comment">//常量池</span></span><br><span class="line">u2             access_flags;<span class="comment">//Class 的访问标志</span></span><br><span class="line">u2             this_class;<span class="comment">//当前类</span></span><br><span class="line">u2             super_class;<span class="comment">//父类</span></span><br><span class="line">u2             interfaces_count;<span class="comment">//接口</span></span><br><span class="line">u2             interfaces[interfaces_count];<span class="comment">//一个类可以实现多个接口</span></span><br><span class="line">u2             fields_count;<span class="comment">//Class 文件的字段属性</span></span><br><span class="line">field_info     fields[fields_count];<span class="comment">//一个类会可以有个字段</span></span><br><span class="line">u2             methods_count;<span class="comment">//Class 文件的方法数量</span></span><br><span class="line">method_info    methods[methods_count];<span class="comment">//一个类可以有个多个方法</span></span><br><span class="line">u2             attributes_count;<span class="comment">//此类的属性表中的属性数</span></span><br><span class="line">attribute_info attributes[attributes_count];<span class="comment">//属性表集合</span></span><br></pre></td></tr></table></figure><p>无论是无符号数还是表，当需要描述同一类型数据但数量不定时，经常会使用一个潜质的容量计数器加若干个连续的数据项形式，这时称这一系列的某一类型的数据为某一类型的集合。</p><p>Class文件字节码结构组织示意图：<br><img src="/posts/31580/%E7%B1%BB%E6%96%87%E4%BB%B6%E5%AD%97%E8%8A%82%E7%A0%81%E7%BB%93%E6%9E%84%E7%BB%84%E7%BB%87%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt></p><h1 id="魔数"><a href="#魔数" class="headerlink" title="魔数"></a>魔数</h1><p>每个Class文件的头4个字节称为魔数（Magic Number），<strong>它的唯一作用就是确定这个文件是否为一个能被虚拟机接受到Class文件</strong>，很多文件存储标准中都使用魔数来进行身份识别而不是扩展名的主要原因是基于安全方面的考虑，因为文件扩展名可以随意的改动。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">u4             magic;<span class="comment">//Class 文件的标志</span></span><br></pre></td></tr></table></figure><p>Java中Class文件的魔数值为：0xCAFEBABE（咖啡宝贝？）。</p><h1 id="Class文件版本"><a href="#Class文件版本" class="headerlink" title="Class文件版本"></a>Class文件版本</h1><p><strong>紧接着魔术的4个字节存储的是Class文件的版本号：第5个和第6个是次版本号（Minor Version），第7个和第8个是主版本号（Major Version）</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">u2             minor_version;<span class="comment">//Class 的次版本号</span></span><br><span class="line">u2             major_version;<span class="comment">//Class 的主版本号</span></span><br></pre></td></tr></table></figure><p>Java版本号是从45开始的，JDK1.1之后每个JDK大版本发布主版本号向上加一，高版本的JDK能向下兼容以前版本的Class文件，但不能运行以后版本的Class文件，即使文件格式并未发生任何变化。</p><h1 id="常量池"><a href="#常量池" class="headerlink" title="常量池"></a>常量池</h1><p><strong>紧接着主次版本号之后的是常量池入口，常量池可以理解为Class文件之中的资源仓库，它是Class文件结构中与其他项目关联最多的数据类型，也是战役Class文件空间最大的数据项目之一，同时它还是在Class文件中第一个出现的表类型数据项目。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">u2             constant_pool_count;<span class="comment">//常量池的数量</span></span><br><span class="line">cp_info        constant_pool[constant_pool_count-<span class="number">1</span>];<span class="comment">//常量池</span></span><br></pre></td></tr></table></figure><p><strong>常量池的入口为一项u2类型的数据，代表常量池容量计数值（constant_pool_count），这个容量计数是从1开始而不是从0开始的，值为0代表“不引用任何一个常量池项目”的特殊情况。Class文件结构中只有常量池的容量计数是从1开始的。</strong></p><p><strong>常量池中主要存放两大类常量：字面量和符号引用。</strong>字面量比较接近于Java语言层面的常量概念，如文本字符串、声明为final类型的常量值等；而符号引用则属于编译原理方面的概念，包括下面三类常量：</p><ul><li>类和接口的全限定名</li><li>字段的名称和描述符</li><li>方法的名称和描述符</li></ul><p>在Class文件之不会保存各个方法、字段的最终内存的布局信息，当虚拟机运行时，需要从常量池获得对应的符号引用，再在类创建时或运行时解析、翻译到具体的内存地址之中。</p><p><strong>常量池中每一个项都是一个表，这14种表有一个共同的特点：表开始的第一位是一个u1类型的标志位（tag），代表这个常量属于哪种常量类型。</strong><br><img src="/posts/31580/constant_pool.jpg" alt></p><p>由于Class文件中方法、字段等都需要引用CONSTANT_Utf8_info型常量来描述名称，而这里的最大长度就是length的最大值，既u2类型能表达的最大值65535，所以Java程序中如果定义可超过64KB英文字符的变量或方法名，将会无法编译。</p><p>Class 文件可以通过javap -v class类名 指令来看一下其常量池中的信息(javap -v  class类名-&gt; temp.txt ：将结果输出到 temp.txt 文件)。</p><p>常量池中一部分自动生成的常量的确都没有在Java代码里面出现过，但它们会被后面即将讲到的字段表（field_info）、方法表（method_info）、属性表（attribute_info）引用到，他们会用来描述一些不方便使用“固定字节”进行表达的内容，譬如描述方法的返回值是什么？有几个参数？每个参数的类型是什么？</p><p>常量池中的14种常量项的结构总表：<br><img src="/posts/31580/3458176-8b9bb010f69e4a93.webp" alt><br><img src="/posts/31580/3458176-878fa839b1e28cf3.webp" alt></p><h1 id="访问标志"><a href="#访问标志" class="headerlink" title="访问标志"></a>访问标志</h1><p>在常量池结束之后，紧接着的两个字节代表访问标志（access_flags），这个标志用于识别一些类或者接口层次的访问信息，包括：这个Class是接口还是类；是否定义为public类型；是否定义为abstract类型；如果是类的话，是否声明为final等。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">u2access_flags;<span class="comment">//Class 的访问标记</span></span><br></pre></td></tr></table></figure><p><img src="/posts/31580/%E8%AE%BF%E9%97%AE%E6%A0%87%E5%BF%97.png" alt><br>最后这两个字节的值是上面这8个标志位的值的异或结果，没有用到的标志位一律为0。</p><h1 id="类索引、父类索引与接口索引集合"><a href="#类索引、父类索引与接口索引集合" class="headerlink" title="类索引、父类索引与接口索引集合"></a>类索引、父类索引与接口索引集合</h1><p>类索引和父类索引都是一个u2类型的数据，而接口索引集合是一组u2类型的数据的集合，Class文件中由这三项来确定这个类的继承关系。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">u2             this_class;<span class="comment">//当前类</span></span><br><span class="line">u2             super_class;<span class="comment">//父类</span></span><br><span class="line">u2             interfaces_count;<span class="comment">//接口</span></span><br><span class="line">u2             interfaces[interfaces_count];<span class="comment">//一个类可以实现多个接口</span></span><br></pre></td></tr></table></figure><p>类索引用于确定这个类的全限定名，父类索引用于确定这个类的父类的全限定名。<strong>除了Java.lang.Object之外，所有的Java类都有父类，因此除了Java.lang.Object之外，所有Java类的父类索引都不为0，</strong></p><p>接口索引集合就用来描述这个类实现了哪些接口，这些实现的接口将按implements语句（如果这个类本身是一个接口，则应当是extends语句）后的接口顺序从左到右排列在接口索引集合中。</p><p>类索引、父类索引和接口索引集合都按顺序排列在访问标志之后；对于接口索引集合，入口的第一项————u2类型的数据为接口计数器，表示索引表的容量，如果该类没有实现任何接口，则该计数器值为0。</p><h1 id="字段表集合"><a href="#字段表集合" class="headerlink" title="字段表集合"></a>字段表集合</h1><p>字段表（field_info）用于描述接口或者类中声明的变量。字段包括类级变量以及实例级变量，但不包括在方法内部声明的局部变量。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">u2             fields_count;<span class="comment">//Class 文件的字段的个数</span></span><br><span class="line">field_info     fields[fields_count];<span class="comment">//一个类会可以有个字段</span></span><br></pre></td></tr></table></figure><p>字段表的结构：<br><img src="/posts/31580/%E5%AD%97%E6%AE%B5%E8%A1%A8%E7%9A%84%E7%BB%93%E6%9E%84.png" alt></p><p>字段修饰符放在access_flags项目中，在实际情况中，ACC_PUBLIC、ACC_PRIVATE、ACC_PROTECTED三个标志最多只能选择其一，ACC_FINAL、ACC_VOLATILE不能同时选择，接口之中的字段必须有ACC_PUBLIC、ACC_STATIC、ACC_FINAL标志，其可以设置的标志位和含义如图：<br><img src="/posts/31580/%E5%AD%97%E6%AE%B5%E7%9A%84access_flags%E7%9A%84%E5%8F%96%E5%80%BC.png" alt></p><p>跟随access_flags标志的是两项索引值：name和descriptor_index。它们都是对常量池的引用，分别代表着字段的简单名称以及字段和方法的描述符。</p><blockquote><p>全限定名：一个类的全名的“.”全部替换成“/”<br>简单名称：没有类型和参数修饰的方法或字段名称，既只有名字<br>描述符：用来描述字段的数据类型、方法的参数列表（包括数量、类型和顺序）和返回值。描述符标识字符含义：<img src="/posts/31580/4222138-e6178ef8b07a6a77.webp" alt>对于数组来说，每一维度将使用一个前置的“[”字符来描述；描述方法时，按照先参数列表，后返回值的顺序描述，参数列表按照参数的严格顺序放在一组小括号“（）”内</p></blockquote><p>descriptor_index之后跟随着一个属性表集合用于存储一些额外的信息，字段都可以在描述表中描述零至多项的额外信息。</p><p>字段表集合中不会列出从超累或者父类中继承来的字段，但有可能列出原本Java代码之中不存在的字段，譬如在内部类中为了保持对外部类的访问性，会自动添加指向外部类实例的字段。另外如果两个字段的描述符不一致，那字段重名就是合法的。</p><h1 id="方法表集合"><a href="#方法表集合" class="headerlink" title="方法表集合"></a>方法表集合</h1><p>方法表的结构如同字段表一样：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">u2             methods_count;<span class="comment">//Class 文件的方法的数量</span></span><br><span class="line">method_info    methods[methods_count];<span class="comment">//一个类可以有个多个方法</span></span><br></pre></td></tr></table></figure><p><img src="/posts/31580/%E6%96%B9%E6%B3%95%E8%A1%A8%E7%9A%84%E7%BB%93%E6%9E%84.png" alt><br>方法表的 access_flag 取值：<img src="/posts/31580/%E6%96%B9%E6%B3%95%E8%A1%A8%E7%9A%84access_flag%E7%9A%84%E6%89%80%E6%9C%89%E6%A0%87%E5%BF%97%E4%BD%8D.png" alt></p><p>方法里的Java代码，经过编译器编译成字节码指令后，存放在方法属性表集合中一个名为“Code”的属性里面，属性表作为Class文件格式中最具扩展性的一种数据项目，见下一节。</p><p>与字段表集合相对应的，如果父类方法在子类中没有进行重写（Override），方法表集合中就不会出现来自弗雷德方法信息。但同样有可能出现由编译器自动添加的方法，最典型的便是类构造器<clinit>方法和实例构造器<init>方法。</init></clinit></p><p>Java语言中，要重载（Overload）一个方法，除了要与原方法具有相同的简单名称之外，还要求必须拥有一个与原方法不同的特征签名，特征签名就是一个方法中各个参数在常量池中的字段符号引用的集合，也就是因为返回值不会包含在特征签名中，因此Java语言无法仅仅依靠返回值的不同来对一个已有方法进行重载。</p><h1 id="属性表集合"><a href="#属性表集合" class="headerlink" title="属性表集合"></a>属性表集合</h1><p>在Class文件、字段表、方法表都可以携带自己的属性表集合，以用于描述某些场景专有的信息。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">u2             attributes_count;<span class="comment">//此类的属性表中的属性数</span></span><br><span class="line">attribute_info attributes[attributes_count];<span class="comment">//属性表集合</span></span><br></pre></td></tr></table></figure><p>属性表的限制相对其他的数据项目稍微宽松了一些，不再要求各个属性表具有严格的顺序，并且只要不与已有属性名重复，任何人实现的编译器都可以向属性表中写入自己定义的属性信息，Java虚拟机运行时会忽略它不认识的属性。<br><img src="/posts/31580/20170528124404308.png" alt><img src="/posts/31580/20170528124505057.png" alt><img src="/posts/31580/20170528124624262.png" alt></p><p>对于每个属性，它的名称需要从常量池中引用一个CONSTANT_Utf8_info类型的常量来标识，而属性值的结构则是完全自定义的，只需要通过一个u4的长度属性去说明属性值所占用的位数即可。<br><img src="/posts/31580/20141213150547531.png" alt></p><h2 id="Code属性"><a href="#Code属性" class="headerlink" title="Code属性"></a>Code属性</h2><p>Java程序方法体中的代码经过Javac编译器处理后，最后变为字节码指令存储在Code属性内。Code属性出现在方法表的属性集合之中，但并非所有的方法表都必须存在这个属性，譬如接口或者抽象类中的方法就不存在Code属性。<br><img src="/posts/31580/20170528124832359.png" alt></p><p>attribute_name_index是一项指向CONSTANT_Utf8_info型常量的索引，常量值固定为“Code”，它代表该属性的属性名称。</p><p>attribute_length指示了属性值的长度，由于属性名称索引与属性长度一共为6字节，所以属性值的长度固定为整个属性表长度减去6个字节。</p><p>max_stack代表了操作栈数深度的最大值。</p><p>max_locals代表了局部变量表所需的存储空间，单位是Slot，Slot时虚拟机为局部变量分配内存所使用的最小单位。对于byte、char、float、int、short、boolean和returnAdress等长度不超过32位的数据类型，每个局部变量占用1个Slot，而double和long这种64位的数据类型则需要两个Slot来存放。并不是在方法中用到了多少个局部变量，就把这些局部变量所占Slot之和作为max_locals的值，原因是局部变量表中的Slot可以重用，当代码执行超过一个局部变量的作用域时，这个局部变量所占的Slot可以被其他局部变量所使用，Javac编译器会根据变量的作用域来分配Slot给各个变量使用，然后计算出max_locals的大小。</p><p>code_length和code用来存储Java源程序编译后生成的字节码指令，code_length代表字节码长度，code是用于存储字节码指令的一系列字节流，每个指令长度为u1类型的单字节，虚拟机每次读入一个字节码指令。关于code_length，虽然他是一个u4类型的长度值，但虚拟机明确限制了一个方法不允许超过65535条字节码指令，即它实际只使用了u2的长度。</p><p>在实例方法的局部变量表中至少会存在一个指向当前对象实例的局部变量，局部变量表中也会预留出一个Slot位来存放对象实例的引用，方法参数值从1开始计算。</p><p>exception_table：异常表如下。<img src="/posts/31580/20170528125111983.png" alt>如果当字节码在第start_pc行到第end_pc行之间（不含end_pc行）出现了类型为catch_type或者其子类的异常（catch_type为指向一个CONSTANT_Class_info型常量的引用），则转到第handler_pc行继续处理。当catch_type的值为0时，代表任意异常情况都需要转向到handler_pc行进行处理。 </p><h2 id="Exceptions属性"><a href="#Exceptions属性" class="headerlink" title="Exceptions属性"></a>Exceptions属性</h2><p>Exceptions属性的作用是列举出方法中可能抛出的受查异常（Checked Exceptions），也就是方法描述时在throws关键字后面列举的异常。<br><img src="/posts/31580/TIM%E5%9B%BE%E7%89%8720190903214436.png" alt><br>Exceptions属性中的number_of_exceptions项表示方法可能抛出number_of_exceptions种受查异常。每一种受查异常使用一个number_index_table项表示，exception_index_table是一个指向常量池中CONSTANT_Class_info型常量的索引，代表了该受查异常的类型。</p><h2 id="LineNumberTable属性"><a href="#LineNumberTable属性" class="headerlink" title="LineNumberTable属性"></a>LineNumberTable属性</h2><p>LineNumberTable属性用于描述Java源码行号与字节码（字节码的偏移量）之间的对应关系。<br><img src="/posts/31580/TIM%E5%9B%BE%E7%89%8720190903215128.png" alt><br>line_number_table是一个数量为line_number_table_length、类型为line_number_info的集合，line_number_info表包括了start_pc和line_number两个u2类型的数据项，前者是字节码行号，后者是Java源码行号。</p><h2 id="LocalVariableTable属性"><a href="#LocalVariableTable属性" class="headerlink" title="LocalVariableTable属性"></a>LocalVariableTable属性</h2><p>LocalVariableTable属性用于描述栈帧中局部变量表中与Java源码中定义的变量之间的关系。<br><img src="/posts/31580/TIM%E5%9B%BE%E7%89%8720190903215615.png" alt><br> start_pc和length属性分别代表了这个局部变量的生命周期开始地字节码偏移量及其作用范围覆盖的长度，两者结合起来就是这个局部变量在字节码之中的作用域范围。</p><p>name_index和descriptor_index都是指向常量池中CONSTANT_Utf8_info型常量的索引，分别代表了局部变量的名称以及这个局部变量的描述符。</p><p>index是这个局部变量在栈帧局部变量表中Slot的位置。当这个变量数据类型是64位类型时（double和long），他占用的Slot为index和index+1两个。</p><p>在JDK1.5引入泛型之后，LocalVariableTable属性增加了一个“姐妹属性”：LocalVariableTypeTable，这个新增的属性结构与LocalVariableTable非常相似，仅仅是吧记录的字段描述符的descriptor_index替换成了字段的特征签名（Signature），对于非泛型类型来说，描述符和特征签名能描述的信息是基本一致的，但是泛型引入后，由于描述符中反省的参数化类型被擦除掉，描述符就不能准确的描述泛型类型了，因此出现了LocalVariableTypeTable。</p><h2 id="SourceFile属性"><a href="#SourceFile属性" class="headerlink" title="SourceFile属性"></a>SourceFile属性</h2><p>SourceFile属性用于记录生成这个Class文件的源码文件名称。<br><img src="/posts/31580/TIM%E5%9B%BE%E7%89%8720190903220650.png" alt><br>sourcefile_index数据项是指向常量池中CONSTANT_Utf8_info型常量的索引，常量值是源码文件的文件名。</p><h2 id="ConstantValue属性"><a href="#ConstantValue属性" class="headerlink" title="ConstantValue属性"></a>ConstantValue属性</h2><p>ConstantValue属性的作用是通知虚拟机自动为静态变量赋值。只有被static关键字修饰的变量（类变量）才可以使用这项属性。对于非static类型的变量的赋值是在实力构造器<init>方法中进行的；而对于类变量，则有两种方式可以选择：再类构造器<clinit>方法中或者使用ConstantValue属性。<br><img src="/posts/31580/TIM%E5%9B%BE%E7%89%8720190903221413.png" alt><br> 从数据结构中可以看出，ConstantValue属性是一个定长属性，他的attribute_length数据项值必须固定为2。constantvalue_index数据项代表了常量池中一个字面量常量的引用，根据字段类型的不同，字面量可以是CONSTANT_Long_info、CONSTANT_Float_info、CONSTANT_Double_info、CONSTANT_Integer_info、CONSTANT_String_info常量中的一种。</clinit></init></p><h2 id="InnerClasses属性"><a href="#InnerClasses属性" class="headerlink" title="InnerClasses属性"></a>InnerClasses属性</h2><p>Inner属性用于记录内部类与宿主类之间的关联。如果一个类中定义了内部类，那编译器将会为它以及它所包含的内部类生成InnerClasses属性。</p><h2 id="Deprecated及Synthetic属性"><a href="#Deprecated及Synthetic属性" class="headerlink" title="Deprecated及Synthetic属性"></a>Deprecated及Synthetic属性</h2><p>Depreciated和Syntactic两个属性都属于标志类型的布尔属性，只存在有和没有的区别，没有属性值的概念。</p><p>Depreciated属性用于表示某个类、字段或者方法，已经被程序作者定为不再推荐使用，它可以通过在代码中使用<code>@deprecated</code>注解进行设置。</p><p>Syntactic属性代表此字段或者方法并不是由Java源码直接产生的，而是由编译器自行添加的。<strong>唯一例外的是实例构造器<init>方法和类构造器<clinit>方法。</clinit></init></strong></p><h2 id="StackMapTable属性"><a href="#StackMapTable属性" class="headerlink" title="StackMapTable属性"></a>StackMapTable属性</h2><p>StackMapTable属性在JDK1.6发布后增加到Class文件规范中，它是一个复杂的变长属性，位于Code属性的属性表中。</p><p>这个属性会在虚拟机类加载的字节码验证阶段被新类型检查验证器使用，目的在于代替以前比较消耗性能的基于数据流分析的类型推导验证器。</p><h2 id="Signature属性"><a href="#Signature属性" class="headerlink" title="Signature属性"></a>Signature属性</h2><p>Signature属性在KJDk1.5发布后增加到了Class文件规范中，他是一个可选的定长类属性，可以出现于类、字段表、和方法表结构的属性表中。</p><p>在JDK 1.5大幅增强了Java语言的语法，在此之后，任何类、接口、初始化方法或成员的泛型签名如果包含了类型变量（Type Variables）或参数化类型（Parameterized Types），则Signature属性会为它记录泛型签名信息。之所以要专门使用这样一个属性去记录泛型类型，是因为Java语言的泛型采用的是擦除法实现的伪泛型。</p><p>使用擦除法的好处是实现简单（主要修改Javac编译器，虚拟机内部只做了很少的改动）、非常容易实现Backport，运行期也能够节省一些类型所占的内存空间。但坏处是运行期就无法像C#等有真泛型支持的语言那样，将泛型类型与用户定义的普通类型同等对待，例如运行期做反射时无法获得到泛型信息。Signature属性就是为了弥补这个缺陷而增设的。</p><h2 id="BootstrapMethods属性"><a href="#BootstrapMethods属性" class="headerlink" title="BootstrapMethods属性"></a>BootstrapMethods属性</h2><p>BootstrapMethods属性在JDK1.7发布后增加到了Class文件规范之中，它是一个复杂的变长属性，位于类文件的属性表中。这个属性用于保存invokeddynamic指令引用的引导方法限定符。目前的Javac暂时无法生成InvokeDynamic指令和BootstrapMethods属性，必须通过一些非常规的手段才能使用它们。</p>]]></content>
    
    <summary type="html">
    
      在 Java 中，JVM 可以理解的代码就叫做字节码（即扩展名为 .class 的文件），它不面向任何特定的处理器，只面向虚拟机。Java 语言通过字节码的方式，在一定程度上解决了传统解释型语言执行效率低的问题，同时又保留了解释型语言可移植的特点。
    
    </summary>
    
      <category term="Java虚拟机" scheme="http://yoursite.com/categories/Java%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    
    
  </entry>
  
  <entry>
    <title>虚拟机性能监控与故障处理工具</title>
    <link href="http://yoursite.com/posts/61312/"/>
    <id>http://yoursite.com/posts/61312/</id>
    <published>2019-09-01T12:42:20.000Z</published>
    <updated>2019-09-14T12:59:51.443Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JDK的命令行工具"><a href="#JDK的命令行工具" class="headerlink" title="JDK的命令行工具"></a>JDK的命令行工具</h1><p>JDK的bin目录中除了有我们所熟知的“java.exe”、“Javac.exe”这两个命令行工具，还有也许我们并不了解的其他命令行工具。这里我们主要介绍一些用于监视虚拟机和故障处理的工具，这些关工具都非常稳定而且功能强大，能在处理应用程序性能问题、定位故障时发挥很大的作用。</p><p>这些命令行工具大多数是jdk/lib/tool.jar类库的一层薄包装而已，它们主要的功能代码是在tools类库中实现的。JDK开发团队选择采用Java代码来实现这些监控工具是有特别用意的：当应用程序部署到生产环境后，无论是直接接触物理服务器还是远程Telnet到服务器上都可能会受到限制，借助tools.jar类库里面的接口，我们可以直接在应用程序中实现功能强大的监控分析功能。</p><p><strong>Sun JDK 监控和故障处理工具：</strong>  </p><table><thead><tr><th align="center">名称</th><th align="center">主要作用</th></tr></thead><tbody><tr><td align="center">jps</td><td align="center">JVM Process Status Tool ， 显示指定系统内所有的HotSpot虚拟机进程</td></tr><tr><td align="center">jstat</td><td align="center">JVM Statistics Monitoring Tool ， 用于收集HotSpot虚拟机各方面的运行数据</td></tr><tr><td align="center">jinfo</td><td align="center">Configuration In for Java ， 显示虚拟机配置信息</td></tr><tr><td align="center">jmap</td><td align="center">Memory Map for Java ， 生成虚拟机的内存转储快照（heapdump文件）</td></tr><tr><td align="center">jhat</td><td align="center">JVM Heap Dump Browser ， 用于分析headgump文件，它会建立一个HTTP/HTML服务器，让用户可以在浏览器上查看分析结果</td></tr><tr><td align="center">jstack</td><td align="center">Stack Trace for Java ， 显示虚拟机的线程快照</td></tr></tbody></table><h2 id="jps：虚拟机进程状况工具"><a href="#jps：虚拟机进程状况工具" class="headerlink" title="jps：虚拟机进程状况工具"></a>jps：虚拟机进程状况工具</h2><p>JDK的很多小工具的命名方式采用了UNIX命令的命名方式，jps就是其中的典型，它的作用就是类似于UNIX的ps命令：</p><p><strong>可以列出正在运行的虚拟机进程，并显示虚拟机执行主类（Main Class，main() 函数所在的类）名称以及这些进程的本地虚拟机唯一ID（Local Virtual Mechain Identifier，LVMID）。</strong>对于本地虚拟机进程来说，LVMID与操作系统的进程ID是一致的。</p><p>jps命令格式：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jps[options][hostid]</span><br></pre></td></tr></table></figure><p>jps工具主要选项：</p><table><thead><tr><th align="center">选项</th><th align="center">作用</th></tr></thead><tbody><tr><td align="center">-q</td><td align="center">只输出LVMID，省略主类的名称</td></tr><tr><td align="center">-m</td><td align="center">输出虚拟机进程启动时，传递给主类main()函数的参数</td></tr><tr><td align="center">-l</td><td align="center">输出主类全名，如果进程执行的是Jar包，输出Jar路径</td></tr><tr><td align="center">-v</td><td align="center">输出虚拟机启动时JVM参数</td></tr></tbody></table><h2 id="jstat：虚拟机统计信息监视工具"><a href="#jstat：虚拟机统计信息监视工具" class="headerlink" title="jstat：虚拟机统计信息监视工具"></a>jstat：虚拟机统计信息监视工具</h2><p>jstat是用于监视虚拟机各种运行状态信息的命令行工具。<strong>它可以显示虚拟机进程中的类装载、内存、垃圾收集、JIT编译等运行数据。</strong></p><p>jstat命令格式：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jstat[option vmid/lvmid  [interval[s|ms][count]] ]</span><br></pre></td></tr></table></figure><p>vmid/lvmid分别是远程虚拟机进程与本地虚拟机进程。参数interval和count代表查询间隔和次数，如果省略这两个参数，说明只查询一次。</p><p>option主要分为三类：类装载、垃圾收集、运行期编译。jstat工具主要选项：</p><table><thead><tr><th align="center">选项</th><th align="center">作用</th></tr></thead><tbody><tr><td align="center">-class</td><td align="center">监视类装载、卸载数量、总空间以及类装载所耗费的时间</td></tr><tr><td align="center">-gc</td><td align="center">监视Java堆状况，包括Eden区、两个Survivor区、老年代、永久代等的容量、已用空间、GC时间合计等信息</td></tr><tr><td align="center">-gccapacity</td><td align="center">监视内容与-gc基本相同，但输出主要关注Java堆各个区域使用到的最大、最小空间</td></tr><tr><td align="center">-gcutil</td><td align="center">监视内容与-gc基本相同，但输出主要关注已使用空间占总空间的百分比</td></tr><tr><td align="center">-gccause</td><td align="center">与-gcutil功能一样，但是会额外输出导致上一次GC产生的原因</td></tr><tr><td align="center">-gcnew</td><td align="center">监视新生代GC状况</td></tr><tr><td align="center">-gcnewcapacity</td><td align="center">监视内容与-gcnew基本相同，输出主要关注使用到的最大、最小空间</td></tr><tr><td align="center">-gcold</td><td align="center">监视老年代GC状况</td></tr><tr><td align="center">-gcoldcapacity</td><td align="center">监视内容与-gcold基本相同，输出主要关注使用到的最大、最小空间</td></tr><tr><td align="center">-gcpermcapacity</td><td align="center">输出永久代使用到的最大、最小空间</td></tr><tr><td align="center">-compiler</td><td align="center">输出JIT编译器编译过的方法、耗时等信息</td></tr><tr><td align="center">-printcompilation</td><td align="center">输出已经被JIT编译过的方法</td></tr></tbody></table><h2 id="jinfo：Java配置信息工具"><a href="#jinfo：Java配置信息工具" class="headerlink" title="jinfo：Java配置信息工具"></a>jinfo：Java配置信息工具</h2><p>jinfo的作用是实时地查看和调整虚拟机各项参数。</p><p>jinfo的<code>-flag</code>选项可以查询未被显式指定的参数的系统默认值，可以使用<code>-flag [+|-]</code>或者<code>-flag name=value</code>修改一部分运行期可写的虚拟机参数值 。jinfo还可以使用-sysprops选项把虚拟机进程的System.getProperties()的内容打印出来。</p><h2 id="jamp：Java内存映像工具"><a href="#jamp：Java内存映像工具" class="headerlink" title="jamp：Java内存映像工具"></a>jamp：Java内存映像工具</h2><p>jmap命令用于生成堆转储快照（一般为heapdump或者dump文件），如果不使用 jmap 命令，要想获取 Java 堆转储，可以使用 “-XX:+HeapDumpOnOutOfMemoryError” 参数，可以让虚拟机在 OOM 异常出现之后自动生成 dump 文件，Linux 命令下可以通过 kill -3 发送进程退出信号也能拿到 dump 文件。它还可以查询finalize执行队列、Java堆和永久代的详细信息，如空间使用率、当前使用的是哪种收集器等。和jinfo一样，jmap有不少功能在 Windows 平台下也是受限制的。</p><p>jamp命令格式：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jmap[option]vmid</span><br></pre></td></tr></table></figure><p>jmap工具主要选项：</p><table><thead><tr><th align="center">选项</th><th align="center">作用</th></tr></thead><tbody><tr><td align="center">-dump</td><td align="center">生成Java堆转出快照。格式为：-dump[live,]format=b,file=<filename>,其中live子参数说明是否只dump出存活对象</filename></td></tr><tr><td align="center">-finalizerinfo</td><td align="center">显示在F-Queue中等待Finalizer线程等待执行finalize方法的对象。只在Linux/Solaris平台下有效</td></tr><tr><td align="center">-heap</td><td align="center">显示Java堆详细信息，如使用哪种回收器、参数配置、分代状况等。</td></tr><tr><td align="center">-histo</td><td align="center">显示堆中对象统计信息，包括类、实例数量、合计容量</td></tr><tr><td align="center">-permstat</td><td align="center">已ClassLoader为统计口径，显示永久代内存状况。只在Linux/Solaris平台下有效</td></tr><tr><td align="center">-F</td><td align="center">当虚拟机进程堆-dump选项没有响应时，可使用这个选项强制生成dump快照。只在Linux/Solaris平台下有效</td></tr></tbody></table><h2 id="jhat：虚拟机堆转储快照分析工具"><a href="#jhat：虚拟机堆转储快照分析工具" class="headerlink" title="jhat：虚拟机堆转储快照分析工具"></a>jhat：虚拟机堆转储快照分析工具</h2><p>jhat与jmap搭配使用，来分析jmap生成的堆转储快照，可以在浏览器中查看。</p><p>但是一般不会直接使用jhat命令来分析dump文件，主要原因有二：</p><ul><li>一般不会在部署应用程序的服务器上直接分析dump文件，即使可以这样做，也会尽量将dump文件复制到其他机器上分析，因为分析是一个耗时而且消耗硬件资源的过程，尽然都要在其他机器上进行，就没有必要受到命令行工具的限制了。</li><li>jhat的分析功能相对来说比较简陋，有更强的工具可以代替它。</li></ul><p>jamp命令格式：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jhatfilename</span><br></pre></td></tr></table></figure><h2 id="jstack：Java堆栈跟踪工具"><a href="#jstack：Java堆栈跟踪工具" class="headerlink" title="jstack：Java堆栈跟踪工具"></a>jstack：Java堆栈跟踪工具</h2><p>jstack命令用于生成虚拟机当前时刻的线程快照（一般称为threaddump或者javacore文件）。线程出现停顿的时候通过jstack来查看各个线程的调用堆栈，就可以知道没有响应的线程到底在后台做什么，或者等待什么资源。</p><p>线程快照就是当前虚拟机每一条线程正在执行的方法堆栈的集合，生成线程快照的主要目的是定位线程出现长时间停顿的原因，如线程死锁、死循环、请求外部资源导致的长时间等待等都是导致线程长时间停顿的常见原因。</p><p>jstack命令格式：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jstack[option]vmid</span><br></pre></td></tr></table></figure><p>jmap工具主要选项：</p><table><thead><tr><th align="center">选项</th><th align="center">作用</th></tr></thead><tbody><tr><td align="center">-F</td><td align="center">当正常输出的请求不被响应时，强制输出线程堆栈</td></tr><tr><td align="center">-l</td><td align="center">除堆栈外，显示关于锁的附加信息</td></tr><tr><td align="center">-m</td><td align="center">如果调用到本地方法的话，可以显示C/C++的堆栈</td></tr></tbody></table><h1 id="JDK的可视化工具"><a href="#JDK的可视化工具" class="headerlink" title="JDK的可视化工具"></a>JDK的可视化工具</h1><p>JDK中除了提供大量的命令行工具外，还有两个功能强大的可视化工具：JConsole和VisualVM。</p><h2 id="JConsole：Java监视与管理控制台"><a href="#JConsole：Java监视与管理控制台" class="headerlink" title="JConsole：Java监视与管理控制台"></a>JConsole：Java监视与管理控制台</h2><p>JConsole是一种基于JMX的可视化监视、管理工具。它管理部分的功能是针对JMX MBean进行管理。</p><h3 id="启动JConsole"><a href="#启动JConsole" class="headerlink" title="启动JConsole"></a>启动JConsole</h3><p>提供JDK/bin目录下的“jconsole.exe”启动JConsole后，将自动搜索出本机运行的所有虚拟机进程，双击选择其中一个进程即可开始监控，也可以使用下面的“远程进程”功能来连接远程服务器，对远程虚拟机进行监控。<br><img src="/posts/61312/%E5%90%AF%E5%8A%A8JConsole.png" alt><img src="/posts/61312/JConsole%E6%A6%82%E8%BF%B0.png" alt><br>“概述”页签显示的是整个虚拟机主要运行数据的概览，其中包括“堆内存使用情况”、“线程”、“类”、“CPU使用情况”4种信息的曲线图。</p><h3 id="内存监控"><a href="#内存监控" class="headerlink" title="内存监控"></a>内存监控</h3><p>JConsole可以显示当前内存的详细信息，不仅包括堆内存/非堆内存的整体信息，还可以细化到Eden区、Survivor区等的使用情况。点击右边的“执行 GC(G)”按钮可以强制应用程序执行一个Full GC。<br><img src="/posts/61312/3%E5%86%85%E5%AD%98%E7%9B%91%E6%8E%A7.png" alt></p><h3 id="线程监控"><a href="#线程监控" class="headerlink" title="线程监控"></a>线程监控</h3><p>类似于jstack命令，遇到线程停顿时可以使用这个页签进行监控分析。最下面有一个”检测死锁 (D)”按钮，点击这个按钮可以自动为你找到发生死锁的线程以及它们的详细信息 。<br><img src="/posts/61312/4%E7%BA%BF%E7%A8%8B%E7%9B%91%E6%8E%A7.png" alt></p><h2 id="VisualVM：多合一故障处理工具"><a href="#VisualVM：多合一故障处理工具" class="headerlink" title="VisualVM：多合一故障处理工具"></a>VisualVM：多合一故障处理工具</h2><p>VisualVM是到目前为止随JDK发布的功能最强大的运行监视和故障处理程序。它除了运行监视、故障处理外，还提供了很多其他方面的功能，如性能分析。</p><p>VisualVM还有一个很大的优点：不需要被监视的程序基于特殊Agent运行，因此它对应用程序的实际性能的影响很小，使得它可以直接应用在生产环境中。</p><p>VisualVM 基于 NetBeans 平台开发，因此他一开始就具备了插件扩展功能的特性，通过插件扩展支持，VisualVM 可以做到：</p><ul><li>显示虚拟机进程以及进程的配置、环境信息（jps、jinfo）。</li><li>监视应用程序的CPU、GC、堆、方法区以及线程的信息（jstat、jstack）。</li><li>dump以及分析堆转储快照（jmap、jhat）。</li><li>方法级的程序运行性能分析，找出被顶用最多、运行时间最长的方法。</li><li>离线程序快照：收集程序的运行时配置、线程dump、内存dump等信息建立一个快照，可以将快照发送开发者除进行Bug反馈。</li><li>其他plugins的无限的可能性……</li></ul>]]></content>
    
    <summary type="html">
    
      在了解关于虚拟机的内存分配与回收技术的理论知识之后，就要考虑把这些知识应用到实际工作中的问题。这里就介绍一些经常使用的虚拟机监控和分析的工具，使用它们可以帮助我们快速分析数据，定位解决问题。
    
    </summary>
    
      <category term="Java虚拟机" scheme="http://yoursite.com/categories/Java%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    
    
  </entry>
  
  <entry>
    <title>内存分配与回收策略</title>
    <link href="http://yoursite.com/posts/44680/"/>
    <id>http://yoursite.com/posts/44680/</id>
    <published>2019-08-31T06:48:38.000Z</published>
    <updated>2019-09-14T12:59:35.322Z</updated>
    
    <content type="html"><![CDATA[<p>Java技术体系中所提倡的自动内存管理最终可以归结为自动化地解决了两个问题：给对象分配内存以及回收分配给对象的内存。</p><p>对象的内存分配，往大方向讲，就是在堆上分配，对象主要分配在新生代的Eden区上，如果启动了本地线程分配缓冲（TLAB），将按线程优先在TLAB上分配。少数情况下也可能会直接分配在老年代中，分配堆规则并不是百分之百固定的。<br><img src="/posts/44680/%E5%A0%86%E5%86%85%E5%AD%98.jpg" alt></p><h1 id="新生代GC和老年代GC"><a href="#新生代GC和老年代GC" class="headerlink" title="新生代GC和老年代GC"></a>新生代GC和老年代GC</h1><p>在了解分配策略之前，先了解一下新生代（Minor）GC和老年代（Full/Major）GC有什么不同。</p><ul><li>新生代GC（Minor GC）：指发生在新生代的垃圾收集动作，因为Java对象大多都具备朝生夕灭的特性，所以Minor GC非常频繁，一般回收速度也比较快。</li><li>老年代GC（Major/Full GC）：指发生在老年代的GC，出现了Major GC，经常会伴随至少一次的Minor GC（但并非绝对，在Parallel Scavenge收集器的收集策略里就有直接进行Major GC的策略选择过程）。Major GC的速度一般会比Minor GC慢10倍以上。</li></ul><h1 id="对象优先在Eden分配"><a href="#对象优先在Eden分配" class="headerlink" title="对象优先在Eden分配"></a>对象优先在Eden分配</h1><p>大多数情况下，对象在新生代Eden区中分配。当Eden区没有足够的空间进行分配时，虚拟机将发起一次Minor GC。</p><p>当给一个对象分配内存的的时候，发现Eden已经被占用的了一部分,剩余的空间已不足以分配当前对象所需的内存，因此发生Minor GC。GC期间虚拟机首先尝试把Eden中的对象放入Survivor空间中，如果Survivor中的空间大小不足的话，就会通过分配担保机制提前转移到老年代去。</p><h1 id="大对象直接进入老年代"><a href="#大对象直接进入老年代" class="headerlink" title="大对象直接进入老年代"></a>大对象直接进入老年代</h1><p>所谓的大对象是指，需要大量连续内存空间的Java对象，最典型的大对象就是那种很长的字符串以及数组。</p><p>虚拟机提供了一个<code>-XX:PretenureSizeThreshold</code>参数，令大于这个设置值的对象直接在老年代分配，这样做的目的是避免Eden区及两个Survivor区之间发生大量的内存复制（新生代采用复制算法收集内存）。</p><h1 id="长期存活的对象将进入老年代"><a href="#长期存活的对象将进入老年代" class="headerlink" title="长期存活的对象将进入老年代"></a>长期存活的对象将进入老年代</h1><p>既然虚拟机采用了分代收集的思想来管理内存，那么内存回收时就必须能识别哪些对象应放在新生代，哪些对象应放在老年代中。为了做到这一点，虚拟机给每个对象一个对象年龄（Age）计数器。</p><p>如果对象在Eden出生经过一次Minor GC后仍然存活，并且能够被Survivor容纳的话，将被移动到Survivor空间中，并且对象年龄设为1。</p><p>对象在Survivor区中每熬过一次Minor GC，年龄就增加1岁，当他的年龄增加到一定程度（默认为15岁），就会被晋升到老年代中。对象晋升到老年代中的阈值，可以通过参数<code>-XX:MaxTenuringThreshold</code>设置。</p><h1 id="动态对象年龄判定"><a href="#动态对象年龄判定" class="headerlink" title="动态对象年龄判定"></a>动态对象年龄判定</h1><p>为了更好的适应不同程序的内存状况，虚拟机并不是永远的要求对象的年龄达到了阈值才能晋升到老年代中，如果在Survivor空间中相同年龄所有对象大小的总和大于Survivor空间的一半，年龄大于或等于该年龄的对象就可以直接进入老年代，无须等到MaxTenuringThreshold中要求的年龄。</p><h1 id="空间分配担保"><a href="#空间分配担保" class="headerlink" title="空间分配担保"></a>空间分配担保</h1><p>在发生Minor GC之前，虚拟机会先检查老年代最大可用的连续空间是否大于新生代所有对象总空间，如果这个条件成立，那么Minor GC可以确保是安全的。如果不成立，则虚拟机会查看HandlePromotionFailure设置值是否允许担保失败。如果允许，那么会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，如果大于，将尝试着进行一次Minor GC，尽管这次Minor GC是有风险的；如果小于，或者HandlePromotionFailure设置不允许冒险，那这时也要改为进行一次Full GC。</p><p>取平均值进行比较其实仍然是一种动态概率的手段，也就是说，如果某次Minor GC存活后的对象突增，远远高于平均值的话，依然会导致担保失败（Handle Promotion Failure）。如果出现了HandlePromotionFailure失败，那就只好在失败后重新发起一次Full GC。</p><p>虽然担保失败时绕的圈子是最大的，但大部分情况下都还是会将HandlePromotionFailure开关打开，避免Full GC过于频繁。</p>]]></content>
    
    <summary type="html">
    
      关于内存回收这一点，在Java垃圾收集机制中详细介绍了各种回收算法以及JVM中常见的收集器。接下来主要看看JVM是如何给对象分配内存的。
    
    </summary>
    
      <category term="Java虚拟机" scheme="http://yoursite.com/categories/Java%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    
    
  </entry>
  
  <entry>
    <title>理解GC日志</title>
    <link href="http://yoursite.com/posts/41052/"/>
    <id>http://yoursite.com/posts/41052/</id>
    <published>2019-08-31T06:13:03.000Z</published>
    <updated>2019-09-14T12:59:28.043Z</updated>
    
    <content type="html"><![CDATA[<p>每一种收集器的日志形式都是由它们自身的实现所决定的,换而言之,每个收集器的日志格式都可以不一样。但虚拟机设计者为了方便用户阅读,将各个收集器的日志都维持一定的共性,例如以下两段典型的GC日志:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">33.125</span>: [GC [DefNew: <span class="number">3324</span>K-&gt;<span class="number">152</span>K(<span class="number">3712</span>K), <span class="number">0.0025925</span> secs] <span class="number">3324</span>K-&gt;<span class="number">152</span>K(<span class="number">11904</span>K), <span class="number">0.0031680</span>secs]</span><br><span class="line"></span><br><span class="line"><span class="number">100.667</span>: [Full GC [Tenured: <span class="number">0</span>K-&gt;<span class="number">210</span>K(<span class="number">10240</span>K), <span class="number">0.0149142</span> secs] <span class="number">4603</span>K-&gt;<span class="number">210</span>K(<span class="number">19456</span>K), [Perm : <span class="number">2999</span>K-&gt;<span class="number">2999</span>K(<span class="number">21248</span>K)], <span class="number">0.0150007</span> secs] [Times: user=<span class="number">0.01</span> sys=<span class="number">0.00</span>, real=<span class="number">0.02</span> secs]</span><br></pre></td></tr></table></figure><p>最前面的数字“<code>33.125</code>”和“<code>100.66</code>7”：代表了GC发生的时间，这个数字的含义是从Java虚拟机启动以来经过的秒数。</p><p>GC日志开头的“<code>[GC</code>”和“<code>[Full GC</code>”<strong>说明了这次垃圾收集的停顿类型，而不是用来区分新生代GC还是老年代GC的。</strong>如果有“<code>Full</code>”，说明这次GC是发生了Stop-The-World的。</p><p>接下来的“<code>[DefNew</code>”、“<code>[Tenured</code>”、“<code>[Perm</code>”表示GC发生的区域，这里显示的区域名称与使用的GC收集器是密切相关的。例如上面Serial收集器中的新生代名为“Default NewGeneration”，所以显示的收集“<code>[DefNew</code>”。如果是ParNew收集器，新生代名称就会变为“<code>[ParNew</code>”，意为“Parallel New Generation”。如果采用Parallel Scavenge收集器，那它配套的新生代为“PSYoungGen”，老年代和永久代同理,名称也是由收集器决定的。</p><p>后面方括号内部的“<code>3324K-&gt;152K(3712K)</code>” 含义是 “<strong>GC前该区域已使用容量 -&gt; GC后该区域已使用容量（该内存区域总容量</strong>）”。</p><p>而在方括号之外的“<code>3324K-&gt;152K(11904K)</code>” 表示 “<strong>GC前Java堆已使用容量 -&gt; GC后Java堆已使用容量（Java堆总容量）</strong>”。</p><p>再往后，“<code>0.0031680secs</code>”表示该内存区域GC所占用的时间，单位是秒。有的收集器会给出更具体的时间数据，如“<code>[Times: user=0.01 sys=0.00, real=0.02 secs]</code>”，这里面的user、sys和real与Linux的time命令所输出的含义一致，分别代表用户态消耗的CPU时间、内核态消耗的CPU时间和操作从开始到结束所经过的墙钟时间。</p><p>CPU时间与墙钟时间的区别是,墙钟时间包括各种非运算的等待耗时,例如等待磁盘I/O、等待线程阻塞,而CPU时间不包括这些耗时,但当系统有多CPU或者多核的话,多线程操作会叠加这些CPU时间,所以读者看到user或sys时间超过real时间是完全正常的。</p>]]></content>
    
    <summary type="html">
    
      阅读GC日志是处理Java虚拟机内存问题的基础技能，他只是一些人为规定的规则，没有太多技术含量。这里只是对两段典型的GC日志分析。
    
    </summary>
    
      <category term="Java虚拟机" scheme="http://yoursite.com/categories/Java%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    
    
  </entry>
  
</feed>
