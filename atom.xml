<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Potato Blog</title>
  
  <subtitle>李土豆的Blog</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-08-26T17:36:04.753Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Potato</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>HotSpot 虚拟机对象探秘</title>
    <link href="http://yoursite.com/posts/58276/"/>
    <id>http://yoursite.com/posts/58276/</id>
    <published>2019-08-26T14:19:49.000Z</published>
    <updated>2019-08-26T17:36:04.753Z</updated>
    
    <content type="html"><![CDATA[<h1 id="对象的创建"><a href="#对象的创建" class="headerlink" title="对象的创建"></a>对象的创建</h1><p>下图便是一个Java对象创建的过程<br><img src="/posts/58276/Java%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1%E7%9A%84%E8%BF%87%E7%A8%8B.png" alt></p><h2 id="类加载检查"><a href="#类加载检查" class="headerlink" title="类加载检查"></a>类加载检查</h2><p>在Java程序运行期间无时无刻都有对象被创建出来，在语言层面来说，创建对象通常仅仅是一个new关键字而已，而在虚拟机中，遇到一条new指令时，<strong>首先将去检查这个指令的参数是否能在常量池中定位到这个类的符号引用，并且检查这个符号引用代表的类是否已被加载、解析和初始化过。如果没有，那必须先执行相应的类加载过程。</strong></p><h2 id="分配内存"><a href="#分配内存" class="headerlink" title="分配内存"></a>分配内存</h2><p>在类加载检查通过之后，接下来虚拟机将为新生对象分配内存。对象所需的内存大小在类加载完成后便可完全确定（具体将在下一节介绍）。</p><p>为对象分配内存空间的任务等于把一块确定大小的内存从Java堆中划分出来。分配方式有两种：<strong>“内存碰撞”</strong>和<strong>“空闲列表”</strong>，选择哪种方式由Java堆是否规整决定，而Java堆是否规整取决于虚拟机所采用的垃圾收集器是否带有压缩整理功能。</p><blockquote><ul><li>指针碰撞：Java堆中内存是绝对规整的，所有用过的内存放在一边，空闲的内存放在另一边，中间放着一个指针作为分界点的指示器，那么分配内存就是把指针向空闲空间那边挪动对象大小的距离即可。</li><li>空闲列表：如果Java堆中内存并不是规整的，已使用的内存与空闲的内存相互交错，那么虚拟机就必须维护一个列表，记录那些内存是可用的，在分配的时候从列表中找到一块足够大的内存空间划分给对象实例，并更新列表上的记录。</li></ul></blockquote><p><img src="/posts/58276/%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%9A%84%E4%B8%A4%E7%A7%8D%E6%96%B9%E5%BC%8F.png" alt></p><p>因为在虚拟机中对象创建是一个非常频繁的行为，即使是仅仅修改一个指针所指向的位置，在并发的情况下也并不是线程安全的。可能出现正在给A对象分配内存，指针还没来得及修改，对象B又同时使用了原来的指针来分配内存的情况。所以对于内存分配引发的并发问题有两种解决方案：<strong>CAS+失败重试</strong>和<strong>本地线程分配缓冲（TLAB）</strong></p><blockquote><ul><li>CAS+失败重试：以这种方式保证更新操作的原子性。</li><li>本地线程分配缓冲（TLAB）：把内存分配堆动作按线程划分在不同的空间之中进行，即每个线程在Java堆中预先分配一小块内存，每个线程在自己的TLAB上分配内存，只有当对象大于TLAB中的剩余内存或者TLAB用完时，采用同步锁定（synchronized）的方式分配新的TLAB。</li></ul></blockquote><h2 id="初始化零值"><a href="#初始化零值" class="headerlink" title="初始化零值"></a>初始化零值</h2><p>内存分配完成后，虚拟机将对分配到的内存空间都初始化为零值（不包括对象头），如果使用TLAB，这一步可以提前至TLAB分配时进行。</p><p>这一步的操作保证了对象的实例字段在Java代码中可以不赋初始值就直接使用，程序能访问到这些字段的数据类型所对应的零值。</p><h2 id="设置对象头"><a href="#设置对象头" class="headerlink" title="设置对象头"></a>设置对象头</h2><p>初始化零值之后，虚拟机要对对象进行必要的设置，例如这个对象是哪个类的实例、如何才能找到类的元数据信息、对象的哈希码、对象的GC分代年龄等信息。<strong>这些信息都存放在对象头中。</strong></p><p>根据虚拟机当前的运行状态不同，如是否启用偏向锁等，对象头会有相应的不同的设置方式，具体会在下一节做详细介绍。</p><h2 id="执行init方法"><a href="#执行init方法" class="headerlink" title="执行init方法"></a>执行init方法</h2><p>在上面四个步骤完成之后，在Java虚拟机的角度，一个新的对象已经产生了；但是在Java程序的角度来看，对象的创建才刚开始，<code>&lt;init&gt;</code>方法还没有执行，所有的字段都是零。</p><p>所以一般来说，<strong>执行new指令之后会接着执行<code>&lt;init&gt;</code>方法，把对象按照程序员的意愿进行初始化</strong>，这样一个真正可用的对象才算完全产生出来。</p><h1 id="对象的内存布局"><a href="#对象的内存布局" class="headerlink" title="对象的内存布局"></a>对象的内存布局</h1><p><strong>在HotSpot虚拟机中，对象在内存中存储的布局可以分为3块区域：对象头（Header）、实例数据（Instance Data）和对齐填充（Padding）。</strong></p><h2 id="对象头"><a href="#对象头" class="headerlink" title="对象头"></a>对象头</h2><p>HotSpot虚拟机的对象头包括两部分信息:<strong>Mark Word</strong> 和 <strong>类型指针（Class Pointer）</strong>。</p><p>Java虚拟机中对象头的方式有以下俩种（以32位Java虚拟机为例）：<br>普通对象：<img src="/posts/58276/%E6%99%AE%E9%80%9A%E5%AF%B9%E8%B1%A1Header.png" alt><br>数组对象：<img src="/posts/58276/%E6%95%B0%E7%BB%84%E5%AF%B9%E8%B1%A1Header.png" alt></p><h3 id="Mark-Word"><a href="#Mark-Word" class="headerlink" title="Mark Word"></a>Mark Word</h3><p><strong>第一部分用于存储对象自身的运行时数据（mark Word）</strong>，如哈希码、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳等。<br>这部分数据的长度在32位和64位的虚拟机（未开启压缩指针）中分别为32bit和64bit，也就是一个Word的大小，官方称它为“Mark Word”。</p><p>对象需要存储的运行时数据很多时，如果超出了32位或64位Bitmap结构所能记录的限度。考虑到虚拟机的空间效率，Mark Word被设计成一个非固定的数据结构以便在极小的空间内存储尽量多信息，<strong>它会根据对象的状态复用自己的存储空间</strong>。</p><p>大部分情况下，Mark Word的32bit空间中的25bit用于存储对象哈希码，4bit用于存储对象分代年龄，2bit用于存储锁状态标志位，1bit用于标记对象是否启用偏向锁</p><p>不同锁状态标志位标记位表示的整个Mark Word含义不同，具体如下： <img src="/posts/58276/MarkWord.png" alt>    </p><p>其中各部分的含义如下：</p><blockquote><ul><li><strong>lock</strong> : 2位的锁状态标记位，该标记的值不同，整个Mark Word表示的含义不同。</li></ul><table><thead><tr><th align="center">存储内容</th><th align="center">biased_lock</th><th align="center">lock（标记位）</th><th align="center">状态</th></tr></thead><tbody><tr><td align="center">对象的哈希码、分代年龄</td><td align="center">0</td><td align="center">01</td><td align="center">无锁</td></tr><tr><td align="center">偏向线程ID、偏向时间戳、对象分代年龄</td><td align="center">1</td><td align="center">01</td><td align="center">偏向锁</td></tr><tr><td align="center">指向锁记录的指针</td><td align="center">0</td><td align="center">00</td><td align="center">轻量级锁</td></tr><tr><td align="center">指向重量级锁的指针</td><td align="center">0</td><td align="center">10</td><td align="center">重量级锁</td></tr><tr><td align="center">空，不需要记录信息</td><td align="center">0</td><td align="center">11</td><td align="center">GC标记</td></tr></tbody></table><ul><li><strong>biased_lock</strong> : 只占1位，用于标记对象是否启用偏向锁。为1时表示对象启用偏向锁，为0时表示对象没有偏向锁。</li><li><strong>age</strong> ： 4位的Java对象分代年龄。由于只有4位，所以最大值为15。</li><li><strong>identity_hashcode</strong> ： 25位的对象标识哈希码，采用延迟加载技术。调用<code>System.identityHashCode()</code>计算，并会将结果写到该对象头中。<strong>当对象被锁定时，该值会移动到管程Monitor中。</strong></li><li><strong>thread</strong> ： 占23位，表示持有偏向锁的线程ID。</li><li><strong>epoch</strong> ： 占2位，表示偏向时间戳。</li><li><strong>ptr_to_lock_record</strong> ： 占30位，指向栈中锁记录的指针。</li><li><strong>ptr_to_heavyweight_monitor</strong> ： 占30位，指向管程Monitor的指针。</li></ul></blockquote><h3 id="类型指针"><a href="#类型指针" class="headerlink" title="类型指针"></a>类型指针</h3><p>对象头的另一部分就是类型指针，<strong>即对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例</strong>。</p><p>该指针的位长度为JVM的一个字大小，即32位的JVM为32位，64位的JVM为64位。如果应用的对象过多，使用64位的指针将浪费大量内存，统计而言，64位的JVM将会比32位的JVM多耗费50%的内存。为了节约内存可以开启压缩指针（<code>+UseCompressedOops</code>），，其中，OOPS（ordinary object pointers），即普通对象指针。开启该选项后，下列指针将压缩至32位：</p><ul><li>每个Class的属性指针（即静态变量）</li><li>每个对象的属性指针（即对象变量）</li><li>普通对象数组的每个元素指针</li></ul><p><strong>如果对象是一个Java数组，那在对象头中还必须有一块用于记录数组长度的数据，</strong>这部分数据的长度也随着JVM架构的不同而不同：32位的JVM上，长度为32位；64位JVM则为64位。</p><h2 id="实例数据"><a href="#实例数据" class="headerlink" title="实例数据"></a>实例数据</h2><p><strong>实例数据部分是对象真正存储的有效信息</strong>，也就是在程序代码中所定义的各种类型的字段。</p><p><strong>这部分的存储顺序会受到虚拟机分配策略和字段在Java源码中定义的顺序的影响</strong>，HotSpot虚拟机默认的分配策略为longs/doubles、ints、shorts/chars、bytes/booleans、OOPS（ordinary object pointers），从这个分配策略可以看出，子类中较窄的变量也可能会插入到父类变量的空隙之中。</p><h2 id="对齐填充"><a href="#对齐填充" class="headerlink" title="对齐填充"></a>对齐填充</h2><p><strong>第三部分对齐填充并不是必然存在的，也没有特别的含义，仅仅起着占位符的作用</strong>，因为 Hotspot 虚拟机的自动内存管理系统要求对象起始地址必须是 8 字节的整数倍，换句话说就是对象的大小必须是 8 字节的整数倍。而对象头部分正好是 8 字节的倍数（1 倍或 2 倍），因此，当对象实例数据部分没有对齐时，就需要通过对齐填充来补全。</p><p>关于对象头的具体实现处，可以参考ArrayList的数组默认最大长度（Integer.MAX_VALUE - 8）。</p><h1 id="对象的访问定位"><a href="#对象的访问定位" class="headerlink" title="对象的访问定位"></a>对象的访问定位</h1><p>建立对象就是为了使用对象，<strong>我们的Java程序需要通过栈上的reference数据来操作堆上的具体对象</strong>。</p><p>而由于reference类型在Java虚拟机规范中只规定了一个指向对象的引用，没有定义这个引用该通过何种方式去定位、访问堆中的对象的具体位置。所以目前主流的访问方式有两种：<strong>句柄</strong>和<strong>直接指针</strong>。</p><h2 id="句柄"><a href="#句柄" class="headerlink" title="句柄"></a>句柄</h2><p>如果使用句柄访问的话，那么<strong>Java堆中将会划分出一块内存来作为句柄池，reference中储存的就是对象的句柄地址，而句柄中包含了对象实例数据与类型数据各自的具体地址信息</strong>。如图所示：<img src="/posts/58276/%E5%AF%B9%E8%B1%A1%E7%9A%84%E8%AE%BF%E9%97%AE%E5%AE%9A%E4%BD%8D-%E4%BD%BF%E7%94%A8%E5%8F%A5%E6%9F%84.png" alt></p><h2 id="直接指针"><a href="#直接指针" class="headerlink" title="直接指针"></a>直接指针</h2><p>如果使用直接指针，那么<strong>Java堆对象的布局中就必须考虑如何放置访问类型数据的相关信息，而reference在储存的直接就是对象的地址</strong>。如图所示：<img src="/posts/58276/%E5%AF%B9%E8%B1%A1%E7%9A%84%E8%AE%BF%E9%97%AE%E5%AE%9A%E4%BD%8D-%E7%9B%B4%E6%8E%A5%E6%8C%87%E9%92%88.png" alt></p><h2 id="句柄和直接指针对比"><a href="#句柄和直接指针对比" class="headerlink" title="句柄和直接指针对比"></a>句柄和直接指针对比</h2><p>这两种方式各有优势。</p><ul><li><p><strong>句柄方式的最大好处就是reference中存储的是稳定的句柄地址</strong>，在对象被移动（GC回收时移动对象是非常普遍的行为）时只会改变句柄中的示例数据指针，而reference本身不需要改变。</p></li><li><p><strong>直接指针方式的最大好处就是速度更快</strong>，它节省了一次指针定位的时间开销。由于对象的访问在Java中非常频繁，因此这类开销积少成多后也是一项非常可观的执行成本。</p></li></ul>]]></content>
    
    <summary type="html">
    
      在了解了Java内存区域是如何划分后，就要落实到具体的问题来思考了，要知道数据是如何创建、如何布局以及如何访问的细节问题，因此就以HotSpot虚拟机为例来了解这些细节问题。
    
    </summary>
    
      <category term="Java虚拟机" scheme="http://yoursite.com/categories/Java%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
      <category term="JVM" scheme="http://yoursite.com/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>Java内存区域</title>
    <link href="http://yoursite.com/posts/35314/"/>
    <id>http://yoursite.com/posts/35314/</id>
    <published>2019-08-25T13:50:45.000Z</published>
    <updated>2019-08-25T17:24:11.834Z</updated>
    
    <content type="html"><![CDATA[<h1 id="运行时数据区域"><a href="#运行时数据区域" class="headerlink" title="运行时数据区域"></a>运行时数据区域</h1><p>Java虚拟机（JVM）在执行Java程序的过程中会把它所管理的内存划分为若干个不同的数据区域。而在JDK1.8前后数据区域的划分略有不同，下面会介绍到。<br>JDK1.8之前：<img src="/posts/35314/JVM%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E5%9F%9F.png" alt><br>JDK1.8： <img src="/posts/35314/2019-3Java%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E5%9F%9FJDK1.8.png" alt><br>因此根据上面的运行时数据区划分图可以看出：</p><p><strong>线程私有的：</strong></p><blockquote><ul><li>程序计数器</li><li>虚拟机栈</li><li>本地方法栈</li></ul></blockquote><p><strong>线程共享的：</strong></p><blockquote><ul><li>堆</li><li>方法区</li><li>直接内存（非运行时数据区的一部分）</li></ul></blockquote><p>下面就按照上面的顺序逐个进行了解。</p><h2 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h2><p>程序计数器是一块较小的内存空间。在虚拟机的概念模型里面，字节码解释器工作时需要知道该执行哪一条字节码指令，而程序计数器的作用就是，通过改变程序计数器的值，来让字节码解释器知道，下一条需要执行的指令是什么。</p><p>其次，Java虚拟机的多线程执行，是通过线程之间轮流执行，而对于一个处理器（如果是多核处理器，那么就是一个内核），在任意一个确定的时刻，只会执行一条线程中的指令。因此，为了避免一个线程过长时间（可能因为计算时间过长或者陷入死循环等原因）占用处理器，导致系统崩溃，所以处理器会给每个线程分配执行的时间，如果当分配的时间结束时，该线程的任务还没有执行完，处理器会被剥夺并分配给另一个线程，直到到达下一次该线程的时间片，处理器才会切换回来，继续执行该线程。因此，为了线程切换后能恢复到正确的执行位置，所以每条线程都需要有一个独立的程序计数器，各线程之间计数器互不影响，独立存储，我们称这类内存区域为“线程私有”的内存。</p><p>从上面的介绍中我们知道程序计数器主要有两个作用：</p><blockquote><ul><li>字节码解释器通过改变程序计数器，从而实现代码的流程控制，如：顺序执行、选择、循环、异常处理等。</li><li>在多线程情况下，程序计数器用于记录当前线程执行的位置，从而当线程切换回来的时候，能够知道该线程上次执行到哪里，接下来该执行什么指令。</li></ul></blockquote><p><strong>注意：</strong></p><blockquote><ul><li>如果线程正在执行的是一个Java方法，那么这个程序计数器是正在执行的方法的虚拟机字节码指令的地址。</li><li>如果线程正在执行的是一个Native方法，那么这个程序计数器则为空（Undefined）。<strong>因此程序计数器是唯一一个不会出现 OutOfMemoryError 的内存区域</strong>，它的生命周期随着线程的创建而创建，随着线程的结束而死亡。</li></ul></blockquote><h2 id="Java虚拟机栈"><a href="#Java虚拟机栈" class="headerlink" title="Java虚拟机栈"></a>Java虚拟机栈</h2><p>Java虚拟机栈描述的是Java方法的内存模型，每次方法调用的数据都是通过栈传递的。而栈中储存的是一个个的栈帧，栈帧就是每个方法在执行的时候都会创建一个栈帧（Stack Frame），栈帧用于储存局部变量表、操作数栈、动态链接、方法出口等信息。因为线程每调用一个方法从开始到结束，都意味着一个栈帧在虚拟机栈中从入栈到出栈的过程。</p><p>Java内存可以粗糙的分为堆内存（Heap）和栈内存（Stack），其中的栈就是Java虚拟机栈，或者说是Java虚拟机栈中的局部变量表部分。</p><p>局部变量表存放了编译器可知的各种（八种）基本数据类型（boolean、byte、char、short、int、float、double、long）、对象引用（不同于对象本身，可能是一个指向对象起始地址的引用指针，也可能是指向一个代表对象的句柄或其他与此对象相关的位置）和returnAdress类型（指向一条字节码指令地址）。<br>其中64位的长度的double和long类型的数据都会占用两个局部变量空间，其余数据只会占用一个局部变量空间。局部变量表所需内存空间在编译期间完成分配，因此当进入一个方法时，这个局部变量表的大小就已经完全确定了，运行期间不会改变其大小。</p><p>Java 虚拟机栈会出现两种异常：<strong>StackOverFlowError 和 OutOfMemoryError</strong></p><blockquote><ul><li><strong>StackOverFlowError:</strong>若Java虚拟机栈的内存大小<strong>不允许</strong>动态扩展，那么如果线程请求的栈深度大于虚拟机所允许的最大深度，那么就会抛出StackOverFlowError异常。</li><li><strong>OutOfMemoryError：</strong>若Java虚拟机栈的内存大小<strong>允许</strong>动态扩展，那么如果线程在扩展时无法申请到足够的内存，就会抛出OutOfMemoryError异常。</li></ul></blockquote><p>Java方法的返回方式有两种：<strong>return语句</strong>和<strong>抛出异常</strong>，不管哪种方法，都会导致栈帧出栈。</p><h2 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h2><p>本地方法栈的作用与Java虚拟机栈的结构和作用几乎完全一样，可以认为二者唯一的区别就是：<strong>Java虚拟机栈为虚拟机执行Java方法（也就是字节码）服务；而本地方法栈为虚拟机执行Native方法服务</strong>。甚至在HotSpot虚拟机栈中将两者合二为一。</p><p><strong>总结得到一点：程序计数器、Java虚拟机栈和本地方法栈都是线程所私有的，故而他们的生命周期和线程相同，它们的生命周期随着线程的创建而创建，随着线程的结束而死亡。</strong></p><h2 id="Java堆"><a href="#Java堆" class="headerlink" title="Java堆"></a>Java堆</h2><p>Java堆（Heap）是Java虚拟机所管理的内存中最大的一块。Java 堆是所有线程共享的一块内存区域，在虚拟机启动时创建。此内存的唯一目的就是：<strong>存放对象实例，几乎所有的对象实例都在这里分配</strong>，在Java虚拟机规范中的描述是：<strong>所有对象的实例以及数组都要在堆上分配。</strong>，但是随着JIT编译器的发展，这种情况也不是那么绝对的了。</p><p>java堆也是垃圾收集器管理的主要区域，因此也被称为 GC堆 ，从垃圾回收的角度看，Java堆中还可细分为：新生代和老生代；再度细分可分：Eden 空间、From Survivor、To Survivor 空间等为；大部分情况下，对象都会首先在Eden区域分配，再一次新生代垃圾回收后，如果对象还存活，则会进入s0或是s1在，并且对象年龄还加一，当他的年龄增加到一定程度（默认为15岁）时，就会被划分到老年代中。</p><p>不论如何划分，都与存放的内容无关；不论哪个区域，存储的都是对象的实例。<strong>进一步划分的目的是为了更好的回收内存，更快的分配内存。</strong></p><p>Java堆可以处于物理上不连续的内存空间中，只要逻辑上是连续的即可。</p><p>Java堆的内存大小可以是固定大小的，也可以是可扩展的（大部分都是）。如果在堆中没有内存来完成实例的分配，并且堆也无法再扩展时，将会抛出<strong>OutOfMemoryError</strong>异常。</p><h2 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h2><p>方法区同样是各个线程共享的内存区域，<strong>它用于储存已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。</strong>方法区有一个别名叫“非堆（Non-Heap）”，目的就是为了将其与Java堆区分开来。</p><p>仅在HotSpot虚拟机中，方法区也被称为“<strong>永久代</strong>”，仅仅是因为在HotSpot虚拟机中把GC分代收集扩展至方法区，这样可以省去专门为方法区编写内存管理代码的工作。但是问题也因此而来，因为永久代有大小上限，所以当触碰到内存大小的上限时，会抛出OutOfMemoryError异常。</p><p>所以在JDK1.8之后，永久代被彻底删除了，取而代之的是<strong>元空间</strong>（MetaSpace），与永久代有JVM本身内存大小上限的限制不同的是，元空间使用的是直接内存，受到的是本机可用内存的上限限制，只有当触碰到本地内存的极限时，才会抛出OutofMemoryError异常（概率极小）。</p><p>与java堆一样，方法区同样不需要连续的内存和可以选择固定大小或可扩展外，还可以选择不实现垃圾收集。相对而言垃圾收集行为在该区域比较少见，因为该区域内存回收目标主要是针对常量池的回收和对类型的卸载。</p><h2 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h2><p>JDK1.7之前，运行时常量池是方法区的一部分。Class文件中除了有类的版本、字段、方法、接口等描述信息外，还有常量池信息，用于存放编译期生成的各种<strong>字面量</strong>和<strong>符号引用</strong>。<br>运行时常量池相对于Class文件常量池还有一个重要特征是具备<strong>动态性</strong>，将运行期间可能得到的新的常量放入池中。<br>因此既然运行时常量池是方法区的一部分，所以当常量池无法再申请到内存时会抛出 OutOfMemoryError 异常。</p><p><strong>但是在JDK1.7及其之后版本的JVM中，将运行时常量池从方法区中移了出来，在Java堆中开辟了一块内存存放运行时常量池，这样也更加方便于垃圾回收的工作。</strong><br><img src="/posts/35314/26038433.jpg" alt></p><h2 id="直接内存"><a href="#直接内存" class="headerlink" title="直接内存"></a>直接内存</h2><p><strong>直接内存既不是虚拟机运行时数据区的一部分，也不是Java虚拟机规范中定义的内存区域，但是这一部分内存被频繁的使用，而且也可能导致OutofMemoryError异常。</strong></p><p>在JDK1.4中新加入了NIO类，引入了一种基于通道（Channel）于缓存区（Buffer）的I/O方式，它使用Native函数库直接分配堆外内存，然后通过一个存储在Java堆中的DirectByteBuffer对象作为这块内存的引用进行操作。<strong>这样就能在一些场景中显著提高性能，因为避免了在Java堆和Native堆之间来回复制数据。</strong></p><p>虽然本机直接内存并不会收到Java堆的内存大小限制，但是显然会受到本地总内存的大小限制，因此也可能会在动态扩展时抛出OutOfMemoryError异常。</p>]]></content>
    
    <summary type="html">
    
      对于Java程序员来说，在虚拟机自动内存管理机制的帮助下，不需要为每一个new的操作去写配对的delete/free代码，不容易出现内存泄露和内存溢出的问题，因为把这些工作交给虚拟机去管理内存；但也正是因为如此，一旦出现内存泄露和溢出方面的问题，如果不了解虚拟机是如何使用内存的，那么排查错误将会成为一项异常艰难的工作。
    
    </summary>
    
      <category term="Java虚拟机" scheme="http://yoursite.com/categories/Java%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
      <category term="JVM" scheme="http://yoursite.com/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>ArrayList源码阅读</title>
    <link href="http://yoursite.com/posts/33665/"/>
    <id>http://yoursite.com/posts/33665/</id>
    <published>2019-08-06T11:57:45.000Z</published>
    <updated>2019-08-24T17:48:25.911Z</updated>
    
    <content type="html"><![CDATA[<h1 id="ArrayList的数据结构"><a href="#ArrayList的数据结构" class="headerlink" title="ArrayList的数据结构"></a>ArrayList的数据结构</h1><p>ArrayList往往被人用来与LinkedList对比，它们俩最重要的差异之一就是：ArrayList的底层是由数组组成的，而LinkedList的底层则是由链表组成，对于LinkedList不再多赘述，具体可以看一下LinkedList的文章。回到ArrayList中来，其实现的数据结构是一个名为elementData的Object数组，可以存放所有Object对象，因此我们对ArrayList类的实例的所有的操作底层都是基于这个数组的。<br><img src="/posts/33665/ArrayListDataStructure.jpg" alt></p><h1 id="顶部注释"><a href="#顶部注释" class="headerlink" title="顶部注释"></a>顶部注释</h1><blockquote><p>List接口的可调整大小的数组实现。 实现所有可选列表操作，并允许所有元素，包括null 。 除了实现List接口之外，该类还提供了一些方法来处理内部用于存储列表的数组的大小。 （这个类大致相当于Vector ，除了它是不同步的。）<br>该size ， isEmpty ， get ， set ， iterator ，并listIterator操作在固定时间内运行。 add操作以摊销的常数运行 ，即添加n个元素需要O（n）个时间。 所有其他操作都以线性时间运行（粗略地说）。 与LinkedList实现相比，常数因子较低。 </p><p>每个ArrayList实例都有一个容量 。 容量是用于存储列表中的元素的数组的大小。 它总是至少与列表大小一样大。 当元素添加到ArrayList时，其容量会自动增长。 没有规定增长政策的细节，除了添加元素具有不变的摊销时间成本。 </p><p>在使用ensureCapacity操作添加大量元素之前，应用程序可以增加ArrayList实例的容量。 这可能会减少增量重新分配的数量。 </p><p>请注意，此实现不同步。 如果多个线程同时访问ArrayList实例，并且至少有一个线程在结构上修改列表，则必须在外部进行同步。 （结构修改是添加或删除一个或多个元素的任何操作，或明确调整后台数组的大小;仅设置元素的值不是结构修改。）这通常是通过在一些自然地封装了名单。 如果没有这样的对象存在，列表应该使用Collections.synchronizedList方法“包装”。 这最好在创建时完成，以防止意外的不同步访问列表： </p><p>List list = Collections.synchronizedList(new ArrayList(…)); 由这个类的iterator和listIterator方法返回的迭代器是故障快速的 ：如果列表在迭代器创建之后的任何时间被结构地修改，除了通过迭代器自己的remove或add方法之外，迭代器将抛出一个ConcurrentModificationException 。 因此，面对并发修改，迭代器将快速而干净地失败，而不是在未来未确定的时间冒着任意的非确定性行为。 </p><p>请注意，迭代器的故障快速行为无法保证，因为一般来说，在不同步并发修改的情况下，无法做出任何硬性保证。 失败快速的迭代器ConcurrentModificationException扔出ConcurrentModificationException 。 因此，编写依赖于此异常的程序的正确性将是错误的： 迭代器的故障快速行为应仅用于检测错误。 </p><p>这个类是Java Collections Framework的成员。 </p></blockquote><p>总结上面的顶部注释可以得到以下几点：</p><ul><li><strong>底部实现</strong>：可调整大小的数组实现的。</li><li><strong>是否允许null值</strong>：允许所有元素，包括null。</li><li><strong>是否是线程安全的</strong>：不是线程安全的。</li><li><strong>迭代器</strong>： 迭代器是fast-fail，但是迭代器的快速失败行为不能得到保证。</li><li><strong>运行时间</strong>：在get，set，size等操作中，都是以常数时间运行，而add操作需要O(n)时间运行。</li></ul><h1 id="ArrayList的定义"><a href="#ArrayList的定义" class="headerlink" title="ArrayList的定义"></a>ArrayList的定义</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayList</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractList</span>&lt;<span class="title">E</span>&gt; <span class="keyword">implements</span> <span class="title">List</span>&lt;<span class="title">E</span>&gt;, <span class="title">RandomAccess</span>, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span></span></span><br></pre></td></tr></table></figure><ul><li><strong>ArrayList<e></e></strong>：支持泛型的存储模式。</li><li><strong>extends AbstractList<e></e></strong>：继承于AbstractList，继承了其中的方法，方便操作。</li><li><strong>implements List<e></e></strong>：实现了List接口，与继承AbstractList作用相同，实现该接口提供的方法，方便了实现。但是据开发这个collection 的作者Josh说：这其实是一个mistake，因为他写这代码的时候觉得这个会有用处，但是其实并没什么用，但因为没什么影响，就一直留到了现在。</li><li><strong>implements RandomAccess</strong>：实现了RandomAccess接口，表明支持固定时间的快速随机访问，这也是其在get和set方法时已固定时间运行的原因</li><li><strong>implements Cloneable</strong>：实现了Cloneable接口，内部可以调用clone()方法来返回实例的浅拷贝(shallow copy)。</li><li><strong>implements Serializable</strong>：实现了Serializable接口，表明该类时可以序列化的。</li></ul><h1 id="静态全局变量"><a href="#静态全局变量" class="headerlink" title="静态全局变量"></a>静态全局变量</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 默认的初始容量</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_CAPACITY = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    *  用于空实例的共享空数组实例。</span></span><br><span class="line"><span class="comment">    * 也就是说当传入的指定容量为0的时候建立数组。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 共享空数组实例，用于默认大小的空实例。</span></span><br><span class="line"><span class="comment">    * 我们将其与EMPTY_ELEMENTDATA区分开来，以了解添加第一个元素时应该膨胀多少。</span></span><br><span class="line"><span class="comment">    * 当无指定的容量传入时，返回的数组。其与EMPTY_ELEMENTDATA的区别在于：</span></span><br><span class="line"><span class="comment">    * EMPTY_ELEMENTDATA是当传入的指定容量为时候返回的</span></span><br><span class="line"><span class="comment">    * DEFAULTCAPACITY_EMPTY_ELEMENTDATA是为传入指定容量参数时候返回的。 </span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 存储ArrayList元素的数组缓冲区。</span></span><br><span class="line"><span class="comment">    * ArrayList的容量是这个数组缓冲区的长度。</span></span><br><span class="line"><span class="comment">    * 当添加第一个元素时，任何带有elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA的空ArrayList都将扩展为DEFAULT_CAPACITY。</span></span><br><span class="line"><span class="comment">    * 也就是底层用来存储元素的数组</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">transient</span> Object[] elementData; <span class="comment">// 非私有以简化嵌套类访问,这里是用来为subList方法使用的。</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * ArrayList的大小(它包含的元素的数量)。</span></span><br><span class="line"><span class="comment">    * ArrayList中实际包含的元素的数量</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@serial</span></span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">int</span> size;</span><br><span class="line"></span><br><span class="line">       <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 最大可分配的数组大小，减去8是为了一些vm在数组中保留一些头信息。</span></span><br><span class="line"><span class="comment">   * 试图分配更大的数组可能会导致OutOfMemoryError:请求的数组大小超过VM限制</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_ARRAY_SIZE = Integer.MAX_VALUE - <span class="number">8</span>;</span><br></pre></td></tr></table></figure><h1 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h1><h2 id="指定初始容量"><a href="#指定初始容量" class="headerlink" title="指定初始容量"></a>指定初始容量</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    *构造具有指定初始容量的空列表。</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span>  initialCapacity  列表的初始容量</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@throws</span> IllegalArgumentException 如果指定初始容量是负的       </span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 如果指定的初始容量大于零，则创建一个指定初始容量大小的数组</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">       <span class="keyword">if</span> (initialCapacity &gt; <span class="number">0</span>) &#123;</span><br><span class="line">           <span class="keyword">this</span>.elementData = <span class="keyword">new</span> Object[initialCapacity];</span><br><span class="line">       &#125; <span class="keyword">else</span> <span class="keyword">if</span> (initialCapacity == <span class="number">0</span>) &#123;</span><br><span class="line">       <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * 如果指定的初始等于零，则使用空数组EMPTY_ELEMENTDATA</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">           <span class="keyword">this</span>.elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">       <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * 如果指定的初始为负数，抛出异常</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal Capacity: "</span>+</span><br><span class="line">                                              initialCapacity);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><ul><li>如果传入的指定初始容量大于零，那就创建一个指定初始容量大小的数组用来存放数据</li><li>如果指定的初始等于零，则使用静态全局变量中的空数组EMPTY_ELEMENTDATA</li><li>如果指定的初始为负数，抛出异常</li></ul><h2 id="无指定初始容量"><a href="#无指定初始容量" class="headerlink" title="无指定初始容量"></a>无指定初始容量</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 当无指定初始容量参数时，使用默认容量，构造一个初始容量为10的空列表。</span></span><br><span class="line"><span class="comment"> * 但是其实在初始化后，此时的数组容量为0，当第一次存入数据时，才对这个空数组进行扩容，变为长度为10的数组</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="传入集合初始化"><a href="#传入集合初始化" class="headerlink" title="传入集合初始化"></a>传入集合初始化</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *构造包含指定集合的元素的列表，按集合的迭代器返回元素的顺序排列。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> c 要将其元素放入此列表的集合</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> NullPointerException 如果指定的集合为空</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 把传入的集合转化为数组</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">    elementData = c.toArray();</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 判断传入的集合是否为空，如果为空则初始化为EMPTY_ELEMENTDATA数组，也就是等于指定初始容量为0时的情况</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> ((size = elementData.length) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 为了防止传入集合转型后的数组的类型不是Object类型，所以在这里进行验证</span></span><br><span class="line">        <span class="comment">// 如果不是Object类型，则使用Arrays.copyOf()的方法重新拷贝成Object[].class类型</span></span><br><span class="line">        <span class="keyword">if</span> (elementData.getClass() != Object[].class)</span><br><span class="line">            elementData = Arrays.copyOf(elementData, size, Object[].class);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 用空数组替换。</span></span><br><span class="line">        <span class="keyword">this</span>.elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="核心方法"><a href="#核心方法" class="headerlink" title="核心方法"></a>核心方法</h1><h2 id="trimToSize-方法"><a href="#trimToSize-方法" class="headerlink" title="trimToSize 方法"></a>trimToSize 方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 修改此ArrayList实例的容量成为列表的当前大小。 应用程序可以使用此操作来最小化ArrayList实例的存储。 </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">trimToSize</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 因为是对结构进行了修改，所以modCount加一次</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 如果当前数组中的元素数量小于数组长度，就对数组进行修改</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (size &lt; elementData.length) &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 如果数组中的元素数量为0，则把数组变为EMPTY_ELEMENTDATA</span></span><br><span class="line"><span class="comment">     * 如果数组中的元素数量不为0，则把当前数组中的所有元素拷贝到一个新的数组，数组长度为元素的数量</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">        elementData = (size == <span class="number">0</span>)</span><br><span class="line">          ? EMPTY_ELEMENTDATA</span><br><span class="line">          : Arrays.copyOf(elementData, size);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该方法用于回收多余的内存。也就是说一旦我们确定集合不在添加多余的元素之后，调用 trimToSize() 方法会将实现集合的数组大小刚好调整为集合元素的大小。<br>注意：该方法会花时间来复制数组元素，所以应该在确定不会添加元素之后在调用。</p><h2 id="ensureCapacity-方法"><a href="#ensureCapacity-方法" class="headerlink" title="ensureCapacity 方法"></a>ensureCapacity 方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 如果需要，增加此 ArrayList实例的容量，以确保它至少能够容纳最小容量参数指定的元素数。 </span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> minCapacity 所需的最小容量 </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ensureCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 先判断是否满足增加容量的条件：</span></span><br><span class="line"><span class="comment"> * 1.新的容量大于当前数组的长度，不然没有必要扩容</span></span><br><span class="line"><span class="comment"> * 2.数组中有数据，或者数组中没有数据并且新的容量大于默认的容量长度</span></span><br><span class="line"><span class="comment"> * 满足上面的两个条件后，modCount加一，然后调用grow方法进行数组的扩容和复制</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">    <span class="keyword">if</span> (minCapacity &gt; elementData.length</span><br><span class="line">        &amp;&amp; !(elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA</span><br><span class="line">             &amp;&amp; minCapacity &lt;= DEFAULT_CAPACITY)) &#123;</span><br><span class="line">        modCount++;</span><br><span class="line">        grow(minCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="grow-方法"><a href="#grow-方法" class="headerlink" title="grow 方法"></a>grow 方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 增加容量，以确保它至少可以容纳由最小容量参数指定的元素数目。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> minCapacity 所需的最小容量</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> OutOfMemoryError 如果minCapacity小于零</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> Object[] grow(<span class="keyword">int</span> minCapacity) &#123;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用newCapacity方法获得新的合适的容量大小，因为minCapacity不一定时最合适的扩容容量</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">    <span class="keyword">return</span> elementData = Arrays.copyOf(elementData,</span><br><span class="line">                                       newCapacity(minCapacity));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> Object[] grow() &#123;</span><br><span class="line">    <span class="keyword">return</span> grow(size + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="newCapacity-方法"><a href="#newCapacity-方法" class="headerlink" title="newCapacity 方法"></a>newCapacity 方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 返回至少与给定的最小容量相同大的容量。返回当前容量增加50%(如果足够的话)。</span></span><br><span class="line"><span class="comment"> * 除非给定的最小容量大于MAX_ARRAY_SIZE，否则不会返回大于MAX_ARRAY_SIZE的容量。</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> minCapacity 所需的最小容量</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> OutOfMemoryError 如果minCapacity小于零</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">newCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 旧的容量是现在数组的长度</span></span><br><span class="line"><span class="comment">     * 默认的新的容量是旧容量的1.5倍</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">int</span> oldCapacity = elementData.length;</span><br><span class="line">    <span class="keyword">int</span> newCapacity = oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 如果传入的要求的最小容量（newCapacity）大于等于默认的新的容量，就进入if做边界条件的判断</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (newCapacity - minCapacity &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 如果当前数组是空数组，这种情况下就是数组进行了初始化，但是没有放入任何数据，还是一个空数组，所以上面得到的oldCapacity和newCapacity都是0</span></span><br><span class="line"><span class="comment">     * 那么就取要求的最小容量和默认容量（16）二者中较大的那个进行扩容。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">        <span class="keyword">if</span> (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA)</span><br><span class="line">            <span class="keyword">return</span> Math.max(DEFAULT_CAPACITY, minCapacity);</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 因为上面的if判断的是 &lt;= 的情况，所以有可能传入的 minCapacity是负数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">        <span class="keyword">if</span> (minCapacity &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> OutOfMemoryError();</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 边界没有溢出的话，就扩大为minCapacity</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">return</span> minCapacity;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 如果传入的要求的最小容量（newCapacity）小于默认的新的容量，就不使用传入的minCapacity</span></span><br><span class="line"><span class="comment">     * 如果默认的新的容量小于数组最大容量Integer.MAX_VALUE-8，那么就使用它，也就是数组扩容1.5倍</span></span><br><span class="line"><span class="comment">     * 但是如果大于数组最大容量Integer.MAX_VALUE-8，就尝试使用minCapacity，进入hugeCapacity函数判断</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">return</span> (newCapacity - MAX_ARRAY_SIZE &lt;= <span class="number">0</span>)</span><br><span class="line">        ? newCapacity</span><br><span class="line">        : hugeCapacity(minCapacity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">hugeCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (minCapacity &lt; <span class="number">0</span>) <span class="comment">// 溢出</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> OutOfMemoryError();</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 如果newCapacity大于数组最大容量Integer.MAX_VALUE-8，但是minCapacity没有，就使用Integer.MAX_VALUE-8</span></span><br><span class="line"><span class="comment">     * 但是如果newCapacity和minCapacity都大于了Integer.MAX_VALUE-8的话，就把数组扩容为Integer.MAX_VALUE</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">return</span> (minCapacity &gt; MAX_ARRAY_SIZE)</span><br><span class="line">        ? Integer.MAX_VALUE</span><br><span class="line">        : MAX_ARRAY_SIZE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结来说，对于数组容量扩容过程如下：</p><ol><li>先确定三个变量：传入的所需的最小容量（minCapacity），旧容量（oldCapacity）也就是当前现在数组的长度，默认的新的容量（newCapacity）是旧容量的1.5倍。</li><li>对比minCapacity和newCapacity，如果对比minCapacity大于等于（&gt;=）newCapacity,那么进入3，否则进入5。</li><li>如果elementData是只进行初始化，但是还没有存入数据的数组，那么它的长度肯定是0，所以这种情况下上面得到的oldCapacity和newCapacity是0，因此取默认初始容量（16）和minCapacity中的较大值，作为扩容后的容量。否则进入4。</li><li>判断如果传入的minCapacity是负数，那么抛出异常。否则将其作为扩容后的容量。</li><li>如果newCapacity小于等于MAX_ARRAY_SIZE（Integer.MAX_VALUE-8），那么newCapacity就是扩容大小，也就是扩容1.5倍。否则进行6。</li><li>如果newCapacity大于minCapacity，但是minCapacity其实是负数，那么直接抛出异常。否则再次判断minCapacity与MAX_ARRAY_SIZE的大小关系，如果minCapacity也大于MAX_ARRAY_SIZE，那么newCapacity和minCapacity都大于了MAX_ARRAY_SIZE，就把数组扩容为Integer.MAX_VALUE。否则进行7。</li><li>否则就只有newCapacity大于MAX_ARRAY_SIZE，而minCapacity小于等于MAX_ARRAY_SIZE，则数组扩容为MAX_ARRAY_SIZE。</li></ol><h2 id="size-方法"><a href="#size-方法" class="headerlink" title="size 方法"></a>size 方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 以常数时间返回此列表中的元素数量。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 列表中元素的数量</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> size;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="isEmpty-方法"><a href="#isEmpty-方法" class="headerlink" title="isEmpty 方法"></a>isEmpty 方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 如果此列表不包含任何元素，则返回true。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; 如果此列表不包含任何元素</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> size == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="contains-方法"><a href="#contains-方法" class="headerlink" title="contains 方法"></a>contains 方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 如果此列表包含指定的元素，则返回true 。</span></span><br><span class="line"><span class="comment"> * 更正式地说，返回true当且仅当此列表包含至少一个元素e这样Objects.equals(o, e) 。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> o 其在此列表中的存在性将被测试</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; 如果此列表包含指定的元素</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 实则调用了indexOf方法得到其下标，只需判断得到的下标是否小于零即可</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">    <span class="keyword">return</span> indexOf(o) &gt;= <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="indexOf-于-lastIndexOf-方法"><a href="#indexOf-于-lastIndexOf-方法" class="headerlink" title="indexOf 于 lastIndexOf 方法"></a>indexOf 于 lastIndexOf 方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 以常数时间返回此列表中指定元素的第一次出现的索引，如果此列表不包含元素，则返回-1。</span></span><br><span class="line"><span class="comment"> * 更正式地，返回最低下标i ，使得Objects.equals(o, get(i)) ，如果没有这样的下标则返回-1。 </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 如果要寻找的对象是null，那么就遍历数组，找第一个null的下标</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">    <span class="keyword">if</span> (o == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">            <span class="keyword">if</span> (elementData[i]==<span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 如果要寻找的对象非null，那么就遍历数组，找第一个为o的元素的下标</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">            <span class="keyword">if</span> (o.equals(elementData[i]))</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 如果找不到的话，就返回-1</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 返回此列表中指定元素的最后一次出现的索引，如果此列表不包含元素，则返回-1。</span></span><br><span class="line"><span class="comment"> * 更正式地说，返回满足i这样Objects.equals(o, get(i)) ，如果没有这样的索引则返回-1。 </span></span><br><span class="line"><span class="comment"> * 搜索方法与indexOf相似，同为遍历整个数组，区别就是该方法从后向前寻找。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lastIndexOf</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (o == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = size-<span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">            <span class="keyword">if</span> (elementData[i]==<span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = size-<span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">            <span class="keyword">if</span> (o.equals(elementData[i]))</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该方法需要遍历整个数组，寻找对应的元素的下标，所以时间复杂度为O(N)。</p><h2 id="clone​-方法"><a href="#clone​-方法" class="headerlink" title="clone​ 方法"></a>clone​ 方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 返回此ArrayList实例的浅拷贝。（元素本身不被复制。） </span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 这个 ArrayList实例的克隆 </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">clone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 调用AbstractList的clone方法得到一个ArrayList</span></span><br><span class="line"><span class="comment">     * 然后给这个v的elementData数组复制为当前数组，同时modCount重置为0</span></span><br><span class="line"><span class="comment">     * 返回这个ArrayList。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">        ArrayList&lt;?&gt; v = (ArrayList&lt;?&gt;) <span class="keyword">super</span>.clone();</span><br><span class="line">        v.elementData = Arrays.copyOf(elementData, size);</span><br><span class="line">        v.modCount = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> v;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (CloneNotSupportedException e) &#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 这不应该发生，因为我们是可克隆的</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InternalError(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该方法只返回此ArrayList实例的浅拷贝，元素本身不被复制。</p><h2 id="toArray-方法"><a href="#toArray-方法" class="headerlink" title="toArray 方法"></a>toArray 方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 以正确的顺序（从第一个到最后一个元素）返回一个包含此列表中所有元素的数组。 </span></span><br><span class="line"><span class="comment"> * 返回的数组将是“安全的”，因为该列表不保留对它的引用。 （换句话说，这个方法必须分配一个新的数组）。</span></span><br><span class="line"><span class="comment"> * 因此，调用者可以自由地修改返回的数组。 </span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 此方法充当基于阵列和基于集合的API之间的桥梁。 </span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 一个包含该列表中所有元素的数组</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> Object[] toArray() &#123;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用Arrays的copyOf拷贝elementData，得到并且返回一个新的数组。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">    <span class="keyword">return</span> Arrays.copyOf(elementData, size);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 以正确的顺序返回一个包含此列表中所有元素的数组（从第一个到最后一个元素）; 返回的数组的运行时类型是指定数组的运行时类型。 </span></span><br><span class="line"><span class="comment"> * 如果列表适合指定的数组，则返回其中。 否则，将为指定数组的运行时类型和此列表的大小分配一个新数</span></span><br><span class="line"><span class="comment"> * 如果列表符合指定的数组，则有剩余空间（即数组的列表数量较多），则紧跟在集合结束后的数组中的元素设置为null 。 </span></span><br><span class="line"><span class="comment"> * （这仅在调用者知道列表不包含任何空元素的情况下才能确定列表的长度。） </span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> a 要存储列表的元素的数组，如果它足够大; 否则，为此目的分配相同运行时类型的新数组。 </span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 包含列表元素的数组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> ArrayStoreException 如果指定数组的运行时类型不是此列表中每个元素的运行时类型的超类型 </span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> NullPointerException 如果指定的数组为空</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; T[] toArray(T[] a) &#123;</span><br><span class="line">    <span class="keyword">if</span> (a.length &lt; size)</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 如果传入的数组的长度小于当前的元素数量，则创建一个新的数组a的运行时类型的数组，把elementData数组中的元素复制到该数组中。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">return</span> (T[]) Arrays.copyOf(elementData, size, a.getClass());</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 否则直接把elementData数组中的元素复制到该数组中。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    System.arraycopy(elementData, <span class="number">0</span>, a, <span class="number">0</span>, size);</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 如果传入数组长度大于元素数量，那么就把最后一个元素的后面的元素设置为null。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (a.length &gt; size)</span><br><span class="line">        a[size] = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>toArray 方法主要有两种方式，一种是无参方法，直接返回包含此列表中所有元素的数组；另一种是传入一个数组，然后把此列表中所有元素复制到该数组中，然后返回该数组。</p><h2 id="get-方法"><a href="#get-方法" class="headerlink" title="get 方法"></a>get 方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 因为底层是数组，所以以常数时间返回此列表中指定位置的元素。 </span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>  index 要返回的元素的索下标</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 该列表中指定位置的元素 </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IndexOutOfBoundsException  如果下标超出范围（ index &lt; 0 || index &gt;= size() ） </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Objects.checkIndex方法调用了Preconditions.checkIndex(index, length, null)检查下标是否超出范围</span></span><br><span class="line"><span class="comment"> * Preconditions.checkIndex() 方法判断如果index &lt; 0 || index &gt;= size()，就抛出异常，否则返回传出的index。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">    Objects.checkIndex(index, size);</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 如果下标满足要求，返回elementData数组中对应下标处的元素。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">return</span> elementData(index);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="set-方法"><a href="#set-方法" class="headerlink" title="set 方法"></a>set 方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 用指定的元素替换此列表中指定位置的元素。 </span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> index 要替换的元素的下标</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> element 要存储在指定位置的元素 </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 该元素以前在指定的位置 </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IndexOutOfBoundsException  如果索引超出范围（ index &lt; 0 || index &gt;= size() ） </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">set</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 同get方法一样，先判断下表是否越界，如果越阶就抛出异常。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">    Objects.checkIndex(index, size);</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 记录下elementData数组中指定位置处的旧元素，用于返回。</span></span><br><span class="line"><span class="comment">     * 将elementData数组中指定位置处的元素设置为传入的元素，然后返回旧的元素</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    E oldValue = elementData(index);</span><br><span class="line">    elementData[index] = element;</span><br><span class="line">    <span class="keyword">return</span> oldValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="add-方法"><a href="#add-方法" class="headerlink" title="add 方法"></a>add 方法</h2><h3 id="将指定的元素追加到此列表的末尾"><a href="#将指定的元素追加到此列表的末尾" class="headerlink" title="将指定的元素追加到此列表的末尾"></a>将指定的元素追加到此列表的末尾</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 以常数时间，将指定的元素追加到此列表的末尾。 </span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> e 要附加到此列表的元素 </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; (由 Collection.add(E)指定)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 因为往数组中添加元素，所以结构发生了改变，因此modCount加一</span></span><br><span class="line"><span class="comment"> * 调用内部的add方法添加元素，add方法见下面。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">    modCount++;</span><br><span class="line">    add(e, elementData, size);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="内部的add方法添加元素"><a href="#内部的add方法添加元素" class="headerlink" title="内部的add方法添加元素"></a>内部的add方法添加元素</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 这个helper方法从add(E)中分离出来，以将方法字节码大小保持在35以下(-XX:MaxInlineSize默认值)，这有助于在c1编译的循环中调用add(E)。</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(E e, Object[] elementData, <span class="keyword">int</span> s)</span> </span>&#123;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 先判断数组中的元素数量是否达到了数组长度</span></span><br><span class="line"><span class="comment"> * 如果达到，则对数组进行扩容，扩容大小是原数组长度的1.5倍</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">    <span class="keyword">if</span> (s == elementData.length)</span><br><span class="line">        elementData = grow();</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 然后将传入的元素添加到数组尾部，元素数量加一</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    elementData[s] = e;</span><br><span class="line">    size = s + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="在指定位置插入指定的元素"><a href="#在指定位置插入指定的元素" class="headerlink" title="在指定位置插入指定的元素"></a>在指定位置插入指定的元素</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 以O(N)的时间，在此列表中的指定位置插入指定的元素。 </span></span><br><span class="line"><span class="comment"> * 将当前位于该位置的元素（如果有）和任何后续元素（向其索引添加一个）移动。 </span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> index  要在其中插入指定元素的下标 </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> element 要插入的元素 </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IndexOutOfBoundsException  如果索引超出范围（ index &lt; 0 || index &gt; size() ） </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * rangeCheckForAdd方法见下面；</span></span><br><span class="line"><span class="comment"> * 同样把数组修改次数加一；</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">    rangeCheckForAdd(index);</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> s;</span><br><span class="line">    Object[] elementData;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 如果数组中的元素数量是否达到了数组长度，对数组进行扩容，扩容大小是原数组长度的1.5倍</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> ((s = size) == (elementData = <span class="keyword">this</span>.elementData).length)</span><br><span class="line">        elementData = grow();</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 然后将该index位置的元素和它后面的所有元素后移一位</span></span><br><span class="line"><span class="comment">     * 把index的位置空出来，然后将其赋值为传入的元素</span></span><br><span class="line"><span class="comment">     * 元素数量加一。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    System.arraycopy(elementData, index,</span><br><span class="line">                     elementData, index + <span class="number">1</span>,</span><br><span class="line">                     s - index);</span><br><span class="line">    elementData[index] = element;</span><br><span class="line">    size = s + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 由add和addAll使用的rangeCheck的一个版本。同为对下标范围的判断，本质与之前的checkIndex方法没什么区别。</span></span><br><span class="line"><span class="comment"> * 只是自己自定义了抛出异常的语句而已</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">rangeCheckForAdd</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (index &gt; size || index &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException(outOfBoundsMsg(index));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结来说，如果在指定位置插入指定的元素，因为要移动指定位置后面的所有元素，那么O(N)的时间；如果将指定的元素追加到此列表的末尾，那么仅花费常数的时间，但是如果数组需要扩容的话，将花费时间对数组进行扩容，所以尽量在初始化该List时就指定好容量大小。</p><h2 id="remove-方法"><a href="#remove-方法" class="headerlink" title="remove 方法"></a>remove 方法</h2><h3 id="删除指定位置的元素"><a href="#删除指定位置的元素" class="headerlink" title="删除指定位置的元素"></a>删除指定位置的元素</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 删除该列表中指定位置的元素。 将任何后续元素移动到左侧（从其索引中减去一个元素）。  </span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> index 要删除的元素的下标</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 从列表中删除的元素 </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IndexOutOfBoundsException 如果索引超出范围（ index &lt; 0 || index &gt;= size() ） </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 依旧先对下标范围进行检查</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">    Objects.checkIndex(index, size);</span><br><span class="line">    <span class="keyword">final</span> Object[] es = elementData;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 把旧的元素暂存下来，调用fastRemove方法把指定位置的元素删除，等删除后返回。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    E oldValue = (E) es[index];</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * fastRemove方法见下面</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    fastRemove(es, index);</span><br><span class="line">    <span class="keyword">return</span> oldValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="删除第一个出现的指定元素"><a href="#删除第一个出现的指定元素" class="headerlink" title="删除第一个出现的指定元素"></a>删除第一个出现的指定元素</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 从列表中删除第一个出现的指定元素（如果存在）。 </span></span><br><span class="line"><span class="comment"> * 如果列表不包含该元素，则它不会更改。</span></span><br><span class="line"><span class="comment"> * 更正式地，删除具有最低索引i的元素，使得Objects.equals(o, get(i)) （如果这样的元素存在）。</span></span><br><span class="line"><span class="comment"> *  如果此列表包含指定的元素（或等效地，如果此列表作为调用的结果而更改），则返回true 。 </span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> o 要从此列表中删除的元素（如果存在） </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; 如果此列表包含指定的元素</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Object[] es = elementData;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> size = <span class="keyword">this</span>.size;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    found: &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 遍历整个数组，查找指定元素o的下标，如果数组中不存在该元素，就直接返回false</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">        <span class="keyword">if</span> (o == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (; i &lt; size; i++)</span><br><span class="line">                <span class="keyword">if</span> (es[i] == <span class="keyword">null</span>)</span><br><span class="line">                    <span class="keyword">break</span> found;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (; i &lt; size; i++)</span><br><span class="line">                <span class="keyword">if</span> (o.equals(es[i]))</span><br><span class="line">                    <span class="keyword">break</span> found;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 找到该元素的下标后，调用fastRemove方法进行删除。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    fastRemove(es, i);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="fastRemove-方法"><a href="#fastRemove-方法" class="headerlink" title="fastRemove 方法"></a>fastRemove 方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 私有的remove方法，该方法跳过边界检查，并且不返回已删除的值。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">fastRemove</span><span class="params">(Object[] es, <span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 数组修改次数加一</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> newSize;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将指定元素第一次出现的下标后面的元素全部左移一位，等于将指定元素覆盖掉</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> ((newSize = size - <span class="number">1</span>) &gt; i)</span><br><span class="line">        System.arraycopy(es, i + <span class="number">1</span>, es, i, newSize - i);</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 然后将最后那个空出来的元素变赋值为null，同时size减小1</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    es[size = newSize] = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="clear-方法"><a href="#clear-方法" class="headerlink" title="clear 方法"></a>clear 方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 从列表中删除所有元素。 此呼叫返回后，列表将为空。 </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 数组修改次数加一</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="keyword">final</span> Object[] es = elementData;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 遍历整个数组，把所有下标置为null，同时size设置为0</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> to = size, i = size = <span class="number">0</span>; i &lt; to; i++)</span><br><span class="line">        es[i] = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="addAll-方法"><a href="#addAll-方法" class="headerlink" title="addAll 方法"></a>addAll 方法</h2><h3 id="将指定集合中的所有元素追加到列表的末尾"><a href="#将指定集合中的所有元素追加到列表的末尾" class="headerlink" title="将指定集合中的所有元素追加到列表的末尾"></a>将指定集合中的所有元素追加到列表的末尾</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 按指定集合的Iterator返回的顺序。</span></span><br><span class="line"><span class="comment"> * 如果在操作进行中修改了指定的集合，则此操作的行为是不确定的。（这意味着如果指定的集合是此列表，则此调用的行为是不确定的，并且此列表是非空的。） </span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> c 包含要添加到此列表的元素的集合 </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; 如果此列表因调用而更改 </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> NullPointerException  如果指定的集合为空 </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">addAll</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 把传入的集合转化为数组，方便进行拷贝，同时修改次数加一</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">    Object[] a = c.toArray();</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 如果传入的集合中没有元素，那么此列表没有更改，因此返回false </span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">int</span> numNew = a.length;</span><br><span class="line">    <span class="keyword">if</span> (numNew == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    Object[] elementData;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> s;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * elementData.length- size 得到数组剩余的空闲空间，</span></span><br><span class="line"><span class="comment">     * 如果传入的集合长度numNew大于数组剩余的空闲空间，因此当前数组放不下传入的元素，所以要对数组进行扩容</span></span><br><span class="line"><span class="comment">     * 扩容的后的大小最小值为：当前元素数量加将要添加的元素数量</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (numNew &gt; (elementData = <span class="keyword">this</span>.elementData).length - (s = size))</span><br><span class="line">        elementData = grow(s + numNew);</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将传入的集合元素数组拷贝到列表数组的后面</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    System.arraycopy(a, <span class="number">0</span>, elementData, s, numNew);</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 元素数量加上传入的元素数量</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    size = s + numNew;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="从指定的位置开始，将指定集合中的所有元素插入到此列表中。"><a href="#从指定的位置开始，将指定集合中的所有元素插入到此列表中。" class="headerlink" title="从指定的位置开始，将指定集合中的所有元素插入到此列表中。"></a>从指定的位置开始，将指定集合中的所有元素插入到此列表中。</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 将指定集合中的所有元素插入到此列表中，从指定的位置开始。</span></span><br><span class="line"><span class="comment">    * 将当前位于该位置（如果有的话）的元素和随后的任何元素移动到右边（增加其索引）。</span></span><br><span class="line"><span class="comment">    * 新元素将按照指定集合的迭代器返回的顺序显示在列表中。 </span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> index 从中指定集合插入第一个元素的索引 </span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> c 包含要添加到此列表的元素的集合 </span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; 如果此列表因呼叫而更改</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@throws</span> IndexOutOfBoundsException 如果索引超出范围（ index &lt; 0 || index &gt; size() ）</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@throws</span> NullPointerException 如果指定的集合为空 </span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">addAll</span><span class="params">(<span class="keyword">int</span> index, Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 使用自定义的方法对下标是否越界进行检查</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">       rangeCheckForAdd(index);</span><br><span class="line">       <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * 将传入的集合转化为数组，方便拷贝</span></span><br><span class="line"><span class="comment">        * 同时修改次数加一</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">       Object[] a = c.toArray();</span><br><span class="line">       modCount++;</span><br><span class="line">       <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * 如果传入的集合中没有元素，那么此列表没有更改，因此返回false </span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">       <span class="keyword">int</span> numNew = a.length;</span><br><span class="line">       <span class="keyword">if</span> (numNew == <span class="number">0</span>)</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">       Object[] elementData;</span><br><span class="line">       <span class="keyword">final</span> <span class="keyword">int</span> s;</span><br><span class="line">       <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * elementData.length- size 得到数组剩余的空闲空间，</span></span><br><span class="line"><span class="comment">        * 如果传入的集合长度numNew大于数组剩余的空闲空间，因此当前数组放不下传入的元素，所以要对数组进行扩容</span></span><br><span class="line"><span class="comment">        * 扩容的后的大小最小值为：当前元素数量加将要添加的元素数量</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">       <span class="keyword">if</span> (numNew &gt; (elementData = <span class="keyword">this</span>.elementData).length - (s = size))</span><br><span class="line">           elementData = grow(s + numNew);</span><br><span class="line">       <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * s - index 计算得到需要向右移动的元素的长度</span></span><br><span class="line"><span class="comment">        * 然后将其向右移动该长度</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">       <span class="keyword">int</span> numMoved = s - index;</span><br><span class="line">       <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)</span><br><span class="line">           System.arraycopy(elementData, index,</span><br><span class="line">                            elementData, index + numNew,</span><br><span class="line">                            numMoved);</span><br><span class="line">       <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * 把传入的集合中的元素拷贝到指定的位置，也就是上面数组向右移动后空出来的位置</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">       System.arraycopy(a, <span class="number">0</span>, elementData, index, numNew);</span><br><span class="line">       <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * 元素数量加上传入的集合中的元素数量</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">       size = s + numNew;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h2 id="removeAll-与-retainAll-方法"><a href="#removeAll-与-retainAll-方法" class="headerlink" title="removeAll 与 retainAll 方法"></a>removeAll 与 retainAll 方法</h2><h3 id="removeAll-方法"><a href="#removeAll-方法" class="headerlink" title="removeAll 方法"></a>removeAll 方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 从此列表中删除指定集合中包含的所有元素。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> c 包含要从此列表中删除的元素的集合 </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; 如果此列表因调用而更改</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> ClassCastException 如果此列表的元素的类与指定的集合不兼容（ 可选 ） </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> NullPointerException 如果此列表包含空元素，并且指定的集合不允许空元素（ 可选 ），或者如果指定的集合为空</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">removeAll</span><span class="params">(Collection&lt;?&gt; c)</span> </span>&#123;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * batchRemove 方法见下面</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">    <span class="keyword">return</span> batchRemove(c, <span class="keyword">false</span>, <span class="number">0</span>, size);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="retainAll-方法"><a href="#retainAll-方法" class="headerlink" title="retainAll 方法"></a>retainAll 方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 仅保留此列表中包含在指定集合中的元素。 </span></span><br><span class="line"><span class="comment"> * 换句话说，从此列表中删除其中不包含在指定集合中的所有元素。</span></span><br><span class="line"><span class="comment"> * 本质就是求交集。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> c 包含要保留在此列表中的元素的集合</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; 如果此列表因调用而更改</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> ClassCastException 如果此列表的元素的类与指定的集合不兼容（ 可选 ） </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> NullPointerException 如果此列表包含空元素，并且指定的集合不允许空元素（ 可选 ），或者如果指定的集合为空</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">retainAll</span><span class="params">(Collection&lt;?&gt; c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> batchRemove(c, <span class="keyword">true</span>, <span class="number">0</span>, size);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="batchRemove-方法"><a href="#batchRemove-方法" class="headerlink" title="batchRemove 方法"></a>batchRemove 方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 对比removeAll和retainAll方法，同样都是调用了batchRemove方法，唯一的区别就是传入的complement参数</span></span><br><span class="line"><span class="comment"> * removeAll的参数是false，而retainAll方法传入的是true，所导致的结果则截然不同，所以这个complement是决定结果的关键</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">batchRemove</span><span class="params">(Collection&lt;?&gt; c, <span class="keyword">boolean</span> complement,</span></span></span><br><span class="line"><span class="function"><span class="params">           <span class="keyword">final</span> <span class="keyword">int</span> from, <span class="keyword">final</span> <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 该方法判断传入的集合c是否为null，如果是null则抛出异常，代码见下方</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">Objects.requireNonNull(c);</span><br><span class="line"><span class="keyword">final</span> Object[] es = elementData;</span><br><span class="line"><span class="keyword">int</span> r;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 从头开始遍历数组，它的作用就是找到数组中第一个在集合c包含或者不包含的元素的位置，具体看下面</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">for</span> (r = from;; r++) &#123;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 如果r走到了最后依旧没找到任何一个集合c中包含或者不包含的元素</span></span><br><span class="line"><span class="comment"> * 那么数组将不会发生任何变化，返回false</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (r == end)</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 如果complement是false，那么在找到数组中第一个存在于集合c中的元素时，结束循环</span></span><br><span class="line"><span class="comment"> * 如果complement是true，那么在找到数组中第一个不存在于集合c中的元素时，结束循环</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (c.contains(es[r]) != complement)</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 看到w和r，顾名思义，w是write，r是read，也就是写和读，具体作用看下面就知道了</span></span><br><span class="line"><span class="comment"> * 这里把r赋给了w，r加一</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">int</span> w = r++;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">for</span> (Object e; r &lt; end; r++)</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 从上一次循环中，扎到数组中第一个存在/不存在于集合c中的元素的下标开始遍历</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 如果complement是false，那么在找到数组中一个不存在于集合c中的元素时，把他覆盖到刚刚找到的第一个存在于集合c中的元素的位置处</span></span><br><span class="line"><span class="comment"> * 这里可能难以理解一点，可以这样想：</span></span><br><span class="line"><span class="comment"> * 因为complement是false的情况是删除重复的元素嘛，所以用数组后面不重复的元素覆盖前面的元素，以此代替了删除。</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 同样如果complement是true，那么在找到数组中一个存在于集合c中的元素时，把他覆盖到刚刚找到的第一个不存在于集合c中的元素的位置处</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (c.contains(e = es[r]) == complement)</span><br><span class="line">es[w++] = e;</span><br><span class="line">&#125; <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 即使c.contains()抛出异常，也可以保持与AbstractCollection的兼容性</span></span><br><span class="line"><span class="comment"> * 将已经覆盖的元素后面重复出来的元素删除掉</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">System.arraycopy(es, r, es, w, end - r);</span><br><span class="line">w += end - r;</span><br><span class="line"><span class="keyword">throw</span> ex;</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 修改此处对应增加改变的数量</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">modCount += end - w;</span><br><span class="line">shiftTailOverGap(es, w, end);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">T <span class="title">requireNonNull</span><span class="params">(T obj)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (obj == <span class="keyword">null</span>)</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">       <span class="keyword">return</span> obj;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="comment">/**通过以下元素向下滑动，消除从lo到hi的间隔。 */</span></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">shiftTailOverGap</span><span class="params">(Object[] es, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi)</span> </span>&#123;</span><br><span class="line">       System.arraycopy(es, hi, es, lo, size - hi);</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> to = size, i = (size -= hi - lo); i &lt; to; i++)</span><br><span class="line">           es[i] = <span class="keyword">null</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>这里总结一下removeAll，retainAll和addAll方法之间的关系吧：</p><ul><li>removeAll 方法就是把存在于指定的集合中的元素全部删除掉，也就是求补集。</li><li>retainAll 方法就是把不存在于指定的集合中的元素全部删除掉，也就是求交集。</li><li>addAll 方法就把不存在于指定的集合中的元素全部添加到列表中，也就是求并集。</li></ul><h2 id="subList-方法"><a href="#subList-方法" class="headerlink" title="subList 方法"></a>subList 方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 返回指定的fromIndex （含）和toIndex之间的列表部分的视图。 （如果fromIndex和toIndex相等，返回的列表为空。）</span></span><br><span class="line"><span class="comment"> * 返回的列表由此列表支持，因此返回列表中的非结构更改将反映在此列表中，反之亦然。 返回的列表支持所有可选列表操作。 </span></span><br><span class="line"><span class="comment"> * 该方法消除了对显式范围操作（对于数组通常存在的排序）的需要。 </span></span><br><span class="line"><span class="comment"> * 任何期望列表的操作都可以通过传递一个子列表视图而不是整个列表来用作范围操作。 例如，以下成语从列表中移除了一系列元素： list.subList(from, to).clear();</span></span><br><span class="line"><span class="comment"> * 可以为indexOf(Object)和lastIndexOf(Object)构造类似的成语，并且可以将Collections类中的所有算法应用于子列表。 </span></span><br><span class="line"><span class="comment"> * 如果支持列表（即，此列表）以除了通过返回的列表之外的任何方式进行结构修改 ，则此方法返回的列表的语义将变为不正确。 </span></span><br><span class="line"><span class="comment"> * （结构修改是那些改变此列表的大小，或以其他方式扰乱它，使得正在进行的迭代可能产生不正确的结果）。</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 简单的来说，就是返回整个列表中，指定范围那部分的列表的视图。</span></span><br><span class="line"><span class="comment"> * 但是！！如果对返回的这部分列表进行修改，那么同时原列表的对应位置也会发生修改</span></span><br><span class="line"><span class="comment"> * 所以本质就是返回了一部分引用而已。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IndexOutOfBoundsException 如果端点索引值超出范围 (fromIndex &lt; 0 || toIndex &gt; size) </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IllegalArgumentException 如果端点索引不正确 (fromIndex &gt; toIndex) </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;E&gt; <span class="title">subList</span><span class="params">(<span class="keyword">int</span> fromIndex, <span class="keyword">int</span> toIndex)</span> </span>&#123;</span><br><span class="line">    subListRangeCheck(fromIndex, toIndex, size);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> SubList&lt;&gt;(<span class="keyword">this</span>, fromIndex, toIndex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以总结来说，尽量不要使用subList方法，如果要使用的话，一定要注意下面几点使用方法：</p><ol><li>千万不要再对原 List 进行任何改动的操作(例如: 增删改), 查询和遍历倒是可以. 因为如果对原 List 进行了改动, 那么后续只要是涉及到子 List 的操作就一定会出问题. 而至于会出现什么问题呢? 具体来说就是:<br>(1) 如果是对原 List 进行修改 (即: 调用 set() 方法) 而不是增删, 那么子 List 的元素也可能会被修改 (这种情况下不会抛出并发修改异常).<br>(2) 如果是对原 List 进行增删, 那么此后只要操作了子 List , 就一定会抛出并发修改异常.</li><li>千万不要直接对子 List 进行任何改动的操作(例如: 增删改), 但是查询和间接改动倒是可以. 不要对子 List 进行直接改动, 是因为如果在对子 List 进行直接改动之前, 原 List 已经被改动过, 那么此后在对子 List 进行直接改动的时候就会抛出并发修改异常.</li><li>如果要进行操作，则使用例如：List<integer> subList = new ArrayList&lt;&gt;(list.subList(2, list.size()));  的方法，把分割出来的数组转化为一个新的列表，在新的列表基础上操作就不会对原列表产生任何影响。</integer></li></ol><h1 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h1><p>考虑一点：elementData设置成了transient，那ArrayList是怎么把元素序列化的呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">writeObject</span><span class="params">(java.io.ObjectOutputStream s)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> java.io.IOException</span>&#123;</span><br><span class="line">    <span class="comment">// 防止序列化期间有修改</span></span><br><span class="line">    <span class="keyword">int</span> expectedModCount = modCount;</span><br><span class="line">    <span class="comment">// 写出非transient非static属性（会写出size属性）</span></span><br><span class="line">    s.defaultWriteObject();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 写出元素个数</span></span><br><span class="line">    s.writeInt(size);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 依次写出元素</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;size; i++) &#123;</span><br><span class="line">        s.writeObject(elementData[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果有修改，抛出异常</span></span><br><span class="line">    <span class="keyword">if</span> (modCount != expectedModCount) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readObject</span><span class="params">(java.io.ObjectInputStream s)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> java.io.IOException, ClassNotFoundException </span>&#123;</span><br><span class="line">    <span class="comment">// 声明为空数组</span></span><br><span class="line">    elementData = EMPTY_ELEMENTDATA;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读入非transient非static属性（会读取size属性）</span></span><br><span class="line">    s.defaultReadObject();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读入元素个数，没什么用，只是因为写出的时候写了size属性，读的时候也要按顺序来读</span></span><br><span class="line">    s.readInt();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (size &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 计算容量</span></span><br><span class="line">        <span class="keyword">int</span> capacity = calculateCapacity(elementData, size);</span><br><span class="line">        SharedSecrets.getJavaOISAccess().checkArray(s, Object[].class, capacity);</span><br><span class="line">        <span class="comment">// 检查是否需要扩容</span></span><br><span class="line">        ensureCapacityInternal(size);</span><br><span class="line"></span><br><span class="line">        Object[] a = elementData;</span><br><span class="line">        <span class="comment">// 依次读取元素到数组中</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;size; i++) &#123;</span><br><span class="line">            a[i] = s.readObject();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>查看writeObject()方法可知，先调用s.defaultWriteObject()方法，再把size写入到流中，再把元素一个一个的写入到流中。</p><p>一般地，只要实现了Serializable接口即可自动序列化，writeObject()和readObject()是为了自己控制序列化的方式，这两个方法必须声明为private，在java.io.ObjectStreamClass#getPrivateMethod()方法中通过反射获取到writeObject()这个方法。</p><p>在ArrayList的writeObject()方法中先调用了s.defaultWriteObject()方法，这个方法是写入非static非transient的属性，在ArrayList中也就是size属性。同样地，在readObject()方法中先调用了s.defaultReadObject()方法解析出了size属性。</p><p>elementData定义为transient的优势，自己根据size序列化真实的元素，而不是根据数组的长度序列化元素，减少了空间占用。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ol><li>ArrayList内部使用数组存储元素，当数组长度不够时进行扩容，每次加一半的空间，ArrayList不会进行缩容；</li><li>ArrayList支持随机访问，通过索引访问元素极快，时间复杂度为O(1)；</li><li>ArrayList添加元素到尾部极快，平均时间复杂度为O(1)；</li><li>ArrayList添加元素到中间比较慢，因为要搬移元素，平均时间复杂度为O(n)；</li><li>ArrayList从尾部删除元素极快，时间复杂度为O(1)；</li><li>ArrayList从中间删除元素比较慢，因为要搬移元素，平均时间复杂度为O(n)；</li><li>ArrayList支持求并集，调用addAll(Collection&lt;? extends E&gt; c)方法即可；</li><li>ArrayList支持求交集，调用retainAll(Collection&lt;? extends E&gt; c)方法即可；</li><li>ArrayList支持求单向差集，调用removeAll(Collection&lt;? extends E&gt; c)方法即可；</li></ol>]]></content>
    
    <summary type="html">
    
      对Java集合中比较常用的一个容器：ArrayList的源码进行分析，相比来说ArrayList的源码还是比较容易阅读的。
    
    </summary>
    
      <category term="Java容器" scheme="http://yoursite.com/categories/Java%E5%AE%B9%E5%99%A8/"/>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
      <category term="容器" scheme="http://yoursite.com/tags/%E5%AE%B9%E5%99%A8/"/>
    
      <category term="源码" scheme="http://yoursite.com/tags/%E6%BA%90%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>HashMap源码阅读</title>
    <link href="http://yoursite.com/posts/42557/"/>
    <id>http://yoursite.com/posts/42557/</id>
    <published>2019-07-27T11:51:13.239Z</published>
    <updated>2019-08-04T12:11:11.836Z</updated>
    
    <content type="html"><![CDATA[<h2 id="HashMap的数据结构"><a href="#HashMap的数据结构" class="headerlink" title="HashMap的数据结构"></a>HashMap的数据结构</h2><p>先介绍一点基础结构<br>  <img src="/posts/42557/HashMapDateStructure.jpg" alt><br>HashMap的基础结构是由数组（Node&lt;K,V&gt;[] table）+ 链表 + 红黑树组成的，因为我对红黑树不太了解，所以就没有看后面红黑树部分的东西（1400行之后的代码基本全是在说红黑树部分的），下面就没有讲述红黑树部分的内容。<br>数组的每个下标位置储存的是Node结点， 在Javadoc中把存放数据的table数组的每个下表称作bin（桶），数组每个下标的一开始存放的是链表，当链表长度大于等于（&gt;=）8的时候，会将链表转换为红黑树。  </p><p><strong>顶部注释：</strong></p><blockquote><p>HashMap是Map接口基于哈希表的实现。这种实现提供了所有可选的Map操作，并允许key和value为null（除了HashMap是unsynchronized的和允许使用null外，HashMap和HashTable大致相同。）。此类不保证映射的顺序，特别是它不保证该顺序恒久不变。</p><p>此实现假设哈希函数在桶内适当地分布元素，为基本实现(get 和 put)提供了稳定的性能。迭代 collection 视图所需的时间与 HashMap 实例的“容量”（桶的数量）及其大小（键-值映射关系数）成比例。如果遍历操作很重要，就不要把初始化容量initial capacity设置得太高（或将加载因子load factor设置得太低），否则会严重降低遍历的效率。</p><p>HashMap有两个影响性能的重要参数：初始化容量initial capacity、加载因子load factor。容量是哈希表中桶的数量，初始容量只是哈希表在创建时的容量。加载因子是哈希表在其容量自动增加之前可以达到多满的一种尺度。initial capacity<em>load factor就是当前允许的最大元素数目，超过initial capacity</em>load factor之后，HashMap就会进行rehashed操作来进行扩容，扩容后的的容量为之前的两倍。</p><p>通常，默认加载因子 (0.75) 在时间和空间成本上寻求一种折衷。加载因子过高虽然减少了空间开销，但同时也增加了查询成本（在大多数 HashMap类的操作中，包括 get 和 put 操作，都反映了这一点）。在设置初始容量时应该考虑到映射中所需的条目数及其加载因子，以便最大限度地减少rehash操作次数。如果初始容量大于最大条目数除以加载因子，则不会发生rehash 操作。</p><p>如果很多映射关系要存储在 HashMap 实例中，则相对于按需执行自动的 rehash 操作以增大表的容量来说，使用足够大的初始容量创建它将使得映射关系能更有效地存储。</p><p>注意，此实现不是同步的。如果多个线程同时访问一个哈希映射，而其中至少一个线程从结构上修改了该映射，则它必须保持外部同步。（结构上的修改是指添加或删除一个或多个映射关系的任何操作；仅改变与实例已经包含的键关联的值不是结构上的修改。）这一般通过对自然封装该映射的对象进行同步操作来完成。如果不存在这样的对象，则应该使用 Collections.synchronizedMap 方法来“包装”该映射。最好在创建时完成这一操作，以防止对映射进行意外的非同步访问，如下所示：<br>Map m = Collections.synchronizedMap(new HashMap(…));</p><p>由所有此类的“collection 视图方法”所返回的迭代器都是fail-fast 的：在迭代器创建之后，如果从结构上对映射进行修改，除非通过迭代器本身的remove方法，其他任何时间任何方式的修改，迭代器都将抛出 ConcurrentModificationException。因此，面对并发的修改，迭代器很快就会完全失败，而不冒在将来不确定的时间发生任意不确定行为的风险。</p><p>注意，迭代器的快速失败行为不能得到保证，一般来说，存在非同步的并发修改时，不可能作出任何坚决的保证。快速失败迭代器尽最大努力抛出 ConcurrentModificationException。因此，编写依赖于此异常的程序的做法是错误的，正确做法是：迭代器的快速失败行为应该仅用于检测bug。</p><p>此类是 Java Collections Framework 的成员。</p></blockquote><p><strong>从上面的内容可以总结出以下几点：</strong></p><ul><li><strong>底层</strong>： HashMap是Map接口基于哈希表实现的。</li><li><strong>是否允许null</strong>： HashMap允许key和value为null。</li><li><strong>是否有序</strong>：HashMap不保证映射到顺序，特别是它不保证顺序恒久不变。</li><li><strong>两个影响HashMap性能的参数</strong>： 初始化容量initial capacity、加载因子load factor。</li><li><strong>每次扩容大小</strong>：扩容后的的容量为之前的两倍。</li><li><strong>初始化容量对性能的影响</strong>： 不应设置的太小，容量小虽然可以节省空间，但是可能会导致频繁的扩容，扩容操作非常消耗时间；也不应该设置的太大，容量大会导致严重降低遍历的效率以及内存空间的浪费。<strong>总结来说就是：小了会增大时间开销（频繁的扩容）；大了会增大空间开销和时间开销（降低遍历效率）。</strong></li><li><strong>加载因子对性能的影响</strong>： 0.75是一个折中的值，加载因子过高虽然减少了空间开销，但是也增加了查询到成本；而加载因子过低会导致频繁的扩容。</li><li><strong>是否同步</strong>： HashMap不是同步的。</li><li><strong>迭代器</strong>： 迭代器是fast-fail，但是迭代器的快速失败行为不能得到保证。</li></ul><h2 id="HashMap的定义"><a href="#HashMap的定义" class="headerlink" title="HashMap的定义"></a>HashMap的定义</h2><pre><code>public class HashMap&lt;K,V&gt; extends AbstractMap&lt;K,V&gt; implements Map&lt;K,V&gt;, Cloneable, Serializable </code></pre><ul><li><strong>HashMap&lt;K,V&gt;</strong>：HashMap是以key-value形式存储数据。</li><li><strong>extends AbstractMap&lt;K,V&gt;</strong>： 继承于AbstractMap，大大减少了实现Map接口时需要的工作。</li><li><strong>implements Map&lt;K,V</strong>： 实现了Map接口，提供所有可选的Map操作。</li><li><strong>implements Cloneable</strong>：实现了Cloneable接口，内部可以调用clone()方法来返回实例的浅拷贝(shallow copy)。</li><li><strong>implements Serializable</strong>：实现了Serializable接口，表明该类时可以序列化的。</li></ul><h2 id="静态全局变量"><a href="#静态全局变量" class="headerlink" title="静态全局变量"></a>静态全局变量</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 默认初始容量—必须是2的幂。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">4</span>;<span class="comment">// 也就是 16</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 如果具有参数的任一构造函数隐式指定更高的值，则使用最大容量。</span></span><br><span class="line"><span class="comment"> * 必须是2的幂 &lt;= 1 &lt;&lt; 30。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAXIMUM_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">30</span>;<span class="comment">// 也就是 2的30次方</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 构造函数中没有指定时使用的加载因子，即默认的加载因子。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> DEFAULT_LOAD_FACTOR = <span class="number">0.75f</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将链表转化成红黑树的临界值。</span></span><br><span class="line"><span class="comment"> * 当链表长度(包括下标处开始的那个结点)大于等于8时，桶中的链表被转化成红黑树。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TREEIFY_THRESHOLD = <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将红黑树恢复成链表时的临界值。</span></span><br><span class="line"><span class="comment"> * 当红黑树的长度小于等于6时，桶中的红黑树被转化成链表。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> UNTREEIFY_THRESHOLD = <span class="number">6</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 桶被转化成红黑树的最小容量。</span></span><br><span class="line"><span class="comment"> * 当链表长度大于等于8，且HashMap的总体大小大于等于64时，才会将桶中的链表被转化成红黑树。</span></span><br><span class="line"><span class="comment"> * 否则只会采取扩容的方式来减少冲突。</span></span><br><span class="line"><span class="comment"> * 该值不能小于 4 * TREEIFY_THRESHOLD</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MIN_TREEIFY_CAPACITY = <span class="number">64</span>;</span><br></pre></td></tr></table></figure><h2 id="静态内部类-Node"><a href="#静态内部类-Node" class="headerlink" title="静态内部类 Node"></a>静态内部类 Node</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * HashMap的基本节点类型，即是HashMap底层的组成元素，也是每个桶（bin）中的链表的组成元素。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">   <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * key的hash值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">       <span class="keyword">final</span> <span class="keyword">int</span> hash;</span><br><span class="line">       <span class="keyword">final</span> K key;</span><br><span class="line">       V value;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 指向下一个Node节点的引用</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">       Node&lt;K,V&gt; next;</span><br><span class="line"></span><br><span class="line">       Node(<span class="keyword">int</span> hash, K key, V value, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">           <span class="keyword">this</span>.hash = hash;</span><br><span class="line">           <span class="keyword">this</span>.key = key;</span><br><span class="line">           <span class="keyword">this</span>.value = value;</span><br><span class="line">           <span class="keyword">this</span>.next = next;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> K <span class="title">getKey</span><span class="params">()</span>        </span>&#123; <span class="keyword">return</span> key; &#125;</span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">getValue</span><span class="params">()</span>      </span>&#123; <span class="keyword">return</span> value; &#125;</span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> key + <span class="string">"="</span> + value; &#125;</span><br><span class="line"></span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">           <span class="keyword">return</span> Objects.hashCode(key) ^ Objects.hashCode(value);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">setValue</span><span class="params">(V newValue)</span> </span>&#123;</span><br><span class="line">           V oldValue = value;</span><br><span class="line">           value = newValue;</span><br><span class="line">           <span class="keyword">return</span> oldValue;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">           <span class="keyword">if</span> (o == <span class="keyword">this</span>)</span><br><span class="line">               <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">           <span class="keyword">if</span> (o <span class="keyword">instanceof</span> Map.Entry) &#123;</span><br><span class="line">               Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;)o;</span><br><span class="line">               <span class="keyword">if</span> (Objects.equals(key, e.getKey()) &amp;&amp;</span><br><span class="line">                   Objects.equals(value, e.getValue()))</span><br><span class="line">                   <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h2 id="静态工具"><a href="#静态工具" class="headerlink" title="静态工具"></a>静态工具</h2><h3 id="hash方法详解"><a href="#hash方法详解" class="headerlink" title="hash方法详解"></a>hash方法详解</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * 计算key.hashCode（）并将更高位的散列扩展（XOR）降低。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">   <span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">int</span> h;</span><br><span class="line">       <span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">i = (table.length - <span class="number">1</span>) &amp; hash;<span class="comment">//这一步是在后面添加元素putVal()方法中进行位置的确定</span></span><br></pre></td></tr></table></figure><p>主要分为三步：</p><ol><li>取hashCode的值： key.hashCode()。调用Object. hashCode() 方法，该方法根据一定规则将与对象相关的信息，例如对象的存储地址，对象的字段等，映射成与一个32位 int 类型的值，这个数值称作为hash值。</li><li>让高位参与运算： h&gt;&gt;&gt;16 。将得到的hash值无符号右移十六位，空出来的高位补零。</li><li>取模运算： (n-1) &amp; hash 。 为了让数组元素分布均匀，把hash值对数组长度-1取余，也就是hash%n，得到在数组中保存的位置下标。</li></ol><p><strong>为什么要这样做的理由：</strong><br>  <img src="/posts/42557/1120165-20180405000930403-1215437085.png" alt><br>整个过程如上图所示，将原本的32位的hash值右移16位，然后与原值进行异或运算，是为了混合原始哈希码的高位和低位，以此来加大低位的随机性。</p><p>看到这里有个疑问，<strong>为什么要做异或运算？</strong><br>设想一下，如果n很小，假设为16的话，那么n-1即为15（0000 0000 0000 0000 0000 0000 0000 1111），这样的值如果跟hashCode()直接做与操作，实际上只使用了哈希值的后4位。如果当哈希值的高位变化很大，低位变化很小，这样很容易造成碰撞，所以把高低位都参与到计算中，从而解决了这个问题，而且也不会有太大的开销。<br>然后将得到的最终的hash值对数组长度-1取余，就可以得到在数组中保存的位置下标。这也是为什么要保证数组的长度总是2的n次方的理由。当数组长度length总是2的n次方时，(n - 1) &amp; hash == hash % n，但是位运算的速度更快，因此保证效率更高。</p><h3 id="comparableClassFor方法解读"><a href="#comparableClassFor方法解读" class="headerlink" title="comparableClassFor方法解读"></a>comparableClassFor方法解读</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 当对象x的类型为X，并且X实现了Comparable接口（比较的参数本身必须为X类本身）时</span></span><br><span class="line"><span class="comment">    * 返回x的运行时类型，否则返回null。</span></span><br><span class="line"><span class="comment">    * </span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">static</span> Class&lt;?&gt; comparableClassFor(Object x) &#123;</span><br><span class="line">       <span class="keyword">if</span> (x <span class="keyword">instanceof</span> Comparable) &#123;</span><br><span class="line">           Class&lt;?&gt; c; Type[] ts, as; ParameterizedType p;</span><br><span class="line">           <span class="keyword">if</span> ((c = x.getClass()) == String.class) <span class="comment">// bypass checks</span></span><br><span class="line">               <span class="keyword">return</span> c;</span><br><span class="line">           <span class="keyword">if</span> ((ts = c.getGenericInterfaces()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">               <span class="keyword">for</span> (Type t : ts) &#123;</span><br><span class="line">                   <span class="keyword">if</span> ((t <span class="keyword">instanceof</span> ParameterizedType) &amp;&amp;</span><br><span class="line">                       ((p = (ParameterizedType) t).getRawType() ==</span><br><span class="line">                        Comparable.class) &amp;&amp;</span><br><span class="line">                       (as = p.getActualTypeArguments()) != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                       as.length == <span class="number">1</span> &amp;&amp; as[<span class="number">0</span>] == c) <span class="comment">// type arg is c</span></span><br><span class="line">                       <span class="keyword">return</span> c;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>如注释所示，传参传入一个对象，当对象x的类型为X，并且X实现了Comparable接口（比较的参数本身必须为X类本身）时，返回x的运行时类型，否则返回null。<br>接下来分析这个方法的每行代码。</p><ul><li><strong>instanceof</strong><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x <span class="keyword">instanceof</span> Comparable</span><br></pre></td></tr></table></figure></li></ul><p><strong>instanceof</strong>可以理解为是某种类型的实例。不论是运行时类型，或者是他的父类、它实现的接口、他的父类实现的接口、甚至是他父类的父类的父类实现的接口的父类的父类，总之，只要在继承链上有这个类型就可以了。  </p><ul><li><strong>getClass()</strong><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">c = x.getClass()</span><br></pre></td></tr></table></figure></li></ul><p>与instanceof相应对的是<strong>getClass()</strong>方法，无论该对象如何转型，该方法返回的只会是它的运行时类型，可以简单的理解为它的实际类型，也就是new它的时候的类型。<br>有一种例外情况：匿名对象。当匿名对象调用该方法时，返回的是依赖它的对象的运行时类型，并且以1，2，3…的索引区分。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">       D d = <span class="keyword">new</span> D();</span><br><span class="line">       System.out.println(<span class="keyword">new</span> A()&#123;&#125;.getClass());   <span class="comment">// class Demo$1</span></span><br><span class="line">       System.out.println(<span class="keyword">new</span> B()&#123;&#125;.getClass());   <span class="comment">// class Demo$2</span></span><br><span class="line">       System.out.println(<span class="keyword">new</span> Comparable&lt;Object&gt;()&#123;    <span class="comment">// class Demo$3</span></span><br><span class="line">           <span class="meta">@Override</span></span><br><span class="line">           <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">               <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">           &#125;&#125;.getClass());</span><br><span class="line">       System.out.println(d.c.getClass()); <span class="comment">// class D$1</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span></span>&#123;&#125;</span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">B</span></span>&#123;&#125;</span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">C</span></span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span></span>&#123;</span><br><span class="line">   C c;</span><br><span class="line">   D()&#123;</span><br><span class="line">       c= <span class="keyword">new</span> C()&#123;&#125;;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>getGenericInterfaces()</strong><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ts = c.getGenericInterfaces()</span><br></pre></td></tr></table></figure></li></ul><p>getGenericInterfaces()方法返回的是该对象的运行时类型”直接实现”的接口，这意味着:</p><blockquote><ul><li>返回的一定是接口</li><li>必然是该类型自己直接实现的接口，继承过来的不算</li></ul></blockquote><ul><li><p><strong>getGenericSuperclass()和getSuperclass()</strong><br>这两个方法虽然没有出现在上述代码中，但是也顺便说一下：</p><blockquote><ul><li>getGenericSuperclass()返回的是父类的直接类型，不包括泛型参数。</li><li>getSuperclass()返回的是包括泛型参数的父类类型，但是注意，如果子类在继承父类时，没有实现（声明）父类的泛型，那么这时候子类是没有泛型参数的。</li></ul></blockquote></li><li><p><strong>ParameterizedType</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">t <span class="keyword">instanceof</span> ParameterizedType</span><br></pre></td></tr></table></figure></li></ul><p>ParameterizedType是Type接口的子接口，表示实现了泛型参数的类型。需要注意：</p><blockquote><ul><li>如果直接用Bean对象 instanceof ParameterizedType，结果都是false。</li><li>Class对象不能 instanceof ParameterizedType，编译会报错。</li><li>只有用Type对象 instanceof ParameterizedType ，才能得到想要的比较结果。可以理解为：一个Bean类不会是ParameterizedType，只有代表这个Bean类的类型（Type）才有可能是ParameterizedType。</li><li>实现泛型参数，必须给泛型传入参数，例如：class Child2&lt;A,B&gt; extends Super&lt;A,B&gt;{} ;只声明泛型而不实现,例如：class Child3&lt;A,B&gt; extends Super{} , 对比结果为false。</li></ul></blockquote><ul><li><strong>getRawType()</strong><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">((p = (ParameterizedType) t).getRawType()</span><br></pre></td></tr></table></figure></li></ul><p>该方法返回实现了这个类型的类或者接口，即去掉了泛型参数部分的类型对象。</p><ul><li><strong>getActualTypeArguments()</strong><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">as = p.getActualTypeArguments()</span><br></pre></td></tr></table></figure></li></ul><p>该方法与getRawType()相对应，以数组形式返回泛型的参数列表。</p><blockquote><ul><li>当参数是真实类型时，打印的是全类名</li><li>当参数是另一个新声明的泛型参数时，打印的是代表该泛型类型的符号。</li></ul></blockquote><p>所以总结comparableClassFor(Object x)方法的实现为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> Class&lt;?&gt; comparableClassFor(Object x) &#123;</span><br><span class="line">       <span class="keyword">if</span> (x <span class="keyword">instanceof</span> Comparable) &#123;  <span class="comment">// 判断是否实现了Comparable接口</span></span><br><span class="line">           Class&lt;?&gt; c; Type[] ts, as; Type t; ParameterizedType p;</span><br><span class="line">           <span class="keyword">if</span> ((c = x.getClass()) == String.class) </span><br><span class="line">               <span class="keyword">return</span> c;   <span class="comment">// 如果是String类型，直接返回String.class</span></span><br><span class="line">           <span class="keyword">if</span> ((ts = c.getGenericInterfaces()) != <span class="keyword">null</span>) &#123;  <span class="comment">// 判断是否有直接实现的接口</span></span><br><span class="line">               <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ts.length; ++i) &#123;   <span class="comment">// 遍历直接实现的接口</span></span><br><span class="line">                   <span class="keyword">if</span> (((t = ts[i]) <span class="keyword">instanceof</span> ParameterizedType) &amp;&amp;   <span class="comment">// 该接口实现了泛型</span></span><br><span class="line">                       ((p = (ParameterizedType)t).getRawType() == <span class="comment">// 获取接口不带参数部分的类型对象</span></span><br><span class="line">                        Comparable.class) &amp;&amp;   <span class="comment">//  该类型是Comparable</span></span><br><span class="line">                       (as = p.getActualTypeArguments()) != <span class="keyword">null</span> &amp;&amp;    <span class="comment">// 获取泛型参数数组</span></span><br><span class="line">                       as.length == <span class="number">1</span> &amp;&amp; as[<span class="number">0</span>] == c)   <span class="comment">// 只有一个泛型参数，且该实现类型是该类型本身</span></span><br><span class="line">                       <span class="keyword">return</span> c;   <span class="comment">// 返回该类型</span></span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h3 id="compareComparables-方法"><a href="#compareComparables-方法" class="headerlink" title="compareComparables 方法"></a>compareComparables 方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns k.compareTo(x) if x matches kc (k's screened comparable</span></span><br><span class="line"><span class="comment"> * class), else 0.</span></span><br><span class="line"><span class="comment"> * 如果x的类型是kc，返回 k.compareTo(x) 的比较结果</span></span><br><span class="line"><span class="comment"> * 如果x为空，或者类型不是kc，返回0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@SuppressWarnings</span>(&#123;<span class="string">"rawtypes"</span>,<span class="string">"unchecked"</span>&#125;) <span class="comment">// for cast to Comparable</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">compareComparables</span><span class="params">(Class&lt;?&gt; kc, Object k, Object x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (x == <span class="keyword">null</span> || x.getClass() != kc ? <span class="number">0</span> :</span><br><span class="line">            ((Comparable)k).compareTo(x));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="tableSizeFor-方法"><a href="#tableSizeFor-方法" class="headerlink" title="tableSizeFor 方法"></a>tableSizeFor 方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns a power of two size for the given target capacity.</span></span><br><span class="line"><span class="comment"> * 返回给定数值的比第一个比它大的2的幂次方的数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">tableSizeFor</span><span class="params">(<span class="keyword">int</span> cap)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = cap - <span class="number">1</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">2</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">4</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">8</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">16</span>;</span><br><span class="line">    <span class="keyword">return</span> (n &lt; <span class="number">0</span>) ? <span class="number">1</span> : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该方法是为了在构造函数中，把传入的指定容量转化为2的幂次方的整数，保证HashMap的容量为2的幂次方。</p><h2 id="字段"><a href="#字段" class="headerlink" title="字段"></a>字段</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * table数组，存放HashMap的所有元素的容器</span></span><br><span class="line"><span class="comment"> * 在第一次使用的时候初始化，并且可以根据需要调整大小</span></span><br><span class="line"><span class="comment"> * 当分配时，长度总是为2的幂次方</span></span><br><span class="line"><span class="comment"> * 在某些操作中容忍长度为零，以允许当前不需要的引导机制</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">transient</span> Node&lt;K,V&gt;[] table;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 保存缓存的 entrySet </span></span><br><span class="line"><span class="comment"> * AbstractMap字段用于keySet（）和values（）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">transient</span> Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * HashMap中的包含的键值对数量</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">int</span> size;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 该HashMap经过结构修改的次数</span></span><br><span class="line"><span class="comment"> * 结构修改指的是更改HashMap中的键值对数量或者以其他方式修改其内部结构（例如：rehash）</span></span><br><span class="line"><span class="comment"> * 该字段用于在迭代器中的快速失败（fail-fast），抛出 ConcurrentModificationException 的异常</span></span><br><span class="line"><span class="comment"> * 因为HashMap时线程不安全的容器，所以当A线程遍历时HashMap时，还没有遍历到的部分，被线程B修改，如删除</span></span><br><span class="line"><span class="comment"> * 那么当线程A遍历到被删除的地方时就会抛出该异常</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">int</span> modCount;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 下一个要调整HashMap大小的值，容量乘加载因子(capacity * load factor).</span></span><br><span class="line"><span class="comment"> * 因为当大小超过这个值时，哈希碰撞的概率会大大增加，所以达到该值时，对HashMap扩容</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@serial</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">int</span> threshold;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 哈希表的加载因子</span></span><br><span class="line"><span class="comment"> * 默认为 0.75f</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@serial</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">float</span> loadFactor;</span><br></pre></td></tr></table></figure><h2 id="核心方法"><a href="#核心方法" class="headerlink" title="核心方法"></a>核心方法</h2><h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h3><h4 id="指定初始化容量和加载因子"><a href="#指定初始化容量和加载因子" class="headerlink" title="指定初始化容量和加载因子"></a>指定初始化容量和加载因子</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 构造具有指定初始容量和加载因子的空HashMap。</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span>  initialCapacity 初始容量</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span>  loadFactor      加载因子</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@throws</span> IllegalArgumentException 如果初始容量为负或负载因子为非正时，抛出该异常</span></span><br><span class="line"><span class="comment">   *         </span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal initial capacity: "</span> +</span><br><span class="line">                                             initialCapacity);</span><br><span class="line"><span class="comment">//当指定初始容量超过最大容量（2的30次方）时，把其值设置为最大容量</span></span><br><span class="line">      <span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">          initialCapacity = MAXIMUM_CAPACITY;</span><br><span class="line">      <span class="keyword">if</span> (loadFactor &lt;= <span class="number">0</span> || Float.isNaN(loadFactor))</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal load factor: "</span> +</span><br><span class="line">                                             loadFactor);</span><br><span class="line">      <span class="keyword">this</span>.loadFactor = loadFactor;</span><br><span class="line"><span class="comment">//将传入指定容量转换为最近的2的整数次方</span></span><br><span class="line">      <span class="keyword">this</span>.threshold = tableSizeFor(initialCapacity);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h4 id="指定初始化容量"><a href="#指定初始化容量" class="headerlink" title="指定初始化容量"></a>指定初始化容量</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 构造一个具有指定初始容量和默认加载因子(0.75)的空HashMap。</span></span><br><span class="line"><span class="comment">   * </span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span>  initialCapacity 初始容量</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@throws</span> IllegalArgumentException 如果初始容量为负时，抛出该异常</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line"><span class="comment">//调用指定初始化容量和加载因子的构造方法，加载因子为默认（0.75）</span></span><br><span class="line">      <span class="keyword">this</span>(initialCapacity, DEFAULT_LOAD_FACTOR);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h4 id="默认的初始化容量和加载因子"><a href="#默认的初始化容量和加载因子" class="headerlink" title="默认的初始化容量和加载因子"></a>默认的初始化容量和加载因子</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 构造一个具有默认初始容量(16)和默认负载因子(0.75)的空HashMap。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.loadFactor = DEFAULT_LOAD_FACTOR; <span class="comment">// 所有其他字段都默认</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="使用与指定映射相同的映射"><a href="#使用与指定映射相同的映射" class="headerlink" title="使用与指定映射相同的映射"></a>使用与指定映射相同的映射</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 使用与指定映射相同的映射构造新的HashMap。</span></span><br><span class="line"><span class="comment">   * HashMap是使用默认负载因子(0.75)创建的，初始容量足以容纳指定映射中的映射。</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span>   m 要在此map中放置其键值对（映射）的map</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@throws</span>  NullPointerException 如果指定的映射为空抛出该异常</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.loadFactor = DEFAULT_LOAD_FACTOR;</span><br><span class="line"><span class="comment">//putMapEntries方法见核心方法putMapEntries()章节</span></span><br><span class="line">      putMapEntries(m, <span class="keyword">false</span>);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h3 id="putMapEntries方法"><a href="#putMapEntries方法" class="headerlink" title="putMapEntries方法"></a>putMapEntries方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 实现了Map接口的 Map.putAll and Map 构造方法</span></span><br><span class="line"><span class="comment">   * 其中的加载因子等参数、是默认的</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> m 指定map</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> 在最初构造此映射时为false，否则为true</span></span><br><span class="line"><span class="comment">   *        (传递到下面的afterNodeInsertion方法，该方法请详见允许LinkedHashMap后操作的回调节)。</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">putMapEntries</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m, <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">int</span> s = m.size();</span><br><span class="line">       <span class="keyword">if</span> (s &gt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="comment">//如果table未初始化，对其进行初始化</span></span><br><span class="line">           <span class="keyword">if</span> (table == <span class="keyword">null</span>) &#123; <span class="comment">// pre-size</span></span><br><span class="line"><span class="comment">//使用默认的加载因子（0.75）和传入的map的大小计算出阈值（扩容的临界值）</span></span><br><span class="line">               <span class="keyword">float</span> ft = ((<span class="keyword">float</span>)s / loadFactor) + <span class="number">1.0F</span>;</span><br><span class="line">               <span class="comment">//用上一步计算出的阈值与最大容量对比，如果超过最大容量，就把它赋为最大容量</span></span><br><span class="line">               <span class="keyword">int</span> t = ((ft &lt; (<span class="keyword">float</span>)MAXIMUM_CAPACITY) ? (<span class="keyword">int</span>)ft : MAXIMUM_CAPACITY);</span><br><span class="line">               <span class="comment">//如果当前默认的阈值小于t，就把当前的阈值扩容为大于t的最小的2的整数次方的整数</span></span><br><span class="line">               <span class="keyword">if</span> (t &gt; threshold)</span><br><span class="line">                   threshold = tableSizeFor(t);</span><br><span class="line">           &#125;<span class="comment">//如果table已经初始化，且传入的map的大小超过阈值，就对table扩容（resize()方法请在核心方法章节查看）</span></span><br><span class="line">           <span class="keyword">else</span> <span class="keyword">if</span> (s &gt; threshold)</span><br><span class="line">               resize();</span><br><span class="line">           <span class="comment">//做完初始化、扩容等准备工作，现在table已经可以放下传入的map的元素了，迭代map，挨个放入table中</span></span><br><span class="line">           <span class="keyword">for</span> (Map.Entry&lt;? extends K, ? extends V&gt; e : m.entrySet()) &#123;</span><br><span class="line">               K key = e.getKey();</span><br><span class="line">               V value = e.getValue();</span><br><span class="line"><span class="comment">//putVal()方法见下面</span></span><br><span class="line">               putVal(hash(key), key, value, <span class="keyword">false</span>, evict);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="size方法"><a href="#size方法" class="headerlink" title="size方法"></a>size方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 返回此映射中键值对的数目。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 此映射中键值映对的数目。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> size;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="isEmpty方法"><a href="#isEmpty方法" class="headerlink" title="isEmpty方法"></a>isEmpty方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 如果此映射不包含键值映射，则返回&#123;<span class="doctag">@code</span> true&#125;。</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span> 如果此映射不包含键值映射，则返回&#123;<span class="doctag">@code</span> true&#125;。</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//键值对数目为零则为空</span></span><br><span class="line">      <span class="keyword">return</span> size == <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h3 id="get方法"><a href="#get方法" class="headerlink" title="get方法"></a>get方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *返回指定键映射到的值，如果该映射不包含键的映射，则返回null。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 更正式地说，如果这个映射包含从键k到值v的映射(key==null ?k==null:key.equals(k))，</span></span><br><span class="line"><span class="comment"> * 则该方法返回v;否则返回null。(最多可以有一个这样的映射。)</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 返回值为null并不一定表示映射不包含键的映射;也有可能映射显式地将键映射为null。</span></span><br><span class="line"><span class="comment"> * containsKey操作可用于区分这两种情况。</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #put(Object, Object)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="comment">//getNode方法见下面</span></span><br><span class="line">    <span class="keyword">return</span> (e = getNode(hash(key), key)) == <span class="keyword">null</span> ? <span class="keyword">null</span> : e.value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="getNode方法"><a href="#getNode方法" class="headerlink" title="getNode方法"></a>getNode方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 实现 Map接口的get方法 和其他相关方法</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> hash key的hash值</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> key 键（key）</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> 返回节点，如果不存在的话返回null</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title">getNode</span><span class="params">(<span class="keyword">int</span> hash, Object key)</span> </span>&#123;</span><br><span class="line">       Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; <span class="keyword">int</span> n; K k;</span><br><span class="line">       <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * 1.如果table为空，那么代表HashMap没有进行初始化</span></span><br><span class="line"><span class="comment">        * 2.如果table长度小于等于0，那么就代表HashMap中没有数据</span></span><br><span class="line"><span class="comment">        * 3.如果根据key的hash值计算出的下标处，没有结点，那么不存在以该key为键得映射</span></span><br><span class="line"><span class="comment">        * 满足以上三种情况得任意一种，直接返回null；只有三种情况全部满足的情况下，才进入链表/红黑树查找</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">       <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">           (first = tab[(n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">       <span class="comment">//检查该下标处得第一个结点，如果符合即返回</span></span><br><span class="line">           <span class="keyword">if</span> (first.hash == hash &amp;&amp; <span class="comment">// 总是检查第一个结点</span></span><br><span class="line">               ((k = first.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">               <span class="keyword">return</span> first;</span><br><span class="line">           <span class="comment">//头节点不合符，那么检查头结点后面的结点</span></span><br><span class="line">           <span class="keyword">if</span> ((e = first.next) != <span class="keyword">null</span>) &#123;</span><br><span class="line">           <span class="comment">//如果桶中的数据结构是红黑树，则用红黑树的方法查找</span></span><br><span class="line">               <span class="keyword">if</span> (first <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                   <span class="keyword">return</span> ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);</span><br><span class="line">               <span class="keyword">do</span> &#123;</span><br><span class="line">               <span class="comment">/**</span></span><br><span class="line"><span class="comment">                * 如果同桶中的数据结构是链表，从链表的第二个节点开始，遍历链表的每一个结点查找</span></span><br><span class="line"><span class="comment">                * e.hash == hash 比较hash值是否相等</span></span><br><span class="line"><span class="comment">                * key.equals(k) 和 (k = e.key) == key其实是一样的</span></span><br><span class="line"><span class="comment">                * Object的equals方法内部调用的就是 == 来验证是否相等</span></span><br><span class="line"><span class="comment">                * 此处体现出了严谨性</span></span><br><span class="line"><span class="comment">                */</span></span><br><span class="line">                   <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                       ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                       <span class="keyword">return</span> e;</span><br><span class="line">               &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h3 id="get和getNode方法总结"><a href="#get和getNode方法总结" class="headerlink" title="get和getNode方法总结"></a>get和getNode方法总结</h3><p>从上面的源码中可以看出，get方法可以分为三个步骤：</p><ol><li>通过hash方法得到key的hash值（hash方法在上面有详细的解释）</li><li>将上一步得到的key的hash值和key传入getNode方法，得到该key对应的Node</li><li>如果该key对应的Node为空，则返回null，否则返回Node中的value，如果Node中的value为空，那么也返回null</li></ol><p>getNode方法步骤如下：</p><ol><li>判断HashMap中存放数据的table的是否初始化，是否有数据（长度是否为0），根据key的hash值计算得到的该key在table中对应得下标处是否有结点；只有三种情况全部满足的情况下，才进入下标处得链表/红黑树查找，否则直接返回null</li><li>检查下标处的头节点是否匹配，匹配则返回该节点，否则检查头结点后面的结点</li><li>判断桶中存放数据的的数据结构是红黑树还是链表，如果桶中的数据结构是红黑树，则用红黑树的方法查找。</li><li>如果是链表则从链表的第二个节点开始，遍历链表的每一个结点查找，找到就返回对应的节点。</li><li>如果红黑树或链表的遍历中都没有找到，那么就返回null，代表不存在该节点。</li></ol><h3 id="containsKey方法"><a href="#containsKey方法" class="headerlink" title="containsKey方法"></a>containsKey方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 如果此映射包含特定键的映射，则返回true。</span></span><br><span class="line"><span class="comment"> * 否则返回false。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>   key   要测试在此映射中存在的key</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; 如果此映射包含指定的key</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">containsKey</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> getNode(hash(key), key) != <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该方法其实本质调用了getNode的方法，判断是否存在以key的键的结点，如过Node存在则返回true，否则返回false。</p><h3 id="put方法"><a href="#put方法" class="headerlink" title="put方法"></a>put方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将指定参数key和指定参数value插入map中，如果key已经存在，那就替换key对应的value</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key 指定key</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> value 指定value</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 如果value被替换，则返回旧的value，否则返回null。当然，可能key对应的value就是null。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//putVal方法的实现就在下面</span></span><br><span class="line">    <span class="keyword">return</span> putVal(hash(key), key, value, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>put方法可以分为三个步骤：</p><ol><li>通过hash方法获取到传入的key的hash值（hash方法在上面有详细的解释）</li><li>通过putVal方法放入map中</li><li>返回putVal方法的结果</li></ol><h3 id="putVal方法"><a href="#putVal方法" class="headerlink" title="putVal方法"></a>putVal方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 实现了 Map接口的 put和 相关方法。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> hash key的hash值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key  键</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> value 要放入的值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> onlyIfAbsent 如果为true，即使指定参数key在map中已经存在，也不会替换value</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> evict 如果为false，则该表处于创建模式。</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 如果value被替换，则返回旧的value，否则返回null。当然，可能key对应的value就是null。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent,</span></span></span><br><span class="line"><span class="function"><span class="params">               <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, i;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 如果table为null，则代表table没有初始化；或者table数组的长度为0，</span></span><br><span class="line"><span class="comment">     * 这两种情况下，调用resize方法对table进行初始化，</span></span><br><span class="line"><span class="comment">     * resize方法不仅可以对table扩容，还可以对table初始化</span></span><br><span class="line"><span class="comment">     * n用来记录table的长度</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">        n = (tab = resize()).length;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 如果通过key的hash值计算得到的下标处没有结点，那么新建一个链表结点放入</span></span><br><span class="line"><span class="comment">     * newNode方法调用了Node的构造方法，生成了一个新的结点。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>)</span><br><span class="line">        tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">    <span class="keyword">else</span> &#123;<span class="comment">//下面就是产生了碰撞的情况</span></span><br><span class="line">        Node&lt;K,V&gt; e; K k;</span><br><span class="line">        <span class="comment">//如果第一个结点的key就与传入的key相等，那么就把这个结点记录下来，在后面覆盖</span></span><br><span class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">            ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            e = p;</span><br><span class="line">        <span class="comment">//如果第一个key没有碰撞，而且桶中的结构是树，那么就调用相应的树的方法放置键值对</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//如果第一个key没有碰撞，而且桶中的结构是链表，那么就遍历链表</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;<span class="comment">//binCount记录了链表长度</span></span><br><span class="line">            <span class="comment">//当遍历到链表尾部，新建节点然后插入链表尾部</span></span><br><span class="line">                <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    p.next = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">                    <span class="comment">/**</span></span><br><span class="line"><span class="comment">                     * 如果插入后的链表长度大于等于8，那就把链表转化为树</span></span><br><span class="line"><span class="comment">                     * 这里减一是为了加上头结点，因为链表是从第二个结点开始遍历的</span></span><br><span class="line"><span class="comment">                     */</span></span><br><span class="line">                    <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) </span><br><span class="line">                        treeifyBin(tab, hash);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//如果在链表中某个结点的key就与传入的key相等，那么就把这个结点记录下来，在后面覆盖</span></span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                p = e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果发生了结点相等的情况，那么之前就记录了下来，所以e不为null，在这里进行覆盖</span></span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123; </span><br><span class="line">        <span class="comment">//把结点的原值记录下来，用来返回</span></span><br><span class="line">            V oldValue = e.value;</span><br><span class="line">            <span class="comment">//如果存在则覆盖或者旧节点的值为空，那么覆盖</span></span><br><span class="line">            <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>)</span><br><span class="line">                e.value = value;</span><br><span class="line">            <span class="comment">//回调方法，文章最后会说</span></span><br><span class="line">            afterNodeAccess(e);</span><br><span class="line">            <span class="comment">//把旧值返回</span></span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//因为上面是覆盖，所以未发生结构性改变，但是如果是插入，那么久发生了结构改变，所以modCount加一</span></span><br><span class="line">    ++modCount;</span><br><span class="line">    <span class="comment">//如果table大小超过了阈值，那就进行扩容，扩容后面会详细讲解</span></span><br><span class="line">    <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">        resize();</span><br><span class="line">    <span class="comment">////回调方法，文章最后会说</span></span><br><span class="line">    afterNodeInsertion(evict);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结putVal方法，共有如下几个步骤：</p><ol><li>判断table数组是否初始化，如果没有就进行初始化</li><li>根据key的hash值计算得到的下标处，如果该下标处没有节点，那么就新建一个结点放入桶中</li><li>如果该下标处已经存在节点，那么就代表发生了碰撞，开始对链表/红黑树进行遍历</li><li>如果第一个结点的key就与传入的key相等，那么就把这个结点记录下来，在后面覆盖；</li><li>如果第一个key没有碰撞，而且桶中的结构是树，那么就调用相应的树的方法放置键值对， 如果第一个key没有碰撞，而且桶中的结构是链表，那么就遍历链表</li><li>当遍历到链表尾部，新建节点然后插入链表尾部，然后判断链表长度，是否需要转化为红黑树，如果在遍历链表中发生了key相等，那么就把这个结点记录下来，在后面覆盖；</li><li>如果发生了key相等的情况，就对结点旧值覆盖，然后把旧值返回</li><li>如果没有发生key相等的情况，而是插入了新的结点，那么modCount和size都加一，判断size是否超过阈值，超过就扩容</li><li>返回null</li></ol><h3 id="resize方法"><a href="#resize方法" class="headerlink" title="resize方法"></a>resize方法</h3><p>当像HashMap中不断地添加元素的时候，元素的数量就会增加，数量增大就不避免的增大了碰撞的概率。所以当元素的数量达到一个阈值的时候，就对HashMap进行扩容。当然数组是无法自动扩容的，扩容方法使用一个新的数组代替已有的容量小的数组。<br>resize方法非常巧妙，因为每次扩容都是翻倍，保证了数组大小为2得整数次方，同时与原来计算（n-1）&amp;hash的结果相比，节点要么就在原来的位置，要么就被分配到“原位置+旧容量”这个位置。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    *  对table进行初始化或者大小翻倍的扩容。  </span></span><br><span class="line"><span class="comment">    * 如果为空，则按照字段阈值中包含的初始容量目标分配。</span></span><br><span class="line"><span class="comment">    * 否则，因为我们使用的是2的幂展开，所以每个bin中的元素必须保持相同的索引，或者在新表中以2的幂偏移量移动。</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> 新的table数组</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">       Node&lt;K,V&gt;[] oldTab = table;</span><br><span class="line">       <span class="comment">//记录旧的容量大小和旧的阈值</span></span><br><span class="line">       <span class="keyword">int</span> oldCap = (oldTab == <span class="keyword">null</span>) ? <span class="number">0</span> : oldTab.length;</span><br><span class="line">       <span class="keyword">int</span> oldThr = threshold;</span><br><span class="line">       <span class="comment">//定义新的容量和阈值</span></span><br><span class="line">       <span class="keyword">int</span> newCap, newThr = <span class="number">0</span>;</span><br><span class="line">     <span class="comment">//如果旧的容量 &gt; 0</span></span><br><span class="line">       <span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123;</span><br><span class="line">       <span class="comment">//如果旧的容量 &gt; 最大容量，那么就把阈值变为最大值</span></span><br><span class="line">           <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class="line">               threshold = Integer.MAX_VALUE;</span><br><span class="line">               <span class="keyword">return</span> oldTab;</span><br><span class="line">           &#125;<span class="comment">//如果旧容量的二倍小于规定的最大容量，并且旧的容量大于默认容量</span></span><br><span class="line">           <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">                    oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">           <span class="comment">//则对数组的容量和阈值进行翻倍扩容，新的容量和阈值是旧值的二倍</span></span><br><span class="line">               newThr = oldThr &lt;&lt; <span class="number">1</span>; <span class="comment">// double threshold</span></span><br><span class="line">       &#125;<span class="comment">//如果旧容量 = 0，而且旧临界值 &gt; 0，那么就把容量设置为旧的阈值</span></span><br><span class="line">       <span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>) <span class="comment">// 初始容量设置为阈值</span></span><br><span class="line">           newCap = oldThr;</span><br><span class="line">       <span class="keyword">else</span> &#123; <span class="comment">// 如果旧容量 = 0，且旧阈值 = 0，表示使用默认值，容量为16，阈值为容量*加载因子</span></span><br><span class="line">           newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">           newThr = (<span class="keyword">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//在当上面的条件判断中，只有oldThr &gt; 0成立时，newThr == 0</span></span><br><span class="line">       <span class="keyword">if</span> (newThr == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//ft为临时阈值，使用上面得到的新的容量和默认的加载因子计算得到</span></span><br><span class="line">           <span class="keyword">float</span> ft = (<span class="keyword">float</span>)newCap * loadFactor;</span><br><span class="line">           <span class="comment">//这个阈值是否合法，如果合法，那就是真正的临界值，如果超出了最大容量，那么就是最大容量</span></span><br><span class="line">           newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="keyword">float</span>)MAXIMUM_CAPACITY ?</span><br><span class="line">                     (<span class="keyword">int</span>)ft : Integer.MAX_VALUE);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//把阈值变为新阈值</span></span><br><span class="line">       threshold = newThr;</span><br><span class="line">       <span class="meta">@SuppressWarnings</span>(&#123;<span class="string">"rawtypes"</span>,<span class="string">"unchecked"</span>&#125;)</span><br><span class="line">       <span class="comment">//创建一个新的数组，大小为新的容量，并且后面把旧的table中的数据全部转移到新的table中</span></span><br><span class="line">       Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node[newCap];</span><br><span class="line">       <span class="comment">//把系统的table变为新的table</span></span><br><span class="line">       table = newTab;</span><br><span class="line">       <span class="comment">//如果旧table不为空，将旧table中的元素复制到新的table中</span></span><br><span class="line">       <span class="keyword">if</span> (oldTab != <span class="keyword">null</span>) &#123;</span><br><span class="line">       <span class="comment">//遍历旧的table的每个桶</span></span><br><span class="line">           <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; oldCap; ++j) &#123;</span><br><span class="line">               Node&lt;K,V&gt; e;</span><br><span class="line">               <span class="comment">//如果该桶中含有元素，那么久开始复制，先使用e复制下来</span></span><br><span class="line">               <span class="keyword">if</span> ((e = oldTab[j]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">               <span class="comment">//然后把旧的桶赋为null，便于GC回收</span></span><br><span class="line">                   oldTab[j] = <span class="keyword">null</span>;</span><br><span class="line">                   <span class="comment">//如果这个桶中只有一个结点，那么计算新的坐标后放入</span></span><br><span class="line">                   <span class="keyword">if</span> (e.next == <span class="keyword">null</span>)</span><br><span class="line">                       newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e;</span><br><span class="line">                   <span class="comment">//如果这个桶中的数据结构为红黑树，那么就使用红黑树的方法将其拆分后复制</span></span><br><span class="line">                   <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                       ((TreeNode&lt;K,V&gt;)e).split(<span class="keyword">this</span>, newTab, j, oldCap);</span><br><span class="line">                   <span class="keyword">else</span> &#123; <span class="comment">// 使用两个头尾对象保持顺序，是由于链表中的元素的下标在扩容后,要么是原下标+oldCap,要么不变,下面会证实</span></span><br><span class="line">                       Node&lt;K,V&gt; loHead = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;</span><br><span class="line">                       Node&lt;K,V&gt; hiHead = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;</span><br><span class="line">                       Node&lt;K,V&gt; next;</span><br><span class="line">                       <span class="keyword">do</span> &#123;<span class="comment">//遍历链表，分别把要存放新坐标的结点和要存放旧坐标的结点放到两根链表中</span></span><br><span class="line">                           next = e.next;</span><br><span class="line">                           <span class="comment">//如果计算得到0，那么下标没有改变，使用旧的头尾对象保存</span></span><br><span class="line">                           <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;</span><br><span class="line">                           <span class="comment">//如果链表中没有结点，就把该节点设置为头节点</span></span><br><span class="line">                               <span class="keyword">if</span> (loTail == <span class="keyword">null</span>)</span><br><span class="line">                                   loHead = e;</span><br><span class="line">                               <span class="keyword">else</span></span><br><span class="line">                                   loTail.next = e;</span><br><span class="line">                               loTail = e;</span><br><span class="line">                           &#125;</span><br><span class="line">                           <span class="keyword">else</span> &#123;<span class="comment">//否则下标改变，使用新的头尾对象保存</span></span><br><span class="line">                           <span class="comment">//如果链表中没有结点，就把该节点设置为头节点</span></span><br><span class="line">                               <span class="keyword">if</span> (hiTail == <span class="keyword">null</span>)</span><br><span class="line">                                   hiHead = e;</span><br><span class="line">                               <span class="keyword">else</span></span><br><span class="line">                                   hiTail.next = e;</span><br><span class="line">                               hiTail = e;</span><br><span class="line">                           &#125;</span><br><span class="line">                       &#125; <span class="keyword">while</span> ((e = next) != <span class="keyword">null</span>);</span><br><span class="line">                       <span class="comment">// 原下标对应的链表</span></span><br><span class="line">                       <span class="keyword">if</span> (loTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                       <span class="comment">// 尾部节点next设置为null，代码严谨</span></span><br><span class="line">                           loTail.next = <span class="keyword">null</span>;</span><br><span class="line">                           <span class="comment">//下标没有改变</span></span><br><span class="line">                           newTab[j] = loHead;</span><br><span class="line">                       &#125;</span><br><span class="line">                       <span class="comment">// 新下标对应的链表</span></span><br><span class="line">                       <span class="keyword">if</span> (hiTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                           hiTail.next = <span class="keyword">null</span>;</span><br><span class="line">                         <span class="comment">//新下标为就 旧的下标+新的容量</span></span><br><span class="line">                           newTab[j + oldCap] = hiHead;</span><br><span class="line">                       &#125;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> newTab;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>resize方法总结：<br>总体可以两大部分：</p><ol><li>首先是计算新桶数组的容量 newCap 和新阈值 newThr</li><li>将原集合的元素重新映射到新集合中<br>细节的过程如下：<br><img src="/posts/42557/resize.png" alt></li></ol><h3 id="remove方法"><a href="#remove方法" class="headerlink" title="remove方法"></a>remove方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 如果存在，则从此映射中删除指定键的映射，并且返回与该键相关联的值。</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span>  key 要从映射中删除其映射的键</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> 与key关联的值，如果没有key的映射，则为null。</span></span><br><span class="line"><span class="comment">    * (null返回值还可以代表将null与key关联的映射。)</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> V <span class="title">remove</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">       Node&lt;K,V&gt; e;</span><br><span class="line"><span class="comment">//removeNode方法就在下面</span></span><br><span class="line">       <span class="keyword">return</span> (e = removeNode(hash(key), key, <span class="keyword">null</span>, <span class="keyword">false</span>, <span class="keyword">true</span>)) == <span class="keyword">null</span> ?</span><br><span class="line">           <span class="keyword">null</span> : e.value;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h3 id="removeNode方法"><a href="#removeNode方法" class="headerlink" title="removeNode方法"></a>removeNode方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 实现了 Map接口的remove方法 和其他相关方法</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> hash key（键）的hash值</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> key 键</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> value 如果matchValue为true，则value也作为确定被删除的node的条件之一，否则忽略</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> matchValue 如果为true，则仅在键值都相等时删除</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> movable 如果为false，删除时不会移动其他节点</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> Node节点，如果没有，则为空</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title">removeNode</span><span class="params">(<span class="keyword">int</span> hash, Object key, Object value,</span></span></span><br><span class="line"><span class="function"><span class="params">                              <span class="keyword">boolean</span> matchValue, <span class="keyword">boolean</span> movable)</span> </span>&#123;</span><br><span class="line">       Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, index;</span><br><span class="line">       <span class="comment">//如果table数组不为空，且数组内有元素，且根据hash值计算得到的下标处的桶里有元素，才寻找，否则直接返回null</span></span><br><span class="line">       <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">           (p = tab[index = (n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">           Node&lt;K,V&gt; node = <span class="keyword">null</span>, e; K k; V v;</span><br><span class="line">         <span class="comment">//如果桶上第一个node的就是要删除的node，那么就把他先记录下来，在下面删除</span></span><br><span class="line">           <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">               ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">               node = p;</span><br><span class="line">           <span class="comment">//如果第一个结点不是，并且还有后续结点，那么就在后续节点中还寻找</span></span><br><span class="line">           <span class="keyword">else</span> <span class="keyword">if</span> ((e = p.next) != <span class="keyword">null</span>) &#123;</span><br><span class="line">           <span class="comment">//如果是红黑树，就是用红黑树的方法寻找这个结点，也记录下来</span></span><br><span class="line">               <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                   node = ((TreeNode&lt;K,V&gt;)p).getTreeNode(hash, key);</span><br><span class="line">               <span class="keyword">else</span> &#123;<span class="comment">//如果是链表，就从链表的第二个个节点开始遍历寻找</span></span><br><span class="line">                   <span class="keyword">do</span> &#123;<span class="comment">//如果找到，就把这个这个结点记录下来，在下面删除</span></span><br><span class="line">                       <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                           ((k = e.key) == key ||</span><br><span class="line">                            (key != <span class="keyword">null</span> &amp;&amp; key.equals(k)))) &#123;</span><br><span class="line">                           node = e;</span><br><span class="line">                           <span class="keyword">break</span>;</span><br><span class="line">                       &#125;</span><br><span class="line">                       p = e;</span><br><span class="line">                   &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">//如果得到的node不为null且(matchValue为false||node.value和参数value匹配)</span></span><br><span class="line">           <span class="keyword">if</span> (node != <span class="keyword">null</span> &amp;&amp; (!matchValue || (v = node.value) == value ||</span><br><span class="line">                                (value != <span class="keyword">null</span> &amp;&amp; value.equals(v)))) &#123;</span><br><span class="line">           <span class="comment">//如果是红黑树，就使用红黑树的方法删除</span></span><br><span class="line">               <span class="keyword">if</span> (node <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                   ((TreeNode&lt;K,V&gt;)node).removeTreeNode(<span class="keyword">this</span>, tab, movable);</span><br><span class="line">               <span class="keyword">else</span> <span class="keyword">if</span> (node == p)<span class="comment">//如果第一个结点就是要删除的目标，则使用第二个结点代替第一个结点</span></span><br><span class="line">                   tab[index] = node.next;</span><br><span class="line">               <span class="keyword">else</span><span class="comment">//如果要删除的目标结点在链表中，则使用下一个结点代替该结点</span></span><br><span class="line">                   p.next = node.next;</span><br><span class="line">               <span class="comment">//结构修改记录加一，元素个数减一</span></span><br><span class="line">               ++modCount;</span><br><span class="line">               --size;</span><br><span class="line">               <span class="comment">//回调函数，最后会讲</span></span><br><span class="line">               afterNodeRemoval(node);</span><br><span class="line">               <span class="comment">//把删除的结点返回</span></span><br><span class="line">               <span class="keyword">return</span> node;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//如果数组table为空或key映射到的桶为空，返回null。</span></span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>总结removeNode方法为：</p><ol><li>如果数组table为空或key映射到的桶为空，直接返回null。</li><li>如果key映射到的桶上第一个Node的就是要删除的Node，记录下来。</li><li>如果桶内不止一个Node，且桶内的结构为红黑树，记录key映射到的Node。</li><li>桶内的结构不为红黑树，那么桶内的结构就肯定为链表，遍历链表，找到key映射到的Node，记录下来。</li><li>如果被记录下来的Node不为null，则使用数据结构相对应的删除方法删除Node，++modCount;–size;</li><li>返回被删除的node。</li></ol><h3 id="clear方法"><a href="#clear方法" class="headerlink" title="clear方法"></a>clear方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 删除HashMap中的所有映射。</span></span><br><span class="line"><span class="comment"> * 这个调用返回后HashMap将为空。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab;</span><br><span class="line">    <span class="comment">//结构修改次数+1</span></span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="comment">//如果table不为空且其中有元素，就进行清空</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; size &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">//元素数量设置为零</span></span><br><span class="line">        size = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//遍历table数组每一个桶，将桶置为null，剩下的交给让GC自动回收</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tab.length; ++i)</span><br><span class="line">            tab[i] = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="containsValue方法"><a href="#containsValue方法" class="headerlink" title="containsValue方法"></a>containsValue方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 如果此HashMap中将一个或多个键映射到指定的值，则返回true。</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> value 值，其在此映射中的存在性将被测试</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 如果此映射将一个或多个键映射到指定值，则返回true，否则返回false。</span></span><br><span class="line"><span class="comment"> *         </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">containsValue</span><span class="params">(Object value)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; V v;</span><br><span class="line">    <span class="comment">//如果table不为空且其中有元素，就进行寻找，否则直接返回false</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; size &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">//遍历table数组中每个小标出处的桶寻找</span></span><br><span class="line">        <span class="keyword">for</span> (Node&lt;K,V&gt; e : tab) &#123;</span><br><span class="line">        <span class="comment">//遍历桶中的Node结点链</span></span><br><span class="line">            <span class="keyword">for</span> (; e != <span class="keyword">null</span>; e = e.next) &#123;</span><br><span class="line">            <span class="comment">//如果有值匹配，就返回true</span></span><br><span class="line">                <span class="keyword">if</span> ((v = e.value) == value ||</span><br><span class="line">                    (value != <span class="keyword">null</span> &amp;&amp; value.equals(v)))</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="一些其他方法"><a href="#一些其他方法" class="headerlink" title="一些其他方法"></a>一些其他方法</h2><h3 id="keySet方法"><a href="#keySet方法" class="headerlink" title="keySet方法"></a>keySet方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 返回此映射中所包含的键的 Set 视图。</span></span><br><span class="line"><span class="comment"> * 该 set 受映射的支持，所以对映射的更改将反映在该 set 中，反之亦然。</span></span><br><span class="line"><span class="comment"> * 如果在对 set 进行迭代的同时修改了映射（通过迭代器自己的 remove 操作除外），则迭代结果是不确定的。</span></span><br><span class="line"><span class="comment"> * 该 set 支持元素的移除，通过 Iterator.remove、 Set.remove、 removeAll、 retainAll 和 clear 操作可从该映射中移除相应的映射关系。</span></span><br><span class="line"><span class="comment"> * 它不支持 add 或 addAll 操作。</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> 此映射中包含的键的 set 视图</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> Set&lt;K&gt; <span class="title">keySet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       Set&lt;K&gt; ks = keySet;</span><br><span class="line">       <span class="keyword">if</span> (ks == <span class="keyword">null</span>) &#123;</span><br><span class="line">           ks = <span class="keyword">new</span> KeySet();</span><br><span class="line">           keySet = ks;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> ks;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h3 id="values方法"><a href="#values方法" class="headerlink" title="values方法"></a>values方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 返回此映射所包含的值的 Collection 视图。</span></span><br><span class="line"><span class="comment"> * 该 collection 受映射的支持，所以对映射的更改将反映在该 collection 中，反之亦然。</span></span><br><span class="line"><span class="comment"> * 如果在对 collection 进行迭代的同时修改了映射（通过迭代器自己的 remove 操作除外），则迭代结果是不确定的。</span></span><br><span class="line"><span class="comment"> * 该 collection 支持元素的移除，</span></span><br><span class="line"><span class="comment"> * 通过 Iterator.remove、 Collection.remove、 removeAll、 retainAll 和 clear 操作可从该映射中移除相应的映射关系。</span></span><br><span class="line"><span class="comment"> * 它不支持 add 或 addAll 操作。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> a view of the values contained in this map</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Collection&lt;V&gt; <span class="title">values</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Collection&lt;V&gt; vs = values;</span><br><span class="line">    <span class="keyword">if</span> (vs == <span class="keyword">null</span>) &#123;</span><br><span class="line">        vs = <span class="keyword">new</span> Values();</span><br><span class="line">        values = vs;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> vs;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="entrySet方法"><a href="#entrySet方法" class="headerlink" title="entrySet方法"></a>entrySet方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 返回此映射所包含的映射关系的 Set 视图。 </span></span><br><span class="line"><span class="comment"> * 该 set 受映射支持，所以对映射的更改将反映在此 set 中，反之亦然。</span></span><br><span class="line"><span class="comment"> * 如果在对 set 进行迭代的同时修改了映射（通过迭代器自己的 remove 操作，或者通过在该迭代器返回的映射项上执行 setValue 操作除外），则迭代结果是不确定的。</span></span><br><span class="line"><span class="comment"> * 该 set 支持元素的移除，通过 Iterator.remove、 Set.remove、 removeAll、 retainAll 和 clear 操作可从该映射中移除相应的映射关系。</span></span><br><span class="line"><span class="comment"> * 它不支持 add 或 addAll 操作。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> a set view of the mappings contained in this map</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet() &#123;</span><br><span class="line">    Set&lt;Map.Entry&lt;K,V&gt;&gt; es;</span><br><span class="line">    <span class="keyword">return</span> (es = entrySet) == <span class="keyword">null</span> ? (entrySet = <span class="keyword">new</span> EntrySet()) : es;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="clone方法"><a href="#clone方法" class="headerlink" title="clone方法"></a>clone方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 返回此HashMap实例的浅拷贝:键和值本身没有克隆。</span></span><br><span class="line"><span class="comment"> * 浅拷贝与深拷贝的区别：</span></span><br><span class="line"><span class="comment"> * 简单的来说就是，在有指针的情况下，浅拷贝只是增加了一个指针指向已经存在的内存</span></span><br><span class="line"><span class="comment"> * 而深拷贝就是增加一个指针并且申请一个新的内存，使这个增加的指针指向这个新的内存</span></span><br><span class="line"><span class="comment"> * 采用深拷贝的情况下，释放内存的时候就不会出现在浅拷贝时重复释放同一内存的错误！</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> a shallow copy of this map</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">clone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    HashMap&lt;K,V&gt; result;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        result = (HashMap&lt;K,V&gt;)<span class="keyword">super</span>.clone();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (CloneNotSupportedException e) &#123;</span><br><span class="line">        <span class="comment">// this shouldn't happen, since we are Cloneable</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InternalError(e);</span><br><span class="line">    &#125;</span><br><span class="line">    result.reinitialize();</span><br><span class="line">    result.putMapEntries(<span class="keyword">this</span>, <span class="keyword">false</span>);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="回调方法"><a href="#回调方法" class="headerlink" title="回调方法"></a>回调方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 允许LinkedHashMap后操作的回调</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">afterNodeAccess</span><span class="params">(Node&lt;K,V&gt; p)</span> </span>&#123; &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">afterNodeInsertion</span><span class="params">(<span class="keyword">boolean</span> evict)</span> </span>&#123; &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">afterNodeRemoval</span><span class="params">(Node&lt;K,V&gt; p)</span> </span>&#123; &#125;</span><br></pre></td></tr></table></figure><p>这三个回调方法在之前方法中出现过，它们的作用就是在给LinkedHashMap时继承使用，在HashMap中没有实质的作用，所以方法体为空。LinkedHashMap 是 HashMap 的一个子类，它保留插入的顺序，如果需要输出的顺序和输入时的相同，那么就选用 LinkedHashMap。</p><h2 id="个人总结"><a href="#个人总结" class="headerlink" title="个人总结"></a>个人总结</h2><ol><li>可以看出HashMap在扩容时的操作是很花费时间的，所以尽量在创建HashMap的时候就把容量指定，避免扩容操作，增大运行时间。</li><li>不知道有没有人想过，为什么在很多方法中，都是新建局部变量，然后把相应的数据赋给局部变量，而不是直接使用全局变量呢？例如下面这样：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; <span class="keyword">int</span> n; K k;</span><br><span class="line">tab = table;</span><br><span class="line">n = tab.length;</span><br><span class="line">first = tab[(n - <span class="number">1</span>) &amp; hash];</span><br><span class="line">k = first.key;</span><br></pre></td></tr></table></figure></li></ol><p>个人猜测这样做的原因是：<br>新定义的变量在栈顶，出栈快，局部变量，用完就销毁，提高速度，也不额外占用内存。<br>当然还有一种可能是因为HashMap不是线程安全的，所以可能因为使用全局变量的话会导致数据差异的原因，所以在每个方法里面，把这个方法开始的时候的数据保存下来，只对当前保存下来的数据进行运算，不影响其他线程和方法对数据的使用，同时也体现了高明的严谨性。</p><p>当然这只是个人猜测的结果，具体的原因也没有查到，所以这里就算是一个遗留的小问题吧。</p>]]></content>
    
    <summary type="html">
    
      花了两天时间，对HashMap 1.8的一千多行的源码认真的研究了一下，不禁感叹源码的严谨性，在我平常看来有很多判断都是没有必要的，但是仔细想想为什么这样写，其实严谨的不无道理。 因为源码一共有两千多行，但是真正关键的部分大概是1400行之前，所以就详细的对这些部分做一个解释。
    
    </summary>
    
      <category term="Java容器" scheme="http://yoursite.com/categories/Java%E5%AE%B9%E5%99%A8/"/>
    
    
      <category term="容器" scheme="http://yoursite.com/tags/%E5%AE%B9%E5%99%A8/"/>
    
      <category term="源码" scheme="http://yoursite.com/tags/%E6%BA%90%E7%A0%81/"/>
    
  </entry>
  
</feed>
