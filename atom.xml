<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Potato Blog</title>
  
  <subtitle>李土豆的Blog</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2020-02-10T17:00:09.729Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Potato</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>InnoDB存储引擎下MySQL中的文件</title>
    <link href="http://yoursite.com/posts/13147/"/>
    <id>http://yoursite.com/posts/13147/</id>
    <published>2020-02-05T14:05:02.000Z</published>
    <updated>2020-02-10T17:00:09.729Z</updated>
    
    <content type="html"><![CDATA[<p>本文将分析构成MySQL数据库和InnoDB存储引擎表的各种类型文件，这写文件包括以下类型：</p><ul><li><strong>参数文件</strong>：告诉MySQL实例启动时在哪里可以找到数据库文件，并且指定某些初始化参数，这些参数定义了某种内存结构的大小等设置，还会介绍各种参数的类型。</li><li><strong>日志文件</strong>：用来记录MySQL实例对某种条件做出响应时写入的文件，如错误日志、二进制日志文件、慢查询日志文件和查询日志文件等。</li><li><strong>socket文件</strong>：当用UNIX域套接字方式进行连接时需要的文件。</li><li><strong>pid文件</strong>：MySQL实力的进程ID文件。</li><li><strong>MySQL表结构文件</strong>：用来存放MySQL表结构定义文件。</li><li><strong>存储引擎文件</strong>：因为MySQL表存储引擎的关系，<strong>每个存储引擎都会有自己的文件来保存各种数据。这些存储引擎正在存储了记录和索引等数据，</strong>这里主要介绍与InnoDB有关的存储引擎文件。</li></ul><h1 id="参数文件"><a href="#参数文件" class="headerlink" title="参数文件"></a>参数文件</h1><p><strong>当MySQL实例启动时，数据库会先去读一个配置参数文件，用来寻找数据库的各种文件所在位置以及指定某些初始化参数，这些参数通常定义了某些内存结构有多大等。在默认情况下，MySQL实例会按照一定的顺序在指定的位置进行读取，</strong>用户可以通过命令<code>mysql--help|grep my.cnf</code>来寻找。</p><p><strong>MySQL实例可以不需要参数文件，这时所有的参数值取决于编译MySQL时指定的默认值和源代码中指定参数的默认值。但是如果MySQL实例在默认的数据库目录下找不到mysql架构，则启动会失败，</strong>此时可能在错误日志文件中找到如下内容：<img src="/posts/13147/TIM%E5%9B%BE%E7%89%8720200205234429.png" alt></p><p>MySQL数据库的参数文件是以文本方式进行存储的，用户可以直接通过一些常用的文本编辑软件进行参数的修改。</p><h2 id="什么是参数"><a href="#什么是参数" class="headerlink" title="什么是参数"></a>什么是参数</h2><p>##<br>简单的说，数据库参数可以看成一个键-值（key-value）对，可以通过命令<code>SHOW VARIABLES</code>查看数据库中的所有参数（推荐），也可以通过LIKE来过滤参数名，还可以通过information_schema架构下的GLOBAL_VARIABLES视图来进行查找，例如：<img src="/posts/13147/TIM%E6%88%AA%E5%9B%BE20200205235751.png" alt></p><p>这里MySQL数据库有一点不同于Oracle数据库：MySQL数据库并没有所谓的隐藏参数。</p><h2 id="参数类型"><a href="#参数类型" class="headerlink" title="参数类型"></a>参数类型</h2><p>MySQL数据库中的参数可以分为两类：</p><ul><li><strong>动态（dynamic）参数</strong>：意味着可以在MySQL实例运行中进行更改。</li><li><strong>静态（static）参数</strong>：说明在整个实例生命周期内都不得进行更改，就好像时只读的（read only）。</li></ul><p>可以通过SET命令对动态参数进行修改，SET的语法如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span></span><br><span class="line">| [<span class="keyword">global</span> | <span class="keyword">session</span>] system_var_name = expr</span><br><span class="line">| [@@global. | @@session. | @@] system_var_name = expr</span><br></pre></td></tr></table></figure><p><strong>这里可以看到global和session关键字，它们表明该参数的修改是基于当前会话还是整个实例的生命周期。</strong>有些动态擦拭农户只能在会话中进行修改，如autocommit；而有些参数修改完后，在整个实例生命周期中都会生效，如binlog_cache_seiz；而有些参数既可以在会话中又可以在整个实例的生命周期内生效，如read_buffer_size。</p><p><strong>需要注意的是，对变量的全局值进行了修改，在这次的实例生命周期内都有效，但是MySQL实例本身并不会对参数文件中的该值进行修改。也就是说，在下次启动时，MySQL实例还是会读取参数文件。若想在数据库实例下一次启动时该参数还是保留为当前修改的值，那么用户必须去修改参数文件。</strong></p><h1 id="日志文件"><a href="#日志文件" class="headerlink" title="日志文件"></a>日志文件</h1><p><strong>日志文件记录了影响MySQL数据库的各种类型活动</strong>，MySQL数据库中常见的日志文件有：</p><ul><li>错误日志（error log）</li><li>二进制日志（binlog）</li><li>慢查询日志（slow query log）</li><li>查询日志（log）</li></ul><h2 id="错误日志"><a href="#错误日志" class="headerlink" title="错误日志"></a>错误日志</h2><p><strong>错误日志文件对MySQL的启动、运行和关闭过程进行了记录。</strong>MySQL DBA在遇到问题时应该首先查看该文件以便定位问题。该文件不仅记录了所有的错误信息，<strong>也记录一些警告信息或正确信息。</strong>用户可以通过命令<code>SHOW VARIABLES LIKE &#39;log_error</code>来定位该文件，可以看到错误文件的路径和文件名，在默认情况下错误文件的文件名为：服务器的主机名.err 。</p><h2 id="慢查询日志"><a href="#慢查询日志" class="headerlink" title="慢查询日志"></a>慢查询日志</h2><p><strong>慢查询日志可帮助DBA定位可能存在问题的SQL语句，从而进行SQL语句层面的优化。</strong></p><p>例如可以在MySQL启动时设一个阈值，将运行时间超过该值的所有SQL语句都记录到慢查询日志文件中，<strong>该阈值可以通过参数<code>long_query_time</code>来设置，默认值为10，代表10秒。</strong></p><p><strong>在默认情况下，MySQL数据库并不启动慢查询日志，用户需要手动将<code>log_slow_queries</code>这个参数设为ON。</strong></p><p>需要注意有两点。</p><ul><li><strong>设置<code>long_query_time</code>这个阈值后，MySQL数据库会记录运行时间超过该值的所有SQL语句，但运行时间正好等于<code>long_query_time</code>的情况并不会被记录下来。</strong></li><li><strong>从MySQL 5.1 开始，<code>long_query_time</code>开始以微秒记录SQL语句运行的时间，这样可以更精确的记录SQL的运行时间。</strong></li></ul><p><strong>另一个和慢查询有关的参数是<code>log_queries_not_using_indexes</code>，如果运行的SQL语句没有使用索引，则MySQL数据库同样会将这条SQL语句记录到慢查询日志文件。</strong></p><p>MySQL 5.6.5 版本开始新增了一个参数<code>log_throttle_queries_not_using_indexes</code>，用来表示每分钟允许记录到slow log的且未使用索引的SQL语句次数。该值默认为0，表示没有限制。在生产环境下，若没有使用索引，此类SQL语句会频繁地被记录到slow log，从而导致slow log文件的大小不断增加，故DBA可通过此参数进行配置。</p><p>随着MySQL数据库服务器运行时间的增加，可能会有越来越多的SQL查询被记录到slow log，此时要分析该文件就显得不是那么简单和直观了，这时MySQL数据库提供的<strong><code>mysqldumpslow</code></strong>命令，可以很好的帮助DBA解决该问题。例如希望得到执行时间最长的10条语句，可以运行如下命令：<img src="/posts/13147/TIM%E6%88%AA%E5%9B%BE20200208013654.png" alt></p><p>MySQL 5.1开始可以将慢查询的日志记录放入一张表中，这使得用户的查询更加方便和直观。慢查询表在mysql架构下，名为slow_log，其表结构定义如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SHOW CREATE TABLE mysql.slow_log\G</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">       Table: slow_log</span><br><span class="line"><span class="keyword">Create</span> <span class="keyword">Table</span>: <span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`slow_log`</span> (</span><br><span class="line">  <span class="string">`start_time`</span> <span class="built_in">timestamp</span>(<span class="number">6</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="keyword">CURRENT_TIMESTAMP</span>(<span class="number">6</span>) <span class="keyword">ON</span> <span class="keyword">UPDATE</span> <span class="keyword">CURRENT_TIMESTAMP</span>(<span class="number">6</span>),</span><br><span class="line">  <span class="string">`user_host`</span> mediumtext <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`query_time`</span> <span class="built_in">time</span>(<span class="number">6</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`lock_time`</span> <span class="built_in">time</span>(<span class="number">6</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`rows_sent`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`rows_examined`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`db`</span> <span class="built_in">varchar</span>(<span class="number">512</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`last_insert_id`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`insert_id`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`server_id`</span> <span class="built_in">int</span>(<span class="number">10</span>) <span class="keyword">unsigned</span> <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`sql_text`</span> mediumblob <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`thread_id`</span> <span class="built_in">bigint</span>(<span class="number">21</span>) <span class="keyword">unsigned</span> <span class="keyword">NOT</span> <span class="literal">NULL</span></span><br><span class="line">) <span class="keyword">ENGINE</span>=CSV <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8 <span class="keyword">COMMENT</span>=<span class="string">'Slow log'</span></span><br><span class="line"><span class="number">1</span> <span class="keyword">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure><p><strong>参数log_output制定了慢查询输出的格式，默认为FILE，可以将它设置为TABLE,然后就可以查询mysql架构下的slow_log表了。</strong>参数log_output是动态的，并且是全局的，因此用户可以在线进行修改。</p><p>查看slow_log表的定义会发现该表使用的是CSV引擎，对大数据量下的查询效率可能不高。用户可以先关闭慢查询日志，然后把slow_log表的引擎转换到MyISAM，并在start_time列上添加索引以进一步提高查询的效率，再开启慢查询日志参数即可。</p><p>MySQL的slow log通过运行时间来对SQL语句进行捕获，这是一个非常有用的优化技巧，但是当数据库的容量较小时，可能因为数据库刚建立，此时非常大的可能是数据全部被缓存在缓冲池中，SQL语句运行的时间可能是非常短的。</p><p>InnoDB版本加强了对于SQL语句的捕获方式，在原版MySQL的基础上再slow log中增加了对于<strong>逻辑读取（logical reads）和物理读取（physical reads）</strong>的统计。<strong>这里的物理读取是指从磁盘机性IO读取的次数。逻辑读取包括所有的读取，不管是磁盘还是缓冲池。</strong></p><p>用户可以通过额外的参数long_query_io将超过指定逻辑IO次数的SQL语句记录到slow log中，该值默认为100，即表示对于逻辑读取次数大于100的SQL语句，记录到slow log 中。而为了兼容原MySQL数据库的运行方式，还添加了参数slow_query_type，用来表示启用slow log的方式，可选值为：</p><ul><li>0 表示不将SQL语句记录到slow log</li><li>1 表示根据运行时间将SQL语句记录到slow log</li><li>2 表示根据逻辑IO次数将SQL语句记录到slow log</li><li>3 表示根据运行时间及逻辑IO次数将SQL语句记录到slow log</li></ul><h2 id="查询日志"><a href="#查询日志" class="headerlink" title="查询日志"></a>查询日志</h2><p><strong>查询日志记录了所有对MySQL数据请求的信息，无论这些请求是否得到了正确的执行。默认文件名为：主机名.log。</strong>如查看一个查询日志：<img src="/posts/13147/TIM%E6%88%AA%E5%9B%BE20200209234714.png" alt></p><p>通过上面的查询日志会发现，查询日志甚至记录了Acess denied的请求，即对于未能正确执行的SQL语句，查询日志也会进行记录。同样地，从MySQL 5.1 开始可以将查询日志的记录放入mysql架构下的general_log表中。</p><h2 id="二进制日志"><a href="#二进制日志" class="headerlink" title="二进制日志"></a>二进制日志</h2><p><strong>二进制日志（binary log）记录了对MySQL数据库执行更改的所有操作，但是不包括SELECT和SHOW这类操作，因为这类操作对数据本身并没有修改。然而若操作本身并没有导致数据库数据发生变化，那么该操作可能也会写入二进制日志。</strong></p><p>如果用户像记录SELECT和SHOW操作，那只能使用查询日志，而不是二进制日志。此外，二进制还包括了执行数据库更改操作的时间等其它额外信息。总的来说，二进制日志主要有以下几种作用：</p><ul><li><strong>恢复（recovery）</strong>：某些数据的恢复需要二进制日志。</li><li><strong>复制（replication）</strong>：其原理与恢复类似，通过复制和执行二进制日志使一台远程的MySQL数据库（一般称为slave或standby）与一台MySQL数据库（一般为master或primary）进行实时同步。</li><li><strong>审计（audit）</strong>：用户可以通过二进制日志中的信息来审计，判断是否有对数据库进行注入的攻击。</li></ul><p><strong>通过配置参数<code>log-bin [= name]</code>可以启动二进制日志，如果不指定name，则默认二进制日志文件名为主机名，后缀名为二进制日志的序列号，所在路径为数据所在目录。</strong>例如：<img src="/posts/13147/TIM%E6%88%AA%E5%9B%BE20200210002645.png" alt><br>这里的bin_log.00001即为二进制日志文件，bin_log.index为二进制的索引文件，用来存储过往产生的二进制日志序号。</p><p>二进制日志文件在默认情况下并没有启动，需要手动指定参数来启动，一位内开启这个选型的确会影响性能，但是性能的损失十分有效，开启二进制日志会使性能下降1%，但考虑到可以使用复制和恢复功能时，这些性能损失绝对是可以且应该被接受的。</p><p>以下配置文件的参数影响着二进制日志记录的信息和行为：</p><ul><li><strong>max_binlog_size</strong>：指定了单个二进制日志文件的最大值，如果超过该值，则产生新的二进制日志文件，后缀名+1，并记录到.index文件，默认大小为1G。</li><li><strong>binlog_cache_size</strong>：当使用事务的表存储引擎（如InnoDB）时，所有未提交的二进制日志会被记录到一个缓存中去，等该事务提交时直接将缓存中的二进制日志写入二进制日志文件，而该缓存的大小即由binlog_cache_size决定，默认大小为32K。此外该参数是基于会话（session）的，也就是说当一个线程开始一个事务时，MySQL会自动分配一个大小为binlog_cache_size的缓存，因此该值的设置需要相当小心，不能设置过大；但是也不能过小，因为当一个事务的记录大于设定的binlog_cache_size时，MySQL会把缓冲中的日志写入一个临时文件中。</li><li><strong>sync_binlog</strong>：在默认情况下，二进制日志并不是每次在写的时候同步到磁盘，因此当数据所在操作系统发生宕机时，可能会有最后一部分数据没有写入二进制日志文件中，这会给恢复和复制带来问题。参数<strong>sync_binlog = [N]</strong> 表示每写缓冲多少次就同步到磁盘，如果将N设为1，表示采用同步写磁盘的方式来写二进制日志，这时写操作不使用操作系统的缓冲来写二进制日志。默认情况下该值为0，代表不开启该参数。但是即使将sync_binlog设为1，还是会有一种情况导致问题的发生：当使用InnoDB存储引擎时，在一个事务发出COMMIT动作之前，由于sync_binlog为1，因此会将二进制日志立即写入磁盘，如果这时已经写入了二进制日志，但是提交还没有发生，并且此时发生了宕机，那么在MySQL数据库下次启动时，由于COMMIT操作并没有发生，这个事务会被回滚掉，但是二进制日志已经记录了该事务信息，不能被回滚。<strong>这个问题可以通过将参数innodb_support_xa设为1来解决，虽然innodb_support_xa与XA事务有关，但它同时确保了二进制日志二号InnoDB引擎数据文件的同步。</strong></li><li><strong>binlog-do-db和binlog-ignore-db</strong>：这两个参数表示需要写入或忽略写入哪些库的日志，默认为空，表示需要同步所有库的日志到二进制日志。</li><li><strong>log-slave-update</strong>：如果当前数据库是复制中的slave角色，则它不会将从master取得并执行的二进制日志写入自己的二进制日志文件中去。如果需要写入，要设置该参数。<strong>如果需要搭建master=&gt;slave=&gt;slave架构的复制，则必须设置该参数。</strong></li><li><strong>binlog_format</strong>：该参数影响着记录二进制日志的格式，该值可设置的值有STATEMENT、ROW和MIXED：<ul><li><strong>STATEMENT</strong>：二进制日志文件记录的是日志的逻辑SQL语句。</li><li><strong>ROW</strong>：二进制日志记录的是表的行更改情况，如果设置为该值，可以将InnoDB的事务隔离基本设为READ COMMITED，以获得更好的并发性。</li><li><strong>MIXED</strong>：该值情况下MySQL默认采用STATEMENT格式进行二进制日志文件的记录，但是一些情况下会使用ROW格式，可能的情况有：<ul><li>表的存储引擎为NDB，这时对表的DML操作都会以ROW格式记录。</li><li>使用了UUID()、USER()、CURRENT_USER()、FOUND_ROWS()、ROW_COUNT（）等不确定函数。</li><li>使用了INSERT DELAY语句。</li><li>使用了用户定义函数。</li><li>使用了临时表。</li></ul></li></ul></li></ul><p>此外binlog_format参数还有对于存储引擎的限制：<img src="/posts/13147/TIM%E6%88%AA%E5%9B%BE20200210010121.png" alt></p><p>binlog_format是动态参数，因此可以在数据库运行环境下进行更改。</p><p><strong>在通常情况下，我们将参数binlog_format设置为ROW，这可以为数据库的恢复和复制带来更好的可靠性，但是不能忽略的一点是，这会带来二进制文件大小的增加，有些语句下ROW格式可能需要更大的容量，如同样UPDATE 100万条语句，STATEMENT情况下，需要200字节的空间；但是ROW情况下则需要大约13MB的空间，所以将参数binlog_format设置为ROW，会对磁盘空间要求有一定的增加，而由于是采用传输二进制日志方式实现的，所以复制的网络开销也有所增加。</strong></p><p>二进制日志文件的文件格式为二进制，要查看文件的内容，必须通过MySQL提供的工具mysqlbinlog，并且加上参数<code>-vv</code>可以显示出更详细的内容，如更新的类型。</p><h1 id="套接字文件"><a href="#套接字文件" class="headerlink" title="套接字文件"></a>套接字文件</h1><p><strong>在UNIX系统下本地连接MySQL可以采用UNIX域套接字方式，这种方式需要一个套接字文件。</strong>套接字文件可由参数socket控制，一般在/tmp目录下，名为mysql.sock。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show variables like 'socket'\G</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">Variable_name: socket</span><br><span class="line">        Value: MySQL</span><br><span class="line">1 row in <span class="keyword">set</span>, <span class="number">1</span> <span class="keyword">warning</span> (<span class="number">0.04</span> sec)</span><br></pre></td></tr></table></figure><h1 id="pid文件"><a href="#pid文件" class="headerlink" title="pid文件"></a>pid文件</h1><p><strong>当MySQL实例启动时，会将自己的进程ID写入一个文件中——该文件即为pid文件。</strong>该文件可由参数pid_file控制，默认位于数据库目录下，文件名为主机名.pid：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SHOw variables like 'pid_file'\G</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">Variable_name: pid_file</span><br><span class="line">        Value: C:\ProgramData\MySQL\MySQL Server 8.0\Data\LAPTOP-MNHTPI2P.pid</span><br><span class="line">1 row in <span class="keyword">set</span>, <span class="number">1</span> <span class="keyword">warning</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure><h1 id="表结构定义文件"><a href="#表结构定义文件" class="headerlink" title="表结构定义文件"></a>表结构定义文件</h1><p>因为MySQL插件式存储引擎的体系结构的关系，MySQL数据的存储是根据表进行的，每个表都会有与之对应的文件。<strong>但不论表采用何种存储引擎，MySQL都有一个以<code>.frm</code>为后缀名的文件，这个文件记录了该表的表结构定义。</strong></p><p>frm还用来存放视图的定义，如用户创建了一个v_a视图，那么对应地会产生一个v_a.frm文件，用来记录视图的定义，该文件是文本文件，可以直接使用cat命令查看。</p><h1 id="InnoDB存储引擎文件"><a href="#InnoDB存储引擎文件" class="headerlink" title="InnoDB存储引擎文件"></a>InnoDB存储引擎文件</h1><p>之前介绍的文件都是MySQL数据库本身的文件，和存储引擎无关，除了这些文件以外，每个表存储引擎还有其自己独有的文件，这些文件包括重做日志文件、表空间文件。</p><h2 id="表空间文件"><a href="#表空间文件" class="headerlink" title="表空间文件"></a>表空间文件</h2><p><strong>InnoDB采用将存储的数据按表空间（tablespace）进行存放的设计。在默认配置下会有一个初始大小为10MB，名为ibdata1的文件，该文件就是默认的表空间文件，用户可以通过参数innodb_data_file_path对其进行设置，</strong>格式如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">innodb_data_file_path = datafile_spec1[;datafile_spec2]...</span><br></pre></td></tr></table></figure><p>用户可以通过多个文件组成一个表空间，同时制定文件的属性，如：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">innodb_data_file_path = /db/ibdata1:2000M;/dr2/db/ibdata2:2000M:autoextend</span><br></pre></td></tr></table></figure><p>这里将/db/ibdata1和/db/ibdata2两个文件用来组成表空间，若这两个文件位于不同的磁盘上，磁盘的负载可能被平均，因此可以提高数据库的整体性能。同时两个文件的文件名后都跟了属性，表示文件ibdata1的大小为2000MB，文件ibdata2的大小为2000MB，如果用完这2000MB，该文件可以自动增长。</p><p><strong>设置innodb_data_file_path参数后，所有基于InnoDB存储引擎的表的数据都会记录到该共享空间中。若设置了参数innodb_file_per_table，则用户可以将每个基于InnoDB存储引擎的表产生一个独立空间。独立表空间的命名规则为：表名.ibd。通过这样的方式，用户不再将所有数据都存放于默认的表空间中。</strong></p><p><strong>需要注意的是，这些单独的表空间文件仅存储该表的数据、索引和插入缓冲BITMAP等信息，其余信息还是存放在 默认的表空间中。</strong>下图是InnoDB存储引擎对于文件的存储方式：<img src="/posts/13147/TIM%E6%88%AA%E5%9B%BE20200211001301.png" alt>                               </p><h2 id="重做日志文件"><a href="#重做日志文件" class="headerlink" title="重做日志文件"></a>重做日志文件</h2><p><strong>在默认情况下，在InnoDB存储引擎的数据目录下会有两个名为ib_logfile0和ib_logfile1的文件，称其为重做日志文件（redo log file），重做日志文件对于InnoDB存储引擎至关重要，因为他们记录了对于InnoDB存储引擎的事务日志。</strong></p><p>当实例或介质失败时，重做日志文件就能派上用场。例如数据库由于所在主机掉电导致实例失败，InnoDB存储引擎会使用重做日志恢复到掉电前的时刻，以此来保证数据的完整性。</p><p><strong>每个InnoDB存储引擎至少有1个重做日志文件组，每个文件组下至少有2个重做日志文件，</strong>如默认的ib_logfile0和ib_logfile1。<strong>为了得到更高的可靠性，用户可以设置多个的镜像日志组，将不同的文件组放在不同的磁盘上，以此提供重做日志的高可用性。</strong></p><p><strong>在日志组中每个重做日志文件的大小一致，并以循环写入的方式运行。</strong>InnoDB存储引擎先写重做日志文件1，当达到文件的最后时，会切换至重做日志文件2，再当重做日志文件2也被写满时，会再切换到重做日志1中，如图：<img src="/posts/13147/TIM%E6%88%AA%E5%9B%BE20200211002141.png" alt></p><p>下列参数影响着重做日志文件的属性：</p><ul><li><strong>innodb_log_file_size</strong>：指定每个重做日志文件的大小，在InnoDB 1.2.x 版本之前重做日志文件总的大小不得大于4GB，而1.2.x版本将该限制扩大为了512GB。</li><li><strong>innodb_log_files_in_group</strong>：指定了日志文件组中重做日志文件的数量，默认为2.</li><li><strong>innodb_mirrored_log_groups</strong>：指定了日志镜像文件组的数量，默认为1，表示只有一个日志文件租，没有镜像。</li><li><strong>innodb_log_group_home_dir</strong>：指定了日志文件组所在路径，默认为./，表示在MySQL数据库的数据目录下。</li></ul><p><strong>重做日志文件的大小设置对于InnoDB存储引擎的性能有着非常大的影响。一方面不能设置得太大，如果设置得很大，在恢复时可能需要很长的时间；另一方面又不能设置得太小，否则可能导致一个事务的日志需要多次切换重做日志文件，此外重做日志文件太小会导致频繁的发生async checkpoint，导致性能的抖动。</strong></p><p>既然同样是记录事务日志，和之前介绍的二进制日志有什么区别呢？</p><ol><li><strong>二进制日志会记录所有与MySQL数据库有关的日志记录，包括InnoDB、MyISAM、Heap等其他存储引擎的日志；而InnoDB存储引擎的重做日志只记录有关该存储引擎的事务日志。</strong></li><li><strong>记录的内容不同。</strong>无论用户将二进制日志文件记录的格式设为STATEMENT还是ROW，又或者是MIXED，<strong>其记录的都是关于一个事务的具体操作内容，即该日志是逻辑日志；而InnoDB的存储引擎的重做日志文件记录的是关于每个页（page）的更改的物理情况。</strong></li><li><strong>写入的时间不同。二进制日志文件仅在事务提交前进行提交，即只写入磁盘一次，不论这时该事务多大；而在该事务进行过程中，却有不断重做日志条目被写入到重做日志文件中。</strong></li></ol><p>在InnoDB存储引擎中，对于各种不同的操作有着不同的重做日志格式，虽然各种重做日志的类型不同，但是它们有着基本的格式：<img src="/posts/13147/TIM%E6%88%AA%E5%9B%BE20200211004008.png" alt></p><p>从上图可以看到重做日志条目是由4部分组成：</p><ul><li><strong>redo_log_type</strong>：占用1字节，表示重做日志的类型。</li><li><strong>space</strong>：表示表空间的ID，但采用压缩的方式，因此占用的空间可能小于4字节。</li><li><strong>page_no</strong>:：表示页的偏移量，同样采用压缩的方式。</li><li><strong>redo_log_body</strong>：表示每个重做日志的数据部分，恢复时需要调用相应的函数进行解析。</li></ul><p>前一篇博客提过，<strong>写入重做日志文件的操作不是直接写，而是先写入一个重做日志缓冲（redo log buffer），然后按照一定的条件顺序地写入日志文件，</strong>即如下图：<img src="/posts/13147/TIM%E6%88%AA%E5%9B%BE20200211004409.png" alt></p><p><strong>从重做日志缓冲写入磁盘时，是按512个字节，也就是一个扇区的大小进行写入，因为扇区是写入的最小单位，因此可以保证写入必定是成功的，因此在重做日志的写入过程中不需要有doublewrite。</strong></p><p><strong>从日志缓冲写入磁盘上的重做日志文件是按一定条件进行的，那这些条件有哪些呢？前一篇博客分析了主线程（master thread），知道在主线程中国每秒会将重做日志缓冲写入磁盘的重做日志文件中，不论事务是否已经提交；另一个触发写磁盘的过程是由参数innodb_flush_log_at_trx_commit控制，表示在提交操作时，处理重做日志的方式。</strong></p><p>参数innodb_flush_log_at_trx_commit的有效值有0、1、2。</p><ul><li>0表示当提交事务时，并不将事务的重做日志写入磁盘上的日志文件，而是等待主线程每秒的刷新。</li><li>1表示在执行commit时将重做日志缓冲同步写到磁盘，即伴有fsync的调用。</li><li>2表示将重做日志异步写到磁盘，即写到文件系统的缓存中，因此不能完全保证在执行commit时肯定会写入重做日志文件，只是有这个动作发生。</li></ul><p><strong>因此为了保证事务的ACID特性，必须将innodb_flush_log_at_trx_commit设置为1，也就是每当事务提交时，就必须确保事务都已经写入重做日志文件，那么当数据库因为意外发生宕机时，可以通过重做日志文件恢复，并保证可以恢复已经提交的事务。而将重做日志文件设置为0或2，都有可能发生恢复时部分事务的丢失。不同之处在于，设置为2时，当MySQL数据库发生宕机而操作系统及服务器并没有发生宕机时，由于此时为写入磁盘的事务日志保存在日志系统缓存中，当恢复时同样能保证数据不丢失。</strong></p>]]></content>
    
    <summary type="html">
    
      本文将分析构成MySQL数据库和InnoDB存储引擎表的各种类型文件。
    
    </summary>
    
      <category term="MySQL" scheme="http://yoursite.com/categories/MySQL/"/>
    
    
  </entry>
  
  <entry>
    <title>InnoDB存储引擎体系架构</title>
    <link href="http://yoursite.com/posts/46117/"/>
    <id>http://yoursite.com/posts/46117/</id>
    <published>2019-11-28T12:57:16.000Z</published>
    <updated>2019-12-08T08:35:22.745Z</updated>
    
    <content type="html"><![CDATA[<h1 id="InnoDB体系架构"><a href="#InnoDB体系架构" class="headerlink" title="InnoDB体系架构"></a>InnoDB体系架构</h1><p>下图简单显示了InnoDB存储引擎的体系架构，从图见，InnoDB存储引擎有多个内存块，可以认为这些内存块组成了一个大的内存池。<img src="/posts/46117/TIM%E6%88%AA%E5%9B%BE20191128222344.png" alt></p><p><strong>后台线程的主要作用是负责刷新内存池中的数据，保证缓冲池中的内存缓存的是最近的数据。此外将已修改的数据文件刷新到磁盘文件，同时保证在数据库发生异常的情况下InnoDB能恢复到正常运行状态。</strong></p><h2 id="后台线程"><a href="#后台线程" class="headerlink" title="后台线程"></a>后台线程</h2><p>InnoDB存储引擎是多线程的模型，因此其后台有多个不同的后台线程，负责处理不同的任务。</p><h3 id="Master-Thread"><a href="#Master-Thread" class="headerlink" title="Master Thread"></a>Master Thread</h3><p><strong>Master Thread是一个非常核心的后台线程，主要负责将缓冲池中的数据异步刷新到磁盘，保证数据的一致性，包括脏页的刷新、合并插入缓冲、UNDO页的回收等。</strong></p><h3 id="IO-Thread"><a href="#IO-Thread" class="headerlink" title="IO Thread"></a>IO Thread</h3><p><strong>在InnoDB存储引擎中大量使用了AIO(Async IO)来处理写IO请求，这样可以极大提高数据库的性能。而IO Thread的工作主要是负责这些IO请求的回调处理</strong>。InnoDB中共有10个IO Thread，分别是4个read thread、4个write thread、1个insert buffer thread、1个log IO thread。</p><h3 id="Purge-Thread"><a href="#Purge-Thread" class="headerlink" title="Purge Thread"></a>Purge Thread</h3><p><strong>事务被提交后，其所使用的undo log可能不再需要，因此需要Purge Thread来回收已经使用并分配的undo页。purge操作可以独立到单独的线程中进行，以此来减轻Master Thread的工作，从而提高CPU的使用率以及提升存储引擎的性能。</strong></p><h3 id="Page-Cleaner-Thread"><a href="#Page-Cleaner-Thread" class="headerlink" title="Page Cleaner Thread"></a>Page Cleaner Thread</h3><p><strong>其作用是将之前版本中脏页的刷新操作都放入到单独的线程中来完成。而其目的是为了减轻原Master Thread的工作及对于用户查询线程的阻塞，进一步提高InnoDB存储引擎的性能。</strong></p><h2 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h2><h3 id="缓冲池"><a href="#缓冲池" class="headerlink" title="缓冲池"></a>缓冲池</h3><p><strong>InnoDB存储引擎是基于磁盘存储的，并将其中的记录按照页的方式进行管理，因此可将其视为基于磁盘的数据库系统。</strong>在数据库系统中，由于CPU的速度与磁盘速度之间的鸿沟，基于磁盘的数据库系统通常使用缓冲池技术来提高数据库的整体性能。</p><p><strong>缓冲池简单来说就是一块内存区域，通过内存的速度来弥补磁盘速度较慢对数据库性能的影响。在数据库中进行读取页的操作，首先将从磁盘读到的页存放在缓冲池中，这个过程称为将页“FIX”在缓冲池中。下一次再读相同的页时，首先判断该页是否在缓冲池中。若在缓冲池中，称该页在缓冲池中被命中，直接读取该页。否则，读取磁盘上的页。</strong></p><p><strong>对于数据库中页的修改操作，则首先修改在缓冲池中的页，然后再以一定的频率刷新到磁盘上。这里需要注意的是，页从缓冲池刷新回磁盘的操作并不是在每次页发生更新时触发，而是通过一种称为Checkpoint的机制刷新回磁盘，同样这也是为了提高数据库的整体性能。</strong></p><p>具体来看，缓冲池中缓存的数据页类型有：索引页、数据页、undo页、插入缓冲（insert buffer）、自适应哈希索引（adaptive hash index，AHI）、InnoDB存储的锁信息、数据字典信息等。下图是InnoDB存储引擎中内存的结构情况：<img src="/posts/46117/TIM%E6%88%AA%E5%9B%BE20191129222440.png" alt></p><p><strong>从InnoDB 1.0x版本开始，允许有多个缓冲池实例。每个页根据哈希值平均分配到不同缓冲池实例中。这样做的好处是减少数据库内部的资源竞争，增加数据库的并发处理能力。可以通过参数<code>innodb_buffer_pool_instances</code>来进行配置。</strong></p><h3 id="LRU-List、Free-List和Flush-List"><a href="#LRU-List、Free-List和Flush-List" class="headerlink" title="LRU List、Free List和Flush List"></a>LRU List、Free List和Flush List</h3><p>在前一小节知道了缓冲池是一个很大的内存区域，其中存放各种类型的页，那么InnoDB存储引擎是在怎么对这么大的内存区域进行管理的呢？通常来说，数据库中的缓冲池是通过LRU（Latest Recent Used，最近最少使用）算法来进行管理的。即最频繁使用的页在LRU列表的前端，而最少使用的页在LRU列表的尾端。<strong>当缓冲池不能存放读取到的页时，将首先释放LRU列表中尾端的页。</strong></p><p>在InnoDB存储引擎中，缓冲池中页的大小默认为16KB，InnoDB对传统的LRU算法做了一些优化，<strong>在InnoDB存储引擎中，LRU列表中还加入了midpoint位置。读取到的页，虽然是最新访问的页，但并不是直接放到LRU列表的首部，而是放入到LRU列表的midpoint位置，在默认配置下，该位置在LRU列表长度的5/8处。</strong>在InnoDB存储引擎中，把midpoint之后的列表称为old列表，之前的列表称为new列表，可以简单的理解为new列表中的都是最为活跃的热点数据。</p><p>之所以这样做，而不使用朴素的LRU算法，这是因为若直接将读取到的页放入到LRU的首部，那么某些SQL操作可能会使缓冲池中的页被刷新出，从而影响缓冲池的效率。常见的这类操作为索引或数据的扫描操作。这类操作需要访问表中的许多页，甚至是全部页，而这些页通常来说又仅在这次查询操作中需要，并不是活跃的热点数据。如果页被放入LRU列表的首部，那么非常可能将所需要的热点数据页从LRU列表中移除，而在下一次需要读取该页时，InnoDB存储引擎需要再次访问磁盘。</p><p><strong>LRU列表用来管理已经读取的页，但当数据库刚启动时，LRU列表是空的，即没有任何的页，这时页都存放在Free列表中。当需要从缓冲池中分页时，首先从Free列表中查找是否可用的空闲页，若有则将该页从Free列表中删除，放入到LRU列表中。否则根据LRU算法，淘汰LRU列表末尾的页，将该内存空间分配给新的页。</strong>当页从LRU列表的old部分加入到new部分时，称此时发生的操作为page made young。</p><p>可以通过命令<code>SHOW ENGINE INNODB STATUS</code>来观察LRU列表以及Free列表的使用情况和运行状态。其中Free buffers表示当前Free列表中页的数量，Database pages表示LRU列表中页的数量，<strong>可能的情况是Free buffers与Database pages的数量之和不等于Buffer pool size，因为缓冲池中的页还可能会被分配给自适应哈希索引、Lock信息、Insert Buffer等页，而这部分不需要LRU算法进行维护，因此不存在于LRU列表中。</strong></p><p>page made young显示了LRU列表中页移动到前端的次数，另外还有一个重要的观察变量——<strong>Buffer pool hit rate，表示缓冲池的命中率，若是100%则说明缓冲池运行状态非常好，通常该值不应该小于95%。若发生Buffer pool hit rate的值小于95%这种情况，用户需要观察是否由于全表扫描引起的LRU列表被污染问题。</strong></p><p><strong>InnoDB存储引擎从1.0x版本开始支持压缩页的功能，即将原本16KB的页压缩为1KB、2KB、4KB和8KB。而由于页的大小发生了变化，LRU列表也有了些许的改变，对于非16KB的页，是通过unzip_LRU列表进行管理的。</strong>通过命令<code>SHOW ENGINE INNODB STATUS</code>可以观察到如下内容：<img src="/posts/46117/TIM%E6%88%AA%E5%9B%BE20191201165804.png" alt>可以看到LRU列表中一共有1539个页，而unzip_LRU列表中有156个页，这里需要注意的是，<strong>LRU中的页包含了unzip_LRU列表中的页。</strong></p><p>对于压缩页的表，每个表的压缩比率各不相同，可能存在有的表页大小为8KB，有的表页大小为2KB的情况。那么unzip_LRU是怎样从缓冲池中分配内存的呢？</p><p><strong>首先在unzip_LRU列表中对不同压缩页大小的页进行分别管理。其次通过伙伴算法进行内存的分配，例如对需要从缓冲池中申请页为4KB的大小，其过程如下：</strong></p><ol><li><strong>检查4KB的unzip_LRU列表，检查是否有可用的空闲页；</strong></li><li><strong>若有，则直接使用；</strong></li><li><strong>否则，检查8KB的unzip_LRU列表；</strong></li><li><strong>若能得到空闲页，将页分成2个4KB页，存放到4KB的unzip_LRU列表；</strong></li><li><strong>若不能得到空闲页，从LRU列表中申请一个16KB的页，将页分为1个8KB的页、2个4KB的页，分别存放到对应的unzip_LRU列表中。</strong></li></ol><p><strong>在LRU列表中的页被修改后，称该页为脏页（dirty page），即缓冲池中的页和磁盘上的页的数据产生了不一致。这时数据库会通过CHECKPOINT机制将脏页刷新回磁盘，而Flush列表中的页即为脏页列表。需要注意的是，脏页既存在于LRU列表中，也存在于Flush列表中。LRU列表用来管理缓冲池中页的可用性，Flush列表用来管理将页刷新回磁盘，二者互不影响。</strong>命令<code>SHOW ENGINE INNODB STATUS</code>结果中显式的Modified db page即为脏页的数量。</p><h3 id="重做日志缓冲"><a href="#重做日志缓冲" class="headerlink" title="重做日志缓冲"></a>重做日志缓冲</h3><p>InnoDB存储引擎的内存区域除了有缓冲池外，还有重做日志缓冲。<strong>InnoDB存储引擎首先将重做日志信息先放入到这个缓冲区，然后按一定频率将其刷新到重做日志文件。重做日志缓冲一般不需要设置的很大，因为一般情况下每秒都会将重做日志缓冲刷新到日志文件，因此用户只需要保证每秒产生的事务量在这个缓冲大小之内即可。</strong></p><p>在通常情况下，8MB的重做日志缓冲池足以满足绝大部分的应用，<strong>因为重做日志在下列三种情况下会将重做日志缓冲中的内容刷新到外部磁盘的重做日志文件中。</strong></p><ul><li>Master Thread每一秒将重做日志缓冲刷新到重做日志文件；</li><li>每个事务提交时会将重做日志缓冲刷新到重做日志文件；</li><li>当重做日志缓冲池剩余空间小于1/2时，重做日志缓冲刷新到重做日志文件。</li></ul><h3 id="额外的内存池"><a href="#额外的内存池" class="headerlink" title="额外的内存池"></a>额外的内存池</h3><p><strong>在InnoDB存储引擎中，对内存的管理是通过一种称为内存堆的方式进行的。在对一些数据结构本身的内存进行分配时，需要从额外的内存池中进行申请，当该区域的内存不够时，会从缓冲池中进行申请。</strong></p><h1 id="Checkpoint"><a href="#Checkpoint" class="headerlink" title="Checkpoint"></a>Checkpoint</h1><p>如前面所说，缓冲池的设计目的为了协调CPU速度与磁盘速度的鸿沟。因此页的操作首先都是在缓冲池中完成的。如果一条DML语句，入Update或Delete改变了页中的记录，那么此时页是脏的，即缓冲池中的页的版本要比磁盘的新。数据库需要将新版本的页从缓冲池中刷新到磁盘。</p><p>倘若每次一个页发生变化，就将新页刷新到磁盘，那么这个开销是非常大的。若热点数据集中在某几个页中，那么数据库的性能将变得非常差。同时如果从缓冲池将页的新版本刷新到磁盘时发生了宕机，那么数据就不能恢复了。</p><p><strong>为了避免数据丢失的问题，当前事务数据库系统普遍都采用了Write Ahead Log策略，即当事务提交时，先写重做日志，再修改页。当由于发生宕机而导致数据丢失时，通过重做日志来完成数据的恢复。这也是事务ACID中D（During 持久性）的要求。</strong></p><p>但是重做日志不可能无限增大，或者如果重写日志太大，那么宕机后数据库的重新应用重做日志的时间会非常久，此时恢复的代价也会非常大。因此Checkpoint（检查点）技术的目的是解决一下几个问题：</p><ul><li>缩短数据库的恢复时间；</li><li>缓冲池不够用时，将脏页刷新到磁盘；</li><li>重做日志不可用时，刷新脏页。</li></ul><p><strong>当数据发生宕机时，数据库不需要重做所有的日志，因此Checkpoint只前的页都已经刷新回磁盘。故数据库只需对Checkpoint后的重做日志进行恢复。这样就大大缩短到了恢复时间。此外，当缓冲池不够用时，根据LRU算法会溢出最近最少使用的页，若此页为脏页，那么需要强制执行Checkpoint，将脏页也就是页的新版本刷新回磁盘。</strong></p><p>重做日志出现不可用的情况是因为当前事务数据库系统对重做日志的设计都是循环使用的，并不是让其无限增大的，这从成本及管理上都是比较困难的。重做日志可以被重用的部分是指这些重做日志已经不再需要，即当数据库发生宕机时，数据库恢复操作不需要这部分的重做日志，因此这部分就可以被覆盖重用。若此时重做日志还需要使用，那么必须强制产生Checkpoint，将缓冲池中的页至少刷新到当前重做日志的位置。</p><p>再InnoDB存储引擎中，Checkpoint发生的时间、条件以及脏页的选择等都非常复杂。而Checkpoint所做的事情无外乎是将缓冲池中的脏页刷回到磁盘。不同之处在于每次刷新多少页到磁盘，每次从哪里取脏页，以及什么时间触发Checkpoint。在InnoDB存储引擎内部，有两种Checkpoint，分别为：</p><ul><li><strong>Sharp Checkpoint</strong></li><li><strong>Fuzzy Checkpoint</strong></li></ul><p><strong>Sharp Checkpoint发生在数据库关闭时将所有的脏页都刷新回磁盘，这是默认的工作方式，即参数<code>innodb_fast_shutdown=1</code>。</strong></p><p><strong>在数据库运行时，InnoDB存储引擎内部使用Fuzzy Checkpoint进行页的刷新，即只刷新一部分脏页，而不是刷新所有的脏页回磁盘。</strong>在InnoDB存储引擎中可能发生如下几种情况的Fuzzy Checkpoint：</p><ul><li>Master Thread Checkpoint</li><li>FLUSH_LRU_LIST Checkpoint</li><li>Async/Sync Flush Checkpoint</li><li>Dirty Page too much Checkpoint</li></ul><p><strong>对于Master Thread（后面会详细讲）中发生的Checkpoint，差不多以每秒或每十秒的速度从缓冲池的脏页列表中刷新一定比例的页回磁盘。这个过程是异步的，即此时InnoDB存储引擎可以进行其它操作，用户查询线程不会阻塞。</strong></p><p><strong>FLUSH_LRU_LIST Checkpoint是因为InnoDB存储引擎需要保证LRU列表中需要有差不多100个空闲页可供使用，倘若没有100个可用空闲页，那么InnoDB存储引擎会将LRU列表尾端的页移除。如果这些页中有脏页，那么需要进行Checkpoint，而这些页是来自LRU列表的，因此被称为FLUSH_LRU_LIST Checkpoint。在InnoDB1.2x版本开始，这个检查被放在了一个单独的Page Cleaner线程中进行</strong>，并且用户可以通过参数innodb_lru_scan_depth控制LRU列表中可用页的数量，该值默认为1024。</p><p><strong>Async/Sync Flush Checkpoint指的是重做日志文件不可用的情况，这时需要强制将一部分页刷新回磁盘，而此时脏页是从脏页列表中选取的。</strong>在InnoDB1.2x版本之前，Async Flush Checkpoint会阻塞发现问题的用户查询线程，而Sync Flush Checkpoint会阻塞所有的用户查询线程，并且等待脏页刷新完成。<strong>从InnoDB1.2x版本开始——也就是MySQL5.6版本，这部分的刷新操作同样放入到了单独的Page Cleaner Thread中，故不会阻塞用户查询线程。</strong></p><p><strong>最后一种Checkpoint的情况是Dirty Page too much，即脏页的数量太多，导致InnoDB存储引擎强制进行Checkpoint。其目的总的来说还是为了保证缓冲池中有足够可用的页，其可用参数innodb_max_dirty_pages_pac控制，默认为75，表示当缓冲池中脏页的数量占据75%时，强制进行Checkpoint，刷新一部分的脏页到磁盘。</strong></p><h1 id="Master-Thread工作方式"><a href="#Master-Thread工作方式" class="headerlink" title="Master Thread工作方式"></a>Master Thread工作方式</h1><p>InnoDB存储引擎的主要工作都是在一个单独的后台线程Master Thread中完成的。</p><h2 id="InnoDB-1-0x版本之前"><a href="#InnoDB-1-0x版本之前" class="headerlink" title="InnoDB 1.0x版本之前"></a>InnoDB 1.0x版本之前</h2><p><strong>Master Thread具有最高的线程优先级别。</strong>其内部由多个循环（loop）组成：主循环（loop）、后台循环（backgroup loop）、刷新循环（flush loop）、暂停循环（suspend loop）。Master Thread会根据数据库运行状态在它们之中进行切换。Loop被称为主循环，因为大多数的操作是在这个循环中，<strong>其中有两大部分的操作——每秒钟的操作和每10秒的操作。loop循环通过thread sleep来实现，这意味着所谓的每秒一次或每10秒一次的操作是不精确的。在负载很大的情况下可能会有延迟，只能说大概在这个频率下。</strong></p><p><strong>每秒一次的操作包括：</strong></p><ul><li><strong>日志缓冲刷新到磁盘，即使这个事务还没有提交（总是）</strong></li><li><strong>合并插入缓冲（可能）</strong></li><li><strong>至多刷新100个InnoDB的缓冲池中的脏页到磁盘（可能）</strong></li><li><strong>如果当前没有用户活动，则切换到backgroup loop（可能）</strong></li></ul><p><strong>即使某个事务还没有提交，InnoDB存储引擎仍然每秒会将重做日志缓冲中的内容刷新到重做日志文件。这一点是必须要知道的，因此这可以很好的解释为什么再大的事务提交的时间也是很短的。</strong></p><p><strong>合并插入缓冲（Insert Buffer）并不是每秒都会发生的，InnoDB存储引擎会判断当前一秒内发生的IO此时是否小于5次，如果小于5次，InnoDB认为当前的IO压力很小，可以执行合并插入缓冲的操作。</strong></p><p><strong>同样，InnoDB存储引擎通过判断当前缓冲池中脏页的比例是否超过了配置文件中的innodb_max_dirty_pages_pct(默认为90%)参数，如果超过了这个阈值，InnoDB存储引擎认为需要做磁盘同步的操作，将100个脏页写入磁盘中。</strong></p><p><strong>每10秒的操作包括如下内容：</strong></p><ul><li><strong>刷新100个脏页到磁盘（可能的情况下）</strong></li><li><strong>合并至多5个插入缓冲（总是）</strong></li><li><strong>将日志缓冲刷新到磁盘（总是）</strong></li><li><strong>删除无用的Undo页（总是）</strong></li><li><strong>刷新100个或者10个脏页到磁盘（总是）</strong></li></ul><p><strong>在以上的过程中，InnoDB存储引擎会先去判断过去10秒内磁盘的IO操作是否小于200次，如果是，InnoDB存储引擎认为当前有足够的IO操作能力，因此将100个脏页刷新到磁盘。</strong></p><p><strong>接着InnoDB存储引擎会合并插入缓冲。不同于每秒一次操作时可能发生的合并插入缓冲操作，这次的合并插入缓冲总会在这个阶段进行。</strong></p><p><strong>之后InnoDB存储引擎会再进行一次将日志缓冲刷新到磁盘的操作，这和每秒一次时发生的操作是一样的。</strong></p><p><strong>接着InnoDB存储引擎会进行一步执行full purge操作，即删除无用的Undo页。</strong>对表进行update、delete这类操作时，原先的行被标记为删除，但是因为一致性读的关系，需要保留这些行版本的信息。但是<strong>在full purge过程中，InnoDB存储引擎会判断当前事务系统中已被删除的行是否可以删除，比如有时候可能还有查询操作需要读取之前版本的undo信息，如果可以删除，InnoDB会立即将其删除。在执行full purge操作时，每次最多尝试回收20个undo页。</strong></p><p><strong>然后InnoDB存储引擎会判断缓冲池中脏页的比例，如果有超过70%的脏页，则刷新100个脏页到磁盘，如果脏页的比例小于70%，则只需要刷新10%的脏页到磁盘。</strong></p><p>接下来是backgroup loop，<strong>若当前没有用户活动（数据库空闲时）胡总和数据库关闭（shutdown），就会切换到这个循环。backgroup loop会执行以下操作：</strong></p><ul><li>删除无用的Undo页（总是）</li><li>合并20个插入缓冲（总是）</li><li>跳回到主循环（总是）</li><li>不断刷新100个页直到符合条件（可能，跳转到flush loop中完成）</li></ul><p><strong>若flush loop中也没有什么事情可以做了，InnoDB存储引擎会切换到suspend loop，将Master Thread挂起。</strong></p><h2 id="InnoDB-1-2x版本之前"><a href="#InnoDB-1-2x版本之前" class="headerlink" title="InnoDB 1.2x版本之前"></a>InnoDB 1.2x版本之前</h2><p>从之前的了解来看，无论何时，InnoDB存储引擎最大只会刷新100个脏页到磁盘，合并20个插入缓冲，如果是在写入密集的应用程序中，每秒可能会产生大于100个的脏页，如果是产生大于20个插入缓冲的情况，Master Thread似乎会忙不过来。即使磁盘能在1秒内处理多于100个页的写入和20个插入缓冲的合并，但是由于hard coding，Master Thread也只会选择刷新100个页和合并20个插入缓冲，当发生宕机需要恢复时，由于许多数据还没有刷新会磁盘，会导致恢复的时间可能需要很久，尤其是对于insert buffer来说。</p><p>为了解决这个问题，InnoDB提供了参数innodb_io_capacity，用来表示磁盘IO的吞吐量，默认值为200。对于刷新到磁盘页的数量，会按照innodb_io_capacity的百分比来进行控制，规则如下：</p><ul><li><strong>在合并插入缓冲时，合并插入缓冲的数量为innodb_io_capacity值的5%；</strong></li><li><strong>在从缓冲区刷新脏页时，刷新页的数量为innodb_io_capacity。</strong></li></ul><p><strong>另一个问题就是，参数innodb_max_dirty_pages_pct默认值的问题，在之前的版本中是90，意味着脏页占缓冲池的90%，但是该值太大了，所以在之后的版本中默认值修改为75，这样既可以加快刷新脏页的频率，又能保证磁盘IO的负载。</strong></p><p><strong>InnoDB 1.0x版本带来的另一个参数是innodb_adaptive_flushing（自适应的刷新），该值影响每秒刷新脏页的数量，原来的刷新规则是：脏页在缓冲池所占的比例小于innodb_max_dirty_pages_pct时，不刷新脏页，大于innodb_max_dirty_pages_pct时，刷新100个脏页。但是innodb_adaptive_flushing引入后，InnoDB存储引擎会通过名为buf_flush_get_desired_flush_rate参数来判断需要刷新脏页最合适的数量。buf_flush_get_desired_flush_rate通过判断产生重做日志的速度来决定最合适的刷新脏页数量。因此当脏页的比例小于innodb_max_dirty_pages_pct时，也会刷新一定量的脏页。</strong></p><p><strong>另外一个改变就是，之前每次进行full pruge操作时，最多回收20个Undo页，从InnoDB 1.0x版本之后引入参数innodb_purge_batch_size，该参数可以通过每次full purge回收的Undo页数量，该参数默认为20，并可以动态的进行修改。</strong></p><h2 id="InnoDB-1-2x版本的Master-Thread"><a href="#InnoDB-1-2x版本的Master-Thread" class="headerlink" title="InnoDB 1.2x版本的Master Thread"></a>InnoDB 1.2x版本的Master Thread</h2><p><strong>在InnoDB 1.2x版本中，对于刷新脏页的操作，从Master Thread线程分离到一个单独的Page Cleaner Thread，从而减轻了Master Thread的工作，同时进一步提高了系统的并发性。</strong></p><h1 id="InnoDB关键特性"><a href="#InnoDB关键特性" class="headerlink" title="InnoDB关键特性"></a>InnoDB关键特性</h1><p>InnoDB存储引擎的关键特性包括：</p><ul><li><strong>插入缓冲（Insert Buffer）</strong></li><li><strong>两次写（Double Write）</strong></li><li><strong>自适应哈希索引（Adaptive Hash Index，AHI）</strong></li><li><strong>异步IO（Async IO）</strong></li><li><strong>刷新邻接页（Flush Neighbor Page）</strong></li></ul><h2 id="插入缓冲"><a href="#插入缓冲" class="headerlink" title="插入缓冲"></a>插入缓冲</h2><h3 id="Insert-Buffer"><a href="#Insert-Buffer" class="headerlink" title="Insert Buffer"></a>Insert Buffer</h3><p>Insert Buffer不是缓冲池的一部分，InnoDB缓冲池中虽然有Insert Buffer的信息不错，但是Insert Buffer和数据页一样，也是物理页的一个组成部分。</p><p>在InnoDB存储引擎中，主键是行唯一的标识符，通常应用程序中行记录的插入顺序是按照主键递增的顺序进行插入的。因此插入聚集索引一般是顺序的，不需要磁盘的随机读取。但是每张表不可能只有一个聚集索引，更多情况下，一张表上还有多个非聚集的辅助索引。</p><p><strong>在这种情况下产生了一个非聚集的且不是唯一的索引。在进行插入操作时，数据页的存放还是按主键进行顺序存放的，但是对于非聚集索引叶子节点的插入不再是顺序的了，这时就需要离散的访问非聚集索引页，由于随机读取的存在而导致了插入操作性能的下降。需要注意的是，在某些情况下，辅助索引的插入依然是顺序的，或者说是顺序的，比如用户购买表中的时间字段。</strong></p><p><strong>InnoDB存储引擎开创性的设计了Insert Buffer，对于非聚集索引的插入或更新操作，不是每一次直接插入到索引页中，而是先判断插入的非聚集索引页是否在缓冲池中，若在则直接插入；若不在，则先放入到一个Insert Buffer对象中，好似欺骗数据库这个非聚集的索引已经插入到叶子节点，而实际没有，只是存放在另一个位置。然后再以一定的频率和情况进行Insert Buffer和辅助索引叶子节点的merge（合并）操作，这是通常能将多个插入合并到一个操作中（因为在一个索引页中），这就大大提高了对于非聚集索引插入的性能。</strong></p><p><strong>然而，Insert Buffer的使用需要同时满足以下两个条件：</strong></p><ul><li><strong>索引是辅助索引（secondary index）</strong></li><li><strong>索引不是唯一（unique）的</strong></li></ul><p><strong>不过考虑这样一种情况：应用程序进行大量的插入操作，这些都涉及了不唯一的非聚集索引，也就是使用了Insert Buffer。若此时MySQL数据库发生了宕机，这时势必有大量的Insert Buffer并没有合并到实际的非聚集索引中。因此这时恢复可能需要很长的时间，在极端情况下甚至需要几个小时。</strong></p><p><strong>辅助索引不能是唯一的，因为插入缓冲时，数据库并不去查找索引页来判断索引插入的记录的唯一性。如果去查找肯定又会有离散读取的情况发生，从而导致Insert Buffer失去意义。</strong></p><p>用户可以通过命令<code>SHOW ENGINE INNODB STATUS</code>来查看插入缓冲的信息：<img src="/posts/46117/TIM%E6%88%AA%E5%9B%BE20191203215845.png" alt></p><p>seg size显示了当前Insert Buffer的大小为11336*16KB，大约为177MB；free list len代表了空闲列表的长度；size代表了已经合并记录页的数量。</p><p><strong>而黑体部分的第2行可能是用户真正关心的，因为它显示了插入性能的提高。Insert代表了插入的记录数次数；merged recs代表了合并的插入记录数量；merges代表合并的次数，也就是实际读取页的次数。merges ：merged recs大约为1 ：3，代表了插入缓冲将对于非聚集索引页的离散IO逻辑请求大约降低了2/3。</strong></p><p><strong>目前Insert Buffer存在一个问题是：在写密集的情况下，插入缓冲会占用过多的缓冲池内存。默认最大可以占用到1/2的缓冲池内存。</strong></p><h3 id="Change-Buffer"><a href="#Change-Buffer" class="headerlink" title="Change Buffer"></a>Change Buffer</h3><p>InnoDB从1.0x版本开始引入Change Buffer，可将其视为Insert Buffer的升级。从这个版本开始，InnoDB存储引擎可以对DML操作——INSERT、DELETE、UPDATE都进行缓冲，它们分别是Insert Buffer、Delete Buffer、Purge buffer。</p><p>当然和之前Insert Buffer一样，<strong>Change Buffer适用的对象依然是非唯一的辅助索引。</strong></p><p><strong>对一条记录进行DELETE操作可能分为两个过程：</strong></p><ul><li><strong>将记录标记为删除；</strong></li><li><strong>真正将记录删除。</strong></li></ul><p><strong>因此Delete Buffer对应DELETE操作的第一个过程，即将记录标记为删除；Purge Buffer对应UPDATE操作的第二个过程，即将记录真正的删除。</strong></p><p>InnoDB存储引擎提供了参数innodb_change_buffering，用来开启各种Buffer的选项。该参数可选的值为：inserts、deletes、purges、changes、all、none。changes表示启动inserts和deletes，all表示启用所有，none表示都不起启用，默认为all。</p><p>从InnoDB 1.2x版本开始，可以通过参数innodb_change_buffer_max_size来控制Change Buffer最大使用内存的数量，<strong>innodb_change_buffer_max_size值默认为25，表示最多使用25%的缓冲池内存空间，该参数最大有效值为50。</strong></p><p>在MySQL5.5版本中通过命令<code>SHOW ENGINE INNODB STATUS</code>，可以观察到类似如下的内容：<img src="/posts/46117/TIM%E6%88%AA%E5%9B%BE20191205191435.png" alt><br>其中insert表示Insert Buffer；delete表示Delete Buffer；delete表示Purge Buffer；discarded operations表示当Change Buffer发生merge时，表已经被删除，此时就无需再将记录合并到辅助索引中了。</p><h3 id="Insert-Buffer的内部实现"><a href="#Insert-Buffer的内部实现" class="headerlink" title="Insert Buffer的内部实现"></a>Insert Buffer的内部实现</h3><p>Insert Buffer的数据结构是一颗B+树，在MySQL4.0之前的版本中每张表有一颗Insert Buffer B+树；<strong>而现在的版本中，全局只有一颗Insert Buffer B+树，负责对所有的表的辅助索引进行Insert Buffer。</strong></p><p>而这颗B+树存放在共享表空间中，默认也就是ibdata1，因此试图通过独立表空间ibd文件恢复表中数据时，往往会导致CHECK TABLE失败，这是因为表的辅助索引中的数据可能还在Insert Buffer中，也就是共享表空间中，<strong>所以通过ibd文件进行恢复后后，还需要进行REPAIR TABLE操作来重建表上所有的辅助索引。</strong></p><p>Insert Buffer是一课B+树，因此其也由叶节点和非叶节点组成。非叶节点存放的时查询的search key（键值），其构造如图 <img src="/posts/46117/TIM%E6%88%AA%E5%9B%BE20191205200733.png" alt>search key一共占用9个字节</p><ul><li>其中space表示待插入记录所在表的表空间id，在InnoDB存储引擎中，每个表都有一个唯一的space id，可以通过space id查询得知是哪张表。space占用4字节。</li><li>marker占用1字节，它是用来兼容老版本的Insert Buffer。</li><li>offset表示页所在的偏移量，占用4字节。</li></ul><p><strong>当一个辅助索引要插入到页时，如果这个页不在缓冲池中，那么InnoDB存储引擎首先根据上述规则构造一个search key，接下来查询Insert Buffer这棵B+树，然后再将这条记录插入到Insert Buffer B+树的叶子节点中。</strong></p><p>对于插入到Insert Buffer B+树叶子节点的记录，并不是直接将待插入的记录插入，而是需要根据如下的规则进行构造：<img src="/posts/46117/TIM%E6%88%AA%E5%9B%BE20191205204741.png" alt>space、marker、offset字段和之前非叶节点中的含义相同，一共占用9字节，第四个metadata占用4字节，其存储内容如下：<img src="/posts/46117/TIM%E6%88%AA%E5%9B%BE20191205205231.png" alt></p><p>IBUF_REC_OFFSET_COUNT是保存两个字节的整数，用来排序每个记录进入Insert Buffer的顺序，因此从InnoDB 1.0x开始支持Change Buffer，所以这个值同样记录进入Insert Buffer的顺序，通过这个顺序回方才能得到记录的正确值。</p><p>从Insert Buffer叶子节点的第5列开始就是实际插入记录的各个字段了，因此较之原插入记录，Insert Buffer B+树的叶子节点记录需要额外13字节的开销。</p><p>因为启用Insert Buffer索引后，辅助索引页中的记录可能被插入到InsertBuffer B+树中，所以为了保证每次Merge Insert BUffer页必须成功，还需要有一个特殊的页用来标记每个辅助索引页的可用空间，这个页的类型为Insert Buffer Bitmap。每个Insert Buffer Bitmap页用来追踪16384个辅助索引页，也就是256个区。每个Insert Buffer Bitmap页都在16384个页的第二个页中。每个辅助索引页在Insert Buffer Bitmap页中占用4位，右下3个部分组成：<img src="/posts/46117/TIM%E6%88%AA%E5%9B%BE20191205205949.png" alt></p><h3 id="Merge-Insert-Buffer"><a href="#Merge-Insert-Buffer" class="headerlink" title="Merge Insert Buffer"></a>Merge Insert Buffer</h3><p>通过前面直到Insert/Change Buffer是一棵B+树。若需要实现插入记录的辅助索引页不在缓冲池中，那么需要将辅助索引记录首先插入到这棵B+树中，但是Insert Buffer中的记录何时合并到真正的辅助索引中呢？</p><p>概括地说，Merge Insert Buffer的操作可能发生在一下几种情况下：</p><ul><li><strong>辅助索引页被读取到缓冲中；</strong></li><li><strong>Insert Buffer Bitmap页追踪到该辅助索引页已无可用空间时；</strong></li><li><strong>Master Thread。</strong></li></ul><p><strong>第一种情况是当辅助索引页被读取到缓冲池中时，例如这在执行正常的SELECT查询操作，这是需要检查Insert Buffer Bitmap页，然后确认该辅助索引页是否有记录存在于Insert BUffer B+树中。若有，则将Insert Buffer B+树中该页的记录插入到该辅助索引页中。可以看到对该页多次的记录操作通过一次操作合并到了原有的辅助索引页中，因此性能会有大幅提高。</strong></p><p><strong>Insert Buffer Bitmap页用来追踪每个辅助索引页的可用空间，并至少有1/32页的空间。若插入辅助索引记录时检测到插入记录后可用空间会小于1/32页，则会强制进行一个合并操作，即前置读取辅助索引页，将Insert Buffer B+树中该页的记录及待插入的记录插入到辅助索引页中。</strong></p><p><strong>还有一种情况是之前分析的Master Thread，在Master Thread线程中每秒或每10秒会进行一次Merge Insert Buffer的操作，不同之处在于每次进行merge操作的页的数量不同。</strong></p><p>在Master Thread中，执行merge操作的不只是一个页，而是根据参数计算出真正要合并多少个辅助索引页。计算的方法如下：在Insert Buffer B+树中，辅助索引页都已排序好，故可以根据辅助索引页的排序顺序进行页的选择，然而对于Insert Buffer页的选择并非采用这个方法，<strong>它随机的选择Insert Buffer B+树种的一个页，读取该页中的space及之后所需要数量的页，该算法在复杂情况下应有更好的公平性，同时若进行merge时，要进行merge的表已经被删除，此时可以直接丢弃已经被Insert Change Buffer的数据记录。</strong></p><h2 id="两次写"><a href="#两次写" class="headerlink" title="两次写"></a>两次写</h2><p>如果说Insert Buffer带给InnoDB存储引擎的是性能上的提升，那么doublewrite（两次写）带给InnoDB存储引擎的是数据页的可靠性。</p><p>当发生数据库宕机时，可能InnoDB存储引擎正在写入某个页到表中，而这个页只写了以部门，之后就发生了宕机，这种情况被称为部分写失效。</p><p>有经验的DBA也许会想，如果发生写失效，可以通过重做日志进行恢复，但是必须清楚的认识到，如果重做日志中记录的是对页的物理操作，如偏移量800，写“aaa”记录，但是如果这个页本身已经发生了损坏，再对其进行重做是没有意义的。这就是说，<strong>在应用重做日志之前，用户需要一个页的副本，当写入失效发生时，先通过页的副本来还原该页，再进行重做，这就是doublewrite。</strong>在InooDB存储引擎中doublewrite的体系架构如图:<img src="/posts/46117/TIM%E6%88%AA%E5%9B%BE20191206192049.png" alt></p><p><strong>doublewirte由两部分组成，一部分是内存中的doublewrite buffer，大小为2MB，另外一部分是物理磁盘上共享表空间中连续的128个页，即两个区，大小同样为2MB。</strong></p><p><strong>在对缓冲池的脏页进行刷新时，并不直接写磁盘，而是会通过memcpy函数将脏页先复制到内存中的doublewrite buffer，之后通过doublewrite buffer再分两次，每次1MB顺序地写入共享表空间的物理磁盘上，然后马上调用fsync函数，同步磁盘，避免缓冲写带来的问题。在这个过程中，因为doublewrite页是连续的，因此这个过程是顺序写的，开销不是很大。在完成doublewrite页的写入后，再将doublewrite buffer中的页写入各个表空间文件中，此时的写入则是离散的。</strong></p><p><strong>如果操作系统在将页写入磁盘的过程中发生了崩溃，在恢复过程中，InnoDB存储引擎可以从共享表空间中的doublewrite中找到该页的一个副本，将其复制到表空间文件，再应用重做日志。</strong></p><p>参数skip_innodb_doublewrite可以禁止使用doublewrite功能，这时可能会发生前面提及的写失效问题。不过如果用户有多个从服务器（slave server），需要提供较快的性能，也许启用这个参数是一个办法。不过对于需要提供数据高可靠的主服务器，任何时候用户都应该确保开启doublewrite功能。</p><h2 id="自适应哈希索引"><a href="#自适应哈希索引" class="headerlink" title="自适应哈希索引"></a>自适应哈希索引</h2><p>哈希是一种非常快的查找方法，在一般情况下这种查找的时间复杂度位O（1），即一般仅需要一次查找就能定位数据，而B+树的查找次数，取决于B+树的高度，在生产环境中，B+树的高度一般为3<del>4层，故需要3</del>4次的查询。</p><p><strong>InnoDB存储引擎中会监控对表上各索引页的查询。如果观察到建立哈希索引可以带来速度的提升，则建立哈希索引，称之为自适应哈希索引（Adaptive Hash Index，AHI）。</strong>AHI是通过缓冲池的B+树页构造而来，因此建立的速度很快，而且不需要对整张表构建哈希索引。<strong>InnoDB存储引擎会自动根据访问的频率和模式来自动的为某些热点页建立哈希索引。</strong></p><p><strong>AHI有一个要求，即对这个页的连续访问模式必须是一样的。</strong>例如对于（a，b）这样的联合索引，其访问模式可以是以下情况：</p><ul><li>WHERE a = xxx</li><li>WHERE a = xxx ADN b = xxx</li></ul><p><strong>访问模式一样指的是查询的条件一样，若交替进行上述两种查询，那么InnoDB存储引擎不会对该页构造AHI。此外AHI还有以下要求：</strong></p><ul><li>以该模式访问了10次</li><li>页通过该模式访问了N次，其中N = 页中记录*1/16</li></ul><p>根据InnoDB存储引擎官方文档显示，启用AHI后，读取和写入速度可以提高5倍。<strong>值得注意的是，哈希索引只能用来搜索等值的查询。</strong>而对于其他查找类型，例如范围查找，是不能使用哈希索引的。</p><h2 id="异步IO"><a href="#异步IO" class="headerlink" title="异步IO"></a>异步IO</h2><p>为了提高磁盘操作性能，当前的数据库系统都采用异步IO（Asynchronous IO，AIO）的方式来处理磁盘操作，InnoDB存储引擎也是如此。</p><p>与AIO对应的是Sync IO（BIO），即每进行一次IO操作，需要等待此次操作结束才能继续接下来的操作。但是如果用户发出的是一条索引扫描的查询，那么这条SQL查询语句可能需要扫描多个索引页，也就是需要进行多次的IO操作。在每扫描一个页并等待其完成后再进行下一次的扫描，这是没必要的。<strong>用户可以在发出一个IO请求后立即再发出另一个IO请求，当全部IO请求发送完毕后，等待所有IO操作的完成，这就是AIO。</strong></p><p><strong>AIO的另一个优势是可以进行IO Merge操作，也就是将多个IO合并为1个IO，这样可以提高IOPS的性能。</strong>例如用户需要访问页的（space，offset）为（8，6）、（8，7）、（8，8），每个页的大小为16KB，那么同步IO需要进行3次IO操作，<strong>而AIO会判断这三个页是连续的（显然可以通过（space，offset）得知），因此AIO底层会发送一个IO请求，从（8，6）开始，读取48KB的页。</strong></p><p><strong>从InnoDB 1.1x开始提供了内核级别AIO的支持，称为Native AIO，Native AIO需要操作系统提供支持，Windows系统和Linux系统都提供Native AIO支持，而Mac OSX系统则未提供。</strong>启用Native AIO，恢复速度可以提高75%。</p><p><strong>在InnoDB存储引擎中，read ahead方式的读取都是通过AIO完成，脏页的刷新，即磁盘的写入操作则全部由AIO完成。</strong></p><h2 id="刷新邻接页"><a href="#刷新邻接页" class="headerlink" title="刷新邻接页"></a>刷新邻接页</h2><p>InnoDB存储引擎还提供了Flush Neighbor Page（刷新邻接页）的特性。其工作原理为：<strong>当刷新一个脏页时，InnoDB存储引擎会检测该页所在区的所有页，如果是脏页，那么一起进行刷新。这样做的好处显而易见，通过AIO可以将多个IO写入操作合并为一个IO操作，故该工作机制在传统机械磁盘下有着显著的优势，但是需要考虑下面两个问题：</strong></p><ul><li>是不是可能将不怎么脏的页进行了写入，而该页之后又会很快变成脏页？</li><li>固态硬盘有着较高的IOPS，是否还需要这个特性？<br>为此，InnoDB存储引擎从1.2x版本开始提供参数innodb_flush_neighbors，用来控制是否启用该特性，<strong>对于传统机械硬盘建议启用该特性，而对于固态硬盘有着超高IOPS性能的磁盘，则建议将该参数设置为0，即关闭此特性。</strong></li></ul><h1 id="启动、关闭与恢复"><a href="#启动、关闭与恢复" class="headerlink" title="启动、关闭与恢复"></a>启动、关闭与恢复</h1><p>InnoDB存储引擎的启动和关闭，更准确的是指在MySQL实例的启动过程中对InnoDB存储引擎中的处理过程。</p><p>在关闭时，参数innodb_fast_shutdown影响着表的存储引擎为InnoDB的行为。该参数取值为0、1、2，默认为1：</p><ul><li><strong>0表示在MySQL数据库关闭时，InnoDB需要完成所有的full purge和merge insert buffer，并且将所有的脏页刷新回磁盘。</strong>这需要一些时间，有时甚至需要几个小时来完成。如果在进行InnoDB升级时，必须将这个参数调为0，然后再关闭数据库。</li><li><strong>1是参数innodb_fast_shutdown的默认值，表示不需要完成上述的full purge和merge insert buffer操作，但是在缓冲池中的一些数据脏页还是会刷新回磁盘。</strong></li><li><strong>2表示不完成full purge和merge insert buffer操作，也不将缓冲池中的数据脏页写回磁盘，而是将日志都写入日志文件，这样不会有任何事务的丢失，但是下次MySQL数据库启动时，会进行恢复操作。</strong></li></ul><p>当正常关闭数据库时，下次的启动应该会非常“正常”。<strong>但是如果没有正常的关闭数据库，</strong>如用kill命令关闭数据库，在MySQL数据库运行中重启了服务器，或者在关闭数据库时，将innodb_fast_shutdown设为了2时，<strong>下次MySQL数据库启动时都会对InnoDB存储引擎的表进行恢复操作。</strong></p><p><strong>参数innodb_force_recovery影响了整个InnoDB存储引擎恢复的状况，该参数默认为0，代表当发生需要恢复时，进行所有的恢复操作，当不能进行有效恢复时，如数据页发生了corruption，MySQL数据库可能发生宕机，并把数据写入错误日志中去。</strong></p><p>参数innodb_force_recovery还可以设置为6个非零值：1~6。大的数字包含了前面所有小数字表示的影响，具体情况如下：</p><ul><li>1 ：忽略检查到的corrupt页。</li><li>2 ：阻止Master Thread线程的运行，如Master Thread线程需要进行full purge操作，这会导致宕机。</li><li>3 ：不进行事务的回滚操作。</li><li>4 ：不进行插入缓冲的合并操作。</li><li>5 ：不查看撤销日志（Undo Log），InnoDB存储引擎会将未提交的事务视为已提交。</li><li>6 ： 不进行前滚的操作。</li></ul><p><strong>需要注意的是，在设置了参数innodb_force_recovery大于0后，用户可以对表进行select、create和drop操作，但是insert、update和delete这类DML操作是不允许的。</strong></p>]]></content>
    
    <summary type="html">
    
      InnoDB是事务安全的MySQL存储引擎，正是因为InnoDB的存在，才使MySQL数据库变得更有魅力，这里就详细介绍一下InnoDB存储引擎的体系架构及其不同于其他存储引擎的特性。
    
    </summary>
    
      <category term="MySQL" scheme="http://yoursite.com/categories/MySQL/"/>
    
    
  </entry>
  
  <entry>
    <title>Redis基础知识</title>
    <link href="http://yoursite.com/posts/33245/"/>
    <id>http://yoursite.com/posts/33245/</id>
    <published>2019-11-23T08:37:50.000Z</published>
    <updated>2019-11-23T13:20:24.718Z</updated>
    
    <content type="html"><![CDATA[<h1 id="线程模型"><a href="#线程模型" class="headerlink" title="线程模型"></a>线程模型</h1><p>redis 内部使用文件事件处理器 file event handler，这个文件事件处理器是单线程的，所以 redis 才叫做单线程的模型。它采用 IO 多路复用机制同时监听多个 socket，根据 socket 上的事件来选择对应的事件处理器进行处理。</p><p>文件事件处理器的结构包含 4 个部分：</p><ul><li>多个 socket</li><li>IO 多路复用程序</li><li>文件事件分派器</li><li>事件处理器（连接应答处理器、命令请求处理器、命令回复处理器）</li></ul><p>多个 socket 可能会并发产生不同的操作，每个操作对应不同的文件事件，但是 IO 多路复用程序会监听多个 socket，会将 socket 产生的事件放入队列中排队，事件分派器每次从队列中取出一个事件，把该事件交给对应的事件处理器进行处理。</p><h1 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h1><p>Redis可以存储键与5种不同数据结构类型之间的映射，这5种数据结构类型分别为STRING（字符串）、LIST（列表）、SET（集合）、HASH（散列）和ZSET（有序集合）。</p><table><thead><tr><th>结构类型</th><th>结构存储的值</th><th>结构的读写能力</th></tr></thead><tbody><tr><td>STRING</td><td>可以是字符串、整数或者浮点数</td><td>对整个字符串或者字符串的其中一部分执行操作；对整数和浮点数执行自增或者自减操作</td></tr><tr><td>LIST</td><td>一个链表，链表上的每个节点都包含了一个字符串</td><td>从链表的两端推入或者弹出元素；根据偏移量对链表进行修剪；读取单个或者多个元素；根据值查找或者移除元素</td></tr><tr><td>SET</td><td>包含字符串的无序收集器，并且被包含的每个字符串都是独一无二的、各不相同的</td><td>添加、获取、移除的单个元素；检查一个元素是否存在于集合中；计算交集、并集、差集；从集合里面随机获取元素</td></tr><tr><td>HASH</td><td>包含键值对的无序散列表</td><td>添加、获取、移除单个键值对；获取所有键值对</td></tr><tr><td>ZSET（有序集合）</td><td>字符串成员（member）与浮点数权值（分值，score）之间的有序映射，元素的排列顺序由分值的大小决定</td><td>添加、获取、删除单个元素；根据分值范围或者成员来获取成员</td></tr></tbody></table><h2 id="字符串STRING"><a href="#字符串STRING" class="headerlink" title="字符串STRING"></a>字符串STRING</h2><p><img src="/posts/33245/TIM%E6%88%AA%E5%9B%BE20191117212603.png" alt><br>字符串可以存储三种类型的值：字节串、整数、浮点数。下面是对Redis字符串执行自增和自减操作的命令：<img src="/posts/33245/TIM%E6%88%AA%E5%9B%BE20191123174310.png" alt></p><p><strong>如果用户对一个不存在的键或者一个保存了空串的键执行自增或者自减操作，那么Redis在执行操作时会将这个键的值当作是0来处理。如果用户尝试对一个值无法被解释为整数或者浮点数的字符串执行自增或者自减操作，那么Redis将向用户返回一个错误。</strong></p><p>除了自增操作和自减操作之外，Redis还拥有对字节串的其中一部分进行读取或者写入的操作：<img src="/posts/33245/TIM%E6%88%AA%E5%9B%BE20191123174650.png" alt></p><h2 id="列表LIST"><a href="#列表LIST" class="headerlink" title="列表LIST"></a>列表LIST</h2><p><img src="/posts/33245/TIM%E6%88%AA%E5%9B%BE20191118203145.png" alt><br>Redis的列表允许用户从序列的两端推入或者弹出元素，获取列表元素，以及执行各种常见的列表操作。除此之外，列表还可以用来存储任务信息、最近浏览过的文章或者常用联系人信息。下面是一部分常用的列表命令：<img src="/posts/33245/TIM%E6%88%AA%E5%9B%BE20191123175003.png" alt></p><p>其次下面还有一些可以将元素从一个列表移动到另一个列表，或者阻塞执行命令的客户端直到有其他客户端给列表添加元素为止的命令：<img src="/posts/33245/TIM%E6%88%AA%E5%9B%BE20191123175457.png" alt></p><h2 id="集合SET"><a href="#集合SET" class="headerlink" title="集合SET"></a>集合SET</h2><p><img src="/posts/33245/TIM%E6%88%AA%E5%9B%BE20191123175709.png" alt><br>Redis的集合以无序的方式来存储多个各不相同的元素，用户可以快速地对集合执行添加元素操作、移除元素操作以及检查一个元素是否存在于集合里：<img src="/posts/33245/TIM%E6%88%AA%E5%9B%BE20191123175849.png" alt></p><p>除此之外，集合真正厉害的地方在于组合和关联多个集合：<img src="/posts/33245/TIM%E6%88%AA%E5%9B%BE20191123180059.png" alt></p><h2 id="散列HASH"><a href="#散列HASH" class="headerlink" title="散列HASH"></a>散列HASH</h2><p><img src="/posts/33245/TIM%E6%88%AA%E5%9B%BE20191123180804.png" alt><br>Redis的散列可以让用户将多个键值对存储到一个Redis键里面。下面是最常用的散列命令，其中包括添加和删除键值对的命令、获取所有键值对的命令，以及对键值对的值进行自增或者自建操作的命令：<img src="/posts/33245/TIM%E6%88%AA%E5%9B%BE20191123180949.png" alt></p><p>下面是散列的其它几个批量操作命令，以及一些和字符串操作类似的散列命令：<img src="/posts/33245/TIM%E6%88%AA%E5%9B%BE20191123181306.png" alt></p><h2 id="有序集合ZSET"><a href="#有序集合ZSET" class="headerlink" title="有序集合ZSET"></a>有序集合ZSET</h2><p><img src="/posts/33245/TIM%E6%88%AA%E5%9B%BE20191123181419.png" alt><br>和散列存储着键与值之间的映射类似，有序集合也存储着成员与分值之间的映射，并且提供了分值处理命令，以及根据分值大小有序的获取或者扫描成员和分值的命令。<img src="/posts/33245/TIM%E6%88%AA%E5%9B%BE20191123181546.png" alt></p><p>除此之外，下面是另外一些非常有用的有序集合命令：<img src="/posts/33245/TIM%E6%88%AA%E5%9B%BE20191123181634.png" alt></p><h1 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h1><h2 id="字典（渐进式rehash）"><a href="#字典（渐进式rehash）" class="headerlink" title="字典（渐进式rehash）"></a>字典（渐进式rehash）</h2><p>在Redis种，键值对存储方式是由字典（Dict）保存的，而字典底层是通过哈希表来是西安的，通过哈希表中的节点保存字典中的键值对。我们知道当HashMap中由于hash冲突超过某个阈值时，处于链表性能的考虑，会进行Resize操作，Redis也一样。</p><p><strong>在Redis的具体实现中，使用了一种叫做渐进式rehash的方式来提高字典的缩放效率，避免rehash对服务器性能的影响，渐进式rehash的好处在于它采取分而治之的方式，将rehash键值对所需的计算工作均摊到对字典的每个添加、删除、查找和更新操作上，从而避免了集中式rehash而带来的庞大计算量。</strong></p><h3 id="字典结构"><a href="#字典结构" class="headerlink" title="字典结构"></a>字典结构</h3><p>字典的结构如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dict</span> &#123;</span></span><br><span class="line">    dictType *type;<span class="comment">//是一个指向dictType结构的指针，每个dictType结构保存了一簇用于特定操作类型键值对的函数，Redis会为用途不同的字典设置不同的类型特定函数</span></span><br><span class="line">    <span class="keyword">void</span> *privdata; <span class="comment">//保存了需要传给那些类型特定函数的可选参数</span></span><br><span class="line">    dictht ht[<span class="number">2</span>];<span class="comment">//在字典内部，为了两张哈希表，一般情况下，字典只使用ht[0]哈希表，ht[1]哈希表只会在对ht[0]哈希表进行rehash时使用</span></span><br><span class="line">    <span class="keyword">long</span> rehashidx;<span class="comment">//记录了rehash目前的进度，如果目前没有在进行rehash，那么它的值为 -1</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> iterators;<span class="comment">//当前运行的迭代器的数量</span></span><br><span class="line">&#125; dict;</span><br></pre></td></tr></table></figure><p>字典中存放的哈希表结构如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictht</span> &#123;</span></span><br><span class="line">    dictEntry **table;<span class="comment">//哈希表数组，数组的每个项是dictEntry链表的头结点指针</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> size;<span class="comment">//哈希表大小，在Redis实现中，size也是触发扩容的阈值</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> sizemask;<span class="comment">//哈希表大小掩码，用于计算索引；总是等于 size-1</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> used;<span class="comment">//哈希表中保存的节点数量</span></span><br><span class="line">&#125; dictht;</span><br></pre></td></tr></table></figure><p>节点的结构如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictEntry</span> &#123;</span></span><br><span class="line">    <span class="keyword">void</span> *key;                <span class="comment">//键</span></span><br><span class="line">    <span class="keyword">union</span> &#123;</span><br><span class="line">        <span class="keyword">void</span> *val;            <span class="comment">//值</span></span><br><span class="line">        <span class="keyword">uint64_t</span> u64;</span><br><span class="line">        <span class="keyword">int64_t</span> s64;</span><br><span class="line">        <span class="keyword">double</span> d;</span><br><span class="line">    &#125; v;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dictEntry</span> *<span class="title">next</span>;</span> <span class="comment">//指向下一个节点，形成链表</span></span><br><span class="line">&#125; dictEntry;</span><br></pre></td></tr></table></figure><p><strong>从哈希表节点结构中，可以看出，在redis中解决hash冲突的方式为采用链地址法。key和v分别用于保存键值对的键和值。</strong></p><h3 id="渐进式rehash的步骤"><a href="#渐进式rehash的步骤" class="headerlink" title="渐进式rehash的步骤"></a>渐进式rehash的步骤</h3><p><strong>在Redis中，扩展或收缩哈希表需要将ht[0]中的所有键值对rehash到ht[1]里面，但是这个rehash动作并不是一次性、集中式的完成，而是分多次、渐进式的完成的。为了避免rehash对服务器性能造成影响，服务器不是一次性将ht[0]里面的所有键值对全部rehash到ht[1]中，而是分多次、渐进式的将ht[0]里面的键值对慢慢的rehash到ht[1]。</strong></p><p>以下是哈希表渐进式rehash的详细步骤：</p><ol><li><strong>为ht[1]分配空间，让字典同时持有ht[0]和ht[1]两个哈希表。</strong></li><li><strong>在字典中维持一个索引计数器变量rehashidx，并将它的值设置为0，表示rehash工作正式开始。</strong></li><li><strong>在rehash进行期间，每次对字典执行添加、删除、查找或者更新操作时，程序除了执行指定的操作以外，还会顺带将ht[0]哈希表在rehashidx索引上的所有键值对rehash到ht[1]中，当rehash工作完成之后，程序将rehashidx属性的值加1。</strong></li><li><strong>随着字典操作的不断执行，最终在某个时间节点上，ht[0]的所有键值对都会被rehash至ht[1]，这时程序将rehashidx属性的值设为-1，表示rehash操作已完成。</strong></li></ol><p><strong>渐进式rehash的好处在于它采取分而治之的方式，将rehash键值对所需要的计算工作均摊到对字典的每个添加、删除、查找和更新操作上，从而避免了集中式rehash而带来的庞大计算量。</strong></p><h3 id="渐进式rehash执行期间的哈希表"><a href="#渐进式rehash执行期间的哈希表" class="headerlink" title="渐进式rehash执行期间的哈希表"></a>渐进式rehash执行期间的哈希表</h3><p><strong>因为在渐进式rehash的过程中，字典会同时使用ht[0]和ht[1]两个哈希表，所以在渐进式rehash进行期间，字典的删除、查找和更新等操作都会在两个哈希表上进行，例如要在字典里面查找一个键的话，程序会先在ht[0]里面进行查找，如果没找到就会继续在ht[1]里面进行查找。</strong></p><p><strong>另外，在渐进式rehash执行期间，新添加到字典的键值对一律会被保存到ht[1]中，而ht[0]则不再进行任何添加操作。这一措施保证了ht[0]包含的键值对数量只减不增，并随着rehash操作的执行而最终变成空表。</strong></p><h3 id="渐进式rehash的问题"><a href="#渐进式rehash的问题" class="headerlink" title="渐进式rehash的问题"></a>渐进式rehash的问题</h3><p><strong>渐进式rehash避免了Redis阻塞，可以说非常完美，但是由于在rehash时，需要分配一个新的hash表，在rehash期间，同时有两个hash表使用，会使得Redis内存使用量瞬间突增，在Redis满容状态下，由于rehash会导致大量Key驱逐。</strong></p><h2 id="跳表skiplist"><a href="#跳表skiplist" class="headerlink" title="跳表skiplist"></a>跳表skiplist</h2><p><strong>跳表是有序集合的底层实现之一。跳表（skiplist）是一种随机化的数据，它是基于多指针有序链表实现，可以看成多个有序链表。</strong><img src="/posts/33245/beba612e-dc5b-4fc2-869d-0b23408ac90a.png" alt></p><p>在查找时，从上层指针开始查找，找到对应的区间再进行到下一层去查找，下面是查找22的过程：<img src="/posts/33245/0ea37ee2-c224-4c79-b895-e131c6805c40.png" alt></p><p>跳表的特点如下：</p><ul><li>跳跃表是一种随机化数据结构，查找、添加、删除操作都可以在对数期望时间下完成。</li><li>跳跃表目前在 Redis 的唯一作用，就是作为有序集类型的底层数据结构（之一，另一个构成有序集的结构是字典）。</li><li>为了满足自身的需求，Redis 对跳表进行了修改，包括：</li><li><ul><li><strong>score 值可重复。</strong></li><li><strong>对比一个元素需要同时检查它的 score 和 memeber 。</strong></li><li><strong>每个节点带有高度为 1 层的后退指针，用于从表尾方向向表头方向迭代。</strong></li></ul></li></ul><p>与红黑树等平衡树相比，跳跃表具有以下优点：</p><ul><li>插入速度非常快速，因为不需要进行旋转等操作来维护平衡性。</li><li>更容易实现。</li><li>支持无锁操作。</li></ul><h1 id="键的过期时间"><a href="#键的过期时间" class="headerlink" title="键的过期时间"></a>键的过期时间</h1><p>Redis中有个设置时间过期的功能，即对存储在 Redis 数据库中的值可以设置一个过期时间。作为一个缓存数据库，这是非常实用的。如我们一般项目中的 Token 或者一些登录信息，尤其是短信验证码都是有时间限制的，按照传统的数据库处理方式，一般都是自己判断过期，这样无疑会严重影响项目性能。</p><p>我们 set key 的时候，都可以给一个 expire time，就是过期时间，通过过期时间我们可以指定这个 key 可以存活的时间。</p><p>如果假设你设置了一批 key 只能存活1个小时，那么接下来1小时后，redis是怎么对这批key进行删除的？Redis有两种删除策略：</p><ul><li><strong>定期删除</strong>：Redis默认是每隔 100ms 就随机抽取一些设置了过期时间的key，检查其是否过期，如果过期就删除。注意这里是随机抽取的。为什么要随机呢？你想一想假如 redis 存了几十万个 key ，每隔100ms就遍历所有的设置过期时间的 key 的话，就会给 CPU 带来很大的负载！</li><li><strong>惰性删除 ：</strong>定期删除可能会导致很多过期 key 到了时间并没有被删除掉。所以就有了惰性删除。假如你的过期 key，靠定期删除没有被删除掉，还停留在内存里，除非你的系统去查一下那个 key，才会被redis给删除掉。</li></ul><p>但是仅仅通过设置过期时间还是有问题的。我们想一下：如果定期删除漏掉了很多过期 key，然后你也没及时去查，也就没走惰性删除，此时会怎么样？如果大量过期key堆积在内存里，导致Redis内存块耗尽了。怎么解决这个问题呢？ Redis 内存淘汰机制。</p><h1 id="Redis内存淘汰机制"><a href="#Redis内存淘汰机制" class="headerlink" title="Redis内存淘汰机制"></a>Redis内存淘汰机制</h1><p>Redis可以设置内存最大使用量，当内存使用量超出时，会施行数据淘汰策略：</p><table><thead><tr><th>策略</th><th>描述</th></tr></thead><tbody><tr><td><code>volatile-lru</code></td><td>从已设置过期时间的数据集中挑选最近最少使用的数据淘汰</td></tr><tr><td><code>allkeys-lru</code></td><td>当内存不足以容纳新写入数据时，在键空间中，移除最近最少使用的Key（这个是最常用的）</td></tr><tr><td><code>volatile-random</code></td><td>从已设置过期时间的数据集中任意选择数据淘汰</td></tr><tr><td><code>allkeys-random</code></td><td>从数据集中任意选择数据淘汰</td></tr><tr><td><code>volatile-ttl</code></td><td>从已设置过期时间的数据集中挑选将要过期的数据淘汰</td></tr><tr><td><code>no-eviction</code></td><td>禁止驱逐数据，也就是说当内存不足以容纳新写入数据时，新写入操作会报错。</td></tr></tbody></table><p>Redis4.0版本后增加以下两种：</p><table><thead><tr><th>策略</th><th>描述</th></tr></thead><tbody><tr><td><code>volatile-lfu</code></td><td>从已设置过期时间的数据集中挑选最不经常使用的数据淘汰</td></tr><tr><td><code>allkeys-lfu</code></td><td>当内存不足以容纳新写入数据时，在键空间中，移除最不经常使用的Key</td></tr></tbody></table><h1 id="持久化"><a href="#持久化" class="headerlink" title="持久化"></a>持久化</h1><p>Redis是内存型数据库，为了保证数据在断电后不会丢失，需要将内存中的数据持久化到硬盘上，Redis通过了两种不同的持久化方法来将数据存储到硬盘里面：<strong>快照（RDB）和只追加文件（AOF）。</strong></p><ul><li><strong>快照（RDB）</strong>：它可以将存在于某一时刻的所有数据都写入硬盘里面。</li><li><strong>只追加文件（AOF）</strong>：它会在执行写命令时，将被执行的写命令复制到硬盘里面。</li></ul><p>这两种方法既可以同时使用，也可以单独使用，在某些情况下甚至可以两种方法都不使用。</p><h2 id="快照持久化（RDB）"><a href="#快照持久化（RDB）" class="headerlink" title="快照持久化（RDB）"></a>快照持久化（RDB）</h2><p>Redis可以通过创建快照来获得存储在内存里面的数据在某个时间点上的副本。在创建快照之后，用户可以对快照进行备份，可以将快照复制到其他服务器从而创建具有相同数据的服务器副本，还可以将快照留在原地以便重启服务器时使用。</p><p>根据配置，快照将被写入 dbfilename 选项指定的文件里面，并存储在dir选项指定的路径上面。如果在新的快照文件创建完毕之前，Redis、系统或者硬件这三者之中的任意一个崩溃了，那么Redis将会丢失最近一次创建快照之后写入的所有数据。</p><p>创建快照的办法有以下几种：</p><ul><li><strong>客户端可以通过向Redis发送<code>BGSAVE</code>命令来创建以恶搞快照。对于支持<code>BGSAVE</code>命令的平台来说（基本所有平台都支持，除了Windows平台），Redis会调用fork来创建一个子进程，然后子进程负责将快照写入硬盘，而父进程则继续处理命令请求。</strong></li><li><strong>客户端还可以通过向Redis发送<code>SAVE</code>命令来创建一个快照，接到<code>SAVE</code>命令的Redis服务器在创建完毕之前将不再响应任何其它命令。SAVE命令并不常用，我们通常只会在没有足够内存去执行BGSAVE命令的情况下，又或者即使等待持久化操作执行完毕也无所谓的情况下，才会使用这个命令。</strong></li><li><strong>如果用户设置了save配置选项，比如<code>save 60 10000</code>，那么从Redis最近一次创建快照之后开始算起，当“60秒之内有10000次写入”这个条件被满足时，Redis就会自动触发BGSAVE命令。如果用户设置了多个save配置选项，那么当任意一个save配置选项所设置的条件被满足时，Redis就会触发一次BGSAVE命令。</strong></li><li><strong>当Redis通过SHUTDOWN命令接收到关闭服务器的请求时，或者接收到标准的TERM信号时，会执行一个SAVE命令，阻塞所有客户端，不在执行客户端发送的任何命令，并在SAVE命令执行完毕之后关闭服务器。</strong></li><li><strong>当一个Redis服务器连接另一个Redis服务器，并向对方发送SYNC命令来开始一次复制操作时，如果主服务器目前没有在执行BGSAVE操作，或者主服务器并非刚刚执行完BGSAVE操作，那么主服务器就会执行BGSAVE命令。</strong></li></ul><p>在使用快照持久化来保存数据时，一定要记住：<strong>如果系统真的发生崩溃，用户将丢失最近一次生成快照之后更改的所有数据。因此，快照持久化只适用于那些即使丢失一部分数据也不会造成问题的应用程序，</strong>而不能接受这种数据损失的应用程序，则可以考虑下面的AOF持久化方式。</p><h2 id="只追加文件持久化（AOF）"><a href="#只追加文件持久化（AOF）" class="headerlink" title="只追加文件持久化（AOF）"></a>只追加文件持久化（AOF）</h2><p><strong>AOF持久化会将被执行的写命令写到AOF文件的末尾，以此来记录数据发生的变化。因此，Redis只要从头到尾执行一次AOF文件包含的所有写命令，就可以恢复AOF文件所记录的数据集。AOF文件可以通过设置<code>appendonly yes</code>配置选项来打开。</strong></p><p>使用AOF持久化需要设置同步选项，从而确保写命令同步到磁盘文件上的时机：</p><table><thead><tr><th>选项</th><th>同步频率</th><th>性能</th></tr></thead><tbody><tr><td>always</td><td>每个Redis写命令都要同步写入硬盘</td><td>这样做会严重降低Redis的速度和服务器的性能</td></tr><tr><td>everysec</td><td>每秒执行一次同步，显式的将多个写命令同步到硬盘</td><td>比较合适，可以保证系统崩溃时只会丢失一秒左右的数据，并且Redis每秒执行一次同步对服务器性能几乎没有任何影响</td></tr><tr><td>no</td><td>让操作系统来决定应该何时进行同步</td><td>并不能给服务器性能带来多大的提升，而且也会增加系统崩溃时数据丢失的数量</td></tr></tbody></table><h3 id="重写-压缩AOF文件"><a href="#重写-压缩AOF文件" class="headerlink" title="重写/压缩AOF文件"></a>重写/压缩AOF文件</h3><p>因为Redis会不断的将被执行的写命令记录到AOF文件里面，所以随着Redis不断运行，AOF文件的体积也会不断的增长，在极端的情况下，体积不断增大的AOF文件甚至可能会用完硬盘的所有可用空间。</p><p>还有另外一个问题就是，因为Redis再重启之后需要通过重新执行AOF文件记录的所有写命令来还原数据，所以如果AOF文件的体积非常大，那么还原操作执行的时间就可能会非常长。</p><p><strong>为了解决AOF文件体积不断增大的问题，用户可以向Redis发送<code>BGREWRITENAOF</code>命令，这个命令会通过移除AOF文件中的冗余命令来重写AOF文件，使AOF文件的体积变得尽可能小。</strong></p><p><strong><code>BGWRITENAOF</code>的工作原理和BGSAVE创建快照的工作原理非常相似：Redis会创建一个子进程，然后由子进程负责对AOF文件进行重写。因为AOF文件重写也需要用到子进程，所以快照持久化因为创建子进程而导致的性能问题和内存占用问题，在AOF持久化中也同样存在。</strong></p><h1 id="复制"><a href="#复制" class="headerlink" title="复制"></a>复制</h1><p><strong>对于一个正在运行的服务器，用户可以通过<code>SLAVEOF host port</code>命令来让服务器开始复制一个新的主服务器，也可以通过发送<code>SLAVEOF no one</code>命令来让服务器终止复制操作，不再接受主服务器的数据更新。</strong></p><h2 id="复制的启动过程"><a href="#复制的启动过程" class="headerlink" title="复制的启动过程"></a>复制的启动过程</h2><p><img src="/posts/33245/TIM%E6%88%AA%E5%9B%BE20191123200406.png" alt></p><p>Redis再复制进行期间也会尽可能的处理接收到的命令请求，但是，如果主从服务器之间的网络带宽不足，或者主服务器没有足够的内存来创建子进程和创建记录写命令的缓冲区，那么Redis处理命令请求的效率就会收到影响。<strong>因此，尽管这并不是必须的，但是在实际中最好还是让主服务器只使用50%~65%的内存，留下30%~45%的内存用于执行BGSAVE命令和创建记录写命令的缓冲区。</strong></p><p>当多个从服务器尝试连接同一个主服务器时，就会出现下表中的其中一种情况：<img src="/posts/33245/TIM%E6%88%AA%E5%9B%BE20191123200942.png" alt></p><h2 id="主从链"><a href="#主从链" class="headerlink" title="主从链"></a>主从链</h2><p>随着负载不断上升，主服务器可能无法很快地更新所有从服务器，或者重新连接和重新同步从服务器将导致系统超载。为了解决这个问题，可以创建一个中间层来分担主服务器的复制工作。中间层的服务器是最上层服务器的从服务器，又是最下层服务器的主服务器。<br><img src="/posts/33245/395a9e83-b1a1-4a1d-b170-d081e7bb5bab.png" alt></p><h2 id="检验硬盘写入"><a href="#检验硬盘写入" class="headerlink" title="检验硬盘写入"></a>检验硬盘写入</h2><p><strong>为了验证主服务器是否已经将写数据发送至从服务器，用户需要在向主服务器写入真正的数据之后，再向主服务器写入一个唯一的虚构值，然后通过检查虚构值是否存在于从服务器来判断写数据是否已经到达从服务器。</strong></p><p><strong>更节约时间的做法是，检查INFO命令的输出结果中<code>aof_pending_bio_fsync</code>属性的值是否为0，如果是的话，那么就表示服务器已经将一致的所有数据都保存到硬盘里面了。</strong></p><h1 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h1><p>在Redis中实现事务主要依靠以下几个命令来实现：<img src="/posts/33245/u=3446052217,1826798516&fm=173&app=49&f=JPEG.jpg" alt></p><p>Redis事务从开始到结束通常会通过三个阶段:</p><ul><li>事务开始</li><li>命令入队</li><li>事务执行</li></ul><p>事务的特点：</p><ul><li>事务提供了一种将多个命令打包，然后一次性、有序地执行的机制。</li><li><strong>事务在执行过程中不会被中断，所有事务命令执行完之后，事务才能结束。</strong></li><li>多个命令会被入队到事务队列中，然后按先进先出（FIFO）的顺序执行。</li><li>带 WATCH 命令的事务会将客户端和被监视的键在数据库的 watched_keys 字典中进行关联，当键被修改时，程序会将所有监视被修改键的客户端的 REDIS_DIRTY_CAS 选项打开。</li><li>只有在客户端的 REDIS_DIRTY_CAS 选项未被打开时，才能执行事务，否则事务直接返回失败。</li><li><strong>Redis 的事务保证了 ACID 中的一致性（C）和隔离性（I），但并不保证原子性（A）和持久性（D）。</strong></li><li><strong>Redis同一个事务中如果有一条命令执行失败，其后的命令仍然会被执行，没有回滚。</strong></li></ul><h1 id="缓存雪崩、缓存穿透和缓存击穿"><a href="#缓存雪崩、缓存穿透和缓存击穿" class="headerlink" title="缓存雪崩、缓存穿透和缓存击穿"></a>缓存雪崩、缓存穿透和缓存击穿</h1><h2 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h2><p>简介：<strong>缓存同一时间大面积的失效，所以，后面的请求都会落到数据库上，造成数据库短时间内承受大量请求而崩掉。</strong></p><p>解决办法：</p><ul><li><strong>事前：尽量保证整个 Redis 集群的高可用性，发现机器宕机尽快补上。选择合适的内存淘汰策略。</strong></li><li><strong>事中：本地ehcache缓存 + hystrix限流&amp;降级，避免MySQL崩掉。限流组件，可以设置每秒的请求，有多少能通过组件，剩余的未通过的请求，怎么办？走降级！可以返回一些默认的值，或者友情提示，或者空白的值。</strong></li><li><strong>事后：利用 redis 持久化机制保存的数据尽快恢复缓存。</strong></li></ul><h2 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h2><p><strong>简介：一般是黑客故意去请求缓存中不存在的数据，导致所有的请求都落到数据库上，造成数据库短时间内承受大量请求而崩掉。</strong></p><p><strong>解决方式很简单，每次系统 A 从数据库中只要没查到，就写一个空值到缓存里去，比如 set -999 UNKNOWN。然后设置一个过期时间，这样的话，下次有相同的 key 来访问的时候，在缓存失效之前，都可以直接从缓存中取数据。</strong></p><h2 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h2><p><strong>缓存击穿，就是说某个 key 非常热点，访问非常频繁，处于集中式高并发访问的情况，当这个 key 在失效的瞬间，大量的请求就击穿了缓存，直接请求数据库，就像是在一道屏障上凿开了一个洞。</strong></p><p>不同场景下的解决方式可如下：</p><ul><li>若缓存的数据是基本不会发生更新的，则可尝试将该热点数据设置为永不过期。</li><li>若缓存的数据更新不频繁，且缓存刷新的整个流程耗时较少的情况下，则可以采用基于 redis、zookeeper 等分布式中间件的分布式互斥锁，或者本地互斥锁以保证仅少量的请求能请求数据库并重新构建缓存，其余线程则在锁释放后能访问到新缓存。</li><li>若缓存的数据更新频繁或者缓存刷新的流程耗时较长的情况下，可以利用定时线程在缓存过期前主动的重新构建缓存或者延后缓存的过期时间，以保证所有的请求能一直访问到对应的缓存。</li></ul><h1 id="Redis的并发竞争Key"><a href="#Redis的并发竞争Key" class="headerlink" title="Redis的并发竞争Key"></a>Redis的并发竞争Key</h1><p>在并发情况下，写请求可能发⽣生竞争，例例如将age的数值加1，⼀一般是取出age,加1，然后set回去。因为是两步操作，存在并发问题，例例如A线程还没set回去时候，其他线程完成了了+1的操作。一般可以通过如下⽅方式解决：</p><ul><li>*<em>使用自带的INCR原子命令。 *</em></li><li><strong>客户端对两步操作加锁，Java原生的或者redis的setnx 。</strong></li><li><strong>使用redis的事务功能。</strong></li></ul><p>Redis通过multi,exec,watch完成对事务的⽀支持。事务能将多个命令打包执⾏，Redis⼀次性、按顺序执⾏，然后结果⼀起返回，执⾏事务过程中不会中断去处理其他请求。</p><p>Redis将事务中的命令放进一个队列，当exec请求时，依次执行队列中的命名，将结果一次放进一个结果队列，然后返回结果队列，需要注意的是，Redis不会因为任意命令的失败而进⾏回滚操作，不论成功失败，都会全部执行完，然后返回结果。 </p><p>*<em>Redis通过watch实现事务的乐观锁，每个redis实例都维护着一个watch_keys字典，记录着key被监视的客户端，当有修改请求时，就会将监视这个key的所有客户端的REDIS_DIRTY_CAS标识打开。当请求exec时，服务器器发现请求客户端的标示打开，说明有数据发⽣生了了修改，则会拒绝执⾏提交的事务。 *</em></p><h1 id="缓存与数据库双写时的数据一致性"><a href="#缓存与数据库双写时的数据一致性" class="headerlink" title="缓存与数据库双写时的数据一致性"></a>缓存与数据库双写时的数据一致性</h1><p>一般情况下我们都是这样使用缓存的：先读缓存，缓存没有的话，就读数据库，然后取出数据后放入缓存，同时返回响应。这种方式很明显会存在缓存和数据库的数据不一致的情况。</p><p>一般来说，如果允许缓存可以稍微的跟数据库偶尔有不一致的情况，也就是说如果你的系统不是严格要求 “缓存+数据库” 必须保持一致性的话，最好不要做这个方案，即：读请求和写请求串行化，串到一个内存队列里去。</p><p>串行化可以保证一定不会出现不一致的情况，但是它也会导致系统的吞吐量大幅度降低，用比正常情况下多几倍的机器去支撑线上的一个请求。</p><p>读的时候，先读缓存，缓存没有的话，就读数据库，然后取出数据后放入缓存，同时返回响应<strong>。更新的时候，先更新数据库，然后再删除缓存。</strong></p><p>如果删除缓存失败了，那么会导致数据库中是新数据，缓存中是旧数据，数据就出现了不一致。</p><p><strong>解决思路：先删除缓存，再更新数据库。如果数据库更新失败了，那么数据库中是旧数据，缓存中是空的，那么数据不会不一致。因为读的时候缓存没有，所以去读了数据库中的旧数据，然后更新到缓存中。</strong></p><p><strong>数据发生了变更，先删除了缓存，然后要去修改数据库，此时还没修改。一个请求过来，去读缓存，发现缓存空了，去查询数据库，查到了修改前的旧数据，放到了缓存中。随后数据变更的程序完成了数据库的修改。完了，数据库和缓存中的数据不一样了…</strong></p><p>解决思路：</p><ul><li><strong>延迟双删</strong></li><li><strong>更新数据的时候，根据数据的唯一标识，将操作路由之后，发送到一个 jvm 内部队列中。读取数据的时候，如果发现数据不在缓存中，那么将重新执行“读取数据+更新缓存”的操作，根据唯一标识路由之后，也发送到同一个 jvm 内部队列中。</strong></li></ul><p>一个队列对应一个工作线程，每个工作线程串行拿到对应的操作，然后一条一条的执行。这样的话，一个数据变更的操作，先删除缓存，然后再去更新数据库，但是还没完成更新。此时如果一个读请求过来，没有读到缓存，那么可以先将缓存更新的请求发送到队列中，此时会在队列中积压，然后同步等待缓存更新完成。</p><p>这里有一个优化点，一个队列中，其实多个更新缓存请求串在一起是没意义的，因此可以做过滤，如果发现队列中已经有一个更新缓存的请求了，那么就不用再放个更新请求操作进去了，直接等待前面的更新操作请求完成即可。</p><h1 id="Redis与Memcache的区别"><a href="#Redis与Memcache的区别" class="headerlink" title="Redis与Memcache的区别"></a>Redis与Memcache的区别</h1><p><img src="/posts/33245/61603179.jpg" alt></p>]]></content>
    
    <summary type="html">
    
      Redis是一个典型的非关系型（NoSQL）远程内存数据库，不过与传统数据库不同的是Redis的数据是存在内存中的，所以读写速度非常快，因此Redis被广泛应用于缓存方向。另外，Redis也经常被用来做分布式锁。Redis提供了多种数据结构来支持不同的业务场景。
    
    </summary>
    
      <category term="Redis" scheme="http://yoursite.com/categories/Redis/"/>
    
    
  </entry>
  
  <entry>
    <title>代理模式</title>
    <link href="http://yoursite.com/posts/48003/"/>
    <id>http://yoursite.com/posts/48003/</id>
    <published>2019-11-16T12:29:28.000Z</published>
    <updated>2019-11-16T13:06:49.142Z</updated>
    
    <content type="html"><![CDATA[<h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><p><strong>代理模式为另一个对象提供一个替身或占位符以控制这个对象的访问。</strong></p><h1 id="结构图"><a href="#结构图" class="headerlink" title="结构图"></a>结构图</h1><p><img src="/posts/48003/9b679ff5-94c6-48a7-b9b7-2ea868e828ed.png" alt></p><h1 id="代理的分类"><a href="#代理的分类" class="headerlink" title="代理的分类"></a>代理的分类</h1><p>代理有以下四种：</p><ul><li><strong>远程代理</strong>：控制对远程对象（不同地址空间）的访问，它负责将请求及其参数进行编码，并向不同地址空间中的对象发送已经编码的请求。</li><li><strong>虚拟代理</strong>：根据需要创建开销很大的对象，它可以缓存实体的附加信息，以便延迟对它的访问，例如在网站加载一张很大的图片时，不能马上完成，可以用虚拟代理缓存图片的大小信息，然后生成一张临时图片代替原始图片。</li><li><strong>保护代理</strong>：按权限控制对象的访问，它负责检查调用者是否具有实现一个请求必须的访问权限。</li><li><strong>智能代理</strong>：取代了简单的指针，它在访问对象时执行一些附加操作：记录对象的引用次数；当第一次引用一个对象时，将它装入内存；在访问一个实际对象前，检查是否已经锁定了它，以确保其它对象不能改变它。</li></ul><h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><p>以下是一个虚拟代理的实现，模拟了图片延迟加载的情况下，使用一个临时的图片去替换原始图片，直到原图片加载完成才将图片显示出来。</p><p>下面先建立一个标识图片的接口和一个具体的实现类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Image</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>图片实现类中，写明图片需要三秒钟才可以加载完成。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HighResolutionInage</span> <span class="keyword">implements</span> <span class="title">Image</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> URL imageURL;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">long</span> startTime;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HighResolutionInage</span><span class="params">(URL imageURL)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.imageURL = imageURL;</span><br><span class="line">startTime = System.currentTimeMillis();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isLoad</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">long</span> currTime = System.currentTimeMillis();</span><br><span class="line"><span class="keyword">return</span> currTime - startTime &gt; <span class="number">3000</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"Real ImageURL:"</span> + imageURL);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面就建立一个代理，用来延迟加载图片时使用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ImageProxy</span> <span class="keyword">implements</span> <span class="title">Image</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> HighResolutionInage highResolutionInage;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ImageProxy</span><span class="params">(HighResolutionInage highResolutionInage)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.highResolutionInage = highResolutionInage;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">while</span>(!highResolutionInage.isLoad()) &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">System.out.println(<span class="string">"Temp Image..."</span>);</span><br><span class="line">Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">highResolutionInage.show();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代理类每隔一秒钟请求原图片是否加载完成，如果加载完成则显示原图片，加载未完成就显示临时图片。下面写一个客户端类测试：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> MalformedURLException </span>&#123;</span><br><span class="line">URL url = <span class="keyword">new</span> URL(<span class="string">"http://image.jpg"</span>);</span><br><span class="line">HighResolutionInage highResolutionInage = <span class="keyword">new</span> HighResolutionInage(url);</span><br><span class="line">ImageProxy imageProxy = <span class="keyword">new</span> ImageProxy(highResolutionInage);</span><br><span class="line">imageProxy.show();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出内容如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Temp Image...</span><br><span class="line">Temp Image...</span><br><span class="line">Temp Image...</span><br><span class="line">Real ImageURL:http:<span class="comment">//image.jpg</span></span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li>代理模式为另一个对象提供代表，以便控制客户对对象的访问，管理访问的方式有许多种。</li><li>远程代理管理客户和远程对象之间的交互。</li><li>虚拟代理控制访问实例化开销很大。</li><li>保护代理基于调用者控制对象方法的访问。</li><li>代理模式有许多变体，例如：缓存代理、同步代理、防火墙代理和写入时复制代理。</li></ul>]]></content>
    
    <summary type="html">
    
      代理要做的就是：控制和管理访问。就像你将看到的，代理有许多种，代理以通过Internet为它们的代理对象搬运的整个方法调用而出名，它也可以代替某些懒惰的对象做一些事情。
    
    </summary>
    
      <category term="设计模式" scheme="http://yoursite.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
  </entry>
  
  <entry>
    <title>适配器模式与外观模式</title>
    <link href="http://yoursite.com/posts/50785/"/>
    <id>http://yoursite.com/posts/50785/</id>
    <published>2019-11-16T07:21:33.000Z</published>
    <updated>2019-11-16T08:32:13.009Z</updated>
    
    <content type="html"><![CDATA[<h1 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p><strong>适配器模式将一个类的接口，转换成客户期望的另一个接口，适配器让原本不兼容的类可以合作无间。</strong></p><p><img src="/posts/50785/TIM%E6%88%AA%E5%9B%BE20191116153205.png" alt><br>适配器工作起来就如同一个中间人，它将客户所发出的请求转换成厂商类能理解的请求。<br><img src="/posts/50785/TIM%E6%88%AA%E5%9B%BE20191116153327.png" alt></p><h2 id="结构图"><a href="#结构图" class="headerlink" title="结构图"></a>结构图</h2><p><img src="/posts/50785/ff5152fc-4ff3-44c4-95d6-1061002c364a.png" alt></p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>如果一个动物，走起路来像鸭子，叫起来像鸭子，那么它可能是一只包装了鸭子适配器的火鸡……</p><p>下面先创建鸭子的接口和一个鸭子的具体实现类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Duck</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">quack</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fly</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class MallarDuck implements Duck &#123;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void quack() &#123;</span><br><span class="line">System.out.println(&quot;Quack!&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void fly() &#123;</span><br><span class="line">System.out.println(&quot;I&apos;m flying!&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来创建与鸭子不同的火鸡接口和具体实现类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Turkey</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">gobble</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fly</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WildTurkey</span> <span class="keyword">implements</span> <span class="title">Turkey</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">gobble</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"Gobble gobble!"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fly</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"I'm flying a short distance"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>火鸡的叫声和鸭子不一样，而且飞行距离也没有鸭子远。</p><p>现在假设你缺鸭子对象，想用一些火鸡对象来冒充，显而易见，因为火鸡的接口不同，所以我们不能公然拿来用，因此就写一个适配器：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TurkeyAdapter</span> <span class="keyword">implements</span> <span class="title">Duck</span> </span>&#123;</span><br><span class="line">Turkey turkey;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">TurkeyAdapter</span><span class="params">(Turkey turkey)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.turkey = turkey;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">quack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">turkey.gobble();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fly</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">turkey.fly();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面创建一个测试类来测试一下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DuckTestDrive</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">Duck duck = <span class="keyword">new</span> MallarDuck();</span><br><span class="line">Turkey turkey = <span class="keyword">new</span> WildTurkey();</span><br><span class="line">Duck turkeyAdapter = <span class="keyword">new</span> TurkeyAdapter(turkey);</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"The Turkey says..."</span>);</span><br><span class="line">turkey.gobble();</span><br><span class="line">turkey.fly();</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"The Duck says..."</span>);</span><br><span class="line">duck.quack();</span><br><span class="line">duck.fly();</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"THe TurkeyAdapter sasy..."</span>);</span><br><span class="line">turkeyAdapter.quack();</span><br><span class="line">turkeyAdapter.fly();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">The Turkey says...</span><br><span class="line">Gobble gobble!</span><br><span class="line">I<span class="string">'m flying a short distance</span></span><br><span class="line"><span class="string">The Duck says...</span></span><br><span class="line"><span class="string">Quack!</span></span><br><span class="line"><span class="string">I'</span>m flying!</span><br><span class="line">THe TurkeyAdapter sasy...</span><br><span class="line">Gobble gobble!</span><br><span class="line">I<span class="string">'m flying a short distance</span></span><br><span class="line"><span class="string">I'</span>m flying a <span class="keyword">short</span> distance</span><br><span class="line">I<span class="string">'m flying a short distance</span></span><br><span class="line"><span class="string">I'</span>m flying a <span class="keyword">short</span> distance</span><br><span class="line">I<span class="string">'m flying a short distance</span></span><br></pre></td></tr></table></figure><p>客户使用适配器模式的过程如下：</p><ol><li>客户通过目标接口调用适配器的方法对适配器发出请求。</li><li>适配器使用被适配者接口把请求转换成被适配者的一个或多个调用接口。</li><li>客户接收到调用的结果，但并未察觉这一切是适配器在起转换作用。</li></ol><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>适配器模式的主要优点是将目标类和适配者类解耦，增加了类的透明性和复用性，同时系统的灵活性和扩展性都非常好，更换适配器或者增加新的适配器都非常方便，符合“开闭原则”；</li><li>类适配器模式的缺点是适配器类在很多编程语言中不能同时适配多个适配者类，对象适配器的缺点是很难置换适配者类的方法。</li><li>适配器模式适用情况包括：系统需要使用现有的类，而这些类的接口不符合系统的需要；想要建立一个可以重复使用的类，用于与一些彼此之间没有太大关联的一些类一起工作。</li></ul><h1 id="外观模式"><a href="#外观模式" class="headerlink" title="外观模式"></a>外观模式</h1><p>我们现在要看一个改变接口的新模式，但是它改变接口的原因是为了简化接口。这个模式被巧妙地命名为外观模式（Facade Pattern），之所以这么称呼，是因为它将一个或数个类的复杂的一切都隐藏在背后，只显露出一个干净美好的外观。</p><h2 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h2><p><strong>外观模式提供了一个统一的接口，用来访问子系统中的一群接口。外观定义了一个高层接口，让子系统更容易使用。</strong></p><h2 id="结构图-1"><a href="#结构图-1" class="headerlink" title="结构图"></a>结构图</h2><p><img src="/posts/50785/f9978fa6-9f49-4a0f-8540-02d269ac448f.png" alt></p><h2 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h2><p>想象你有一个家庭影院系统，当你想要观看电影时，如果没有外观模式，你还需要一步步完成操作，当有了外观模式，这些都交给外观模式来一键看电影。</p><p>首先创建一个家庭影院类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MovieSystem</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">turnOnTV</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"Turn On TV"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCD</span><span class="params">(String cd)</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"Set CD :"</span> + cd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">startWatching</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"Star Watching TV"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">turnOffTV</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"Turn Off TV"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">outCD</span><span class="params">(String cd)</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"Out CD :"</span> + cd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">endtWatching</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"End Watching TV"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后创建外观模式类，帮助你一键完成操作：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Facade</span> </span>&#123;</span><br><span class="line">MovieSystem movieSystem;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Facade</span><span class="params">(MovieSystem movieSystem)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.movieSystem = movieSystem;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">watchMovie</span><span class="params">(String cd)</span> </span>&#123;</span><br><span class="line">movieSystem.turnOnTV();</span><br><span class="line">movieSystem.setCD(cd);</span><br><span class="line">movieSystem.startWatching();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">overMovie</span><span class="params">(String cd)</span> </span>&#123;</span><br><span class="line">movieSystem.turnOffTV();</span><br><span class="line">movieSystem.outCD(cd);</span><br><span class="line">movieSystem.endtWatching();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当你需要看电影时，只需要点一下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">MovieSystem movieSystem = <span class="keyword">new</span> MovieSystem();</span><br><span class="line">Facade facade = <span class="keyword">new</span> Facade(movieSystem);</span><br><span class="line"></span><br><span class="line">facade.watchMovie(<span class="string">"变形金刚"</span>);</span><br><span class="line">System.out.println(<span class="string">"Watching..."</span>);</span><br><span class="line">facade.overMovie(<span class="string">"变形金刚"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>就可以让外观模式类帮你完成整个过程：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Turn On TV</span><br><span class="line">Set CD :变形金刚</span><br><span class="line">Star Watching TV</span><br><span class="line">Watching...</span><br><span class="line">Turn Off TV</span><br><span class="line">Out CD :变形金刚</span><br><span class="line">End Watching TV</span><br></pre></td></tr></table></figure><h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><ul><li><strong>设计原则</strong>：“最少知识”原则：只和你的密友交谈。也就是说客户对象所需要交互的对象应当尽可能少。</li><li>外观模式的主要优点在于对客户屏蔽子系统组件，减少了客户处理的对象数目并使得子系统使用起来更加容易，它实现了子系统与客户之间的松耦合关系，并降低了大型软件系统中的编译依赖性，简化了系统在不同平台之间的移植过程。</li><li>其缺点在于不能很好的限制客户使用子系统类，而且不引入抽象外观类的情况下，增加新的子系统可能需要修改外观类和客户端的源代码，违背了“开闭原则”。</li><li>外观模式适用情况包括：要为一个负责子系统提供一个简单接口；客户程序与多个子系统之间存在很大的依赖性；在层次化结构中，需要定义系统中每一层的入口，使得层与层之间不产生联系。</li></ul><h1 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h1><ul><li>当需要使用一个现有的类而其接口不符合你的需要时，就是用适配器。</li><li>当需要简化并统一一个很大的接口或一群复杂的接口时，使用外观。</li><li>适配器改变接口以符合客户的期望。</li><li>外观将客户从一个复杂的子系统中解耦。</li><li>实现一个适配器可能需要一番功夫，也可能不费功夫，视目标接口的大小与复杂度而定。</li><li>实现一个外观，需要将子系统组合进外观中，然后将工作委托给子系统执行。</li><li>适配器模式有两种形式：对象适配器和类适配器。类适配器需要用到多重继承。</li><li>你可以为一个子系统实现一个以上的外观。</li><li>适配器将一个对象包装起来以改变其接口；而外观将一群对象“包装”起来以简化其接口。</li></ul>]]></content>
    
    <summary type="html">
    
      以不同的目的，包装某些对象：让他们的接口看起来不像自己而像是别的东西。为何要这样做？因为这样就可以在设计中，将类的接口转换成想要的接口，以便实现不同的接口。不仅如此，还要探讨另一个模式，将对象包装起来以简化其接口。
    
    </summary>
    
      <category term="设计模式" scheme="http://yoursite.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
  </entry>
  
  <entry>
    <title>工厂模式</title>
    <link href="http://yoursite.com/posts/6013/"/>
    <id>http://yoursite.com/posts/6013/</id>
    <published>2019-11-14T11:38:43.000Z</published>
    <updated>2019-11-14T13:42:34.699Z</updated>
    
    <content type="html"><![CDATA[<h1 id="简单工厂"><a href="#简单工厂" class="headerlink" title="简单工厂"></a>简单工厂</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p><strong>在创建一个对象时不向客户暴露内部细节，并提供一个创建对象的通用接口。</strong></p><p>简单工厂其实不是一个设计模式，反而比较像一种编程习惯。但是不要因为简单工厂不是一个“真正的”模式，就忽略了它的用法，让我们来看看它的结构图。</p><h2 id="结构图"><a href="#结构图" class="headerlink" title="结构图"></a>结构图</h2><p><img src="/posts/6013/40c0c17e-bba6-4493-9857-147c0044a018.png" alt></p><p><strong>简单工厂把实例化的操作单独放到一个类中，这个类就成为简单工厂，让简单工厂类来决定应该用哪个具体子类实例化。</strong></p><p>这样做能把客户类和具体子类的实现解耦，客户类不再需要知道有哪些子类以及应当实例化哪个子类。客户类往往有多个，如果不使用简单工厂，那么所有的客户类都要知道所有子类的细节。而且子类一旦发生改变，例如增加子类，那么所有的客户类都要进行修改。</p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>现在创建一个Product接口，标志实现这个接口的类为产品类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Product</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后举例，创建三个实现Product接口的类，表示具体的产品：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteProduct</span> <span class="keyword">implements</span> <span class="title">Product</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteProduct1</span> <span class="keyword">implements</span> <span class="title">Product</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteProduct2</span> <span class="keyword">implements</span> <span class="title">Product</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后提供SimpleFactory类，作为一个工厂，当客户端需要Product时，只需去向SimpleFactory这个工厂去获取相对应的具体实现类即可：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleFactory</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> Product <span class="title">createProduct</span><span class="params">(<span class="keyword">int</span> type)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(<span class="number">1</span> == type) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> ConcreteProduct1();</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="number">2</span> == type) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> ConcreteProduct2();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> ConcreteProduct();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后下面是模拟客户类去获取Product的具体实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">SimpleFactory factory = <span class="keyword">new</span> SimpleFactory();</span><br><span class="line">Product product1 = factory.createProduct(<span class="number">1</span>);</span><br><span class="line">Product product2 = factory.createProduct(<span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li><strong>简单工厂最大的优点在于实现对象的创建和对象的使用分离，将对象的创建交给专门的工厂类去负责。</strong></li><li><strong>但是其最大的缺点在于工厂类不够灵活，增加新的具体产品需要修改工厂类的判断逻辑代码，而且产品较多时，工厂方法代码将会非常复杂。</strong></li><li>简单工厂适用情况包括：<strong>工厂类负责创建的对象比较少；客户端只知道传入工厂类的参数，对于如何创建对象不关心。</strong></li></ul><h1 id="工厂方法"><a href="#工厂方法" class="headerlink" title="工厂方法"></a>工厂方法</h1><h2 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h2><p><strong>工厂方法模式定义了一个创建对象的接口，但由子类决定要实例化的类是哪一个。工厂方法让类把实例化推迟到子类。</strong></p><h2 id="结构图-1"><a href="#结构图-1" class="headerlink" title="结构图"></a>结构图</h2><p><img src="/posts/6013/TIM%E6%88%AA%E5%9B%BE20191114202526.png" alt><br>工厂方法模式能够封装具体类型的实例化。根据上面的类图，抽象的Creator提供了一个创建对象的方法的接口，也称为“工厂方法”。在抽象的Creator中，任何其他实现的方法，都可能使用到这个方法所制造出来的产品。但只有子类真正实现这个工厂方法并创建产品。</p><h2 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h2><p>首先Product复用上面简单工厂的代码，接下来创建一个Factory抽象类，为子类提供factoryMethod()方法，和其他看情况可重写的方法，例如anOperation()方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Factory</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> Product <span class="title">factoryMethod</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">anOperation</span><span class="params">()</span> </span>&#123;</span><br><span class="line">Product product = factoryMethod();</span><br><span class="line"><span class="comment">// do something with the product</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着实现其三个子类，分别表示不同类型的Product的工厂：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteFactory</span> <span class="keyword">extends</span> <span class="title">Factory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Product <span class="title">factoryMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> ConcreteProduct();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">anOperation</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//也可以自定义anOperation()方法操作。</span></span><br><span class="line"><span class="keyword">super</span>.anOperation();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteFactory1</span> <span class="keyword">extends</span> <span class="title">Factory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Product <span class="title">factoryMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> ConcreteProduct1();</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">anOperation</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//也可以自定义anOperation()方法操作。</span></span><br><span class="line"><span class="keyword">super</span>.anOperation();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteFactory2</span> <span class="keyword">extends</span> <span class="title">Factory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Product <span class="title">factoryMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> ConcreteProduct2();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">anOperation</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//也可以自定义anOperation()方法操作。</span></span><br><span class="line"><span class="keyword">super</span>.anOperation();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后模拟客户端类获取不同类型的Product：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">ConcreteFactory concreteFactory = <span class="keyword">new</span> ConcreteFactory();</span><br><span class="line">Product concreteProduct = concreteFactory.factoryMethod();</span><br><span class="line"></span><br><span class="line">ConcreteFactory1 concreteFactory1 = <span class="keyword">new</span> ConcreteFactory1();</span><br><span class="line">Product concreteProduct1 = concreteFactory1.factoryMethod();</span><br><span class="line"></span><br><span class="line">ConcreteFactory2 concreteFactory2 = <span class="keyword">new</span> ConcreteFactory2();</span><br><span class="line">Product concreteProduct2 = concreteFactory2.factoryMethod();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><ul><li>工厂方法模式是简单工厂的进一步抽象和推广。由于使用了面向对象的多态性，工厂方法模式保持了简单工厂模式的优点，而且克服了它的缺点。</li><li><strong>工厂方法模式的主要优点是增加新的产品类时无须修改现有代码，并封装了产品对象的创建细节，系统具有良好的灵活性和可扩展性。</strong></li><li><strong>其缺点在于增加新产品的同时需要增加新的工厂，导致系统类的个数成对增加，在一定程度上增加了系统的复杂性。</strong></li><li>工厂方法模式适用情况包括：一个类不知道它所需要的对象的类；一个类通过其子类来指定创建哪个对象；将创建对象的任务委托给多个工厂子类中的某一个，客户端在使用时无需关心是哪一个工厂子类创建产品子类，需要时再动态指定。</li></ul><h1 id="抽象工厂"><a href="#抽象工厂" class="headerlink" title="抽象工厂"></a>抽象工厂</h1><h2 id="定义-2"><a href="#定义-2" class="headerlink" title="定义"></a>定义</h2><p><strong>抽象工厂模式提供一个接口，用于创建相关或依赖对象的家族，而不需要明确指定具体类。</strong></p><h2 id="结构图-2"><a href="#结构图-2" class="headerlink" title="结构图"></a>结构图</h2><p><img src="/posts/6013/e2190c36-8b27-4690-bde5-9911020a1294.png" alt><br>抽象工厂模式创建的是对象家族，也就是很多对象而不是一个对象，并且这些对象是相关的，<strong>也就是说必须一起创建出来。</strong>而工厂方法模式只适用于创建一个对象，这和抽象工厂模式有很大不同。</p><p>抽象工厂模式用到了工厂方法模式来创建单一对象，AbstractFactory中的createProductA()和createProductB()方法都是让子类来实现，这两个方法单独来看就是在创建一个对象，这符合工厂方法模式的定义。</p><p>至于创建对象的家族这一概念是在Client体现，Client要通过AbstractFactory同时掉用两个方法来创建出两个对象，在这里这两个对象就有很大的相关性，Client需要同时创建出这两个对象。</p><p><strong>从高层次来看，抽象工厂模式使用了组合，即Client组合了AbstractFactory，而工厂方法模式则使用了继承。</strong></p><h2 id="实现-2"><a href="#实现-2" class="headerlink" title="实现"></a>实现</h2><p>首先创建抽象产品类，为具体实现类提供基础：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractProductA</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractProductB</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后提供具体的实现类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProductA1</span> <span class="keyword">extends</span> <span class="title">AbstractProductA</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProductA2</span> <span class="keyword">extends</span> <span class="title">AbstractProductA</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProductB1</span> <span class="keyword">extends</span> <span class="title">AbstractProductB</span></span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProductB2</span> <span class="keyword">extends</span> <span class="title">AbstractProductB</span></span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来提供抽象工厂类，为具体工厂类的实现提供基础：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractFactory</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> AbstractProductA <span class="title">createProductA</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> AbstractProductB <span class="title">createProductB</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面实现这个具体的工厂类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteFactory1</span> <span class="keyword">extends</span> <span class="title">AbstractFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> AbstractProductA <span class="title">createProductA</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> ProductA1();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> AbstractProductB <span class="title">createProductB</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> ProductB1();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteFactory2</span> <span class="keyword">extends</span> <span class="title">AbstractFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> AbstractProductA <span class="title">createProductA</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> ProductA2();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> AbstractProductB <span class="title">createProductB</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> ProductB2();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后进行客户端调用即可：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">AbstractFactory abstractFactory = <span class="keyword">new</span> ConcreteFactory1();</span><br><span class="line">AbstractProductA productA = abstractFactory.createProductA();</span><br><span class="line">AbstractProductB productB = abstractFactory.createProductB();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h2><ul><li>抽象工厂模式的主要优点是隔离了具体类的生成，使得客户并不需要知道什么被创建，而且每次可以通过具体工厂类创建一个产品族中的多个对象，增加或者替换产品族比较方便，增加新的具体工厂和产品族很方便。</li><li>主要缺点在于增加新的产品等级结构很复杂，需要修改抽象工厂和所有的具体工厂类，对“开闭原则”的支持呈现倾斜性。</li><li>抽象工厂模式适用情况包括：一个系统不应当依赖于产品类实例如何被创建、组合和表达的细节；系统中有多于一个的产品族，而每次只使用其中某一产品族；属于同一个产品族的产品将在一起使用；系统提供一个产品类的库，所有的产品以同样的接口出现，从而使客户端不依赖于具体实现。</li></ul><h1 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a>总结</h1><ul><li>所有的工厂都是用来封装对象的创建</li><li>简单工厂，虽然不是真正的设计模式，但仍不失为一个简单的方法，可以将客户端程序从具体类解耦。</li><li>工厂方法使用继承：把对象的创建委托给子类，子类实现工厂方法来创建对象。</li><li>抽象工厂使用对象组合：对象的创建被实现在工厂接口所暴露出来的方法中。</li><li>所有工厂模式都通过减少应用程序和具体类之间的依赖促进松耦合。</li><li>工厂方法允许类将实例化延迟到子类进行。</li><li>抽象工厂方法创建相关的对象家族，而不需要依赖他们的具体实现类。</li><li>依赖倒置原则，指导我们避免依赖具体类型，而要尽量依赖对象。</li><li>工厂是很有威力的技巧，帮助我们针对抽象编程，而不要针对具体类编程。</li></ul>]]></content>
    
    <summary type="html">
    
      除了使用new操作符之外，还有更多制造对象的方法。你将了解到实例化这个活动不应该总是公开地进行，也会认识到初始化经常造成“耦合”问题。
    
    </summary>
    
      <category term="设计模式" scheme="http://yoursite.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
  </entry>
  
  <entry>
    <title>单例模式</title>
    <link href="http://yoursite.com/posts/46132/"/>
    <id>http://yoursite.com/posts/46132/</id>
    <published>2019-11-12T13:08:07.000Z</published>
    <updated>2019-11-12T14:08:52.062Z</updated>
    
    <content type="html"><![CDATA[<h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><p><strong>单例模式确保一个类只有一个实例，并提供一个全局访问点。</strong></p><ul><li>我们把某个类设计成自己管理的一个单独实例，同时也避免其他类再自行产生实例。要想取得单例模式，通过单例类是唯一的途径。</li><li>我们也提供对这个实例的全局访问点：当你需要实例时，向类查询，它会返回单个实例。</li></ul><h1 id="结构图"><a href="#结构图" class="headerlink" title="结构图"></a>结构图</h1><p><img src="/posts/46132/eca1f422-8381-409b-ad04-98ef39ae38ba.png" alt></p><h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><p><strong>使用一个私有构造函数，一个私有静态变量以及一个公有静态函数来实现。</strong></p><p><strong>私有构造函数保证了不能通过构造函数来创建对象实例，只能通过公有静态函数返回唯一的私有静态变量。</strong></p><h2 id="饿汉式-线程不安全"><a href="#饿汉式-线程不安全" class="headerlink" title="饿汉式-线程不安全"></a>饿汉式-线程不安全</h2><p><strong>如果应用程序总是创建并使用单件实例，或者在创建和运行时方面的负担不太繁重，你可能想要急切创建此单件</strong>，如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 在静态初始化器（static initializen）中创建单例</span></span><br><span class="line"><span class="comment"> * 这段代码保证了线程安全</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Singleton uniqueInstance = <span class="keyword">new</span> Singleton();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> uniqueInstance ;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>利用这个做法，我们依赖JVM在加载这个类时马上创建此唯一的单件实例，JVM保证在任何线程访问uniqueInstance静态变量之前，一定先创建此实例。</strong></p><h2 id="懒汉式-线程不安全"><a href="#懒汉式-线程不安全" class="headerlink" title="懒汉式-线程不安全"></a>懒汉式-线程不安全</h2><p>以下实现中，私有静态变量uniqueInstance被延迟实例化，<strong>这样做的好处是，如果没有用到该类，那么就不会实例化uniqueInstance，从而节省资源。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Singleton uniqueInstance;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(uniqueInstance == <span class="keyword">null</span>) &#123;</span><br><span class="line">uniqueInstance = <span class="keyword">new</span> Singleton();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> uniqueInstance;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个实现在多线程环境下是不安全的，如果多个线程能够同时进入<code>if(uniqueInstance == null)</code>，那么会有多个线程执行<code>uniqueInstance = new Singleton();</code>语句，这将会导致实例化多次uniqueInstance。</p><h2 id="懒汉式-线程安全"><a href="#懒汉式-线程安全" class="headerlink" title="懒汉式-线程安全"></a>懒汉式-线程安全</h2><p>只要接着上面的，把getInstance变成同步（Synchronized）方法，多线程灾难几乎就可以轻易地解决。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Singleton uniqueInstance ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(uniqueInstance == <span class="keyword">null</span>) &#123;</span><br><span class="line">uniqueInstance = <span class="keyword">new</span> Singleton();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> uniqueInstance ;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样虽然可以解决问题，但是同步会降低性能，而且比你想象的还要严重一些的是：<strong>只有第一次执行此方法时，才真正需要同步。换句话说，一旦设置好uniqueInstance变量，就不再需要同步这个方法了。之后每次调用这个方法，同步都是一种累赘。</strong></p><h2 id="双重检查加锁-线程安全"><a href="#双重检查加锁-线程安全" class="headerlink" title="双重检查加锁-线程安全"></a>双重检查加锁-线程安全</h2><p>利用双重检查加锁（double-checked locking），首先检查是否实例已经创建了，如果尚未创建，才进行同步，这样一来，只有第一次会同步，这正是我们想要的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Singleton uniqueInstance;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(uniqueInstance == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">synchronized</span>(Singleton.class) &#123;</span><br><span class="line"><span class="keyword">if</span>(uniqueInstance == <span class="keyword">null</span>) &#123;</span><br><span class="line">uniqueInstance = <span class="keyword">new</span> Singleton();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> uniqueInstance;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>volatile关键词确保：当uniqueInstance变量被初始化成Singleton实例时，多个线程正确的处理uniqueInstance变量。</strong></p><h2 id="静态内部类实现"><a href="#静态内部类实现" class="headerlink" title="静态内部类实现"></a>静态内部类实现</h2><p><strong>当Singleton类被加载时，静态内部类SingletonHolder没有被加载进内存，只有当调用getInstance方法从而触发SingletonHolder.uniqueInstance时，SingletonHolder才会被加载，此时初始化uniqueInstance实例，并且JVM能确保uniqueInstance只被实例化一次。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonHolder</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton uniqueInstance = <span class="keyword">new</span> Singleton();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> SingletonHolder.uniqueInstance;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种方式不仅具有延迟初始化的好处，而且由JVM提供了对线程安全的支持。</p><h2 id="枚举类实现"><a href="#枚举类实现" class="headerlink" title="枚举类实现"></a>枚举类实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Singleton &#123;</span><br><span class="line">uniqueInstance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>该实现可以防止反射攻击。在其它实现中，通过setAccessible()方法可以将私有构造函数的访问级别设置为public，然后调用构造函数从而实例化对象。如果想要防止这种攻击，需要在构造函数中添加防止多次实例化的代码。该实现是由JVM保证只会实例化一次，因此不会出现上述的反射攻击。</strong></p><p><strong>该实现在多次序列化和反序列化之后，不会得到多个实例，而其它实现需要使用transient修饰所有字段，并且实现序列化和反序列化的方法。</strong></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li>单例模式确保程序中一个类最多只有一个实例。</li><li>单例模式也提供访问这个实例的全局点。</li><li>在Java中实现单例模式需要私有的构造器，一个静态方法和一个静态变量。</li><li>确定在性能和资源上的限制，然后小心的选择适当的方案来实现单例，以解决多线程的问题。</li><li>小心你如果使用多个类加载器，可能导致单例失效而产生多个实例。</li></ul>]]></content>
    
    <summary type="html">
    
      单例模式（Singleton Pattern）：用来创建独一无二的，只能有一个实例的对象的入场券。
    
    </summary>
    
      <category term="设计模式" scheme="http://yoursite.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
  </entry>
  
  <entry>
    <title>观察者模式</title>
    <link href="http://yoursite.com/posts/7755/"/>
    <id>http://yoursite.com/posts/7755/</id>
    <published>2019-11-11T11:35:57.000Z</published>
    <updated>2019-11-12T14:13:09.270Z</updated>
    
    <content type="html"><![CDATA[<h1 id="认识观察者模式"><a href="#认识观察者模式" class="headerlink" title="认识观察者模式"></a>认识观察者模式</h1><p>我们看看报纸和杂志社的订阅是怎么回事：</p><ol><li>报社的业务就是出版报纸。</li><li>向某家报社订阅报纸，只要他们有新报纸出版，就会给你送来。只要你是他们的订户，你就会一直收到新报纸。</li><li>当你不想再看报纸的时候，取消订阅，他们就不会再送新报纸来。</li><li>只要报社还在运营，就会一直有人（或单位）向他们订阅报纸或取消订阅报纸。</li></ol><p><img src="/posts/7755/TIM%E6%88%AA%E5%9B%BE20191111194914.png" alt></p><p>如果你了解了报纸的订阅是怎么回事，其实就知道观察者模式是怎么回事，只是名称不太一样：出版社改称为“<strong>主题（Subject）</strong>”，订阅者改称为“<strong>观察者（Observer）</strong>”。</p><h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><p><strong>观察者模式定义了对象之间的一对多以来，这样一来，当一个对象改变状态时，它的所有依赖着都会收到通知并自动更新。</strong></p><h1 id="结构图"><a href="#结构图" class="headerlink" title="结构图"></a>结构图</h1><p><img src="/posts/7755/TIM%E6%88%AA%E5%9B%BE20191111194123.png" alt><br>具体的解释看下图:<img src="/posts/7755/TIM%E6%88%AA%E5%9B%BE20191111195045.png" alt></p><h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><p>假设现在要气象监测的应用，此系统中由三个部分，分别是气象站（获取实际气象数据的物理装置），WeatherData对象（追踪来自气象站的数据，并更新布告板），布告板（显示目前天气状况给用户看）。<br><img src="/posts/7755/TIM%E6%88%AA%E5%9B%BE20191111195336.png" alt></p><p>WeatherData对象知道如何跟物理气象站联系，以取得更新的数据。WeatherData对象会随即更新三个布告板的显示：目前状况（温度、湿度、气压）、对象统计和天气预报。我们的工作就是建立一个应用，利用WeatherData对象取得数据，并更新三个布告板：目前状况、气象统计和天气预报。</p><p>因此根据上面的结构图开始设计这个气象站应用：</p><h2 id="实现主题"><a href="#实现主题" class="headerlink" title="实现主题"></a>实现主题</h2><p>先建立一个主题接口，提供WeatherData实现的基础：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Subject</span> </span>&#123;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 这两个方法都需要一个观察者作为参数，该观察者是用来注册或被删除的。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerObserver</span><span class="params">(Observer o)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeObserver</span><span class="params">(Observer o)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 当主题状态改变时，这个方法会被调用，以通知所有的观察者。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">notifyObservers</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后创建WeatherData类，实现Subject接口，说明它是主题的角色：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WeatherData</span> <span class="keyword">implements</span> <span class="title">Subject</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> List&lt;Observer&gt; observers;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">float</span> temperature;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">float</span> humidity;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">float</span> pressure;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">WeatherData</span><span class="params">()</span> </span>&#123;</span><br><span class="line">observers = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerObserver</span><span class="params">(Observer o)</span> </span>&#123;</span><br><span class="line">observers.add(o);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeObserver</span><span class="params">(Observer o)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> i = observers.indexOf(o);</span><br><span class="line"><span class="keyword">if</span>(i &gt;= <span class="number">1</span>) &#123;</span><br><span class="line">observers.remove(o);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">notifyObservers</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span>(Observer o : observers) &#123;</span><br><span class="line">o.update(temperature, humidity, pressure);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">measurementsChanged</span><span class="params">()</span> </span>&#123;</span><br><span class="line">notifyObservers();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMeasurements</span><span class="params">(<span class="keyword">float</span> temperature, <span class="keyword">float</span> humidity, <span class="keyword">float</span> pressure)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.temperature = temperature;</span><br><span class="line"><span class="keyword">this</span>.humidity = humidity;</span><br><span class="line"><span class="keyword">this</span>.pressure = pressure;</span><br><span class="line">measurementsChanged();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>这样告示板就可以通过WeatherData这个对象进行注册和删除，而当气象站的数据更新时，就可以调用WeatherData的setMeasurements()方法进行数据更改，而且会自动通知给所有订阅的告示板。</strong></p><h2 id="观察者接口"><a href="#观察者接口" class="headerlink" title="观察者接口"></a>观察者接口</h2><p>创建一个观察者接口，作为所有观察者的基础，其中只有一个方法update()，用于被通知。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Observer</span> </span>&#123;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 所有的观察者都必须是实现update()方法，以实现观察者接口。</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 当气象观测值改变时，主题会把这些状态值当作方法的参数，传送给观察者。</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> temp</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> humidity</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> pressure</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">float</span> temperature, <span class="keyword">float</span> humidity, <span class="keyword">float</span> pressure)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="告示板接口"><a href="#告示板接口" class="headerlink" title="告示板接口"></a>告示板接口</h2><p>此处为告示板实现基础的接口：DisplayElement，用于标识所实现的类为告示板：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">DisplayElement</span> </span>&#123;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * DisplayElement接口只包含了一个方法就是display()</span></span><br><span class="line"><span class="comment"> * 当布告板需要显示时，调用此方法。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="观察者实现"><a href="#观察者实现" class="headerlink" title="观察者实现"></a>观察者实现</h2><p>下面建立三个告示板，分别用来展示目前状况（温度、湿度、气压）、对象统计和天气预报。因此所有的告示板实现类都需要实现Observer接口，以标识它是一个观察者，而且可以接收到通知；并且实现DisplayElement接口，标识它是一个告示板。</p><ul><li><p><strong>目前状况告示板：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CurrentConditionDisplay</span> <span class="keyword">implements</span> <span class="title">Observer</span>,<span class="title">DisplayElement</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">float</span> temperature;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">float</span> humidity;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">float</span> pressure;</span><br><span class="line"><span class="keyword">private</span> Subject weatherData;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">CurrentConditionDisplay</span><span class="params">(Subject weatherData)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.weatherData = weatherData;</span><br><span class="line">weatherData.registerObserver(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"CurrentConditionDisplay：温度："</span> + temperature  + <span class="string">"度，湿度："</span> + humidity + <span class="string">"%，压强："</span> + pressure);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">float</span> temperature, <span class="keyword">float</span> humidity, <span class="keyword">float</span> pressure)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.temperature = temperature;</span><br><span class="line"><span class="keyword">this</span>.humidity = humidity;</span><br><span class="line"><span class="keyword">this</span>.pressure =pressure;</span><br><span class="line">display();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>对象统计告示板：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StatisticsDisplay</span> <span class="keyword">implements</span> <span class="title">Observer</span>,<span class="title">DisplayElement</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">float</span> temperature;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">float</span> humidity;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">float</span> pressure;</span><br><span class="line"><span class="keyword">private</span> Subject weatherData;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">StatisticsDisplay</span><span class="params">(Subject weatherData)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.weatherData = weatherData;</span><br><span class="line">weatherData.registerObserver(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"StatisticsDisplay：温度："</span> + temperature  + <span class="string">"度，湿度："</span> + humidity + <span class="string">"%，压强："</span> + pressure);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">float</span> temperature, <span class="keyword">float</span> humidity, <span class="keyword">float</span> pressure)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.temperature = temperature;</span><br><span class="line"><span class="keyword">this</span>.humidity = humidity;</span><br><span class="line"><span class="keyword">this</span>.pressure =pressure;</span><br><span class="line">display();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>天气预报告示板：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ForecastDisplay</span> <span class="keyword">implements</span> <span class="title">Observer</span>, <span class="title">DisplayElement</span></span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">float</span> temperature;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">float</span> humidity;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">float</span> pressure;</span><br><span class="line"><span class="keyword">private</span> Subject weatherData;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ForecastDisplay</span><span class="params">(Subject weatherData)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.weatherData = weatherData;</span><br><span class="line">weatherData.registerObserver(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"ForecastDisplay：温度："</span> + temperature  + <span class="string">"度，湿度："</span> + humidity + <span class="string">"%，压强："</span> + pressure);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">float</span> temperature, <span class="keyword">float</span> humidity, <span class="keyword">float</span> pressure)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.temperature = temperature;</span><br><span class="line"><span class="keyword">this</span>.humidity = humidity;</span><br><span class="line"><span class="keyword">this</span>.pressure =pressure;</span><br><span class="line">display();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="查看结果"><a href="#查看结果" class="headerlink" title="查看结果"></a>查看结果</h2><p>下面进行测试：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">WeatherData weatherData = <span class="keyword">new</span> WeatherData();</span><br><span class="line">    CurrentConditionDisplay currentConditionDisplay = <span class="keyword">new</span> CurrentConditionDisplay(weatherData);</span><br><span class="line">    StatisticsDisplay statisticsDisplay = <span class="keyword">new</span> StatisticsDisplay(weatherData);</span><br><span class="line">    ForecastDisplay forecastDisplay = <span class="keyword">new</span> ForecastDisplay(weatherData);</span><br><span class="line">    </span><br><span class="line">    weatherData.setMeasurements(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    weatherData.removeObserver(currentConditionDisplay);</span><br><span class="line">    System.out.println(<span class="string">"气象数据发生变化....."</span>);</span><br><span class="line">    weatherData.setMeasurements(<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出的结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">CurrentConditionDisplay：温度：0.0度，湿度：0.0%，压强：0.0</span><br><span class="line">StatisticsDisplay：温度：0.0度，湿度：0.0%，压强：0.0</span><br><span class="line">ForecastDisplay：温度：0.0度，湿度：0.0%，压强：0.0</span><br><span class="line">气象数据发生变化.....</span><br><span class="line">StatisticsDisplay：温度：1.0度，湿度：1.0%，压强：1.0</span><br><span class="line">ForecastDisplay：温度：1.0度，湿度：1.0%，压强：1.0</span><br></pre></td></tr></table></figure><h2 id="整体结构"><a href="#整体结构" class="headerlink" title="整体结构"></a>整体结构</h2><p><img src="/posts/7755/TIM%E6%88%AA%E5%9B%BE20191111210628.png" alt></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p><strong>观察者模式定义对象之间的一对多依赖，当一个对象状态改变时，它的所有依赖都会收到通知并且自动更新状态。</strong></p><p><strong>主题（Subject）是被观察的对象，而其所有依赖者（Observer）称为观察者。</strong></p><ul><li>观察者模式定义了对象之间一对多的关系。</li><li>主题（也就是可观察者）用一个共同的接口来更新观察者。</li><li>观察者和可观察者之间用松耦合方式结合，可观察者不知道观察者的细节，只知道观察者实现了观察者接口。</li><li>使用此模式时，你可从被观察者处推（push）或拉（pull）数据，然而，推的方式被认为更正确。</li><li>有多个观察者时，不可以依赖特定的通知次序。</li><li>Java有多种观察者模式的实现，包括了通用的java.util.Observable。</li></ul>]]></content>
    
    <summary type="html">
    
      有一个模式可以帮你的对象知悉现况，不会错过该对象感兴趣的事。对象甚至在运行时可决定是否要继续被通知。观察者模式是JDK中使用最多的模式之一，非常有用，有了观察者，你将会消息灵通。
    
    </summary>
    
      <category term="设计模式" scheme="http://yoursite.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
  </entry>
  
  <entry>
    <title>策略模式</title>
    <link href="http://yoursite.com/posts/58639/"/>
    <id>http://yoursite.com/posts/58639/</id>
    <published>2019-11-10T09:30:44.000Z</published>
    <updated>2019-11-10T13:12:58.333Z</updated>
    
    <content type="html"><![CDATA[<h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><p><strong>策略模式定义了算法族，分别封装起来，让它们之间可以互相替换，此模式让算法的变化独立于使用算法的客户。</strong></p><h1 id="结构图"><a href="#结构图" class="headerlink" title="结构图"></a>结构图</h1><p><img src="/posts/58639/cd1be8c2-755a-4a66-ad92-2e30f8f47922.png" alt></p><h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><h2 id="实现鸭子的行为"><a href="#实现鸭子的行为" class="headerlink" title="实现鸭子的行为"></a>实现鸭子的行为</h2><p>考虑实现一个鸭子类，鸭子可能会有飞（Fly）和叫（Quack）的行为，所以先建立两个接口，分别代表飞的行为和叫的行为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">FlyBehavior</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fly</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">QuackBehavior</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">quack</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后建立它们对应的类，负责实现具体的行为.</p><p>例如飞行的行为有用翅膀飞行，也可以是不会飞：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FlyWithWings</span> <span class="keyword">implements</span> <span class="title">FlyBehavior</span> </span>&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fly</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"I'm flying"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FlyNoway</span> <span class="keyword">implements</span> <span class="title">FlyBehavior</span></span>&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fly</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"Sorry,I can't fly."</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在叫的行为中，可能是呱呱叫，也可能是吱吱叫，也可能是不会叫：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Quack</span> <span class="keyword">implements</span> <span class="title">QuackBehavior</span></span>&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">quack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"Quack!"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Squeak</span> <span class="keyword">implements</span> <span class="title">QuackBehavior</span></span>&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">quack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"Squeak"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MuteQuack</span> <span class="keyword">implements</span> <span class="title">QuackBehavior</span></span>&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">quack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"&lt;&lt;&gt;Silence&gt;"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时，该类的结构图就是这样了：<img src="/posts/58639/TIM%E6%88%AA%E5%9B%BE20191110202641.png" alt></p><p><strong>这样的设计，可以让飞行和呱呱叫的动作被其他的对象复用，因为这些行为已经与鸭子类无关了，这么一来，有了继承的“复用”好处，但是却没有继承所带来的包袱。而我们新增一些行为，不会影响到既有的行为类，也不会影响“使用”到飞行行为的鸭子类。</strong></p><h2 id="整合鸭子的行为"><a href="#整合鸭子的行为" class="headerlink" title="整合鸭子的行为"></a>整合鸭子的行为</h2><p>关键在于，鸭子现在将会飞行和呱呱叫的动作“委托”别人处理，而不是使用定义在Duck类（或子类）内的呱呱叫和飞行方法。做法是这样的：</p><ol><li>首先，声明一个Duck类，在Duck类中加入两个实例变量，分别为：flyBehavior与quackBehavior。声明为接口类型，每个鸭子对象都会动态的设置这些变量以在运行时引用正确的类型。<img src="/posts/58639/TIM%E6%88%AA%E5%9B%BE20191110203519.png" alt></li><li>现在来实现performQuack()和performFly()这两个方法：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Duck</span> </span>&#123;</span><br><span class="line">FlyBehavior flyBehavior;</span><br><span class="line">QuackBehavior quackBehavior;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">performFly</span><span class="params">()</span> </span>&#123;</span><br><span class="line">flyBehavior.fly();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">performQuack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">quackBehavior.quack();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>想进行呱呱叫的动作，Duck对象只要交quackBehavior对象去呱呱叫就行了，想要飞的行为，只要叫flyBehavior对象<br>去飞就行了。<strong>我们不在乎接口的对象到底是什么，我们只关心该对象知道如何进行呱呱叫就够了。</strong></p><h2 id="动态行为设定"><a href="#动态行为设定" class="headerlink" title="动态行为设定"></a>动态行为设定</h2><p>假设我们想在鸭子子类中通过“设定方法”来设定鸭子的行为，而不是在鸭子的构造期内实例化，所以：</p><ol><li>在Duck类中，加入两个新方法，和一些其他的行为方法：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Duck</span> </span>&#123;</span><br><span class="line">FlyBehavior flyBehavior;</span><br><span class="line">QuackBehavior quackBehavior;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setFlyBehavior</span><span class="params">(FlyBehavior flyBehavior)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.flyBehavior = flyBehavior;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setQuackBehavior</span><span class="params">(QuackBehavior quackBehavior)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.quackBehavior = quackBehavior;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">performFly</span><span class="params">()</span> </span>&#123;</span><br><span class="line">flyBehavior.fly();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">performQuack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">quackBehavior.quack();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">swim</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"All ducks float,even decoys!"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>从此以后，我们可以“随时”调用setFlyBehavior()和setQuackBehavior()这两个方法改变鸭子的行为。</p><h2 id="查看结果"><a href="#查看结果" class="headerlink" title="查看结果"></a>查看结果</h2><p>创造一个新的鸭子类型：模型鸭,其中一开始我们的鸭子是不会飞也不会叫的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ModelDuck</span> <span class="keyword">extends</span> <span class="title">Duck</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ModelDuck</span><span class="params">()</span> </span>&#123;</span><br><span class="line">flyBehavior = <span class="keyword">new</span> FlyNoway();</span><br><span class="line">quackBehavior = <span class="keyword">new</span> Quack();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"I'm a model duck"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是在运行中，我们如果想要改变它的行为，让它变成会飞且会呱呱叫的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">Duck model = <span class="keyword">new</span> ModelDuck();</span><br><span class="line">model.performFly();</span><br><span class="line">model.performQuack();</span><br><span class="line">model.display();</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"替换策略后......."</span>);</span><br><span class="line"></span><br><span class="line">model.setFlyBehavior(<span class="keyword">new</span> FlyWithWings());</span><br><span class="line">model.setQuackBehavior(<span class="keyword">new</span> Squeak());</span><br><span class="line">model.performFly();</span><br><span class="line">model.performQuack();</span><br><span class="line">model.display();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出的结果为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Sorry,I can&apos;t fly.</span><br><span class="line">&lt;&lt;Silence&gt;&gt;</span><br><span class="line">I&apos;m a model duck</span><br><span class="line">替换策略后.......</span><br><span class="line">I&apos;m flying</span><br><span class="line">Squeak</span><br><span class="line">I&apos;m a model duck</span><br></pre></td></tr></table></figure><h2 id="整体结构"><a href="#整体结构" class="headerlink" title="整体结构"></a>整体结构</h2><p>此时整体的格局如下：<img src="/posts/58639/TIM%E6%88%AA%E5%9B%BE20191110205838.png" alt></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>我们把描述事情的方式稍有改变，不再把鸭子的行为说成是“一组行为”，我们开始把行为想成是“一族算法”，现在回到策略模式的定义上面再看就豁然开朗：</p><p><strong>策略模式定义了算法族，分别封装起来，让它们之间可以互相替换，此模式让算法的变化独立于使用算法的客户。</strong></p>]]></content>
    
    <summary type="html">
    
      策略模式（Strategy Pattern），当你需要给朋友留下深刻的印象，或者想影响关键主管的策略时，请使用“这个”定义。
    
    </summary>
    
      <category term="设计模式" scheme="http://yoursite.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
  </entry>
  
  <entry>
    <title>海量数据处理</title>
    <link href="http://yoursite.com/posts/47572/"/>
    <id>http://yoursite.com/posts/47572/</id>
    <published>2019-11-08T12:49:39.000Z</published>
    <updated>2019-11-10T08:59:42.040Z</updated>
    
    <content type="html"><![CDATA[<p>海量信息，即大规模数据，随着互联网技术的发展，互联网上的信息越来越多，如何从海量信息中提取有用信息成为当前互联网技术发展必须面对的问题。</p><p>针对海量数据的处理，可以使用的方法非常多，常见的方法有Hash法、Bitmap法、Bloom filter法、数据库优化法、倒排索引法、外排序法、Trie数、堆、双层桶法以及MapReduce法。下面就逐个讲解。</p><h1 id="Hash法"><a href="#Hash法" class="headerlink" title="Hash法"></a>Hash法</h1><p>Hash法一般被称为散列，它是一种映射关系，即给定一个数据元素，其关键字为key，按一个确定的散列函数计算出hash(key)，把hash(key)作为关键字key对应元素的存储地址，再进行数据元素的插入和检索操作。简而言之，<strong>散列函数就是一种将任意长度的消息压缩到某一固定长度的消息摘要的函数。</strong></p><p>散列表是具有固定大小的数组，散列函数是用于关键字与存储地址之间的一种映射关系，<strong>但是不能保证每个元素的关键字与函数值是一一对应的，因为极有可能出现对应于不同的元素，却计算出了相同的函数值，冲突指的就是两个关键字映射到同一个存储地址的情况。</strong></p><p>散列函数一般应具有一下几个特点：</p><ul><li>运算应该尽可能简单</li><li>函数的值域必须在散列表的范围内</li><li>尽可能地减少冲突</li></ul><p>针对散列函数的这些特点，在构建散列表时，不仅要设定一个好的散列函数，而且还要设定一种处理冲突的方法。常用的散列函数的构建方法一般有以下几种。</p><h2 id="散列函数"><a href="#散列函数" class="headerlink" title="散列函数"></a>散列函数</h2><ol><li><p><strong>直接寻址法</strong>：<strong>取关键字或关键字的某个线性函数值为散列地址，即<code>h(key)=key</code> 或<code>h(key) = a*key+b</code>，其中a和b均为整型常数，这种散列函数叫做自身函数。</strong>例如，有一个人口数字统计表，人的年龄取值范围为1~100,其中年龄作为关键字，散列函数取关键字自身，<strong>但这种方法效率低下，时间复杂度为O(1)，空间复杂度为O(n)，n为关键字的个数。</strong></p><p> <strong>直接寻址法不会产生冲突，但由于他没有压缩映像，因此当关键字集合很大时，使用这种Hash函数是不可能实现地址编码的散列的。</strong></p></li><li><p><strong>取模法</strong>：<strong>选择一个合适的正整数p，令hash(Key)=Key mod p。p如果选择的是比较大的素数，则效果比较好，一般选取p为TableSize，即散列表的长度。</strong></p></li><li><p><strong>数字分析法</strong>：<strong>设关键字是d位的以r为基的数（例如以10为基的十进制数），且共有n个关键字，则关键字的每个位可能有r个不同的数符出现（即0，1，2…9），但这r个数符在各个位上出现的频率不一样，可能在某些位上分布比较均匀，即每个数符出现的次数接近于n/r，而在另一些位上分布不均匀。因此可选取其中分布比较均匀的那些位，重新组成新的数，用其作散列地址。</strong><br> 这种方法比较简单、直观，<strong>但是需要预先知道每个关键字的情况，这就限制了它的使用范围。</strong></p></li><li><p><strong>折叠法</strong>：<strong>将关键字分成位数为t的几个部分（最后一部分的位数可能小于t），然后把各部分按位对其进行相加，将所得的和舍弃进位，留下t位作为散列地址。当关键字位数很多，而且关键字中每位数字分布比较均匀时，采用折叠法比较合适。</strong></p></li><li><p><strong>平方取中法</strong>：<strong>这是一种较常见的方法，将关键字进行平方运算，然后从结果的中间取出若干位（位数与散列地址的位数相同），将其作为散列地址。</strong></p></li><li><p><strong>除留余数法</strong>：除留余数法是一种比较常用的散列函数，<strong>其主要原理是取关键字除以某个数p（p不大于散列表的长度）的余数作为散列地址，即<code>Hash(key)=key%p</code>，使用该方法时，选取合适的p值也很重要，一般要求p&lt;=TableSize，且接近或等于TableSize，p一般选取质数。</strong></p></li><li><p><strong>随机数法</strong>：<strong>选择一个随机函数，然后用关键字key的随机函数值作为散列地址，即<code>Hash(key)=random(key)</code>，其中random()为随机函数。当关键字的长度不相等时，采用这种方法比较合适。</strong></p></li></ol><p>在构造散列表的过程中，不管使用什么样的散列函数，冲突都是不可能完全避免的，所以解决冲突是构造散列表的一个必不可少的过程。解决冲突的以主要途径就是当一个关键字映射到散列表中的某一个地址，且该地址上已有关键字时，再为该关键字寻找新的存储地址，常用的解决冲突办法有以下几种：</p><h2 id="Hash冲突解决办法"><a href="#Hash冲突解决办法" class="headerlink" title="Hash冲突解决办法"></a>Hash冲突解决办法</h2><ol><li><p><strong>开放地址法</strong>：开放地址法的基本思想就是当地址发生冲突时，在散列表中再按照某种方法继续探测其他的存储地址，直到找到空闲的地址为止，该过程可描述为<code>H(key) = (H(key)+d) mod m) (m=1,2...k,k&lt;=m-1)</code>，其中H(key)为关键字key的直接散列地址，m为散列表长度，d为每次再探测时的地址增量。</p><p> <strong>采用这种方法时，首先计算出关键字的直接散列地址，即H(key)，若该直接散列地址上已经有其他的关键字了，则继续查看地址为[H(key)+d]的存储地址，判断其是否为空，如此反复，直到找到空闲的存储地址为止，然后将关键字key存放到该地址。</strong></p><p> <strong>增量d可以有不同的取法，常用的有以下3种：</strong></p><ul><li>d = 1，2，3，…，m-1，称为<strong>线性探测再散列。</strong></li><li>d = 12，-12，22，-22，…，-k（k&lt;=m/2），<strong>称为二次探测再散列。</strong></li><li>d = 伪随机序列，<strong>称为伪随机再散列。</strong></li></ul><p> <strong>注意：对于利用开放地址法处理冲突所产生的散列表中，删除一个元素时不能直接删除，因为这样将会影响其他具有相同地址的元素的查找地址，所以，通常采用设定一个特殊的标志的方法表示该元素已被删除。</strong></p></li><li><p><strong>链地址法</strong>:链地址法解决冲突的主要思想是：<strong>若散列表空间为[0,m-1]，则设置一个由m个指针组成的一维数组CH[m]，然后在寻找关键字散列地址的过程中，所有散列地址为i的数据元素都插入到头指针为CH[i]的链表中。</strong>这种方法比较适合于冲突比较严重的情况下使用，例如，设有8个元素{a,b,c,d,e,f,g,h}，采用某种散列函数得到的地址为：{0,2,4,1,0,8,7,2}，当散列表长度为10时，采用链地址法解决冲突的散列表如图所示。<img src="/posts/47572/TIM%E6%88%AA%E5%9B%BE20191108221126.png" alt></p></li><li><p><strong>再散列法</strong>：<strong>当发生冲突时，使用第二个、第三个散列函数计算地址，直到无冲突为止，但这种方法的缺点就是计算时间会大幅增加。</strong></p></li><li><p><strong>建立一个公共溢出区</strong>：<strong>假设散列函数的值域为[0,m-1]，则设向量HashTable[0…m-1]为基本表，另外设立存储空间向量OverTable[0…v]用于存储发生冲突的记录。</strong></p></li></ol><p>Hash主要是用来进行“快速存取”，在O(1)时间复杂度里就可以查找到目标元素，或者判断其是否存在。Hash数据结构里的数据对外是杂乱无序的，因此其具体存储位置及各个存储元素位置之间的相互关系是无法得知的，但是却可以在常数时间里判断元素位置及存在与否，在处理海量数据的过程中，使用Hash方法一般可以快速存取、统计某些数据、将大量数据进行分类，例如提取某日访问网站次数最多的IP地址等。</p><h1 id="Bit-map法"><a href="#Bit-map法" class="headerlink" title="Bit-map法"></a>Bit-map法</h1><p>Bit-map法的基本原理是使用位数组来表示某些元素是否存在，例如从8位电话号码中查重复号码，本法适用于海量数据的快速查找、判重、删除等。</p><p><strong>具体而言，Bit-map法的结果是生成一个N位长的串，每位上以“1”或“0”表示需要排序的集合中的数，例如集合为{2,7,4,9,1,10}，则生成一个10位的串，将第2,7,4,9,1,10位置置为“1”，其余位置置为“0”，当把串中所有位置都置完后，排序也自动完成了，上例中用Bit-map法排序后的结果为1101001011。</strong></p><p><strong>Bit-map法排序的时间复杂度是O(n)，</strong>比一般的排序都快，但它是以空间换时间的（需要一个N位的串），<strong>而且有一些限制，即数据状态不是很多，例如排序前集合大小最好已知，而且集合中元素的最大重复次数必须已知。</strong></p><p>Bit-map法的作用巨大，除了判断数据是否重复以外，也经常使用本法来判断集合中某个数据是否存在。</p><h1 id="Bloom-Filter法"><a href="#Bloom-Filter法" class="headerlink" title="Bloom Filter法"></a>Bloom Filter法</h1><p>在日常生活中，很多地方都会遇到类似这样的问题：在设计计算机软件系统时，经常需要判断一个元素是否在一个集合中；在字处理软件中，需要检查一个英语单词是否拼写正确等。</p><p>针对这些问题，最直接的解决办法就是将集合中的全部元素都存储在计算机中，每当遇到一个新元素时，将它和集合中的元素直接逐个进行比较即可。这种做法虽然能够准确无误的完成任务，但存在一个问题，就是比较次数太多，效率极其低下，当数据量巨大时，例如在海量数据信息处理中，效率低的问题就凸显出来了，例如邮箱总是需要过滤垃圾邮件，一个办法就是记录下那些发邮件的E-mail地址，可是由于那些发送者还会不断的再注册新的地址，如果使用散列表，每存储一亿个E-mail地址，一般每个E-mail地址需要占用16B，所以一共需要1亿*16B，大约1.6GB的内存，除非是超级计算机，一般服务器是无法存储如此海量信息的。</p><p>Bloom Filter正是解决这种问题的有效办法，它是一种空间效率和时间效率都很高的随机数据结构，可用来检测一个元素是否属于一个集合。<strong>但它同样带来的问题就是牺牲了正确率。当它判断某元素不属于这个集合时，该元素一定不属于这个集合；当它判断某个元素属于这个集合时，该元素不一定属于这个集合。</strong>所以Bloom Filter法适用于对低错误率可以容忍的场合。</p><p><strong>Bloom Filter的基本原理是位数组与Hash函数的联合使用。首先Bloom Filter是一个包含了m位的位数组，数组的每一位都初始化为0；其次，定义k个不同的Hash函数，每个函数都可以将集合中的元素映射到位数组的某一位。当向集合中差入一个元素时，根据k个Hash函数可以得到位数组中的k个位，将这些位置置为1。</strong></p><p><strong>如果查询某个元素是否属于集合，那么根据k个Hash函数可以得到位数组中的k个位，查看这k个位中的值，如果有的位不为1，那么该元素肯定不在此集合中；如果这k个位的值全部为1，那么该元素可能在此集合中。在插入其它元素时，可能会将这些位置置为1，这样就产生了错误。</strong></p><p>下面是一个实例：<img src="/posts/47572/TIM%E6%88%AA%E5%9B%BE20191109160124.png" alt></p><p>所以使用Bloom Filter法的难点是如何根据输入元素个数n，来确定位数组m的大小以及Hash函数。<strong>当函数个数k=(ln2)*(m/n)时错误率最小，</strong>在错误率不大于E的情况下，m至少要等于n*lg(1/E)才能表示任意n个元素的集合。但m还应该更大些，因为还要保证位数组里至少一半为0，所以m应该&gt;=nlg(1/E)*lge，<strong>m大概就是nlg(1/E)的1.44倍(lg表示以2为底的对数)。</strong></p><p>假设E为0.01，即错误率为1%，则此时m应该大约为n的13倍。这样k大约是8个（m与n的单位不同，m的单位是bit，n的单位是个数）。通常单个元素的长度有很多bit，所以若使用Bloom Filter法，内存上通常都是节省的。</p><p><strong>Bloom Filter的优点是具有很好的空间效率和时间效率。它的插入和查询时间都是以常数，另外，它不保存元素本身，具有良好的安全性。</strong>然而这些都是以牺牲正确率为代价的。当插入的元素越多，错判“元素属于这个集合的概率”就越大。另外<strong>Bloom Filter只能插入元素，不能删除元素，因为多个元素的散列结果可能会共用Bloom Filter结构中的同一个位，</strong>如果删除元素，就可能会影响多个元素的检测。</p><h1 id="数据库优化法"><a href="#数据库优化法" class="headerlink" title="数据库优化法"></a>数据库优化法</h1><p>互联网上的数据一般都被存储在数据库中，很多情况下，人们并非对这些海量数据本身感兴趣，而是需要从这些海量数据中提取出对自己有用的信息，例如从数据中获取访问最多的页面信息等，这就涉及了数据的查询技术等相关内容。常见的数据库优化方法有如下几种：</p><ul><li><strong>数据分区</strong>：进行海量数据的查询优化，其中一种重要的方式就是如何有效的存储并降低需要处理的数据规模，所以可对海量数据进行分区操作以提高效率，不同的数据库有不同的分区方式，不过处理机制却大致相同。例如将不同的数据存于不同的文件组下，不同的文件组存于不同的磁盘分区下，这样讲数据分散开，减小磁盘I/O，减小系统负荷，还可以将日志、索引等放于不同的分区下。</li><li><strong>索引</strong>：索引一般可以加速数据的检索速度，加速表与表之间的链接，提高性能，所以在对海量数据进行处理时，考虑到信息量较大，应该对表建立索引，包括在主键上建立聚簇索引，将聚合索引建立在日期列上等。索引的优点很多，但是对于索引的建立，还需要考虑到实际情况，而不是对每一个列建立一个索引。</li><li><strong>缓存机制</strong>：当数据量增加时，一般的处理工具都要考虑到缓存问题，缓存大小设置的好差也关系到数据处理的成败，例如，在处理2亿条数据聚合操作时，缓存设置为100000条/Buffer可行。</li><li><strong>加大虚存</strong>：由于系统资源有限，而需要处理的数据量非常大，因此当内存不足时，可以通过增加虚拟内存来解决。</li><li><strong>分批处理</strong>：由于需要处理的信息量巨大，可以对海量数据进行分批处理，然后再对处理后的数据进行合并操作，分而治之，这样有利于小数据量的处理，不至于面对大数据量带来的问题。</li><li><strong>使用临时表或中间表</strong>：数据量增加时，处理中要考虑提前汇总。这样做的目的是化整为零，大表变小表，分块处理完成后，再利用一定的规则进行合并，处理过程中临时表的使用和中间结果的保存都非常重要，如果对于超海量的数据，大表处理不了，只能拆分为多个小表。如果处理过程中需要多步汇总操作，可按汇总步骤一步一步来。</li><li><strong>优化查询语句</strong>：查询语句的性能对查询效率的影响非常大，在对SQL语句的编写过程中，例如减少关联，少用或不用游标，设计好高效的数据库表结构都十分重要。</li><li><strong>使用视图</strong></li><li><strong>使用存储过程</strong></li><li><strong>用排序来取代非顺序存取</strong></li><li><strong>使用采样数据进行数据挖掘</strong></li></ul><h1 id="倒排序索引法"><a href="#倒排序索引法" class="headerlink" title="倒排序索引法"></a>倒排序索引法</h1><p>倒排序索引是目前搜索引擎公司对搜索引擎最常用的存储方式，也是搜索引擎的核心内容，在搜索引擎的实际应用中，有时需要按照关键字的某些值查找记录，索引是按照关键字建立索引，这个索引就被称为倒排序索引。</p><p>倒排序索引也常被称为反向索引、置入档案或反向档案，它本质是一种索引方法，被用来存储在全文搜索下某个单词在一个文档或者一组文档中的存储位置的映射，它是文档检索系统中最常用的数据结构，有两种不同的反向索引形式：</p><ul><li><strong>第一种形式是一条记录的水平反向索引包含每个引用单词的文档的列表</strong></li><li><strong>第二种形式是一个单词的水平反向索引还又包含每个单词在一个文档中的位置。</strong></li></ul><p><strong>第二种形式提供了更多的兼容性，但是需要更多的时间和空间来创建。</strong></p><p>例如，对于如下内容，一般情况下可以采用矩阵的方式来存储：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">D1 : The GDP increased.</span><br><span class="line">D2 : The text is this.</span><br><span class="line">D3 : My name is.</span><br></pre></td></tr></table></figure><p>采用矩阵的方式存储的具体表示见表：<img src="/posts/47572/TIM%E6%88%AA%E5%9B%BE20191109190730.png" alt><br>而根据表中的信息，就能得到下面的倒排序索引：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">The : &#123;D1,D2&#125;;</span><br><span class="line">GDP : &#123;D1&#125;;</span><br><span class="line">increased : &#123;D1&#125;;</span><br><span class="line">Text : &#123;D2&#125;;</span><br><span class="line">is : &#123;D2,D3&#125;;</span><br><span class="line">Name : &#123;D3&#125;.</span><br></pre></td></tr></table></figure><p>通过比较发现，采用倒排序索引比采用矩阵的方式节省很多的空间。</p><p><strong>与正向索引相比，倒排序索引的优点是在处理复杂的多关键字查询时，可在倒排序表中先完成查询的并、交等逻辑运算，得到结果后再对记录进行存取，这样把对记录的查询转换为地址集合的运算，不必对每个记录随机存取，从而提高查询速度。</strong>所以倒排序索引一般被应用于文档检索系统，查询哪些文件包含了某关键字。</p><h1 id="外排序法"><a href="#外排序法" class="headerlink" title="外排序法"></a>外排序法</h1><p>当排序的对象数目特别多时，在内存中不能一次处理，必须把他们以文件的形式存放于外存，排序时再把他们一部分一部分的调入内存进行处理，这种方式就是外排序法。</p><p><strong>外排序是相对内排序而言的，它是大文件的排序，待排序的记录存储在外存储器上，待排序的文件无法一次装入内存，需要内存和外部存储器之间进行多次数据交换，以达到对整个文件进行排序的目的。一般采用归并排序的等方式实现外排序，主要分成两个步骤：第一步，生成若干初始归并段，也能被称为文件预处理，把含有n个记录的文件，按内存大小划分为若干长度为L的子文件，然后分别将子文件调入内存，采用有效的内存排序方法排序后送回外存；第二步，进行多路归并，即对这些初始归并段进行多遍归并，使得有序的归并逐渐扩大，最后在外存上形成整个文件的单一归并段，也就是完成了文件的外排序。</strong></p><p>外排序适用于大数据的排序以及去重复，但外排序也存在着很大的缺陷，就是它会消耗大量的I/O，效率不会很高。</p><h1 id="Trie树"><a href="#Trie树" class="headerlink" title="Trie树"></a>Trie树</h1><p>Trie又称字典树或键树，它是一种用于快速字符串检索到多叉树结构，其原理是利用字符串的公共前缀来减少时空开销，即以空间换时间，从而达到提高程序效率的目的。Trie树的典型应用是用于统计和排序大量的字符串，所以经常被搜索引擎系统用于统计估计文本词频统计。<strong>它的优点是：最大限度地减少无谓的字符串比较，查询效率比散列表高。</strong></p><p><strong>Trie树一般具有3个基本特性：</strong></p><ul><li><strong>根结点不包含字符，除根节点外每一个结点都只包含一个字符。</strong></li><li><strong>从根节点到某一结点，路径上经过字符连接起来，为该结点对应的字符串。</strong></li><li><strong>每个结点的所有子结点包含的字符都不同。</strong><br>Tried树可以利用字符串的公共前缀来节约存储空间，下图该Trie树保存了6个字符串：how,hi,her,hello,so,see。<img src="/posts/47572/17262272-fd996e1e9c48b3f8.webp" alt></li></ul><p><strong>Trie树适用于数据量大、重复多，但是数据种类小可以放入内存的情况，</strong>例如已知n（n很大）个由小写字母构成的平均长度为10的单词，判断其中是否存在某个字符串是另一个字符串的前缀子串。</p><h1 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h1><p>堆是一种树形数据结构，每个结点都有一个值，通常所说的堆，一般是指二叉堆。<strong>在堆中，以大顶堆为例，堆的根节点的值最大，且根节点的两个子树也是以恶搞大顶堆，基于以上特点，堆适用于海量数据求前N大或前N小数问题，其中N一般比较小。</strong></p><p>在海量数据中，堆的作用见下表：<img src="/posts/47572/TIM%E6%88%AA%E5%9B%BE20191109200319.png" alt></p><h1 id="双层桶法"><a href="#双层桶法" class="headerlink" title="双层桶法"></a>双层桶法</h1><p>双层桶不是一种数据结构，而是一种算法思想，类似于分治思想。因为元素范围很大，不能利用直接寻址表，所以通过多次划分，逐步确定范围，然后最后在一个可以接受的范围内进行。</p><p>本文以桶排序进行分析，桶排序的基本思想是把[0,1)划分为n个大小相同的子区间，每一子区间是一个桶，然后将n个记录分配到各个桶中。因为关键字序列是均匀分布在[0,1)上的，所以一般不会有很多个记录落入同一个桶中。桶排序的平均时间复杂度是O(n)，最坏的情况仍有可能是O(n²)，一般只适用于关键字取值比较小的情况，否则所需桶的数目m太多导致浪费存储空间和计算时间。</p><p>一般桶排序适用于寻找第k大的数，寻找中位数，寻找不重复或重复的数字等情况，例如：</p><ul><li>在一个文件中有10G个整数，乱序排列，要求找出中位数，内存限制为2G。</li><li>现在有一个0~30000的随机数生成器，请根据这个随机数生成器，设计一个抽奖范围是0~35000彩票中奖号码列表，其中要包含20000个中奖号码。</li></ul>]]></content>
    
    <summary type="html">
    
      当前各大互联网公司研究都将重点放在了海量数据处理上，但是，只寄希望于硬件扩容是很难满足海量数据处理的，如何利用现有条件进行海量信息处理，已经日益成为当前程序员笔试面试中一个新的亮点。
    
    </summary>
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
  </entry>
  
  <entry>
    <title>HTTP详解</title>
    <link href="http://yoursite.com/posts/62018/"/>
    <id>http://yoursite.com/posts/62018/</id>
    <published>2019-11-03T09:01:41.000Z</published>
    <updated>2019-11-06T10:34:35.868Z</updated>
    
    <content type="html"><![CDATA[<h1 id="HTTP状态码"><a href="#HTTP状态码" class="headerlink" title="HTTP状态码"></a>HTTP状态码</h1><p>状态码的职责是当客户端向服务器端发送请求时，描述返回的请求结果。借助状态码，用户可以知道服务器端是正常处理了请求，还是出现了错误。</p><p>状态码如：200 OK，以3位数字和原因短语组成。数字中第一位指定了响应类别，后两位无分类。响应类别有以下5种：</p><table><thead><tr><th align="center">状态码</th><th align="center">类别</th><th align="center">原因短语</th></tr></thead><tbody><tr><td align="center">1XX</td><td align="center">Informational（信息性状态码）</td><td align="center">接收的请求正在处理</td></tr><tr><td align="center">2XX</td><td align="center">Success（成功状态码）</td><td align="center">请求正常处理完毕</td></tr><tr><td align="center">3XX</td><td align="center">Redirection（重定向状态码）</td><td align="center">需要进行附加操作以完成请求</td></tr><tr><td align="center">4XX</td><td align="center">Client Error（客户端错误状态码）</td><td align="center">服务器无法处理请求</td></tr><tr><td align="center">5XX</td><td align="center">Server Error（服务器错误状态码）</td><td align="center">服务器处理请求出错</td></tr></tbody></table><h2 id="2XX成功"><a href="#2XX成功" class="headerlink" title="2XX成功"></a>2XX成功</h2><p><strong>2XX的响应结果表明请求被正常处理了。</strong></p><ul><li><strong>200 OK</strong>： <strong>表示从客户端发来的请求在服务器端被正常处理了。</strong>在响应报文内，随状态码一起返回的信息会因方法定不同而发生改变。比如，使用GET方法时，对应请求资源的实体会作为响应返回；而使用HEAD方法时，对应请求资源的实体主体不随报文首部作为响应返回。</li><li><strong>204 No Content</strong>：<strong>该状态码代表服务器接收的请求已成功处理，但在返回的响应报文中不含实体的主体部分。另外，也不允许返回任何实体的主体。</strong>一般在只需从客户端往服务器发送信息，而对客户端不需要发送新信息内容的情况下使用。</li><li><strong>206 Partial Content</strong>：<strong>该状态码表示客户端进行了范围请求，而服务器成功执行了这部分的GET请求。响应报文中包含由Content-Range指定范围的实体内容。</strong></li></ul><h2 id="3XX重定向"><a href="#3XX重定向" class="headerlink" title="3XX重定向"></a>3XX重定向</h2><p><strong>3XX响应结果表明浏览器需要执行某些特殊的处理以正确处理请求。</strong></p><ul><li><strong>301 Moved Permanently</strong>：<strong>永久性重定向。</strong>该状态码表示请求的资源已被分配了新的URI，以后应使用资源现在所指的URI。也就是说，如果已经把资源对应的URI保存为书签了，这时应该按Location首部字段提示的URI重新保存。</li><li><strong>302 Found</strong>：<strong>临时性重定向。</strong>该状态码表示请求的资源已被分配了新的URI，希望用户（本次）能使用新的URI访问。和301 Moved Permanently状态码相似，但302状态码代表的资源不是被永久移动。</li><li><strong>303 See Other</strong>：<strong>该状态码表示由于请求对应的资源存在着另一个URI，应使用GET方法定向获取请求的资源。</strong>303状态码和302 Found状态码有着相同的功能，<strong>但303状态码明确表示客户端应当采用GET方法获取资源，</strong>这点与302状态码有所区别。</li></ul><p><strong>当301、302、303响应状态码返回时，几乎所有的浏览器都会把POST改成GET，并删除请求报文内的主体，之后请求会自动再次发送。</strong></p><ul><li><strong>304 Not Modified</strong>：<strong>该状态码表示客户端发送附带条件的请求时，服务器端允许请求访问资源，但因发生请求未满足条件的情况后，直接返回304 Not Modified（服务器端资源未改变，可直接使用客户端未过期的缓存）。304状态码返回时，不包含任何响应的主体部分。304虽然被划分在3XX类别中，但是和重定向没有任何关系。</strong></li><li><strong>307 Temporary Redirect</strong>：<strong>临时重定向</strong>，该状态码与302 Found有着相同的含义。尽管302标准禁止POST变换成GET，但实际使用时大家并不遵守。<strong>307会遵照浏览器标准，不会从POST变成GET。</strong></li></ul><h2 id="4XX客户端错误"><a href="#4XX客户端错误" class="headerlink" title="4XX客户端错误"></a>4XX客户端错误</h2><p><strong>4XX的响应结果表明客户端是发生错误的原因所在。</strong></p><ul><li><strong>400 Bad Request</strong>：<strong>该状态码表示请求报文中存在语法错误。</strong>当错误发生时，需修改请求的内容再次发送请求。另外。浏览器会像200 OK一样对待该状态码。</li><li><strong>401 Unauthorized</strong>：<strong>该状态码表示发送的请求需要有通过HTTP认证的信息。另外若之前已进行过1次请求，则表示用户认证失败。</strong>返回含有401的响应必须包含一个是用于被请求资源的WWW Authenticate首部用以质询用户信息。当浏览器初次接收到401响应，会弹出认证用的对话窗口。</li><li><strong>403 Forbidden</strong>：<strong>该状态码表明对请求资源的访问被服务器拒绝了。</strong>服务器端没有必要给出拒绝的详细理由，但如果想做说明的话，可以在实体的主体部分对原因进行描述，这样就能让用户看到了。</li><li><strong>404 Not Found</strong>：<strong>该状态码表明服务器上无法找到请求的资源。</strong>除此之外，也可以在服务器端拒绝请求且不想说明理由时使用。</li></ul><h2 id="5XX服务器错误"><a href="#5XX服务器错误" class="headerlink" title="5XX服务器错误"></a>5XX服务器错误</h2><p><strong>5XX的响应结果表明服务器本身发生错误。</strong></p><ul><li><strong>500 Internal Server Error</strong>：<strong>该状态码表明服务器端在执行请求时发生了错误。</strong>也有可能是Web应用存在bug或某些临时错误的故障。</li><li><strong>503 Service Unavailable</strong>：<strong>该状态码表明服务器暂时处于超负载状态或正在进行停机维护，现在无法处理请求。</strong>如果事先得知解除以上状况需要的时间，最好写入RetryAfter 首部字段再返回给客户端。</li></ul><h1 id="与HTTP协作的Web服务器"><a href="#与HTTP协作的Web服务器" class="headerlink" title="与HTTP协作的Web服务器"></a>与HTTP协作的Web服务器</h1><p>HTTP通信时，除客户端和服务器以外，还有一些用于通信数据转发的应用程序，例如代理、网关和隧道。它们可以配合服务器工作。这些应用程序和服务器可以将请求转发给通信线路上的下一站服务器，并且能接收从那台服务器发送的响应再转发给客户端。</p><ul><li><strong>代理</strong>：<strong>代理是一种有转发功能的应用程序，它扮演了位于服务器和客户端“中间人”的角色，</strong>接收由客户端发送的请求并转发给服务器，同时也接收服务器返回的响应并转发给客户端。</li><li><strong>网关</strong>：<strong>网关是转发其他服务器通信数据的服务器，</strong>接收从客户端发送来的请求时，它就像自己拥有资源的源服务器一样对请求进行处理。有时客户端可能都不会察觉，自己的通信目标是一个网关。</li><li><strong>隧道</strong>：<strong>隧道是在相隔甚远的客户端和服务器两者之间进行中转，并保持双方通信连接的应用程序。</strong></li></ul><h2 id="代理"><a href="#代理" class="headerlink" title="代理"></a>代理</h2><p><strong>代理服务器的基本行为就是接收客户端发送的请求后，转发给其他服务器。代理不改变请求URI，会直接发送给前方持有资源的目标服务器。</strong></p><p>持有资源实体的服务器被称为源服务器，从源服务器返回的响应经过代理服务器后再传给客户端。</p><p><strong>在HTTP通信过程中，可级联多台代理服务器。</strong>请求和响应的转发会经过数台类似锁链一样连接起来的代理服务器。<strong>转发时，需要附加Via首部字段以标记出经过的主机信息。</strong></p><p>使用代理服务器的理由有：<strong>利用缓存技术减少网络带宽的流量，组织内部针对特定网站的访问控制，以获取访问日志为主要目的，</strong>等等。</p><p>代理有多种使用方法，按两种基准分类：<strong>一种是是否使用缓存，另一种是是否会修改报文。</strong></p><ul><li><strong>缓存代理</strong>：代理转发响应时，<strong>缓存代理会预先将资源的副本（缓存）保存在代理服务器上</strong>。当代理再次接收到对相同资源的请求时，就可以不从源服务器那里获取资源，而是将之前缓存的资源作为响应返回。</li><li><strong>透明代理</strong>：转发请求或响应时，<strong>不对报文做任何加工的代理类型被称为透明代理</strong>。反之，对报文内容进行加工的代理被称为非透明代理。</li></ul><h2 id="网关"><a href="#网关" class="headerlink" title="网关"></a>网关</h2><p>网关的工作机制和代理十分相似，而<strong>网关能使通信线路上的服务器提供非HTTP协议服务。</strong></p><p>利用网关能提高通信的安全性，因为可以在客户端与网关之间的通信线路上加密以确保连接的安全。比如，网关可以连接数据库，使用SQL语句查询数据。另外，在Web购物网站上进行信用卡结算时，网管可以和信用卡结算系统联动。</p><h2 id="隧道"><a href="#隧道" class="headerlink" title="隧道"></a>隧道</h2><p><strong>隧道可按要求建立起一条与其他服务器的通信线路，届时使用SSL等加密手段进行通信。隧道的目的是确保客户端能与服务器进行安全的通信。</strong></p><p><strong>隧道本身不会去解析HTTP请求，也就是说，请求保持原样中转给之后的服务器。隧道会在通信双方断开连接时结束。</strong></p><h2 id="保存资源的缓存"><a href="#保存资源的缓存" class="headerlink" title="保存资源的缓存"></a>保存资源的缓存</h2><p><strong>缓存是指代理服务器或客户端本地磁盘内保存的资源副本。利用缓存可减少对源服务器的访问，因此也就节省了通信流量和通信时间。</strong></p><p>缓存服务器是代理服务器的一种，并归类在缓存代理类型中。换句话说，当代理转发从服务器返回的响应时，代理服务器将会保存一份资源的副本。</p><p>缓存服务器的优势在于利用缓存可避免多次从源服务器转发资源。因此客户端可就近从缓存服务器上获取资源，而源服务器也不必多次处理相同的请求了。</p><ul><li><strong>缓存的有效期限</strong>：当遇上源服务器上的资源更新时，如果还使用不变的缓存 ，那就会演变成返回更新前的“旧”资源了。<strong>即使存在缓存，也会因为客户端的要求、缓存的有效期等因素，向源服务器确认资源的有效性。若判断缓存失效，缓存服务器将会再次从源服务器上获取“新”资源。</strong></li><li><strong>客户端的缓存</strong>：缓存不仅可以存在于缓存服务器内，还可以存在客户端浏览器中。浏览器缓存如果有效，就不必再向服务器请求相同的资源了，可以直接从本地磁盘内读取。另外，和缓存服务器相同的一点是，当判定缓存过期后，会向源服务器确认资源的有效性。若判断浏览器缓存失效，浏览器会再次请求新资源。</li></ul><h1 id="HTTP首部"><a href="#HTTP首部" class="headerlink" title="HTTP首部"></a>HTTP首部</h1><p>HTTP协议的请求和响应报文中必定包含HTTP首部，首部内容为客户端和服务器分别处理请求和响应提供所需要的信息。对于客户端用户来说，这些信息中的大部分内容都无须亲自查看。</p><p>HTTP首部字段是构成HTTP报文的要素之一。在客户端与服务器之间以HTTP协议进行通信的过程中，无论是请求还是响应都会使用首部字段，它能起到传递额外重要信息的作用。使用首部字段是为了给浏览器和服务器提供报文主体大小、所使用的语言、认证信息等内容。</p><p>HTTP首部字段是由首部字段名和字段值构成的，中间用冒号“：”分割。<code>首部字段名：字段值</code>。对于字段值对应单个HTTP首部字段可以有多个值：<code>Keep-Alive：timeout=15，max=100</code></p><p>HTTP首部字段根据实际用途被分为以下4种类型：</p><ul><li><strong>通用首部字段</strong>：请求报文和响应报文两方都会使用的首部。</li><li><strong>请求首部字段</strong>：从客户端向服务端发送请求报文时使用的首部。补充了请求的附加内容、客户端信息、响应内容相关优先级等信息。</li><li><strong>响应首部字段</strong>：从服务器端向客户端返回响应报文时使用的首部。补充了相应的附加内容，也会要求客户端附加额外的内容信息。</li><li><strong>实体首部字段</strong>：针对请求报文和响应报文的实体部分使用的首部。补充了资源内容更新时间等与实体有关的信息。</li></ul><p>下面是HTTP/1.1首部字段一览，共47种：</p><ul><li><strong>通用首部字段：</strong><img src="/posts/62018/TIM%E6%88%AA%E5%9B%BE20191103210305.png" alt></li><li><strong>请求首部字段：</strong><img src="/posts/62018/TIM%E6%88%AA%E5%9B%BE20191103210332.png" alt></li><li><strong>响应首部字段：</strong><img src="/posts/62018/TIM%E6%88%AA%E5%9B%BE20191103210400.png" alt></li><li><strong>实体首部字段：</strong><img src="/posts/62018/TIM%E6%88%AA%E5%9B%BE20191103210433.png" alt></li></ul><h2 id="通用首部字段"><a href="#通用首部字段" class="headerlink" title="通用首部字段"></a>通用首部字段</h2><p>通用首部字段是指，请求报文和响应报文双方都会使用的首部。</p><h3 id="Cache-Control"><a href="#Cache-Control" class="headerlink" title="Cache-Control"></a>Cache-Control</h3><p><strong>通过指定首部字段Cache-Control的指令，就能操作缓存的工作机制。</strong>指令的参数是可选的，多个指令之间通过“，”分隔。首部字段Cache-Control的指令可用于请求及时响应。下面是Cache-Control指令一览：</p><ul><li><strong>缓存请求指令：</strong><img src="/posts/62018/TIM%E6%88%AA%E5%9B%BE20191103213849.png" alt></li><li><strong>缓存响应指令：</strong><img src="/posts/62018/TIM%E6%88%AA%E5%9B%BE20191103213913.png" alt></li></ul><h3 id="Connection"><a href="#Connection" class="headerlink" title="Connection"></a>Connection</h3><p>Connection首部字段具备如下两个作用：</p><ul><li><strong>控制不再转发给代理的首部字段</strong><img src="/posts/62018/TIM%E6%88%AA%E5%9B%BE20191103214424.png" alt>在客户端发送请求和服务器返回响应内，使用Connectioin首部字段，可控制不再转发给代理的首部字段。</li><li><strong>管理持久连接</strong><img src="/posts/62018/TIM%E6%88%AA%E5%9B%BE20191103214525.png" alt>HTTP/1.1版本的默认连接都是持久连接。为此，客户端会在持久连接上连续发送请求。<strong>当服务器端想明确断开连接时，则指定Connection首部字段的值为Close。</strong>HTTP/1.1之前的HTTP版本的默认连接都是非持久连接。为此如果想在旧版本的HTTP协议上维持持久连接，则需要<strong>指定Connection首部字段的值为Keep-Alive。</strong>服务器就会如图上一样加上首部字段Keep-Alive及首部字段Connection后返回响应。</li></ul><h3 id="Date"><a href="#Date" class="headerlink" title="Date"></a>Date</h3><p><strong>首部字段Date表明创建HTTP报文的日期和时间。</strong>HTTP/1.1协议规定的日期时间的格式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Date: Tue, 03 Jul 2012 04:40:59 GMT</span><br></pre></td></tr></table></figure><h3 id="Pragma"><a href="#Pragma" class="headerlink" title="Pragma"></a>Pragma</h3><p>Pragma时HTTP/1.1之前版本的历史遗留字段，仅作为与HTTP/1.0的向后兼容而定义。该首部字段只用在客户端发送的请求中。客户端会要求所有的中间服务器不返回缓存的资源。<strong>HTTP/1.1完全可以使用Cache-Control：no-cache代替。</strong></p><h3 id="Trailer"><a href="#Trailer" class="headerlink" title="Trailer"></a>Trailer</h3><p><strong>首部字段Trailer会事先说明在报文主体后记录了哪些首部字段。该首部字段可应用在HTTP/1.1版本分块传输编码时。</strong><br><img src="/posts/62018/TIM%E6%88%AA%E5%9B%BE20191103215501.png" alt><br>上图中，指定首部字段Trailer的值为Expires，在报文主体之后出现了首部字段Expires。</p><h3 id="Transfer-Encoding"><a href="#Transfer-Encoding" class="headerlink" title="Transfer-Encoding"></a>Transfer-Encoding</h3><p><strong>首部字段Transfer-Encoding规定了传输报文主体时采用的编码方式。HTTP/1.1的传输编码方式仅对分块传输编码有。效</strong><img src="/posts/62018/TIM%E6%88%AA%E5%9B%BE20191103215748.png" alt><br>上图正证如在首部字段Transfer-Encoding中指定的那样，有效使用分块传输编码，且分别被分成3312字节和914字节大小的分块数据。</p><h3 id="Upgrade"><a href="#Upgrade" class="headerlink" title="Upgrade"></a>Upgrade</h3><p><strong>首部字段Upgrade用于检测HTTP协议及其他协议是否可使用更高的版本进行通信，其参数可以用来指定一个完全不同的通信协议。</strong><img src="/posts/62018/TIM%E6%88%AA%E5%9B%BE20191103220121.png" alt></p><p>如上图，<strong>使用首部字段Upgrade时，还需要额外指定Connection：Upgrade。对于附有首部字段Upgrade的请求，服务器可用101 Switching Protocols状态码作为响应返回。</strong></p><h3 id="Via"><a href="#Via" class="headerlink" title="Via"></a>Via</h3><p><strong>使用首部字段Via是为了追踪客户端与服务器端之间的请求和响应报文的传输路径。报文经过代理或网关时，会现在首部字段Via中附加该服务器的信息，然后再进行转发。</strong></p><p><strong>首部字段Via不仅用于追踪报文的转发，还可避免请求回环的发生。所以必须在经过代理时附加该首部字段内容。</strong></p><p>Via首部是为了追踪传输路径，所以经常会和TRACE方法一起使用。比如，代理服务器接收到由TRACE方法发送过来的请求时，其中Max-Forward：0，代理服务器就不能再转发该请求了。这种情况下，代理服务器会将自身的信息附加到Via首部后，返回该去请求的响应。</p><h3 id="Warning"><a href="#Warning" class="headerlink" title="Warning"></a>Warning</h3><p>HTTP/1.1的Warning首部是从HTTP/1.0的响应首部（Retry-After）演变来的。<strong>该首部通常会告知用户一些与缓存相关的问题的警告。</strong>Warning首部的格式如下，最后的日期时间部分可省略：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Warning: [警告码][警告的主机:端口号]“[警告内容]”([日期时间])</span><br></pre></td></tr></table></figure><p>HTTP/1.1中定义了7种警告，警告码对应的警告内容可如下参考：<img src="/posts/62018/TIM%E6%88%AA%E5%9B%BE20191103221113.png" alt></p><h2 id="请求首部字段"><a href="#请求首部字段" class="headerlink" title="请求首部字段"></a>请求首部字段</h2><p>请求首部字段是从客户端往服务器端发送请求报文中所使用的字段，用于补充请求的附加信息、客户端信息、对响应内容相关的优先级等内容。</p><ul><li><strong>Accept</strong>：<strong>Accept首部字段可通知服务器,用户代理能够处理的媒体类型及媒体类型的相对优先级。</strong>可使用type/subtype这种形式，一次指定多种媒体类型。例如，文本文件：text/html，text/plain；图片文件：image/png等等。若想要给显式的媒体类型增加优先级，则使用q=来额外表示权重值，用分号“;”进行分隔。权重范围为0~1，默认为1。</li><li><strong>Accept-Charset</strong>：<strong>该首部字段可用来通知服务器用户代理支持的字符集及字符集的相对优先顺序。</strong>另外，可一次性指定多种字符集。与首部字段Accept相同的是可以使用权重。</li><li><strong>Accept-Encoding</strong>：<strong>Accent-Encoding首部字段可用来告知服务器用户代理支持的内容编码及内容编码的优先级顺序，</strong>可一次性指定多种内容编码。如gzip、compress…。</li><li><strong>Accept-Language</strong>：<strong>该首部字段用来告知服务器用户代理能够处理的自然语言集，以及自然语言集的相对优先级。</strong>可一次指定多种自然语言集。</li><li><strong>Authorization</strong>：<strong>该首部字段用来告知服务器，用户代理的认证信息。</strong>通常，想要通过服务器认证的用户代理在接收到返回的401状态码响应后，把首部字段Authorization加入请求中。</li><li><strong>Expect</strong>：<strong>客户端使用Expect首部字段告知服务器，期望出现的某种特定行为。因服务器无法理解客户端的期望做出回应而发生错误时，会返回状态码417 Expectation Failed。等待状态码100响应的客户端在发生请求时，需要指定Expect：100-continue。</strong></li><li><strong>Form</strong>：<strong>用来告知服务器使用用户代理的用户的电子邮件地址。</strong>通常其使用目的就是为了显示搜索引擎等用户代理的负责人的电子邮件联系方式。</li><li><strong>Host</strong>：<strong>该首部字段会告知服务器，请求的资源所处的互联网主机名和端口号。Host首部字段在HTTP/1.1规范内是唯一一个必须被包含在请求内的首部字段。</strong></li><li><strong>If-Match</strong>：<strong>形如If-xxx这种样式的请求首部字段，都可称为条件请求。服务器接收到附带条件的请求后，只有判断指定条件为真时，才会执行请求。该首部字段会告知服务器匹配资源所用的实体标记（ETag）值，仅当两者一致时，才会执行请求，反之返回状态码412 Precondition Failed的响应。</strong></li><li><strong>If-Modified-Since</strong>：<strong>该首部字段会告知服务器若该字段值早于资源的更新时间，则希望能处理该请求。如果在该字段值的日期时间之后，请求的资源都没有更新过，则返回状态码304 Not Modified响应。</strong></li><li><strong>If-None-Match</strong>：<strong>它和首部字段If-Match作用相反，</strong>用于指定字段值的实体标记（ETag）值与请求资源的ETag不一致时，它就告知服务器处理该请求。</li><li><strong>If-Range</strong>：<strong>它告知服务器若指定的If-Range字段值和请求资源的ETag值或时间相一致时，则作范围请求处理，反之则返回全体资源。</strong></li><li><strong>If-Unmodified-Since</strong>：它与首部字段If-Modified-Since的作用相反。</li><li><strong>Max-Forwards</strong>：<strong>通过TRACE方法或OPTIONS方法，发送包含首部字段Max-Forwards的请求时，该字段以十进制整数形式指定可经过的服务器最大数目。</strong></li><li><strong>Proxy-Authorization</strong>：接收到从代理服务器发来的认证质询时，客户端会发送包含该首部字段的请求，以告知服务器认证所需的信息。</li><li><strong>Range</strong>：<strong>对于只需获取部分资源的范围请求，包含该首部字段即可告知服务器资源的指定范围。接收到附带Range首部字段请求的服务器，会在处理请求之后返回状态码206 Partial Content。无法处理该范围请求时，则会返回状态码200 OK的响应及全部资源。</strong></li><li><strong>Referer</strong>：它会告知服务器请求的原始资源的URI。</li><li><strong>TE</strong>：它会告知服务器客户端能够处理响应的传输编码方式及相对优先级，和Accept-Encoding很像，但是用于传输编码。</li><li><strong>User-Agent</strong>：<strong>该首部字段会将创建请求的浏览器和用户代理名称等信息传达给服务器。</strong></li></ul><h2 id="响应首部字段"><a href="#响应首部字段" class="headerlink" title="响应首部字段"></a>响应首部字段</h2><p>响应首部字段是由服务器向客户端返回响应报文中所使用的字段，用于补充响应的附加信息、服务器信息，以及对客户端的附加要求等信息。</p><ul><li><strong>Accept-Ranges</strong>：<strong>该首部字段是用来告知客户端服务器是否能够处理范围请求，以指定获取服务器端某个部分的资源。可指定的字段值有两种，可处理范围请求时指定其为byte，反之则指定为none；</strong></li><li><strong>Age</strong>：告知客户端，源服务器在多久前创建了响应。字段值的单位为秒。</li><li><strong>ETag</strong>：告知客户端实体标识，它是一种可将资源以字符串形式做唯一性表示的方式。服务器会为每份资源分配对应的ETag值。<ul><li><strong>强ETag</strong>：不论实体发生多么细微的变化都会改变其值。</li><li><strong>若ETag</strong>：只用于提示资源是否相同，只有资源发生了根本改变才会变该其值。会在字段值最开始附加W/。</li></ul></li><li><strong>Location</strong>：<strong>可将响应接收方引导至某个与请求URI位置不同的资源。基本上会配合3xx：Redirecting的响应，提供重定向的URI。</strong></li><li><strong>Proxy-Authenticate</strong>：会把由代理服务器所要求的认证信息发送给客户端。</li><li><strong>Retry-After</strong>：<strong>告知客户端多久之后再次发送请求。主要配和状态码503 Service Unavailabl使用。</strong></li><li><strong>Server</strong>：<strong>告知客户端当前服务器上安装的HTTP服务器应用程序的信息，</strong>不单会标出服务器上的软件应用名称，还有可能包括版本号和安装时启用的可选项。</li><li><strong>Vary</strong>：可对缓存进行控制。源服务器会向代理服务器传达关于本地缓存使用方法的命令。</li><li><strong>WWW-Authenticate</strong>：告知客户端适用于访问请求URI所指定资源的认证方案和带参数提示的质询。<strong>状态码401 Unauthorized响应中，肯定带有该首部字段。</strong></li></ul><h2 id="实体首部字段"><a href="#实体首部字段" class="headerlink" title="实体首部字段"></a>实体首部字段</h2><p>实体首部字段是包含在请求报文和响应报文中的实体部分所使用的首部，用于补充内容的更新时间等与实体相关的信息。</p><ul><li><strong>Allow</strong>：<strong>用于通知客户端能够支持Request-URI指定资源的所有HTTP方法。当服务器接收到不支持的HTTP方法时，会以状态码405 Method Not Allowed作为响应返回，同时还会把所有能支持的HTTP方法写入首部字段Allow后返回。</strong></li><li><strong>Content-Encoding</strong>：<strong>告知客户端服务器对实体的主体部分选用的内容编码。如gzip、compress等。</strong></li><li><strong>Content-Language</strong>：告知客户端实体主体使用的自然语言。</li><li><strong>Content-Length</strong>：表明实体主体部分的大小，单位是字节。<strong>当编码传输时，则不能使用Content-Length首部字段。</strong></li><li><strong>Content-Location</strong>：给出与报文主体部分相对应的URI。</li><li><strong>Content-MD5</strong>：该字段值是一串由MD5算法生成的值，目的在于检查报文主体在传输过程中是否保持完整，以及确认传输到达。</li><li><strong>Content-Range</strong>：针对范围请求，返回响应时使用的首部字段Content-Range，能告知客户端作为响应返回的哪个部分符合范围请求。</li><li><strong>Content-Type</strong>：<strong>说明实体主体内对象的媒体类型，和Accept一样。</strong></li><li><strong>Expires</strong>：<strong>会将资源失效的日期告知客户端，缓存服务器在接收到含有首部字段Expires的响应后，会以缓存来应答请求，在到该该值指定时间之前，响应的副本会一直被保存。当首部字段Cache-Control有指定max-age指令时，会优先处理max-age指令。</strong></li><li><strong>Last-Modified</strong>：指明资源最终修改的时间。</li></ul><h2 id="为Cookie服务的首部字段"><a href="#为Cookie服务的首部字段" class="headerlink" title="为Cookie服务的首部字段"></a>为Cookie服务的首部字段</h2><p>Cookie的工作机制是用户识别及状态管理。Web网站为了管理用户的状态会通过Web浏览器，把一些临时数据写入用户的计算机内。接着当用户访问该Web网站时，可通过通信方式取回之前存放的Cookie。</p><table><thead><tr><th align="center">首部字段名</th><th align="center">说明</th><th align="center">首部类型</th></tr></thead><tbody><tr><td align="center">Set-Cookie</td><td align="center">开始状态管理所使用的Cookie信息</td><td align="center">响应首部字段</td></tr><tr><td align="center">Cookie</td><td align="center">服务器接收到的Cookie信息</td><td align="center">请求首部字段</td></tr></tbody></table><ul><li><strong>Set-Cookie</strong>：下标列举了Set-Cookie的字段值<img src="/posts/62018/TIM%E6%88%AA%E5%9B%BE20191104221710.png" alt></li><li><strong>Cookie</strong>：会告知服务器，当客户端想获得HTTP状态管理支持时，就会在请求中包含从服务器接收到的Cookie。</li></ul><h1 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h1><p>在HTTP协议中有可能存在信息窃听或身份伪装等安全问题。使用HTTPS通信机制可以有效地防止这些问题。</p><h2 id="HTTP的缺点"><a href="#HTTP的缺点" class="headerlink" title="HTTP的缺点"></a>HTTP的缺点</h2><p>到目前为止，已经了解了HTTP具有相当优秀和方便的一面，然而HTTP并非只有好的一面，它也有不足之处：</p><ul><li><strong>通信使用明文（不加密），内容可能会被窃听。</strong></li><li><strong>不验证通信方的身份，因此有可能遭遇伪装。</strong></li><li><strong>无法证明报文的完整性，所以有可能已遭篡改。</strong></li></ul><h2 id="HTTPS是身披SSL外壳的HTTP"><a href="#HTTPS是身披SSL外壳的HTTP" class="headerlink" title="HTTPS是身披SSL外壳的HTTP"></a>HTTPS是身披SSL外壳的HTTP</h2><p>HTTPS的加密方式就是通信加密。HTTP协议中没有加密机制，但可以通过和SSL或TLS的组合使用，加密HTTP的通信内容。</p><p>用SSL建立安全通信线路之后，就可以在这条线路上进行HTTP通信了，与SSL组合使用的HTTP被称为HTTPS。因此HTTPS并非应用层的一种新协议，知识HTTP通信接口部分用SSL和TLS协议代替而已。</p><p><strong>通常，HTTP直接与TCP通信。当使用SSL时，则变成先和SSL通信，再由SSL和TCP通信了，简言之，所谓HTTPS就是身披着SSL协议这层外壳的HTTP。</strong></p><p>在采用SSL后，HTTP就拥有了HTTPS的加密、证书和完整性保护这些功能。SSL是独立于HTTP的协议，所以不光是HTTP协议，其他运行在应用层的SMTP和Telnet等协议均可配合SSL协议使用。</p><h2 id="HTTPS加密过程"><a href="#HTTPS加密过程" class="headerlink" title="HTTPS加密过程"></a>HTTPS加密过程</h2><p>HTTPS使用非对称加密，具体过程如下：</p><ol><li><strong>服务端先把自己的公钥（key1）发给证书颁发机构，向证书颁发机构申请证书。</strong></li><li><strong>证书颁发机构也有自己的一对公钥私钥，机构使用自己的私钥来加密key1，并且通过服务端网址等信息生成一个数字签名信息，证书签名同样经过机构的私钥加密。证书制作完成后，把这个证书返回给服务端。</strong></li><li><strong>当客户端向服务端请求通信时，服务端把自己申请的证书返回给客户端。</strong></li><li><strong>客户端收到证书以后，要做的第一件事情就是验证证书的真伪性。因为各大浏览器和操作系统已经维护了所有权威证书机构的名称和公钥，所以客户端根据证书颁发的机构，使用那个机构的公钥对证解密，书上的数字签名进行验证。</strong></li><li><strong>客户端对证书验证成功后，就可以放心的再次利用机构公钥，解密出服务端的公钥key1。</strong></li><li><strong>客户端生成自己的对称加密密钥key2，并且用服务端的公钥key1加密key2，发送给服务端。</strong></li><li><strong>服务端使用自己的私钥解密，得到对称加密的密钥key2，于是客户端与服务端之间开始使用key2进行对称加密的通信。</strong></li></ol><h2 id="HTTPS也有缺点"><a href="#HTTPS也有缺点" class="headerlink" title="HTTPS也有缺点"></a>HTTPS也有缺点</h2><p>HTTPS也存在一些问题，那就是当使用SSL时，它的处理速度会变慢。<strong>SSL的慢分为两种：一种是指通信慢，另一种是指由于大量消耗CPU及内存等资源，导致处理速度变慢。</strong></p><p>和使用HTTP相比，网络负载可能会变慢2到100倍，<strong>除去和TCP连接、发送HTTP请求/响应以外，还必须进行SSL通信，因此整体上处理通信量不可避免会增加。</strong></p><p><strong>另一点就是SSL必须进行加密处理。在服务器和客户端都需要进行加密和解密的运算处理，因此从结果上来讲，比起HTTP会更多的消耗服务器和客户端的硬件资源，导致负载增强。</strong></p><h1 id="基于HTTP的功能追加协议"><a href="#基于HTTP的功能追加协议" class="headerlink" title="基于HTTP的功能追加协议"></a>基于HTTP的功能追加协议</h1><p>虽然HTTP协议简单又简捷，但随着时代的发展，其功能使用上捉襟见肘的疲态已经凸显，因此下面将讲解一下基于HTTP新增的功能的协议。</p><h2 id="SPDY"><a href="#SPDY" class="headerlink" title="SPDY"></a>SPDY</h2><p>Google在2010年发布了SPDY（取自speedy），其开发目标旨在解决HTTP的性能瓶颈，缩短Web页面的加载时间（50%）。若想在现有Web实现所需的功能，以下这些HTTP标准就会成为瓶颈：</p><ul><li>一条连接上只可发送一个请求。</li><li>请求只能从客户端开始，客户端不可以接收除响应以外的指令。</li><li>请求/响应首部未经压缩就发送，首部信息越多延迟越大。</li><li>发送冗长的首部，每次互相发送相同的首部造成的浪费较多。</li><li>可任意选择数据压缩格式，非强制压缩发送。</li></ul><h3 id="长轮询与短轮询"><a href="#长轮询与短轮询" class="headerlink" title="长轮询与短轮询"></a>长轮询与短轮询</h3><p>长轮询与短轮询是基于Ajax实现的解决办法，使用局部刷新的方法可以达到实时更新的效果，但是依旧没有解决HTTP协议本身的问题。</p><ul><li><strong>长轮询</strong>:<strong>长轮询是服务器收到请求后如果有数据，立刻响应请求；如果没有数据，就会保持连接一段时间，这段时间内如果有数据立刻响应请求，如果时间到了还没有数据，则响应HTTP请求。浏览器在收到请求后，再立刻发送一个同样HTTP请求查询是否有数据。</strong>长轮询的局限在与：<ul><li><strong>浏览器对同一服务器同时HTTP连接有最大限制，最好同一用户只存在一个长轮询。</strong></li><li><strong>服务端没有数据时，保持连接时会造成浪费，容易产生服务器瓶颈。</strong></li></ul></li><li><strong>短轮询</strong>：<strong>短轮询是服务器收到请求时不管是否有数据都直接响应HTTP请求，浏览器收到HTTP响应隔一段时间后，再发送同样的HTTP请求查询是否有数据。HTTP短轮询的局限性在于实时性相对低一些。</strong></li></ul><h3 id="Comet的解决办法"><a href="#Comet的解决办法" class="headerlink" title="Comet的解决办法"></a>Comet的解决办法</h3><p>一旦服务器有内容更新，Comet不会让请求等待，而是直接给客户端返回响应，<strong>这是一种通过延迟应答，模拟实现服务器端向客户端推送的功能。</strong></p><p>通常，服务器端接收到请求，在处理完毕后就会立即返回响应，<strong>但为了实现推送功能，Comet会先将响应置于挂起状态，当服务器端有内容更新时，再返回该响应。</strong>因此，服务端一旦有更新，就可以立即反馈给客户端。</p><p><strong>内容上虽然可以做到实时更新，但为了保留响应，一次连接的持续时间也变长了。</strong>期间，为了维持连接会消耗更多的资源。另外，Comet也仍未解决HTTP协议本身的问题。</p><h3 id="SPDY的设计与功能"><a href="#SPDY的设计与功能" class="headerlink" title="SPDY的设计与功能"></a>SPDY的设计与功能</h3><p>处于持续开发状态中的SPDY协议，正是为了在协议级别消除HTTP所遭遇的瓶颈。SPDY没有完全改写HTTP协议，而是在TCP/IP的应用层与传输层之间通过新加会话层的形式运作。<strong>同时考虑到安全性问题，SPDY规定通信中使用SSL。</strong></p><p>SPDY以会话层的形式加入，控制对数据的流动，但还是采用HTTP建立通信连接，因此可照常使用HTTP的GET和POST等方法、Cookie以及HTTP报文等。<img src="/posts/62018/TIM%E6%88%AA%E5%9B%BE20191106180112.png" alt><br>使用SPDY后，HTTP协议额外获得以下功能：</p><ul><li><strong>多路复用流</strong>：<strong>通过单一的TCP连接，可以无限制处理多个HTTP请求，所有请求的处理都在一条TCP连接上完成，</strong>因此TCP的处理效率得到提高。</li><li><strong>赋予请求优先级</strong>：SPDY不仅可以无限制的并发处理请求，还可以给请求逐个分配优先级顺序。这样主要是为了在发送多个请求时，<strong>解决因带宽低而导致响应变慢的问题。</strong></li><li><strong>压缩HTTP首部</strong>：<strong>压缩HTTP请求和响应的首部</strong>，这样通信产生的数据包流量和发送的字节数就更少了。</li><li><strong>推送功能</strong>：<strong>支持服务器主动向客户端推送数据的功能，</strong>这样服务器就可直接发送数据，而不必等待客户端的请求。</li><li><strong>服务器提示功能</strong>：<strong>服务器可以主动提示客户端请求所需的资源。</strong>由于在客户端发现资源之前就可以获知资源的存在，因此在资源已缓存等情况下，<strong>可以避免发送不必要的请求。</strong></li></ul><h2 id="全双工通信的WebSocket"><a href="#全双工通信的WebSocket" class="headerlink" title="全双工通信的WebSocket"></a>全双工通信的WebSocket</h2><p>WebSocket视野更独立的协议标准，即Web浏览器与Web服务器之间全双工通信标准，一旦Web服务器与客户端之间建立起WebSocket协议的通信连接，之后所有的通信都依靠这个专用协议进行。通信过程中可互相发送JSON、XML、HTML或图片的等任意格式的数据。</p><p><strong>由于是建立在HTTP基础上的协议，因此连接的发起方仍是客户端，而一但确立WebSocket通信连接，不论服务器还是客户端，任意一方都可直接向对方发送报文。</strong>下面是WebSocket协议的主要特点：</p><ul><li><strong>推送功能</strong>：<strong>支持由服务器向客户端推送数据的推送功能，</strong>这样服务器可直接发送数据，而不必等待客户端的请求。</li><li><strong>减少通信量</strong>：<strong>只要建立起WebSocket连接，就希望一直保持连接状态</strong>。和HTTP相比，<strong>不但每次连接时的总开销减少，而且由于WebSocket的首部信息很小，通信量也相应减小了。</strong></li></ul><h2 id="HTTP-2-0"><a href="#HTTP-2-0" class="headerlink" title="HTTP/2.0"></a>HTTP/2.0</h2><p>HTTP/2.0的目标是改善用户在使用Web是的速度体验，HTTP/2.0围绕着主要的7项技术进行讨论，现阶段大都倾向于采用以下协议的技术：</p><ul><li><strong>多路复用</strong></li><li><strong>TLS义务化</strong></li><li><strong>协商</strong></li><li><strong>客户端拉拽/服务器推送</strong></li><li><strong>流量控制</strong></li><li><strong>WebSocket</strong></li></ul>]]></content>
    
    <summary type="html">
    
      详细介绍了HTTP相关的细节和技术，如HTTP的状态码、与Web服务器交互时使用到的技术、首部字段HTTPS以及HTTP各个版本之间的区别等等内容。
    
    </summary>
    
      <category term="计算机网络" scheme="http://yoursite.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
  </entry>
  
  <entry>
    <title>HTTP协议介绍</title>
    <link href="http://yoursite.com/posts/2668/"/>
    <id>http://yoursite.com/posts/2668/</id>
    <published>2019-11-02T08:16:03.000Z</published>
    <updated>2019-11-02T14:22:32.900Z</updated>
    
    <content type="html"><![CDATA[<h1 id="通过请求和响应的交换达成通信"><a href="#通过请求和响应的交换达成通信" class="headerlink" title="通过请求和响应的交换达成通信"></a>通过请求和响应的交换达成通信</h1><p>HTTP协议规定，请求从客户端发出，最后服务器端响应该请求并返回，换句话说，肯定是先从客户端开始建立通信的，服务端在没有接收到接收到请求之前不会发送响应。下面是一个简单的例子：<img src="/posts/2668/TIM%E6%88%AA%E5%9B%BE20191102163147.png" alt></p><p>下面是从客户端发送给某个HTTP服务器的请求报文中的内容</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">GET /index.htm HTTP/1.1</span><br><span class="line">Host:hackr.jp</span><br></pre></td></tr></table></figure><p><strong>起始行开头的GET表示请求访问服务器的类型，称为方法（method）。随后的字符串/index.htm指明了请求访问的资源对象，也叫做请求的URI。最后的HTTP/1.1即HTTP的版本号，用来提示客户端使用的HTTP协议功能。</strong>请求报文是由请求方法、请求URI、协议版本、可选的请求首部字段和内容实体构成的。</p><p>综合来看，这段请求内容的意思是：请求访问某台HTTP服务器上的/index.htm页面资源。</p><p>接收到请求的服务器，会将请求内容的处理结果以响应的形式返回。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 200 OK </span><br><span class="line">Date: Tue, 10 Jul 2012 06:50:15 GMT </span><br><span class="line">Content-Length: 362 </span><br><span class="line">Content-Type: text/html</span><br><span class="line"></span><br><span class="line">&lt;html&gt; </span><br><span class="line">……</span><br></pre></td></tr></table></figure><p><strong>在起始行开头的HTTP/1.1表示服务器对应的HTTP版本，紧挨着的200 OK表示请求的处理结果的状态码和原因短语。下一行显示了创建响应的日期时间，是首部字段内的一个属性。接着以一空行分隔，之后的内容称为资源实体的主体。</strong>响应报文基本上由协议版本、状态码、用以解释状态码的原因短语、可选的响应首部字段以及实体主体构成。</p><h1 id="告知服务器意图的HTTP方法"><a href="#告知服务器意图的HTTP方法" class="headerlink" title="告知服务器意图的HTTP方法"></a>告知服务器意图的HTTP方法</h1><p>下面我们介绍合同HTTP/1.1中可使用的方法。</p><h2 id="GET：获取资源"><a href="#GET：获取资源" class="headerlink" title="GET：获取资源"></a>GET：获取资源</h2><p><strong>GET方法用来请求访问已被URI识别的资源。指定的资源经服务器端解析后返回响应内容。</strong></p><h2 id="POST：传输实体主体"><a href="#POST：传输实体主体" class="headerlink" title="POST：传输实体主体"></a>POST：传输实体主体</h2><p><strong>POST方法用来传输实体的主体。</strong></p><p>虽然用GET方法也可以传输实体的主体，但一般不用GET方法进行传输，而是用POST方法。虽说POST的功能与GET很相似，但POST的主要目的并不是获取响应的主体内容。</p><h2 id="PUT：传输文件"><a href="#PUT：传输文件" class="headerlink" title="PUT：传输文件"></a>PUT：传输文件</h2><p><strong>PUT方法用来传输文件。</strong>就像FTP协议的文件上传一样，要求在请求报文的主体中包含文件内容，然后保存到请求URI指定的位置。</p><p>但是鉴于HTTP/1.1的PUT方法自身不带验证机制，任何人都可以上传文件，存在安全性问题，因此一般的Web网站不使用该方法。</p><h2 id="HEAD：获得报文首部"><a href="#HEAD：获得报文首部" class="headerlink" title="HEAD：获得报文首部"></a>HEAD：获得报文首部</h2><p><strong>HEAD方法和GET方法一样，只是不返回报文主体部分。用于确认URI的有效性及资源更新的日期时间等。</strong></p><h2 id="DELETE：删除文件"><a href="#DELETE：删除文件" class="headerlink" title="DELETE：删除文件"></a>DELETE：删除文件</h2><p><strong>DELETE方法用来删除文件，是与PUT相反的方法。DELETE方法按请求URI删除指定的资源。</strong></p><p>但是HTTP/1.1的DELETE方法本身和PUT方法一样不带验证机制，所以一般的Web网站也不使用DELETE方法。</p><h2 id="OPTIONS：询问支持的方法"><a href="#OPTIONS：询问支持的方法" class="headerlink" title="OPTIONS：询问支持的方法"></a>OPTIONS：询问支持的方法</h2><p><strong>OPTIONS方法用来查询针对请求URI指定的资源支持的方法。</strong></p><h2 id="TRACE：追踪路径"><a href="#TRACE：追踪路径" class="headerlink" title="TRACE：追踪路径"></a>TRACE：追踪路径</h2><p><strong>TRACE方法是让Web服务器端将之前的请求通信返回给客户端的方法。</strong>发送请求时，在Max-Forwards首部字段中填入数值，每经过一个服务器端就将该数字减1，当数值刚好减到0时，就停止继续传输，最后接收到请求的服务器端则返回状态码200 OK的响应。</p><p>客户端通过TRACE方法可以查询发送出去的请求是怎样被加工修改/篡改的。这是因为，请求想要连接到源目标服务器可能会通过代理中转，TRACE方法用来确认连接过程中发生的一系列操作。</p><p>但是TRACE方法本来就不怎么常用，再加上它容易引发XST（跨站追踪）攻击，通常就更不会用到了。</p><h2 id="CONNECT：要求用隧道协议连接代理"><a href="#CONNECT：要求用隧道协议连接代理" class="headerlink" title="CONNECT：要求用隧道协议连接代理"></a>CONNECT：要求用隧道协议连接代理</h2><p>CONNECT方法要求在与代理服务器通信时建立隧道，实现用隧道协议进行TCP通信。主要使用SSL和TLS协议把通信内容加密后经网络隧道传输。</p><h1 id="持久连接节省通信量"><a href="#持久连接节省通信量" class="headerlink" title="持久连接节省通信量"></a>持久连接节省通信量</h1><p><strong>HTTP协议的初始化版本中，每进行一次HTTP通信就要断开一次TCP连接。这也就是短连接。</strong></p><h2 id="持久连接（长连接）"><a href="#持久连接（长连接）" class="headerlink" title="持久连接（长连接）"></a>持久连接（长连接）</h2><p>为了解决TCP连接的问题，HTTP/1.1和一部分的HTTP/1.0想出了持久连接的方法，也就是长连接。</p><p>持久连接的特点是，只要任意一端没有明确的提出断开连接，则保持TCP连接状态。</p><p><strong>持久连接的好处在于减少了TCP连接的重复建立和断开所造成的额外开销，减轻了服务器端的负载。另外，减少开销的那部分时间，使HTTP请求和响应能够更早的结束，这样Web页面的显示速度也就相应提高了。</strong></p><p>在HTTP/1.1中，所有的连接默认都是持久连接，但是在HTTP/1.0中并未标准化。虽然有一部分服务器通过非标准的手段实现了持久连接，但服务器端不一定能够支持持久连接。毫无疑问，除了服务器端，客户端也需要支持持久连接。</p><h2 id="管线化"><a href="#管线化" class="headerlink" title="管线化"></a>管线化</h2><p><strong>持久连接是的多数请求以管线化方式发送成为可能。从前发送请求后需等待并收到响应，才能发送下一个请求。管线化技术出现后，不用等待响应亦可直接发送下一个请求。</strong></p><p>这样就能够做到同时并行发送多个请求，而不需要一个接一个的等待响应了。</p><h1 id="使用Cookie的状态管理"><a href="#使用Cookie的状态管理" class="headerlink" title="使用Cookie的状态管理"></a>使用Cookie的状态管理</h1><p>HTTP是无状态协议，它不对之前发生过的请求和响应的状态进行管理，也就是说，无法根据之前的状态进行本次的请求处理。</p><p>不可否认，无状态协议当然有它的优点，由于不必保存状态，自然可减少服务器的CPU及内存资源的消耗。从另一侧面来说，也正是因为HTTP协议本身是非常简单的，所以才会被应用在各种场景里。</p><p>保留无状态协议这个特征的同时又要解决类似的矛盾问题，于是引入了Cookie技术。Cookie技术通过在请求和响应报文中写入Cookie信息来控制客户端的状态。</p><p><strong>Cookie会根据从服务器发送的响应报文内的一个叫做Set-Cookie的首部字段信息，通知客户端保存Cookie。当下次客户端再往服务器发送请求时，客户端会自动在请求报文中加入Cookie的值后发送出去。</strong></p><p>服务端发现客户端发送过来的Cookie后，会去检查究竟是从哪一个客户端发来的请求，然后对比服务器上的记录，最后得到之前的状态信息。</p><h1 id="HTTP报文"><a href="#HTTP报文" class="headerlink" title="HTTP报文"></a>HTTP报文</h1><p>用于HTTP协议交互的信息被称为HTTP报文。请求端（客户端）的HTTP报文叫做请求报文，响应端（服务器端）的叫做响应报文。HTTP报文本身是由多行数据构成的字符串文本。</p><p><strong>HTTP报文大致可分为报文首部和报文主体两块。两者由最初出现的空行来划分。通常并不一定要有报文主体。</strong><img src="/posts/2668/TIM%E6%88%AA%E5%9B%BE20191102210913.png" alt></p><h2 id="请求报文及响应报文的结构"><a href="#请求报文及响应报文的结构" class="headerlink" title="请求报文及响应报文的结构"></a>请求报文及响应报文的结构</h2><p>下面是请求报文和响应报文的结构：<br><img src="/posts/2668/TIM%E6%88%AA%E5%9B%BE20191102210947.png" alt></p><p>请求报文和响应报文的首部内容由以下数据组成。</p><ul><li><strong>请求行</strong>：包含用于<strong>请求的方法</strong>，<strong>请求URI</strong>和<strong>HTTP版本</strong>。</li><li><strong>状态行</strong>：包含表明<strong>响应结果的状态码</strong>，<strong>原因短语</strong>和<strong>HTTP版本</strong>。</li><li><strong>首部字段</strong>：包含表示<strong>请求和响应的各种条件</strong>和<strong>属性的各类首部</strong>。一般有4种首部，分别是：<strong>通用首部、请求首部、响应首部和实体首部。</strong></li><li><strong>其他</strong>：可能包含HTTP的RFC里未定义的首部，例如Cookie等。</li></ul><h1 id="编码提升传输速率"><a href="#编码提升传输速率" class="headerlink" title="编码提升传输速率"></a>编码提升传输速率</h1><h2 id="压缩传输的内容编码"><a href="#压缩传输的内容编码" class="headerlink" title="压缩传输的内容编码"></a>压缩传输的内容编码</h2><p>HTTP报文的主题用于传输请求或响应的实体主体。向待发送邮件内增加附件时，为了使邮件容量变小，我们会先用ZIP压缩文件之后再添加附件发送。HTTP协议中有一种被称为<strong>内容编码</strong>的功能也能进行类似的操作。</p><p><strong>内容编码指明应用在实体内容上的编码格式，并保持实体信息原样压缩。内容编码后的实体由客户端接收并负责解码。</strong><br><img src="/posts/2668/TIM%E6%88%AA%E5%9B%BE20191102214621.png" alt><br>常用的内容编码有以下几种：</p><ul><li>gzip（GUN zip）</li><li>compress（UNIX系统的标准压缩）</li><li>deflate（zlib）</li><li>identity（不进行编码）</li></ul><h2 id="分割发送的分块传输编码"><a href="#分割发送的分块传输编码" class="headerlink" title="分割发送的分块传输编码"></a>分割发送的分块传输编码</h2><p>在HTTP通信过程中，请求的编码实体资源尚未全部传输完成之前，浏览器无法显示请求页面。在传输大容量数据时，通过把数据分割成多块，能够让浏览器逐步显示页面。</p><p>这种把实体主体分块的功能称为<strong>分块传输编码</strong>。<strong>分块传输编码会将实体主体分成多个部分（块）。每一块都会用十六进制来标记块的大小，而实体主体的最后一块会使用“0（CR+LF）”来标记。</strong></p><p><strong>使用分块传输编码的实体主体由接收的客户端负责解码，恢复到编码前的实体主体。</strong>在HTTP/1.1中存在一种称为传输编码的机制，它可以在通信时按某种编码方式传输，但只定义作用于分块传输编码中。</p><h1 id="发送多种数据的多部分对象集合"><a href="#发送多种数据的多部分对象集合" class="headerlink" title="发送多种数据的多部分对象集合"></a>发送多种数据的多部分对象集合</h1><p>发送邮件时，我们可以在邮件里写入文字并添加多份附件。这是因为采用了MIME机制，它允许邮件处理文本、图片、视频等多种不同类型的数据。相应的HTTP协议中也采纳了多部分对象集合，发送的一份报文主体内可含有多类型实体。通常是在图片或文本文件等上传时使用。</p><p>多部分对象集合包含的对象如下：</p><ul><li><strong>multipart/form-data</strong>：在Web表单文件上传时。<img src="/posts/2668/TIM%E6%88%AA%E5%9B%BE20191102215923.png" alt></li><li><strong>multipart/byteranges</strong>：状态码206（Partial Content，部分内容）响应报文包含了多个范围的内容时使用。<img src="/posts/2668/TIM%E6%88%AA%E5%9B%BE20191102215945.png" alt></li></ul><p><strong>在HTTP报文中使用多部分对象集合时，需要在首部字段里加上Content-type。使用boundary字符串来划分多部分对象集合指明的各类实体。在boundary字符串指定的各个实体的起始行之前插入“–”标记，而在多部分对象集合对应的字符串最后插入“–”标记作为结束。</strong></p><p>多部分对象集合的每个部分类型中，都可以含有首部字段。另外可以在某个部分中嵌套使用多部份对象集合。</p><h1 id="获取部分内容的范围请求"><a href="#获取部分内容的范围请求" class="headerlink" title="获取部分内容的范围请求"></a>获取部分内容的范围请求</h1><p>HTTP实现了为需要指定下载的实体范围。像这样，指定范围发送的请求叫做<strong>范围请求</strong>。对一份10000字节大小的资源，如果使用范围请求，可以只请求5001-10000字节内的资源。<img src="/posts/2668/TIM%E6%88%AA%E5%9B%BE20191102221113.png" alt></p><p>执行范围请求时，会用到首部字段Range来指定资源的byte范围。byte范围的指定形式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">5001~10 000 字节</span><br><span class="line">Range: bytes=5001-10000</span><br><span class="line"></span><br><span class="line">从 5001 字节之后全部的</span><br><span class="line">Range: bytes=5001</span><br><span class="line"></span><br><span class="line">从一开始到 3000 字节和 5000~7000 字节的多重范围</span><br><span class="line">Range: bytes=-3000, 5000-7000</span><br></pre></td></tr></table></figure><p><strong>针对范围请求，响应会返回状态码206 Partial Content的响应报文。另外，对于多重范围的范围请求，响应会在首部字段Content-Type标明multipart/byteranges后返回响应报文。</strong></p><p><strong>如果服务器端无法响应范围请求，则会返回状态码200 OK和完整的实体内容。</strong></p><h1 id="内容协商返回最合适的内容。"><a href="#内容协商返回最合适的内容。" class="headerlink" title="内容协商返回最合适的内容。"></a>内容协商返回最合适的内容。</h1><p><strong>内容协商机制是指客户端和服务器端就响应的资源内容进行交涉，然后提供给客户端最为合适的资源。内容协商会以语言、字符集、编码方式等为基准判断响应的资源。</strong></p><p>包含在请求报文中的某些首部字段就是判断的基准：</p><ul><li>Accept</li><li>Accept-Charset</li><li>Accept-Encoding</li><li>Accept-Language</li><li>Content-Language</li></ul>]]></content>
    
    <summary type="html">
    
      本章针对HTTP协议结构进行讲解，主要使用HTTP1.1版本，对HTTP协议的大概介绍，相关的详细细节在下一章讲解。
    
    </summary>
    
      <category term="计算机网络" scheme="http://yoursite.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
  </entry>
  
  <entry>
    <title>TCP与UDP</title>
    <link href="http://yoursite.com/posts/6245/"/>
    <id>http://yoursite.com/posts/6245/</id>
    <published>2019-10-27T13:44:29.000Z</published>
    <updated>2019-10-30T14:26:41.938Z</updated>
    
    <content type="html"><![CDATA[<p>TCP/IP中有两个具有代表性的传输层协议，它们分别时TCP和UDP。TCP体哦概念股可靠的通信传输，而UDP则常被用于让广播和细节控制交给应用的通信传输。总之，根据通信的具体特征，选择合适的传输层协议是非常重要的。</p><ul><li><strong>TCP</strong>：TCP是面向连接的、可靠的流协议。流就是指不间断的数据结构，你可以把它想象成排水管道中的水流。当应用程序采用TCP发送消息时，虽然可以保证发送的顺序，但还是犹如没有任何间隔的数据流发送给接收端。</li><li><strong>UDP</strong>：UDP是不具有可靠性的数据报协议。细微的处理它会交给上层的应用去完成。在UDP的情况下，虽然可以确保发送消息的大小，却不能保证消息一定会到达。因此，应用有时会根据自己的需要进行重发处理。</li></ul><h1 id="端口号"><a href="#端口号" class="headerlink" title="端口号"></a>端口号</h1><h2 id="端口号定义"><a href="#端口号定义" class="headerlink" title="端口号定义"></a>端口号定义</h2><p><strong>数据链路和IP中的地址，分别指的是MAC地址和IP地址，前者用来识别同一链路中不同的计算机，后者用来识别TCP/IP网络中互联的主机和路由器。</strong>在传输层中也有这种类似于地址的概念，那就是端口号。<strong>端口号用来识别一台计算机中进行通信的不同应用程序。因此，它也被称为程序地址。</strong></p><h2 id="根据端口号识别应用"><a href="#根据端口号识别应用" class="headerlink" title="根据端口号识别应用"></a>根据端口号识别应用</h2><p>一台计算机上同时可以运行多个程序。例如接收WWW服务的Web浏览器、电邮客户端、远程登录用的ssh客户端等程序都可同时运行。传输层协议正是利用这些端口号识别本机中正在进行通信的应用程序，并准确的将数据传输。<img src="/posts/6245/TIM%E6%88%AA%E5%9B%BE20191027215945.png" alt></p><p><strong>但是仅凭目标端口识别某一个通信是远远不够的。TCP/IP或UDP/IP通信中通常采用5个信息来识别一个通信。它们是“源IP地址”、“目标IP地址”、“协议号”、“源端口号”、“目标端口号”。只要其中某一项不同，则被认为是其它通信。</strong></p><h2 id="端口号如何确定"><a href="#端口号如何确定" class="headerlink" title="端口号如何确定"></a>端口号如何确定</h2><p>在实际进行通信时，要事先确定端口号。确定端口号的方法有两种：</p><h3 id="标准既定的端口号"><a href="#标准既定的端口号" class="headerlink" title="标准既定的端口号"></a>标准既定的端口号</h3><p><strong>这种方法也叫静态方法。它是指每个应用程序都有其指定的端口号。</strong>但并不是说可以随意使用任何一个端口号。每个端口号都有其对应的使用目的。</p><p>例如，HTTP、TELNET、FTP等广为使用的应用协议中所使用的端口号就是固定的。这些端口号也被称为知名端口号。知名端口号一般由0到1023的数字分配而成。应用程序应该避免使用知名端口号进行既定目的之外的通信，以免产生冲突。</p><h3 id="时序分配法"><a href="#时序分配法" class="headerlink" title="时序分配法"></a>时序分配法</h3><p><strong>第二种方法也叫时序（或动态）分配法。此时，服务端有必要确定监听端口号，但是接受服务的客户端没必要确定端口号。</strong></p><p>在这种方法下，客户端应用程序可以完全不用自己设置端口号，而全权交给操作系统进行分配。操作系统可以为每个应用程序分配互不冲突的端口号。例如：每需要一个新的端口号，就在之前分配的号码的基础上加1.这样操作系统就可以动态的管理端口号了。</p><p>根据这种分配端口号的机制，即使是同一个客户端程序发起的多个TCP连接，是被这些通信的5部分数字也不会全部相同。</p><p>动态分配的端口号取值范围在49152到65536之间。</p><h2 id="端口号与协议"><a href="#端口号与协议" class="headerlink" title="端口号与协议"></a>端口号与协议</h2><p><strong>端口号有其使用的传输层协议决定。因此不同的传输协议可使用相同的端口号，</strong>例如，TCP与UDP使用同一个端口号，但使用目的各不相同，这是因为端口号上的处理是根据每个传输协议的不同而进行的。</p><p><strong>数据到达IP层后，会先检查IP首部中的协议号，再传给相应协议的模块。如果TCP则传给TCP模块，如果是UDP则传给UDP模块去做端口号的处理。即使是同一个端口号，由于传输协议是各自独立地进行处理，因此相互之间不会受到影响。</strong></p><p>此外，那些知名端口号与传输层协议并无关系，只要端口号一致都将分配同一程序进行处理。</p><h1 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h1><p>UDP是User Datagram Protocol的缩写。</p><p><strong>UDP不提供复杂的控制机制，利用IP提供面向无连接的通信服务。并且它是将应用程序发来的数据在收到的那一刻，立即按照原样发送到网络上的一种机制。</strong></p><p><strong>即使是出现网络拥堵的情况下，UDP也无法进行流量控制等避免网络阻塞的行为。此外，传输途中即使出现丢包，UDP也不负责重发。甚至当出现包的到达顺序乱掉时也没有纠正的功能。如果需要这些细节控制，那么不得不交由采用UDP的应用程序去处理</strong>。</p><p>由于UDP面向无连接，它可以随时发送数据。再叫上UDP本身的处理既简单又高效，因此经常用于以下几个方面：</p><ul><li>包总量较少的通信（DNS、SNMP等）</li><li>视频、音频等多媒体通信</li><li>限定于LAN等特定网络中的应用通信</li><li>广播通信（广播、多播）</li></ul><h1 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h1><p>与UDP相比，TCP与UDP的区别相当大。<strong>它充分的实现了数据传输时各种控制能力，可以进行丢包时的重发控制，还可以对次序乱掉的分包进行顺序控制。此外，YCP作为一种面向连接的协议，只有在确认通信对端存在时才会发送数据，从而可以控制通信流量的浪费。</strong></p><h2 id="通过序列号与确认应答提高可靠性"><a href="#通过序列号与确认应答提高可靠性" class="headerlink" title="通过序列号与确认应答提高可靠性"></a>通过序列号与确认应答提高可靠性</h2><p><strong>在TCP种，当发送端的数据到达接受主机时，接收端主机会返回一个已收到消息的通知。这个消息叫做确认应答（ACK）。TCP通过肯定的确认应答实现可靠的数据传输。</strong>当发送端将数据发出之后会等待对端的确认应答。如果有确认应答，说明数据已经成功到达对端。反之，则数据丢的可能性很大。</p><p>在一定时间内没有等到确认应答，发送端就可以认为数据已经丢失，并进行重发。由此即使产生了丢包，仍然能够保证数据能到达对端，实现可靠传输。</p><p>此外，还有可能因为一些其他原因导致确认应答延迟到达，在源主机重发数据之后才到达的情况。此时源发送主机只要按照机制重发数据即可，但是对于目标主机来说简直是一种“灾难”。它会反复收到相同的数据，而为了对上层应用提供可靠的传输，必须得放弃重复的数据包。</p><p>为此，就必须引入一种机制，它能够识别是否已经收到数据，又能判断是否需要接受。<strong>接收端查询接收数据TCP首部中的序列号和数据的长度，将自己下一步应该接受的序号作为确认应答反送回去。</strong>这样通过序列号和确认应答号TCP就可以实现可靠传输。</p><h2 id="重发超时如何确定"><a href="#重发超时如何确定" class="headerlink" title="重发超时如何确定"></a>重发超时如何确定</h2><p>重发超时是指在重发数据之前，等待确认应答到来的那个特定时间间隔。如果超过了这个时间仍未收到确认应答，发送端将进行数据重发，所以问题就是如何确定这个重发超时的时间长度。</p><p>TCP要求不论在何种网络环境下都要提供高性能通信，并且无论网络拥堵情况发生何种变化，都必须保持这一特性。<strong>为此，它在每次发包时都会计算往返时间及其偏差。将这二者相加，重发超时的时间就是比这个总和要稍大一点的值。</strong></p><p>综上所述，其重发超时时间一般设置为6秒左右。数据被重发之后若还是收不到确认应答，则进行再次发送。此时，等待确认应答的时间将会以2倍、4倍的指数函数延长。</p><p>当然数据也不会被无限次反复的重发，当达到一定重发次数之后，如果仍没有任何确认应答返回，就会判断为网络对端主机发生了异常，强制关闭连接。并且通知应用通信异常强行终止。</p><h2 id="连接管理"><a href="#连接管理" class="headerlink" title="连接管理"></a>连接管理</h2><h3 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h3><p>三次握手其实就是指建立一个TCP连接时，需要客户端和服务器总共发送3个包。</p><p><strong>进行三次握手的主要作用就是为了确认双方的接收能里和发送能力是否正常，指定自己初始化序列号为后面的可靠传输做准备，实质上就是连接服务器指定端口，建立TCP连接，并同步连接双方的序列号和确认号，减缓TCP窗口大小的信息。</strong></p><ol><li><strong>刚开始客户端处于 Closed 的状态，服务端处于 Listen 状态。</strong></li><li><strong>第一次握手：建立连接时，客户端发送SYN包（SYN=1，即同步序列号；seq=x）到服务器，并进入SYN_SENT状态，等待服务器确认。</strong></li><li><strong>第二次握手：服务器收到SYN包，必须确认客户的SYN（ack=x+1，ACK=1），同时自己也发送一个SYN包（SYN=1，seq=y），即SYN+ACK包，此时服务器进入SYN_RECV状态。</strong></li><li><strong>第三次握手：客户端收到服务器的SYN+ACK包，向服务器发送确认包ACK（ACK=1，seq=x+1，ack=y+1)，此包发送完毕，客户端和服务器进入ESTABLISHED的状态，表示连接成功。</strong><br><img src="/posts/6245/v2-2a54823bd63e16674874aa46a67c6c72_hd.jpg" alt></li></ol><h4 id="半连接队列"><a href="#半连接队列" class="headerlink" title="半连接队列"></a>半连接队列</h4><p><strong>服务器第一次收到客户端的SYN之后，就会处于SYN_SEND的状态，此时双方还没有完全建立其连接，服务器就会把此状态下请求连接放到一个队列里，这种队列就称之为半连接队列。</strong></p><p><strong>当然还有一个全连接队列，就是已经完成三次握手，建立起连接的就会放在全连接队列中。如果队列满了就有可能会出现丢包现象。</strong></p><p>服务器发送完SYN-ACK包，如果未收到客户确认包，服务器进行首次重传，等待一段时间仍未收到客户确认包，进行第二次重传。如果重传次数超过系统规定的最大重传次数，系统将该连接信息从半连接队列中删除。注意，每次重传等待的时间不一定相同，一般会是指数增长，例如间隔时间为 1s，2s，4s，8s…</p><h4 id="seq的选择"><a href="#seq的选择" class="headerlink" title="seq的选择"></a>seq的选择</h4><p>当一端为建立连接而发送它的SYN时，它为连接选择一个初始序号，这个序号就是seq，也叫做ISN。</p><p><strong>ISN随时间变化，因此每个连接都将具有不同的ISN。</strong>ISN可以看作是一个32比特的计数器，每4ms加一。这样选择序号的目的在于防止在网络中被延迟的分组在以后又被传送，而导致某个连接的一方对它做出错的反应。<strong>因此ISN是动态生成的。</strong></p><h4 id="携带数据"><a href="#携带数据" class="headerlink" title="携带数据"></a>携带数据</h4><p><strong>在三次握手中，第一次、第二次握手是不可以携带数据的，但是第三次握手是可以携带数据的。</strong></p><p>为什么这样呢?大家可以想一个问题，假如第一次握手可以携带数据的话，如果有人要恶意攻击服务器，那他每次都在第一次握手中的 SYN 报文中放入大量的数据。因为攻击者根本就不理服务器的接收、发送能力是否正常，然后疯狂着重复发 SYN 报文的话，这会让服务器花费很多时间、内存空间来接收这些报文。</p><p>也就是说，第一次握手不可以放数据，其中一个简单的原因就是会让服务器更加容易受到攻击了。而对于第三次的话，此时客户端已经处于 ESTABLISHED 状态。对于客户端来说，他已经建立起连接了，并且也已经知道服务器的接收、发送能力是正常的了，所以能携带数据也没啥毛病。</p><h4 id="SYN攻击及解决办法"><a href="#SYN攻击及解决办法" class="headerlink" title="SYN攻击及解决办法"></a>SYN攻击及解决办法</h4><p>服务端的资源分配是在第二次握手时分配的，但客户端端资源是在完成三次握手时分配的，所以服务器容易受到SYN洪泛攻击。SYN攻击就是客户端在短时间内伪造大量不存在的IP地址，并向服务器不断的发送SYN包，服务器则回复确认包，并等待客户端回复。这些伪造的SYN包将长时间占用未连接队列，导致正常的SYN请求因为队列满而被丢弃，从而引起网络拥塞甚至系统瘫痪。SYN攻击是一种典型的DDOS攻击。</p><p>常见的防御 SYN 攻击的方法有如下几种：</p><ul><li><strong>缩短超时时间</strong></li><li><strong>增大最大短连接数</strong></li><li><strong>过滤网关防护</strong></li><li><strong>SYN cookie技术</strong></li></ul><h3 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h3><ol><li><strong>客户端发出连接释放报文，即FIN包（FIN=1，seq=u，u为前面已经传过来的数据的最后一个字节的序号+1），并且停止发送数据，此时，客户端进入FIN_WAIT_1状态，FIN报文即使不携带数据，也要消耗一个序号。</strong></li><li><strong>服务器收到FIN包，发出确认报文，即ACK包（ACK=1，seq=v，ack=u+1），此时服务端就进入了CLOSE_WAIT状态，TCP服务器通知高层的应用程序，客户端向服务器的方向就释放了，这时候处于半关闭状态，因为即使客户端已经没有数据要发送了，但是服务器若要发送数据，客户端依然要接收。</strong></li><li><strong>客户端收到服务器的确认请求后，此时客户端就进入FIN_WAIT_2状态，等待服务器发送连接释放报文，即服务器的FIN包。</strong></li><li><strong>服务器最后的数据发送完毕后，就向客户端发送FIN包（FIN==1，ACK=1，seq=w，ack=u+1），此时服务器就进入了LAST_ACK状态，等待客户端确认。</strong></li><li><strong>客户端收到服务器的连接释放报文后，必须发出确认ACK包（ACK=1，seq=u+1，ack=w+1），此时客户端就进入了TIME_WAIT状态！！此时TCP连接还没有释放，必须经过2MSL的等待后，才进入CLOSED状态。</strong></li><li><strong>服务器收到客户端的ACK包后，立即进入CLOSED状态。结束这次的TCP连接。</strong><br><img src="/posts/6245/v2-c7d4b5aca66560365593f57385ce9fa9_hd.jpg" alt></li></ol><h4 id="等待2XMLS的意义"><a href="#等待2XMLS的意义" class="headerlink" title="等待2XMLS的意义"></a>等待2XMLS的意义</h4><p>MSL说“最长报文段寿命”的意思，他是任何报文在网络上存在最长时间，超过这个时间报文将被丢弃。</p><p>为了保证客户端发送的最后一个ACK包能够到达服务器，因为这个ACK有可能丢失，从而导致处在LAST_ACK状态的服务器收不到对FIN_ACK的确认报文，服务器会重传这个FIN_ACK包，接着客户端再重传一次确认，重新启动时间等待器。最后客户端和服务端都能正常关闭。</p><p>假设客户端不等待2MLS，而是在发送完ACK之后直接释放关闭，一旦这个ACK丢失，服务器就无法正常进入关闭连接状态。因此可以总结为两个理由：</p><ul><li><strong>保证客户端发送的最后一个ACK报文段能够到达服务器</strong></li><li><strong>防止“已失效的连接请求报文段”出现在本连接中</strong></li></ul><h2 id="TCP以段为单位发送数据"><a href="#TCP以段为单位发送数据" class="headerlink" title="TCP以段为单位发送数据"></a>TCP以段为单位发送数据</h2><p>在建立TCP连接的同时，也可以确定发送数据包的单位，我们也可以称其为“最大消息长度（MSS）”。最理想的情况是，最大消息长度正好是IP中不会被分片的最大数据长度。</p><p><strong>TCP在传送大量数据时，是以MSS的大小将数据进行分割发送，进行重发时也是以MSS为单位。</strong></p><p><strong>MSS是在三次握手的时候，在两端主机之间被计算得出。两端的主机在发出建立连接的请求时，会在TCP首部中写入MSS选项，告诉对方自己的接口能够适应的MSS大小。然后会在两者之间选择一个较小的值使用。</strong></p><p><img src="/posts/6245/TIM%E6%88%AA%E5%9B%BE20191029223512.png" alt></p><h2 id="利用窗口控制提高速度"><a href="#利用窗口控制提高速度" class="headerlink" title="利用窗口控制提高速度"></a>利用窗口控制提高速度</h2><p>TCP以1个段为单位，每发一个段进行一次确认应答的处理，这样的传输方式的缺点就是，包的往返时间越长通信性能就越低。</p><p>为了解决这个这个问题，TCP引入了窗口的概念，确认应答不再是以每个分段，而是以更大的单位进行确认时，转发时间将会被大幅度的缩短怒。也就是说，发送端主机，在发送了一个段以后不必要一直等待确认应答，而是继续发送。<img src="/posts/6245/TIM%E6%88%AA%E5%9B%BE20191030201429.png" alt><br>窗口大小就是指无需等待确认应答而可以继续发送数据的最大值。上图中窗口大小为4个段。这个机制实现了使用大量的缓冲区，通过对多个段同时进行确认应答的功能。</p><p><strong>如下图所示，发送数据中高亮圈起的部分正是前面所提到的窗口。在这个窗口内的数据即便是没有收到确认应答也可以被发送出去。不过，在整个窗口的确认应答没有到达之前，如果其中部分数据出现丢包，那么发送端仍然要负责重传。为此发送端主机得设置缓存保留这些待被重传的数据，直到收到它们的确认应答。</strong><br><img src="/posts/6245/TIM%E6%88%AA%E5%9B%BE20191030201845.png" alt><br>在滑动窗口以外的部分包括尚未发送的数据以及已经确认对端已收到的数据。当数据发出后若如期收到确认应答就可以不用再进行重发，此时数据就可以从缓存区清除。</p><p><strong>收到确认应答的情况下，将窗口滑动到确认应答的序列号的位置。这样可以顺序的将多个段同时发送提高通信性能。这种机制也被称为滑动窗口控制。</strong></p><h2 id="窗口控制与高速重发控制"><a href="#窗口控制与高速重发控制" class="headerlink" title="窗口控制与高速重发控制"></a>窗口控制与高速重发控制</h2><p>在没有使用窗口控制的时候，没有收到确认应答的数据都会被重发。而是用了窗口控制，就如下图所示，某些确认应答即使丢失也无需重发。<img src="/posts/6245/TIM%E6%88%AA%E5%9B%BE20191030210504.png" alt><strong>窗口在一定程度上较大时，即使有少部分的确认应答丢失也不会进行数据重发，可以通过下一个确认应答进行确认。</strong></p><p>其次考虑一下某个报文段丢失的情况，接受主机如果收到一个应该接受的序号以外的数据时，会针对当前为止收到的数据返回确认应答。<img src="/posts/6245/TIM%E6%88%AA%E5%9B%BE20191030211102.png" alt></p><p><strong>当某一段报文丢失后，发送端会一直收到序号为1001的确认应答，这个确认应答好像在提醒发送端“我想接受的是从1001开始的数据”.因此，在窗口比较大，又出现报文段丢失的情况下，同一个序号的确认应答将会被重复不断地返回。而发送端主机如果连续3次收到同一个确认应答，就会将其所对应的数据进行重发。这种机制比之前提到的超时管理更加高效，因此也被称作为高速重发控制。</strong></p><h2 id="流控制"><a href="#流控制" class="headerlink" title="流控制"></a>流控制</h2><p>发送端根据自己的实际情况发送数据。但是接收端可能收到的是一个毫无关系的数据包又可能会在处理其他问题上花费一些时间。因此在为这个数据包做其他处理时会消耗一些时间，甚至在高负荷的情况下无法接收任何数据。如此一来，如果接收端将本应该接受的数据丢弃的话，就会触发重发机制，从而导致网络流量的无端浪费。</p><p>为了防止这种现象的发生，TCP提供一种机制可以让发送端根据接收端的实际接受能力控制发送的数据量。这就是所谓的流控制。</p><p><strong>它的具体操作是，接收端主机向发送端主机通知自己可以接收数据的大小，于是发送端会发送不超过这个限度的数据。改大小限度就被称为窗口大小，上一节提高的窗口大小的值就是由接收端主机决定的。</strong></p><p>TCP首部中，专门有一个字段来通知窗口的大小，接受主机将自己可以接收的缓冲区大小放入这个字段中，通知给发送端。这个字段的值越大，说明网络的吞吐量越高。</p><p><strong>不过接收端的这个缓冲区一旦面临数据溢出时，窗口大小的值也会随之被设置为一个更小的值通知给发送端，从而控制数据发送量。也就是说，发送端主机会根据接收端主机的指示，对发送数据的量进行控制，这也就形成了一个完整的TCP流控制。</strong></p><h2 id="拥塞控制-慢启动"><a href="#拥塞控制-慢启动" class="headerlink" title="拥塞控制-慢启动"></a>拥塞控制-慢启动</h2><p>一般来说，如果在通信刚开始就发送大量的数据，可能会引发其他问题。在网络出现拥堵时，如果突然出现一个叫大量的数据，极有可能会导致整个网络的瘫痪。</p><p>TCP为了防止该问题的出现，在通信一开始就会发送一个叫做<strong>慢启动</strong>的算法得出的数值，对发送数据量进行控制。<br><img src="/posts/6245/TIM%E6%88%AA%E5%9B%BE20191030213453.png" alt><br><strong>首先，为了在发送端调节所要发送的数据的量，定义了一个叫做“拥塞窗口”的概念，于是在慢启动的时候，将这个拥塞窗口的大小设置为1个数据段（1MSS）发送数据，之后每次收到一次确认应答（ACk），拥塞窗口的值就加1.在发送数据包时，将拥塞窗口的大小与接收端主机通知的窗口大小做比较，然后按照它们当中较小的那个值，发送比其还小的数据量。</strong></p><p><strong>不过随着包的往返，拥塞窗口也会以1、2、4等指数函数的增长，拥堵状况甚至导致网络拥塞的发生。为了防止这些，引入了慢启动阈值的概念。只要拥塞窗口的值超过了这个阈值，在每收到一次确认应答时，只允许以下面这种比例放大拥塞窗口</strong>：<img src="/posts/6245/TIM%E6%88%AA%E5%9B%BE20191030214347.png" alt></p><p><strong>TCP的通信开始时，并没有设置相应的慢启动阈值，而是在超时重发时，才会设置为当时拥塞窗口一般的大小。</strong></p><h1 id="其它传输层协议"><a href="#其它传输层协议" class="headerlink" title="其它传输层协议"></a>其它传输层协议</h1><h2 id="UDP-Lite"><a href="#UDP-Lite" class="headerlink" title="UDP-Lite"></a>UDP-Lite</h2><p>UDP-Lite是扩展UDP技能的一种传输层协议。在基于UDP的通信当中如果校验和出现错误，所收到的包将被全部丢弃。然而现实操作中，有些应用在面对这种情况时并不希望把已经收到的所有包丢弃。</p><p>UDP-Lite因此规定计算校验和的范围可以由应用自行决定。这个范围可以是包加上伪首部的校验和，可以是首部与伪首部的校验和计算，也可以是首部、伪首部与数据从起始到中间某个位置的校验和计算。</p><p>有了这样的机制，就可以针对不允许发生错误的部分进行校验和检查。对于其他部分，即使发生了错误，也会被忽略不计。而这个包也不会被丢弃，而是直接传给应用继续处理。</p><h2 id="SCTP"><a href="#SCTP" class="headerlink" title="SCTP"></a>SCTP</h2><p>SCTP主要用于进行通信的应用之间发送众多较小消息的情况，这些较小的应用消息被称为数据块，多个数据块组成一个包。</p><h2 id="DCCP"><a href="#DCCP" class="headerlink" title="DCCP"></a>DCCP</h2><p>DCCP是UDP的改进版本，它不能提供发送数据的可靠性传输，但是它面向连接，能够根据网络拥堵情况进行拥塞控制。</p><h1 id="UDP首部格式"><a href="#UDP首部格式" class="headerlink" title="UDP首部格式"></a>UDP首部格式</h1><p><img src="/posts/6245/TIM%E6%88%AA%E5%9B%BE20191030215737.png" alt></p><ul><li><strong>源端口号</strong>:表示发送端端口号，字段长16位。该字段是可选项，有时可能不会设置源端口号。没有源端口号的时候该字段的值设置为0，可用于不需要返回的通信中。</li><li><strong>目标端口号</strong>：表示接收端端口，字段长度16位。</li><li><strong>包长度</strong>：保存了UDP首部长度跟数据的长度之和，单位为字节。</li><li><strong>校验和</strong>：校验和是为了提供可靠的UDP首部和数据而被设计。UDP也有可能不用校验和，此时该字段中填入0，这种情况下，由于不进行校验和计算，因此协议处理的开销就会降低，从而提高数据转发的速度。</li></ul><h1 id="TCP首部格式"><a href="#TCP首部格式" class="headerlink" title="TCP首部格式"></a>TCP首部格式</h1><p><img src="/posts/6245/TIM%E6%88%AA%E5%9B%BE20191030220210.png" alt><br>TCP中没有表示包长度和数据长度的字段，因为可由IP层获知TCP的包长度，由TCP的包长可知数据的长度。</p><ul><li><p><strong>源端口号</strong>：表示发送端端口号，字段长16位。</p></li><li><p><strong>目标端口号</strong>：表示接收端端口号，字段长16位。</p></li><li><p><strong>序列号（seq）</strong>：字段长32位，<strong>有时也叫序号，是指发送数据的位置，没法送一次数据，就会累加一次该数据字节数的大小。序列号不会从0或1开始，而是在建立连接时由计算机生成的随机数作为其初始值，通过SYN包传给接收端主机。然后再将每转发过去的字节数累加到初始值上表示数据的位置。此外，在建立连接和断开连接时发送的SYN包和FIN包虽然并不写携带数据，但是也会作为一个字节增加对应的序列号。</strong></p></li><li><p><strong>确认应答号（ack）</strong>：字段长度32位，是指下一次应该接收到的数据的序列号。实际上它是指已收到确认应答号前一位为止的数据。发送端收到这个确认应答以后可以认为这个序号以前的数据已经被正常接收。</p></li><li><p><strong>数据偏移</strong>：该字段表示TCP所传输的数据部分应该从TCP包的哪个位开始计算，当然也可以把它看作TCP首部的长度。</p></li><li><p><strong>保留</strong>：长度为4位，为以后扩展时使用。</p></li><li><p><strong>控制位</strong>：<img src="/posts/6245/TIM%E6%88%AA%E5%9B%BE20191030221343.png" alt>字段长8位，每一位从左至右分别为CWR、ECE、URG、ACK、PSH、RST、SYN、FIN。这些控制标志也叫做控制位，当它们对应位上的值为1时，具体含义如下：</p><ul><li>CWR：与后面的ECE标志都用于IP收不到ECN字段，标志通知对方以将拥塞窗口缩小。</li><li>ECE：通知对方，从对方到这边的网络有拥塞。</li><li>URG：表示包中有需要紧急处理的数据。</li><li>ACK：确认应答的字段变为有效，<strong>TCP规定除了最初建立连接时的SYN包之外该位必须设置为1。</strong></li><li>PSH：表示需要将收到的数据立刻传给上层应用协议，为0时则表示先进行缓存。</li><li>RST：表示TCP连接中出现异常必须强制断开连接。例如对方主机突然断电。</li><li>SYN：用于建立连接，SYN为1表示希望建立连接，<strong>并在其序列号的字段进行序列号初始值设定。</strong></li><li>FIN：表示今后不会再有数据发送，希望断开连接。</li></ul></li><li><p><strong>窗口大小</strong>：长16为，用于通知从相同TCP收不到确认应答号所指位置开始能够接收端数据大小。TCP不允许发送超过此处所示大小的数据，不过如果窗口为0，则表示可以发送窗口探测，以了解最新的窗口大小，但这个数据必须是1个字节。</p></li><li><p><strong>校验和</strong>：与UDP相似，区别在于TCP中无法关闭。</p></li><li><p><strong>紧急指针</strong>：长为16位，只要在URG控制位为1时有效。该字段的数值表示本报文段中紧急数据的指针。正确来讲，从数据部分的首位到紧急指针的位置为止为紧急数据，因此可以说紧急指针指出了紧急数据的末尾在报文段中的位置。</p></li><li><p><strong>选项</strong>：<img src="/posts/6245/TIM%E6%88%AA%E5%9B%BE20191030222443.png" alt></p><ul><li>类型2的MSS选项用于在建立连接时决定的那个最大段长度。</li><li>类型3的窗口扩大，是一个用来改善TCP吞吐量的选项。</li><li>类型8时间戳字段选项，用于高速通信中对序列号的管理。</li><li>类型4、5用于选择确认应答。</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      本篇文章旨在介绍传输层的两个主要协议TCP（Transmission Control Protocol）与UDP（User Datagram Protocol）。
    
    </summary>
    
      <category term="计算机网络" scheme="http://yoursite.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
  </entry>
  
  <entry>
    <title>IP协议相关技术</title>
    <link href="http://yoursite.com/posts/15583/"/>
    <id>http://yoursite.com/posts/15583/</id>
    <published>2019-10-26T13:56:38.000Z</published>
    <updated>2019-10-27T07:42:11.025Z</updated>
    
    <content type="html"><![CDATA[<h1 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h1><p>我们平常在访问某个网站时不使用IP地址，而是用一串由几个英文字母用点号连接构成的域名。在这种情况下，产生了一个可以有效管理域名和IP地址之间对应关系的系统，那就是DNS系统。</p><p>在应用中，当用户输入域名时，DNS会自动检索那个注册了域名和IP地址的数据库，并迅速定位对应的IP地址。而且。如果主机名和IP地址需要进行变更时，也只需要在组织机构内部进行处理即可。</p><p>DNS系统是一个分布式数据库，它的结构如下图：<img src="/posts/15583/607e9d15fd6d5f9d02f6f4b0adb261b9_hd.jpg" alt></p><h2 id="DNS查询过程"><a href="#DNS查询过程" class="headerlink" title="DNS查询过程"></a>DNS查询过程</h2><ol><li>例如当在浏览器输入<a href="http://www.qq.com域名时，浏览器首先会在自己的缓存中查找是否有该域名对应的IP地址，如果有，就先调用这个IP地址映射，完成域名解析。" target="_blank" rel="noopener">www.qq.com域名时，浏览器首先会在自己的缓存中查找是否有该域名对应的IP地址，如果有，就先调用这个IP地址映射，完成域名解析。</a></li><li>如果浏览器中没有缓存，则操作系统会先检查自己本地的hosts文件中是否有这个网址的映射关系，如果有，就先调用这个IP地址映射，完成域名解析。</li><li>如果hosts中没有这个域名的映射，则查找本地的DNS解析器缓存，是否有这个网址的映射，如果有则直接返回，完成解析。</li><li>如果hosts文件与本地DNS解析器缓存都没有对应的网址映射关系，首先会找这个TCP/IP参数中设置的首选DNS服务器，在此我们叫它本地DNS服务器，此服务器收到查询时，如果本地配置资源中包含要查找到域名的映射关系，则返回解析结果给客户端，完成域名解析，此解析具有权威性。</li><li>如果要查询的域名不由本地DNS服务器区域解析，但是该服务器已缓存了此网址的映射，则调用这个映射结果，完成域名解析，此解析不具有权威性。</li><li>如果本地DNS服务器的本地区域文件和缓存都解析失败的话，则根据本地DNS服务器端设置进行查询。如果未用转发模式，本地DNS服务器就会把请求发送至13台根DNS服务器，根DNS服务器收到请求后会判断这个域名是谁来授权管理，并会返回一个负责该顶级DNS服务器的IP地址。本地DNS服务器收到IP信息后，将会联系这台顶级DNS服务器。这台顶级DNS服务器收到请求后，如果自己无法解析，他会找一个自己的下一级DNS服务器，也就是权威DNS服务器，给本地DNS服务器。当本地DNS服务器收到返回的权威DNS服务器IP时，重复上面的动作进行查询，直到找到<a href="http://www.qq.com的IP地址。" target="_blank" rel="noopener">www.qq.com的IP地址。</a></li><li>如果用的是转发模式，次DNS服务器会把请求转发至上一级DNS服务器，由上一级进行解析，上一级如果不能解析，或找根DNS服务器或把请求转发至上上级，以此循环，直到找到<a href="http://www.qq.com的IP地址。" target="_blank" rel="noopener">www.qq.com的IP地址。</a></li></ol><h1 id="ARP"><a href="#ARP" class="headerlink" title="ARP"></a>ARP</h1><p>只要确定了IP地址，就可以向这个目标地址发送IP数据报。然而，在底层数据链路层，进行实际通信时却有必要了解每个IP地址所对应的MAC地址。ARP是一种解决地址问题的协议，以目标IP地址为线索，用来定位下一个应该接收数据分包的网络设备对应的MAC地址。</p><h2 id="ARP工作机制"><a href="#ARP工作机制" class="headerlink" title="ARP工作机制"></a>ARP工作机制</h2><p>简单地说，ARP是借助ARP请求与ARP响应两种类型的包确定MAC地址的。假设主机A向同一链路上的主机B发送IP包，主机A的IP地址为172.20.1.1，主机B的IP地址为172.20.1.2，它们互不知道对方的MAC地址。</p><p>主机A为了获得主机B的MAC地址，<strong>起初要通过广播发送一个ARP请求包。</strong>这个包中包含了想要了解其MAC地址的主机IP地址，也就是说，ARP请求包中已经包含了主机B的IP地址172.20.1.2.由于广播的包可以被同一链路上的所有的主机和路由器接收，<strong>因此ARP请求的包也就会被这同一链路上的所有注解和路由器进行解析。如果ARP请求包中的目标IP地址与自己的IP地址一致，那么这个节点就将自己的MAC地址塞入ARP响应包返回给主机A。</strong></p><p><strong>总之，从一个IP地址发送ARP请求包以了解其MAC地址，目标地址将自己的MAC地址填入其中的ARP响应包返回到IP地址，由此，可以通过ARP从IP地址获得MAC地址，实现链路内的IP通信。</strong></p><p>如果没法送一个IP数据包都要进行一次ARP请求将会造成不必要的网络流量，因此，通常的做法就是把获取到的MAC地址缓存一段时间。</p><h2 id="RARP"><a href="#RARP" class="headerlink" title="RARP"></a>RARP</h2><p>RARP是将ARP反过来，从MAC地址定位IP地址的一种协议。例如将打印机服务器等小型嵌入式设备接入到网络时就经常会用得到。</p><p>平常我们个人电脑设置IP地址，也可以通过DHCP自动分配获取IP地址。然而对于嵌入式设备，会遇到没有任何输入接口或无法通过DHCP动态获取IP地址的情况。在类似情况下，就可以使用RARP。</p><p><strong>为此，需要架设一台RARP服务器，从而在这个服务器上注册设备的MAC地址已经IP地址，然后再将这个设备连接到网络，插电启动时，该设备会发送一条“我的MAC地址是***，请告诉我我的IP地址应该是什么”的请求信息。RARP服务器接受到这个请求后，返回类似于“MAC地址为***，IP地址为***”的信息给这个设备。而设备就根据从RARP服务器所收到的应答信息，从而设置自己的IP地址。</strong></p><h2 id="代理ARP"><a href="#代理ARP" class="headerlink" title="代理ARP"></a>代理ARP</h2><p>通常ARP包会被路由器隔离，但是采用代理ARP的路由器可以将ARP请求转发给邻近的网段。由此，两个以上网段的节点之间就可以像在一个网段中一样进行转发通信。</p><h2 id="ARP攻击和防护"><a href="#ARP攻击和防护" class="headerlink" title="ARP攻击和防护"></a>ARP攻击和防护</h2><p>ARP会引起的攻击有以下几种：</p><ul><li><strong>ARP泛洪攻击</strong>：<strong>通过向网关发送大量ARP报文，导致网关无法正常响应。</strong>首先发送大量的ARP请求报文，然后又发送大量虚假的ARP响应报文，从而造成网关部分的CPU利用率上升难以响应正常服务请求，而且网关还会被错误的ARP表充满导致无法更新维护正常ARP表，消耗网络带宽资源。</li><li><strong>ARP欺骗主机的攻击</strong>：ARP欺骗主机的攻击也是ARP众多攻击类型中很常见的一种。攻击者通过ARP欺骗使得局域网内被攻击主机发送给网关的流量信息实际上都发送给攻击者。主机刷新自己的ARP使得在自己的ARP缓存表中对应的MAC为攻击者的MAC，这样一来其他用户要通过网关发送出去的数据流就会发往主机这里，这样就会造成用户的数据外泄。</li><li><strong>欺骗网关的攻击</strong>：欺骗网关就是把别的主机发送给网关的数据通过欺骗网关的形式使得这些数据通过网关发送给攻击者。这种攻击目标选择的不是个人主机而是局域网的网关，这样就会攻击者源源不断的获取局域网内其他用户韵数据．造成数据的泄露，同时用户电脑中病毒的概率也会提升。</li><li><strong>中间人攻击</strong>：中间人攻击是同时欺骗局域网内的主机和网关，局域网中用户的数据和网关的数据会发给同一个攻击者，这样，用户与网关的数据就会泄露。</li><li><strong>IP地址冲突攻击</strong>：通过对局域网中的物理主机进行扫描，扫描出局域网中的物理主机的MAC地址，然后根据物理主机的MAC进行攻击，导致局域网内的主机产生IP地址冲突，影响用户的网络正常使用。</li></ul><p>相对应的攻击防护方法有以下几种：</p><ol><li>不要把网络信任关系单纯地建立在IP基础上或MAC基础上（RARP同样存在欺骗的问题），<strong>应在网络中架设DHCP服务器，绑定网关与客户端IP+MAC，</strong>该做法需要注意的是要保证网络中的dhcp服务器相互之间不冲突。</li><li><strong>添加静态的ARP映射表，</strong>不让主机刷新设定好的映射表，该做法适用于网络中主机位置稳定，不适用在主机更换频繁的局域网中。</li><li>停止使用ARP，将ARP作为永久条目保存在映射表中。</li><li>架设ARP服务器。通过该服务器查找自己的ARP映射表来响应其他机器的ARP广播。</li><li>IP的传输使用“proxy”代理。</li><li>使用防火墙等连续监控网络。注意有使用SNMP的情况下，ARP的欺骗有可能导致陷阱包丢失。</li></ol><h1 id="ICMP"><a href="#ICMP" class="headerlink" title="ICMP"></a>ICMP</h1><p>架构IP网络时需要特别注意两点：确认网络是否正常工作，以及遇到异常时进行问题诊断。ICMP正式提供这类功能的一种协议。</p><p><strong>ICMP的主要功能包括，确认IP包是否成功送达目标地址，通知在发送过程当中IP包被废弃的具体原因，改善网络设置等。</strong>有了这些功能，就可以获得网络是否正常，设置是否有误以及设备有何异常等信息，从而便于进行网络上的问题诊断。不过ICMP时基于尽力而为的IP进行工作的，因此无法保证服务质量，而且在网络安全优先于便利性的环境中往往无法使用ICMP，因此不宜过分依赖于ICMP。</p><p>在IP通信中如果主机A向主机B发送了数据包，由于某种原因，途中的路由器2未能发现主机B的存在，这是，路由器2就会像主机A发送一个ICMP包，说明发往主机B的包未能成功。</p><p>ICMP的这种通知消息会使用IP进行发送，<strong>在ICMP中，包以明文的形式像TCP/UDP一样通过IP进行传输。</strong>然而ICMP所承担大二功能并非传输层的补充，而应该把它考虑为IP的一部分。因此，从路由器2返回的ICMP包会按照往常的路由控制先经过路由器1再转发给主机A。收到该ICMP包的主机A则分解ICMP的首部和数据域以后得知具体发生问题的原因。<br><img src="/posts/15583/TIM%E6%88%AA%E5%9B%BE20191027142714.png" alt></p><p><strong>ICMP的消息大致可以分为两类：一类是通知出错原因的错误消息，另一类是用于诊断的查询消息。</strong><img src="/posts/15583/TIM%E6%88%AA%E5%9B%BE20191027142849.png" alt></p><h2 id="主要的ICMP消息"><a href="#主要的ICMP消息" class="headerlink" title="主要的ICMP消息"></a>主要的ICMP消息</h2><ul><li><strong>ICMP目标不可达消息（类型3）</strong>：IP路由器无法将IP数据包发送给目标地址时，会给发送端主机返回一个目标不可达的ICMP消息，并在这个消息中显示不可达的具体原因。在实际通信中常会遇到错误代码1，表示主机不可达，它是指路由表中没有该主机的信息，或者该主机没有连接到网络的意思；此外错误代码4则用于前面介绍过的MTU探索。</li><li><strong>TCMP重定向消息（类型5）</strong>：如果路由器发现发送端主机使用了次优的路径发送数据，那么它会返回一个ICMP重定向的消息给这个主机。在这个消息中包含了最合适的路由信息和源数据。这主要发生在路由器持有更好的路由信息的情况下。</li><li><strong>ICMP超时消息（类型11）</strong>：IP包中有一个字段叫做TTL，当它的值减到0时该IP包会被丢弃。此时IP路由器将会发送一个ICMP超时的消息（错误号0）给发送端主机，并通知该包已被丢弃。设置IP包生存周期的目的是为了，在路由控制遇到问题发生循环状况时，避免IP包无休止的在网络上被转发。同时也可以控制包的到达范围。</li><li><strong>ICMP回送消息（类型0、8）</strong>：用于进行通信主机或路由器之间，判断所发送的数据包是否以及成功到达对端的一种消息。可以向对端主机发送回送请求的消息（类型8），也可以接收对端主机发回来的回送应答消息（类型0）。网络上最常用的ping命令就是利用这个消息实现的。</li><li><strong>ICMP原点抑制消息（类型4）</strong>：在使用低速广域线路的情况下，连接WAN的路由器可能会遇到网络拥堵的问题，ICMP原点抑制消息的目的就是为了缓和这种拥堵情况。</li><li><strong>ICMP路由器探索消息（类型9、10）</strong>：主要用于发现与自己相连网络中的路由器。</li><li><strong>ICMP地址掩码消息（类型17、18）</strong>：主要用于主机或路由器想要了解子网掩码的情况。</li></ul><h2 id="ICMPv6"><a href="#ICMPv6" class="headerlink" title="ICMPv6"></a>ICMPv6</h2><p>IPv4中ICMP仅作为一个辅助作用支持IPv4，然而在IPV6中，ICMP作用被扩大，如果没有ICMPv6，IPv6就无法进行正常通信。</p><p>在IPv6中，从IP地址定位MAC地址的协议，从ARP转为ICMP的邻居探索消息。这种邻居探索消息融合了IPv4的ARP、TCMP重定向以及ICMP路由器选择消息等功能于一体，甚至还提供自动设置IP地址的功能。</p><p><strong>ICMPv6将ICMP大致分为了两类：错误消息和信息消息。</strong></p><p>ICMP中从类型133至类型137的消息叫做邻居探索消息。邻居请求消息用于查询IPv6的地址与MAC地址的对应关系，并由邻居宣告消息得知MAC地址。</p><p>此外IPv6中实现了即插即用的功能，所以在没有DHCP服务器的情况下也能实现IP地址的自动获取。如果是一个没有路由器的网络，就使用MAC地址作为链路本地单播地址。而在一个有路由器的网络环境中，可以从路由器获得IPv6地址的前面部分，后面部分则由MAC地址进行设置。</p><h1 id="DHCP"><a href="#DHCP" class="headerlink" title="DHCP"></a>DHCP</h1><p>为了实现自动设置IP地址、统一管理IP地址分配，就产生了DHCP协议。有了DHCP，计算机只要连接到网络，就可以进行TCP/IP通信。</p><h2 id="DHCP工作机制"><a href="#DHCP工作机制" class="headerlink" title="DHCP工作机制"></a>DHCP工作机制</h2><p><strong>使用DHCP之前，首先要架设一台DHCP服务器。然后将DHCP所要分配的IP地址设置到服务器上。此外，还需要将相应的子网掩码、路由控制信息以及DNS服务器的地址设置到服务器上。</strong></p><p>DHCP分配IP地址有两种方法，一种是由DHCP服务器在特定的IP地址中自动选出一个进行分配。另一种方法是针对MAC地址分配一个固定的IP地址。而且这两种方法可以并用。<img src="/posts/15583/TIM%E6%88%AA%E5%9B%BE20191027151337.png" alt></p><h2 id="DHCP中继代理"><a href="#DHCP中继代理" class="headerlink" title="DHCP中继代理"></a>DHCP中继代理</h2><p>在一个企业或者学校等大规模组织机构的网络环境中，一般会有多个以太网网段，在这种情况下，若要针对每个网段都设置DHCP服务器将会是个庞大的工程。</p><p>因此在这种网络环境中，往往需要将DHCP统一管理。具体方法可以使用DHCP中继代理来实现。有了DHCP中继代理以后，对不同网段的IP地址分配也可以由一个DHCP服务器统一进行管理和运维。</p><p>这种方法使得在每个网段架设一个DHCP服务器被取代，只需在每个网段设置一个DHCP中继代理即可。它可以设置DHCP服务器的IP地址，从而可以在DHCP服务器上为每个网段注册IP地址的分配范围。</p><p><strong>DHCP客户端会向DHCP中继代理发送DHCP请求包，DHCP中继代理在收到这个广播包以后再以单播的形式发给DHCP服务器。服务端收到该包以后再向DHCP中继代理返回应答，并由DHCP中继代理将此包转发给DHCP客户端。</strong>由此，DHCP服务器即使不在同一个链路上也可以实现统一分配和管理IP地址。<br><img src="/posts/15583/TIM%E6%88%AA%E5%9B%BE20191027152025.png" alt></p><h1 id="NAT"><a href="#NAT" class="headerlink" title="NAT"></a>NAT</h1><p>NAT是用于在本地网络中使用私有地址，在连接互联网时转而使用全局IP地址的技术。除转换IP地址外，还出现了可以转换TCP、UDP端口号的NAPT技术。NAT（NATP）实际上是为了应对正在面临地址枯竭的IPv4而开发的技术。</p><h2 id="NAT工作机制"><a href="#NAT工作机制" class="headerlink" title="NAT工作机制"></a>NAT工作机制</h2><p>如图以10.0.0.10的主机与163.221.120.9的主机进行通信为例。<strong>利用NAT，图中的NAT路由器将发送源地址从10.0.0.10转换为全局的IP地址（202.244.174.37）再发送数据。反之，当包从地址163.221.120.9发过来时，目标地址（202.244.174.37）先被转换成私有IP地址10.0.0.10以后再被转发。</strong><img src="/posts/15583/TIM%E6%88%AA%E5%9B%BE20191027152523.png" alt><br><strong>在NAT（NAPT）路由器的内部，有一张自动生成的用来转换地址的表。当10.0.0.10向163.221.120.9发送第一个包时生成这张表，并按照表中的映射关系进行处理。</strong></p><h2 id="NAT-PT（NAPT-PT）"><a href="#NAT-PT（NAPT-PT）" class="headerlink" title="NAT-PT（NAPT-PT）"></a>NAT-PT（NAPT-PT）</h2><p><strong>为了解决NAT在IPv6中也能正常使用的问题，就产生了NAT-PT（NAPT-PT）规范。NAT-PT（NAPT-PT）是将IPv6的首部转换为IPv4的首部的一种技术。有了这种技术，那些只有IPv6地址的主机也能够与IPv4地址的其他主机进行通信了。</strong><br><img src="/posts/15583/TIM%E6%88%AA%E5%9B%BE20191027152947.png" alt></p><h2 id="NAT的问题与解决方法"><a href="#NAT的问题与解决方法" class="headerlink" title="NAT的问题与解决方法"></a>NAT的问题与解决方法</h2><p>由于NAT（NAPT）都依赖于自己的转换表，因此会有如下几点限制：</p><ul><li>无法从NAT的外部向内部服务器建立连接。</li><li>转换表的生成与转换操作都会产生一定的开销。</li><li>通信过程中一旦NAT遇到异常需重新启动时，所有的TCP连接都将被重置。</li><li>即使备置两台NAT做容灾备份，TCP连接还是会断开。</li></ul><p>解决NAT上述潜在问题有两种方法：</p><ul><li>改用IPv6。</li><li>即使是在一个没有NAT的环境里，根据所制作的应用，用户可以完全忽略NAT的存在而进行通信。</li></ul><h1 id="IP隧道"><a href="#IP隧道" class="headerlink" title="IP隧道"></a>IP隧道</h1><p>在如图所示的网络环境里，网络A、B使用IPv6，如果处于中间的网络C支持使用IPv4的话，网络A与网络B之间将无法直接进行通信。为了让他它们之间正常通信，这时就必须采用IP隧道的功能。<img src="/posts/15583/TIM%E6%88%AA%E5%9B%BE20191027153928.png" alt></p><p>IP隧道中可以将那些从网络A发过来的IPv6的包统和为一个数据，在为之追加一个IPv4的首部以后转发给网络C。这种在网络层的首部后面继续追加网络层首部的通信方法就叫做“IP隧道”。<br><img src="/posts/15583/TIM%E6%88%AA%E5%9B%BE20191027154151.png" alt></p>]]></content>
    
    <summary type="html">
    
      IP旨在让最终目标主机收到数据包，但在这一过程中仅仅有IP是无法实现通信的，必须还有能够解析主机名称和MAC地址的功能，以及数据包在发送过程中异常情况处理的功能。此外，还会涉及IP必不可少的其他功能。
    
    </summary>
    
      <category term="计算机网络" scheme="http://yoursite.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
  </entry>
  
  <entry>
    <title>IP协议</title>
    <link href="http://yoursite.com/posts/18937/"/>
    <id>http://yoursite.com/posts/18937/</id>
    <published>2019-10-24T13:54:27.000Z</published>
    <updated>2019-10-25T14:23:00.182Z</updated>
    
    <content type="html"><![CDATA[<h1 id="IP相当于OSI参考模型的第3层"><a href="#IP相当于OSI参考模型的第3层" class="headerlink" title="IP相当于OSI参考模型的第3层"></a>IP相当于OSI参考模型的第3层</h1><p>IP相当于OSI参考模型中的第3层——网络层。</p><p><strong>网络层的主要作用是“实现终端节点之间的通信”。这种终端节点之间的通信也叫“点对点”通信。</strong></p><p>从前面的章节可知，网络层的下一层是数据链路层，数据链路层的主要作用是再互联同一种数据链路的节点之间进行包传递。而一但快遇多种数据链路，就需要借助网络层。网络层可以跨越不同的数据链路，即使是在不同的数据链路上也能实现两端节点之间的数据包传输。</p><h1 id="IP基础知识"><a href="#IP基础知识" class="headerlink" title="IP基础知识"></a>IP基础知识</h1><p>在计算机通信中，为了识别通信对端，必须要有一个类似于地址的识别码进行标识，<strong>MAC地址正是用来标识同一数据链路中不同计算机的一种识别码；而IP地址用于在“连接到网络中的所有主机中识别出进行通信的目标地址”，因此在TCP/IP通信中所有注解或路由器必须设定自己的IP地址。</strong></p><h2 id="路由控制"><a href="#路由控制" class="headerlink" title="路由控制"></a>路由控制</h2><p>路由控制（Routing）是指将分组数据发送到最终目标地址的功能，即使网络非常复杂，也可以通过路由控制确定到达目标地址的通路。一旦这个路由控制的运行出现异常，分组数据极有可能迷失，无法到达目标地址。因此，一个数据包之所以能成功地到达最终的目标地址，全靠路由控制。</p><p>当某个IP包到达路由器时，路由器首先查找目标地址，从而再决定下一步应该将这个包发往哪个路由器，然后将包发送过去。当这个IP包到达那个路由器以后，会再次经历查找下一目标地址的过程，并由该路由器转发给下一个被找到的路由器。这个过程可能会反复多次，知道找到最终的目标地址，将数据包发送给这个节点。</p><p><strong>为了将数据包发给目标主机，所有主机都维护着一张路由控制表。该表记录IP数据在下一步应该发给哪个路由器。IP包根据这个路由表在各个数据链路上传输。</strong><img src="/posts/18937/TIM%E6%88%AA%E5%9B%BE20191025200434.png" alt></p><h2 id="数据链路的抽象化"><a href="#数据链路的抽象化" class="headerlink" title="数据链路的抽象化"></a>数据链路的抽象化</h2><p>IP是实现多个数据链之间通信的协议。数据链路根据种类的不同各有特点，<strong>不同数据链路有个最大的区别：就是它们各自的最大传输单位（MTU）不同。</strong>MTU的值再以太网是1500字节，再FDDI中是4352字节，而ATM则为9180字节。IP的上一层可能会要求传送比这些MTU更多字节数据，因此必须在线路上传送比包长还要小的MTU。</p><p>为了解决这个问题，IP进行分片处理。顾名思义，所谓分片处理是指，将较大的IP包分成多个较小的IP包。分片的包到了对端目标地址以后会再被组合起来传给上一层。</p><h2 id="IP属于面向无连接型"><a href="#IP属于面向无连接型" class="headerlink" title="IP属于面向无连接型"></a>IP属于面向无连接型</h2><p><strong>IP面向无连接，即在发包之前，不需要建立与对端目标地址之间的连接，上层如果遇到需要发送给IP的数据，该数据会立即被压缩成IP包发送出去。</strong></p><p>IP采用面向无连接的主要原因有两点：</p><ul><li><strong>一是为了简化。</strong>面向连接比起面向无连接处理相对复杂。甚至管理每个连接本身就是一个相当繁琐的事情。</li><li><strong>二是为了提速。</strong>每次通信之前都要事先建立连接，又会降低处理速度。</li></ul><p>需要连接时，可以委托上一层提供此项服务。因此IP为了实现简单化与高速化采用面向无连接的方式。</p><p>IP提供尽力服务，意指“为了把数据包发送到最终目标地址，尽最大努力”。然而，它并不做“最终收到与否的验证”。IP数据包在途中可能会发生丢包、错位以及数据量翻倍等问题。</p><h1 id="IP地址基础知识"><a href="#IP地址基础知识" class="headerlink" title="IP地址基础知识"></a>IP地址基础知识</h1><h2 id="IP地址的定义"><a href="#IP地址的定义" class="headerlink" title="IP地址的定义"></a>IP地址的定义</h2><p>IP（IPv4）地址由32为正整数来表示。TCp/IP通信要求将这样的IP地址分配给每一个参与通信的主机。<strong>采用将32位的IP地址以每8位为一组，分成4组，每组以“.”隔开，再将每组数转换为十进制数。</strong></p><p>IP地址并非是根据主机台数来配置的，而是每一台主机上的每一块网卡都得设置IP地址。通常一块网卡只设置一个IP地址，但其实一块网卡也可以设置多个IP地址。此外，一台路由器通常都会配置两个以上的网卡，因此可以设置两个以上的IP地址。</p><h2 id="IP地址的组成"><a href="#IP地址的组成" class="headerlink" title="IP地址的组成"></a>IP地址的组成</h2><p><strong>IP地址由“网络标识（网络地址）”和“主机标识（主机地址）”两部分组成。</strong></p><p>网络标识必须保证相互连接的每个段的地址不相重复。而相同段内相连的主机必须有相同的网络地址。IP地址的“主机标识”则不允许在同一个网段内重复出现。由此，<strong>可以通过设置网络地址和主机地址，在相互连接的整个网络中保证每台主机的IP地址都不会相互重复。即IP地址具有了唯一性。</strong></p><p>最初二者以分类进行区别，而现在基本以子网掩码（网络前缀）区分。</p><h2 id="IP地址的分类"><a href="#IP地址的分类" class="headerlink" title="IP地址的分类"></a>IP地址的分类</h2><p>IP地址分为四个级别，分别为A类、B类、C类、D类。它根据IP地址中从第1位到第4位的比特列对其网络标识和主机标识进行区分。</p><ul><li><strong>A类地址</strong>：A类IP地址是首位以“0”开头的地址。从第1位到第8位是他的网络标识。用十进制表示的话，0.0.0.0~127.0.0.0是A类的网络地址。A类地址的后24位相当于主机标识。</li><li><strong>B类地址</strong>：B类IP地址是前两位为“10”的地址。从第1位到第16位是它的网络标识。用十进制表示的话，128.0.0.0~191.255.0.0是B类的网络地址。B类地址的后16位相当于主机标识。</li><li><strong>C类地址</strong>：C类IP地址是前三位为“110”的地址。从第1位到第24位是它的网络标识。用十进制表示的话，192.0.0.0~223.255.255.0是C类的网络地址。C类地址的后8位相当于主机标识。</li><li><strong>D类地址</strong>：D类IP地址是前四位为“1110”的地址，从第1为到第32位是它的网络标识。用十进制表示的话，224.0.0.0~239.255.255.255.255是D类的网络地址。D类网络地址没有主机标识，常被用于多播。<br><img src="/posts/18937/TIM%E6%88%AA%E5%9B%BE20191025204003.png" alt><br>在IP地址分配时有一点需要注意，<strong>不可以全部为0或全部为1。</strong>因为全部为0在表示对应的网络地址或IP地址不可获知的情况下才使用。而全部为1的主机地址通常作为广播地址。</li></ul><h2 id="广播地址"><a href="#广播地址" class="headerlink" title="广播地址"></a>广播地址</h2><p><strong>广播地址用于在一个链路中相互连接的主机之间发送数据包。将IP地址中的主机地址部分全部设置为1，就成为了广播地址。</strong></p><p>广播地址分为<strong>本地广播</strong>和<strong>直接广播</strong>两种。<strong>在本网络内的广播叫做本地广播，在不同网络之间的广播叫做直接广播。</strong></p><h2 id="子网掩码"><a href="#子网掩码" class="headerlink" title="子网掩码"></a>子网掩码</h2><p>起初一个IP地址只要确定了其分类，也就确定了它的网络标识和主机标识，网络标识相同的计算机必须同属于同一个链路。但是这样会造成很多的IP地址浪费，因此后来人们改进使用子网掩码进行区分。</p><p>对于子网掩码，目前有两种标识方式。以172.20.100.52的前26位是网络地址的情况为例，以下是其中一种表示方法，它将IP地址与子网掩码的地址分别用两行来表示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">IP地址172.20.100.52</span><br><span class="line">子网掩码255.255.255.192</span><br><span class="line"></span><br><span class="line">网络地址172.20.100.0</span><br><span class="line">子网掩码255.255.255.192</span><br><span class="line"></span><br><span class="line">广播地址172.20.100.63</span><br><span class="line">子网掩码255.255.255.192</span><br></pre></td></tr></table></figure><p>另一种表示方法如下所示，它在每个IP地址后面追加网络地址的位数用“/”隔开。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">IP地址172.20.100.52/26</span><br><span class="line">网络地址172.20.100.0/26</span><br><span class="line">广播地址172.20.100.63/26</span><br></pre></td></tr></table></figure><h1 id="路由控制-1"><a href="#路由控制-1" class="headerlink" title="路由控制"></a>路由控制</h1><p>发送数据包时所使用的地址是网络地址，即IP地址。然而仅仅有IP地址还不足以将数据包发送到对端目标地址，在数据发送过程中还需要类似于“知名路由器或主机”的信息，以便真正的发往目标地址。保存这种信息的就是路由控制表。</p><p><strong>该路由控制表的形成方式有两种：一种是管理员手动设置，另一种是路由器与其他路由器相互交换形信息时自动刷新。前者也叫静态路由控制，后者叫做动态路由控制。</strong></p><h2 id="IP地址与路由控制"><a href="#IP地址与路由控制" class="headerlink" title="IP地址与路由控制"></a>IP地址与路由控制</h2><p>路由控制表中记录着网络地址与下一步应该发送至路由器的地址，在发送IP包时，首先要确定IP包首部中的目标地址，再从路由控制表中找到与该地址具有相同网络地址的记录，根据该记录将IP包转发给相应的下一个路由器。<strong>如果控制表中存在多条相同网络地址的记录，就选择一个最为吻合的网络地址，所谓最为吻合是指相同位数最多的意思。</strong></p><p>如果一张路由表中包含所有的网络及其子网的信息，将会造成无端的浪费，这是，默认路由是不错的选择。默认路由是指路由表中任何一个地址都能与之匹配的记录。默认路由一般标记为0.0.0.0./0或default。</p><p>“IP地址/32”也被称为主机路由。它的意思是整个IP地址的所有位都将参与路由。进行主机路由，意味着基于主机上网卡配置的IP地址本身，而不是基于该地址的网络地址部分进行路由。主机路由多被用于不希望通过网络地址路由的情况。</p><h1 id="IP分割处理与再构成处理"><a href="#IP分割处理与再构成处理" class="headerlink" title="IP分割处理与再构成处理"></a>IP分割处理与再构成处理</h1><p>如前面介绍所说，每种数据链路的最大传输单元（MTU）不尽相同，简与IP数据数据链路上一层，它必须不受限于不同数据链路的MTU大小。</p><h2 id="IP报文的分片与重组"><a href="#IP报文的分片与重组" class="headerlink" title="IP报文的分片与重组"></a>IP报文的分片与重组</h2><p>任何一台主机都有必要对IP分片进行相应的处理。分片往往在网络上遇到比较大的报文无法一下子发送出去时才会进行处理。</p><p><strong>分片默认以8个字节的倍数为单位进行，经过分片之后的IP数据报在被重组的时候，只能由目标主机进行。路由器虽然做分片但是不会进行重组。</strong><br><img src="/posts/18937/TIM%E6%88%AA%E5%9B%BE20191025212713.png" alt></p><h2 id="路径MTU发现"><a href="#路径MTU发现" class="headerlink" title="路径MTU发现"></a>路径MTU发现</h2><p>分片机制也有它的不足，例如路由器的处理符合加重，一旦某个分片丢失，会造成整个IP数据报作废等等。为了应对这些问题，产生了一种新的技术“路径MTU发现”。</p><p><strong>所谓路径MTU是指从发送端主机到接收端主机之间不需要分片时最大的MTU的大小。即路径中存在的所有数据链路中最小的MTU。而路径MTU发现从发送主机按照路径MTU的大小将数据报分片后进行发送，进行路径MTU发现，就可以避免在中途的路由器上进行分片处理，也可以在TCP中发送更大的包。</strong></p><p>路径MTU发现的工作原理如下：<br>首先在发送端主机发送IP数据报时将其首部的分片禁止标志设置为1。根据这个标志位，途中的路由器即使遇到需要分片才能处理的大包，也不会去分片，而是将包丢弃。随后，通过一个ICMP的不可达消息将数据链路上MTU的值给发送主机。</p><p>下一次，从发送给同一目标主机的IP数据报获得ICMP所通知的MTU值以后，将它设置为当前MTU。发送主机根据这个MTU对数据报进行分片处理。如此反复，直到数据报被发送到目标主机为止没有再收到任何ICMP，就认为最后一次ICMP所统治的MTU即是一个合适的MTU值。</p><p>那么，当MTU的值比较多时，最少可以缓存约10分钟。在这10分钟内使用刚刚求得的MTU，但过了这10分钟以后则重新根据链路上的MTU做一次路径MTU发现。</p><p>下面是UDP和TCP的路径MTU发现过程：<img src="/posts/18937/TIM%E6%88%AA%E5%9B%BE20191025214216.png" alt><img src="/posts/18937/TIM%E6%88%AA%E5%9B%BE20191025214237.png" alt></p><h1 id="IPv6"><a href="#IPv6" class="headerlink" title="IPv6"></a>IPv6</h1><p>IPv6是为了根本解决IPv4地址耗尽的问题而被标准化的网络协议。IPv4的地址长度为4个8位字节，即32比特。而IPv6的地址长度则是原来的4倍，即128比特，一般写成8个16字位字节。</p><h2 id="IPv6的特点"><a href="#IPv6的特点" class="headerlink" title="IPv6的特点"></a>IPv6的特点</h2><p>IPv6通过改进IPv4的缺点，减轻了管理员的负担。</p><ul><li>IP地址的扩大与路由控制表的聚合</li><li>IP地址依然适应互联网分层构造。分配与其地址结构相适应的IP地址，尽可能避免路由表膨大</li><li>性能提升</li><li>支持即插即用功能，即使没有DHCP服务器也可以实现自动分配IP地址</li><li>采用认证与加密功能，应对伪造IP地址的网络安全功能以及防止路线窃听的功能</li><li>多播、Mobile IP称为扩展功能</li></ul><h2 id="IPv6在IP地址的标记方法"><a href="#IPv6在IP地址的标记方法" class="headerlink" title="IPv6在IP地址的标记方法"></a>IPv6在IP地址的标记方法</h2><p><strong>一般人们将128比特IP地址以每16为一组，每组用冒号“：”隔开进行标识。而且如果出现连续的0时还可以将这些0省略，并用两个冒号“：：”隔开，但是一个IP地址中只允许出现一次两个连续的冒号。</strong></p><h2 id="IPv6分段处理"><a href="#IPv6分段处理" class="headerlink" title="IPv6分段处理"></a>IPv6分段处理</h2><p><strong>IPv6的分片处理只在作为起点的发送端主机上进行，路由器不参与分片。</strong>这也是为了减少路由器的负荷、提高网速。因此IPv6中的“路径MTU发现”功能必不可少。</p><p><strong>不过IPv6中最小的MTU为1280字节，</strong>因此，在嵌入式系统中对于那些有一定系统资源限制的设备来说，不需要进行“路径MTU发现”，而是在发送IP包时直接以1280字节为单位分片发出。</p><h1 id="IPv4首部"><a href="#IPv4首部" class="headerlink" title="IPv4首部"></a>IPv4首部</h1><p>通过IP进行通信时，需要在数据的前面加入IP首部信息。IP首部中包含用于IP协议进行发包控制时所有的必要信息。<img src="/posts/18937/TIM%E6%88%AA%E5%9B%BE20191025215451.png" alt></p><ul><li><strong>版本</strong>：由4比特构成，表示标识IP首部的版本号，IPv4的版本号为4，因此在这个字段上的值即为“4”，IPv6的版本号为6。</li><li><strong>首部长度</strong>：由4比特构成，表明IP首部的大小，单位为4字节。对于没有可选项的IP包，首部长度则设置为5.</li><li><strong>区分服务</strong>：由8比特构成，用来表明服务质量，如下表：<img src="/posts/18937/TIM%E6%88%AA%E5%9B%BE20191025215837.png" alt></li><li><strong>DSCP段与ECN段</strong>：DSCP（差分服务代码点）是TOS的一部分，用来进行质量控制。ECn（显示拥塞通告）用来报告网络拥堵情况，由两个比特构成。</li><li><strong>总长度</strong>：表示IP首部与数据部分合起来的总字节数，该字段长16比特，<strong>因此IP包的最大长度为65535字节。</strong></li><li><strong>标识（ID）</strong>：由16比特构成，用于分片重组，同一个分片的标识值相同，不同分片的标识值不同。通常每发送一个IP包，它的值也逐渐递增。此外，即使ID相同，如果目标地址、源地址或协议不同的话，也会被认为是不同的分片。</li><li><strong>标志</strong>：由3比特构成，标识包倍分片的相关信息。具体含义如下：<img src="/posts/18937/TIM%E6%88%AA%E5%9B%BE20191025220758.png" alt></li><li><strong>片位移</strong>：由13比特构成，用来标识被分片的每一个分段相对于原始数据的位置。第一个分片对应的位置为0。</li><li><strong>生存时间（TTL）</strong>：由8比特构成，最初意思是以秒为单位记录当前包在网络上应该生存的限期，实际中它是指可以中转多少个路由器的意思，每经过一个路由器，TTL就会减少1，直到变成0则丢弃包。TTl不会超过256，由此可以避免IP包在网络内无限传递的问题。</li><li><strong>协议</strong>：由8比特构成，表示IP包传输层的上层协议编号。</li><li><strong>首部校验和</strong>：由16比特构成，也叫IP首部校验和。盖子都安只校验数据报的首部，不校验数据部分。它主要用来确保IP数据报不被破坏。</li><li><strong>源地址</strong>：由32比特构成，表示发送端IP地址。</li><li><strong>目标地址</strong>：由32比特构成，表示接收端IP地址。</li><li><strong>可选项</strong>：长度可变，通常只在进行实验或诊断时使用，包含信息有如下几点：安全级别、源路径、路径记录和时间戳。</li><li><strong>填充</strong>：也称作填充物，在有可选项的情况下，首部长度可能不是32比特的整数倍，为此，通过向该字段填充0，调整为32比特的整数倍。</li><li><strong>数据</strong>：存入数据。将IP上层协议的首部也为作为数据进行处理。</li></ul><h1 id="IPv6首部格式"><a href="#IPv6首部格式" class="headerlink" title="IPv6首部格式"></a>IPv6首部格式</h1><p>IPv6的IP数据首部格式相比IPv4已经发生巨大变化：<img src="/posts/18937/TIM%E6%88%AA%E5%9B%BE20191025221749.png" alt></p><ul><li><strong>版本</strong>：同IPv4一样。</li><li><strong>通信量类</strong>：相当于IPv4的TOS字段。至今没什么用。</li><li><strong>流标号</strong>：由20比特构成，准备用于服务质量控制，现在也没有用。只有流标号、源地址以及目标地址三项完全一致时，才被认为是一个流。</li><li><strong>有效载荷长度</strong>：有效载荷是指包的数据部分，这里不包括首部，只表示数据部分的长度。</li><li><strong>下一个首部</strong>：相当于IPv4的协议字段，由8比特构成。</li><li><strong>跳数限制</strong>：由8比特构成，相当于IPv4的TTL。</li><li><strong>源地址</strong>：由128比特构成，表示发送端IP地址。</li><li><strong>目标地址</strong>：由128比特构成，表示接收端IP地址。</li></ul><p>IPv6的首部长度固定，无法将可选项加入其中，取而代之的是通过扩展首部对功能进行了有效扩展。</p>]]></content>
    
    <summary type="html">
    
      IP（Internet Protocol，网际协议），IP作为整个TCP/IP中至关重要的协议，主要负责将数据包发送给最终的目标计算机，因此，IP能够让世界上任何两台计算机之间进行通信。
    
    </summary>
    
      <category term="计算机网络" scheme="http://yoursite.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
  </entry>
  
  <entry>
    <title>计算机网络基础知识</title>
    <link href="http://yoursite.com/posts/13182/"/>
    <id>http://yoursite.com/posts/13182/</id>
    <published>2019-10-22T13:36:59.000Z</published>
    <updated>2019-10-23T12:55:58.614Z</updated>
    
    <content type="html"><![CDATA[<h1 id="OSI参考模型"><a href="#OSI参考模型" class="headerlink" title="OSI参考模型"></a>OSI参考模型</h1><p>OSI参考模型将复杂的网络协议整理并分为易于理解的7个分层，对通信中必要的功能做了很好的归纳。不过，OSI参考模型始终是一个模型，它也只是对各层的作用做了一系列粗略的界定，并没有对协议和接口进行详细的定义。<img src="/posts/13182/TIM%E6%88%AA%E5%9B%BE20191022215354.png" alt></p><h2 id="OSI参考模型中各个分层的作用"><a href="#OSI参考模型中各个分层的作用" class="headerlink" title="OSI参考模型中各个分层的作用"></a>OSI参考模型中各个分层的作用</h2><p><img src="/posts/13182/TIM%E6%88%AA%E5%9B%BE20191022215744.png" alt></p><ul><li><strong>应用层</strong>：<strong>为应用程序提供服务并规定应用程序中通信相关的细节，</strong>包括文件传输、电子邮件、远程登录等协议。</li><li><strong>表示层</strong>：<strong>将应用程序的信息转换为适合网络传输的格式，或将来自下一层的数据转换为上层能够处理的格式，因此它主要负责数据格式转换。</strong></li><li><strong>会话层</strong>：<strong>负责建立和断开通信连接（数据流动的逻辑通路），以及数据的分割等数据传输相关的管理。</strong></li><li><strong>传输层</strong>：<strong>起着传输的作用，只在通信双方节点上进行处理，而无需在路由器上处理。</strong></li><li><strong>网络层</strong>：将数据传输到目标地址，目标地址可以是多个网络通过路由器连接而成的某一个地址，因此<strong>这一层主要负责寻址和路由选择。</strong></li><li><strong>数据链路层</strong>：<strong>负责物理层面上互连的、节点之间的通信传输。</strong></li><li><strong>物理层</strong>：<strong>负责0、1比特流与电压的高低、光的闪灭之间的互换。</strong></li></ul><h2 id="OSI参考模型通信处理举例"><a href="#OSI参考模型通信处理举例" class="headerlink" title="OSI参考模型通信处理举例"></a>OSI参考模型通信处理举例</h2><p>下面举例说明7层网络模型的功能，假设使用主机A的用户A要给使用主机B的用户B发送一封电子邮件。</p><h3 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h3><p>用户A在主机A上新建一封电子邮件，指定收件人为B，并输入邮件内容为“早上好”。</p><p><strong>从用户输入完所要发送到内容并点击“发送”按钮的那一刻开始，就进入了应用层协议的处理，该协议会在所要传送数据的前端附加一个首部（标签）信息。</strong>如果主机B上收件人的邮箱空间已满无法接收新的邮件，则会返回一个错误给发送方。<strong>对这类异常的处理也属于应用层要解决的问题。</strong></p><h3 id="表示层"><a href="#表示层" class="headerlink" title="表示层"></a>表示层</h3><p>表示层的“表示”有“表现”、“演示”的意思，因此更关注数据的具体表现形式。此外，所使用的应用软件本身的不同也会导致数据的表现形式截然不同，例如有的字处理软件的文件只能由该字处理厂商所提供的特定版本的软件才来打开读取。</p><p><strong>利用应用层，将数据从“某个计算机特定的数据格式”转换为“网络通用的标准数据格式”后，再发送出去。接收端主机收到数据以后，将这些网络标准格式的数据恢复为“该计算机特定的数据格式”，然后再进行相应处理。</strong></p><h3 id="会话层"><a href="#会话层" class="headerlink" title="会话层"></a>会话层</h3><p><strong>决定采用何种连接方法是会话层的主要责任。会话层也会像应用层或表示层那样，在其收到的数据前端附加首部信息或标签信息后再转发给下一层。而这些首部或标签中记录着数据传送顺序的信息。</strong></p><p><strong>会话层只对何时建立连接、何时发送数据等问题进行管理，并不具有实际传输数据的功能。</strong></p><h3 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h3><p>主机A确保与主机B之间的通信并准备发送数据。这一过程叫“建立连接”。有了这个通信连接就可以使主机A发送的电子邮件到达主机B中，并由主机B的邮件处理程序获取最终数据。此外当通信传输结束后，有必要将连接断开。</p><p>如上，<strong>进行建立连接或断开连接的处理，在两个主机之间创建逻辑上的通信连接即是传输层的主要作用。此处请注意，会话层负责决定建立连接和断开连接的时机，而传输层进行实际的连接和断开处理。</strong></p><p><strong>此外，传输层为确保所传输的数据到达目标地址，会在通信两端的计算机之间进行确认，如果数据没有到达，它会负责重发。</strong>例如，主机A将“早上好”这一数据发送给主机B，期间可能会因为某些原因导致数据被破坏，或由于发生某种网络异常致使只有一部分数据到达目标地址。假设主机B只收到了“早上”这一部分数据，那么会在它收到数据后将自己没有收到“早上”之后那部分数据的事实告知主机A，主机A得知这个情况后就会将后面的“好”重发给主机B，并再次确认对端是否收到。</p><h3 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h3><p><strong>网络层的作用是在网络与网络相互连接的环境中，将数据从发送端主机发送到接收端主机，两端主机之间虽有众多数据链路，但能够将数据从主机A送到主机B也是网络层的功劳。</strong></p><p>在实际发送数据时，目的地址至关重要，这个地址是进行通信的网络中唯一指定的序号。</p><h3 id="数据链路层、物理层"><a href="#数据链路层、物理层" class="headerlink" title="数据链路层、物理层"></a>数据链路层、物理层</h3><p>通信传输实际上是通过物理的传输介质实现的。<strong>数据链路层的作用就是在这些通过传输介质互连的设备之间进行数据处理。</strong></p><p><strong>物理层中，将数据的0、1转换为电压和脉冲光传输给物理的传输介质，</strong>而相互直连的设备之间使用地址实现传输，这种地址被称为MAC地址，也可称为物理地址或硬件地址。<strong>采用MAC地址，目的是为了识别连接到同一传输介质上的设备。</strong>因此，在这一层中将包含MAC地址信息的首部附加到从网络层转发过来的数据上，将其发送给网络。</p><h1 id="传输方式的分类"><a href="#传输方式的分类" class="headerlink" title="传输方式的分类"></a>传输方式的分类</h1><p>网络与通信中可以根据其数据发送方法进行多种分类，分类方法也有很多，下面介绍几种。</p><h2 id="面向有连接型与面向无连接型"><a href="#面向有连接型与面向无连接型" class="headerlink" title="面向有连接型与面向无连接型"></a>面向有连接型与面向无连接型</h2><p>通过网络发送数据，大致可以分为面向有连接与面向无连接两种类型。面向有连接型包括TCP、ATM、帧中继等协议；面向无连接型包括UDP、IP、以太网等协议。</p><ul><li><strong>面向有连接型</strong>：面向有连接型中，在发送数据之前，需要在收发主机之间连接一条通信线路；在通信传输结束之后，专门断开连接。</li><li><strong>面向无连接型</strong>：面向无连接型则不要求建立和断开连接。发送端可于任何时候自由发送数据，反之接收端也永远不知道自己会在何时从哪里收到数据。因此在面向无连接的情况下，接收端需要时常确认是否收到了数据。<strong>面向无连接型采用分组交换的情况要多一些。</strong></li></ul><h2 id="电路交换与分组交换"><a href="#电路交换与分组交换" class="headerlink" title="电路交换与分组交换"></a>电路交换与分组交换</h2><p>在电路交换中，交换机主要负责数据的中转处理。计算机首先被连接到交换机上，而交换机与交换机之间则由众多通信线路再继续连接。因此计算机之间再发送数据时，需要通过交换机与目标主机建立通信电路，我们将连接电路称为建立连接。建立好连接之后，用户就可以一直使用这条电路，知道该链接被断开为止。</p><p>如果某条电路只是用来连接两台计算机的通信线路，就意味着只需要在这两台计算机之间实现通信，因此这两台计算机是可以独占线路进行数据传输的。但是，如果一条电路上连接了多台计算机，而这些计算机之间需要相互传递数据，就会出现新的问题。鉴于一台计算机在收发信息时会独占整个电路，其他计算机只能等待这台计算机处理结束以后才有机会使用这条电路发送数据，并且在此过程中，谁也无法预测某一台计算机的数据传输从何开始又在何时结束。<strong>如果并发用户数超过交换机之间的通信线路数，就意味着通信根本无法实现。</strong></p><p>在分组交换中，由分组交换机（路由器）连接通信线路。分组交换的大致处理过程是：<strong>发送端计算机将数据分组发送给路由器，路由器收到这些分组数据以后，缓存到自己的缓冲区，然后再转发给目标计算机。</strong>因此分组交换也有另一个名称：蓄积交换。<strong>路由器收到数据以后会按照顺序缓存到相应的队列中，再以先进先出的顺序将它们逐一发送出去。</strong></p><p>在分组交换中，计算机与路由器之间以及路由器与路由器之间只有一条通信线路，因此这条线路其实是一条共享线路。在电路交换中，计算机之间的传输速度不变。<strong>然而在分组交换中，通信线路的速度可能会有所不同，根据网络拥堵的情况，数据达到目标地址的时间有长有短。另外，路由器的缓存饱和或溢出时，甚至可能会发生分组数据丢失、无法发送到对端的情况。</strong></p><h2 id="根据接收端数量分类"><a href="#根据接收端数量分类" class="headerlink" title="根据接收端数量分类"></a>根据接收端数量分类</h2><ul><li><strong>单播</strong>：就是一对一通信。</li><li><strong>广播</strong>：它指的是将消息从一台主机发送给与之相连的所有其他主机。广播通信的一个典型例子就是电视播放。</li><li><strong>多播</strong>：多播与广播类似，不同之处子啊与多播要限定某一组主机作为接收端。多播通信最典型的例子就是电视会议。</li><li><strong>任播</strong>：任播是指在特定的多台主机中选出一台作为接收端的一种通信方式。</li></ul><h1 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h1><p>通信传输中，发送端和接收端可以被视为通信主体，他们都能由一个所谓的“地址”的信息加以标识出来。当人们使用电话时，电话号码就相当于“地址”。当地址总数并不是很多的情况下，有了唯一地址就可以定位相互通信的主体。然而当地址的总数越来越多的时候，如何高效的从中找出通信的目标地址将成为一个重要的问题，为此人们发现<strong>地址除了具有唯一性还需要具有层次性。</strong></p><p>MAC地址和IP地址在标识一个通信主体时虽然都具有唯一性，但是它们当中只有IP地址具有层次性。MAC地址由设备的制造厂商针对没块网卡进行分别指定；<strong>IP地址由网络号和主机号两部分组成，即使通信主体的IP地址不同，若主机号不同，网络号相同，说明它们处于同一个网段。</strong></p><p>网络传输中，每个节点会根据分组数据的地址信息，来判断报文应该由哪些网卡发出去。为此，各个地址会参考一个发出接口列表。在这一点上MAC寻址与IP寻址一样。只不过<strong>MAC寻址所参考的这张表叫做地址转发表；而IP寻址中所参考的叫做路由控制表。</strong><img src="/posts/13182/TIM%E6%88%AA%E5%9B%BE20191023200532.png" alt></p><ol><li>主机A先查看自己的路由控制表，在根据此表将发往主机B的数据先发给路由器1。</li><li>接收到该数据的交换机1则根据自己的地址转发表将数据转发给路由器1。</li><li>接收到该数据的路由器1根据自己的路由控制表将数据转发给路由器3。</li><li>接受到该数据的路由器3则根据自己的路由转发表将数据发给交换机3。</li><li>接受到该数据的交换机3再根据自己的地址转发表将数据发给主机B。</li></ol><h1 id="网络构成的要素"><a href="#网络构成的要素" class="headerlink" title="网络构成的要素"></a>网络构成的要素</h1><p>搭建一套网络环境要涉及各种各样的电缆和网络设备，在此仅介绍连接计算机与计算机的硬件设备。<img src="/posts/13182/TIM%E6%88%AA%E5%9B%BE20191023201644.png" alt></p><table><thead><tr><th>设备</th><th>应用</th></tr></thead><tbody><tr><td>网卡</td><td>使计算机连网的设备（Network Interface）</td></tr><tr><td>中继器</td><td>从物理层上延长网络的设备</td></tr><tr><td>网桥/2层交换机</td><td>从数据链路层上延长网络的设备</td></tr><tr><td>路由器/3层交换机</td><td>通过网络层转发分组数据的设备</td></tr><tr><td>4-7层交换机</td><td>处理传输层以上各层网络传输的设备</td></tr><tr><td>网关</td><td>转换协议的设备</td></tr></tbody></table><h2 id="网卡"><a href="#网卡" class="headerlink" title="网卡"></a>网卡</h2><p>任何一台计算机连接网络时，必须要使用网卡（全称为网络接口卡），有时也被称为网络适配器、网络接口卡、LAN卡。</p><h2 id="中继器"><a href="#中继器" class="headerlink" title="中继器"></a>中继器</h2><p>中继器是OSI模型的第一层——物理层面上延长网络的设备。<strong>由电缆传输过来的电信号或光信号经由中继器的波形调整和放大再传给另一个电缆。</strong><img src="/posts/13182/TIM%E6%88%AA%E5%9B%BE20191023202111.png" alt></p><ul><li>中继器是对减弱的信号进行放大和发送的设备。</li><li>中继器通过物理层的连接延长网络。</li><li>即使在数据链路层出现某些错误，中继器仍然转发数据。</li><li>中继器无法改变传输速度。</li></ul><p>一般情况下，中继器的两端连接的是相同的通信媒介，但有的中继器也可以完成不同媒介之间的转接工作，例如可以在同轴电缆与光轴电缆之间调整信号。然而，在这种情况下，<strong>中继器也只是单纯的负责信号在0和1比特流之间的替换，并不负责判断数据是否有错误，也不能在传输速度不同的媒介之间转发。</strong></p><p>通过中继器而进行的网络延长，其距离也并非可以无限扩大，例如一个10Mbps的以太网最多可以用4个中继器分段连接，而一个100Mbps的以太网则最多只能连两个中继器。</p><h2 id="网桥-2层交换机"><a href="#网桥-2层交换机" class="headerlink" title="网桥/2层交换机"></a>网桥/2层交换机</h2><p><img src="/posts/13182/TIM%E6%88%AA%E5%9B%BE20191023202809.png" alt></p><ul><li>网桥根据数据帧的内容转发数据给相邻的其他网络</li><li>网桥没有连接网段个数的限制</li><li>网桥基本上只用于连接相同类型的网络，但是有时也可以连接传输速率不同的网络</li></ul><p>网桥是OSI模型的第2层——数据链路层面上连接两个网络的设备，<strong>它能识别数据链路中的数据帧，并将这些数据帧临时存储于内存，再重新生成信号作为一个全新的帧转发给相连的另一个网段。由于能够存储这些数据帧，网桥能够连接传输速率完全不同的数据链路，并且不限制连接网段的个数。</strong></p><p><strong>数据链路的数据帧中有一个数据为叫做FCS，用以校验数据是否正确送达目的地。网桥通过检查这个域中的值，将那些损坏的数据丢弃，从而避免发送给其他的网段，此外网桥还能通过地址自学机制和过滤功能控制网络流量。</strong></p><p>有些网桥能够判断是否将数据报文转发给相邻的网段，这种网桥被称为自学式网桥，这类网桥会记住曾经自己转发的所有数据帧的MAC地址，并保存到自己的内存中，由此可以判断哪个网段中包含持有哪类MAC地址的设备。</p><h2 id="路由器-3层交换机"><a href="#路由器-3层交换机" class="headerlink" title="路由器/3层交换机"></a>路由器/3层交换机</h2><ul><li>路由器是连接网络与网络的设备</li><li>可以将分组报文发送给另一个目标路由器地址</li><li>基本上可以连接任意两个数据链路</li></ul><p>路由器是在OSI模型的第3层——<strong>网络层面上连接两个网络，并对分组报文进行转发到设备。网桥是根据物理地址（MAC地址）进行处理，而路由器/3层交换机则是根据IP地址进行处理的。</strong></p><p>路由器可以连接不同的数据链路，例如两个以太网，或者一个以太网与一个FDDI。<strong>路由器还有分担网络负荷的作用，甚至有些路由器具备一定的网络安全功能。</strong></p><h2 id="4-7层交换机"><a href="#4-7层交换机" class="headerlink" title="4-7层交换机"></a>4-7层交换机</h2><p><strong>4-7层交换机负责处理OSI模型中从传输层至应用层的数据。</strong>如果用TCP/IP分层模型来表述，4-7层交换机就是以TCP等协议的传输层及其上面的应用层为基础，分析收发数据，并对其进行特定的处理。</p><h2 id="网关"><a href="#网关" class="headerlink" title="网关"></a>网关</h2><p><img src="/posts/13182/TIM%E6%88%AA%E5%9B%BE20191023205136.png" alt></p><ul><li>网关负责协议的转换与数据的转发</li><li>在同一种类型的协议之间转发数据叫做应用网关</li></ul><p><strong>网关是OSI参考模型中负责将传输层到应用层的数据进行转换和转发的设备。它与4-7层交换机都是处理传输层及以上的数据，但是网关不仅转发数据还负责对数据进行转换，它通常会使用一个表示层或应用层网关，在两个不能进行直接通信的协议之间进行翻译，最终实现两者之间的通信。</strong></p><p>为了控制网络流量以及出于安全的考虑，有时会使用代理服务器，这种代理服务器也是网关的一种。</p>]]></content>
    
    <summary type="html">
    
      介绍计算机网络的基本概念，包括OSI参考模型、网络概念的本质、网络构建的设备等。
    
    </summary>
    
      <category term="计算机网络" scheme="http://yoursite.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
  </entry>
  
  <entry>
    <title>面向切面的Spring——AOP</title>
    <link href="http://yoursite.com/posts/5626/"/>
    <id>http://yoursite.com/posts/5626/</id>
    <published>2019-10-19T13:57:41.000Z</published>
    <updated>2019-10-20T09:31:21.020Z</updated>
    
    <content type="html"><![CDATA[<h1 id="什么是面向切面编程"><a href="#什么是面向切面编程" class="headerlink" title="什么是面向切面编程"></a>什么是面向切面编程</h1><p>切面能够帮助我们模块化横切关注点，横切关注点可以被描述为影响应用多处的功能，下图直观的呈现了横切关注点的概念。<br><img src="/posts/5626/TIM%E6%88%AA%E5%9B%BE20191019222640.png" alt><br>每个模块的核心功能都是为特定业务领域提供服务，但是如果要做到通用功能的话，最常见的面向对象技术十集成或委托，但是如果在整个应用程序中都使用相同的基类，继承往往会导致一个脆弱的对象体系；而使用委托可能需要对象进行复杂的调用。</p><p>切面提供了另一种可选方案，而且在很多场景下更清晰简洁。在使用面向切面编程时，我们仍然在一个地方定义通用功能，但是可以通过声明的方式定义这个功能要以何种方式在何处应用，<strong>而无需修改受影响的类。</strong>横切关注点可以被模块化为特殊的类，这些类被称为<strong>切面（aspect）</strong>。<strong>这样做的好处就是每个关注点都集中于一个地方，而不是分散到多处代码中，其次服务模块更加简洁，只需要关注核心代码就行了。</strong></p><h2 id="定义AOP术语"><a href="#定义AOP术语" class="headerlink" title="定义AOP术语"></a>定义AOP术语</h2><ul><li><strong>通知（Advice）</strong>:通知定义了切面是什么以及何时使用。除了描述切面要完成的工作，通知还解决了何时执行这个工作的问题。因此可以说，切面的工作被称为通知。Spring切面可以应用5种类型的通知：<ul><li><strong>前置通知（Before）</strong>：在目标方法被调用之前调用通知功能。</li><li><strong>后置通知（After）</strong>：在目标方法完成之后调用通知，此时不会关心方法的输出。</li><li><strong>返回通知（After-returning）</strong>：在目标方法成功执行之后调用通知。</li><li><strong>异常通知（After-throwing）</strong>：在目标方阿飞抛出异常后调用通知。</li><li><strong>环绕通知（Around）</strong>：通知包裹了被通知的方法，在被通知的方法调用之前和调用之后执行自定义的行为。</li></ul></li><li><strong>连接点（Join point）</strong>：我们的应用可能有数以千计的时机应用通知，这些时机被称为连接点，连接点是在应用程序中能够插入切面的一个点。</li><li><strong>切点（Pointcut）</strong>：如果说通知定义了切面的“什么”和“何时”的话，那么切点就定义了“何处”，切点的定义会匹配通知所要织入的一个或多个连接点。</li><li><strong>切面（Aspect）</strong>：切面是通知和切点的结合。通知和切点共同定义了切面的全部内容：它是什么，在何时和何处完成其功能。</li><li><strong>引入（Introduction）</strong>：引入允许我们向现有的类添加新方法或属性。</li><li><strong>织入（Weaving）</strong>：织入是把切面应用到目标对象并创建新的代理对象的过程。切面在指定的连接点被织入到目标对象中。在目标对象的生命周期里有多个点可以进行织入：<ul><li><strong>编译器</strong>：切面在目标类编译时被织入，AspectJ的织入编译器就是以这种方式织入切面的。</li><li><strong>类加载期</strong>：切面在目标类加载到JVM时被织入。</li><li><strong>运行期</strong>：切面在应用运行的某个时刻被织入。Spring AOP就是以这种方式织入切面的。</li></ul></li></ul><h1 id="通过切点来选择连接点"><a href="#通过切点来选择连接点" class="headerlink" title="通过切点来选择连接点"></a>通过切点来选择连接点</h1><p>切点用于准确定位应该在什么地方应用切面的通知。通知和切点时切面的最基本元素。在Spring AOP中，要使用AspectJ的切点表达式语言来定义切点。下面是Spring AOP所支持的AspectJ切点指示器：<img src="/posts/5626/TIM%E6%88%AA%E5%9B%BE20191020152540.png" alt><br>在Spring中尝试使用AspectJ其它指示器时，将会抛出IllegalArgumentException异常。</p><h2 id="编写切点"><a href="#编写切点" class="headerlink" title="编写切点"></a>编写切点</h2><p>为阐述Spring中的切面，我们需要有个主题来定义切面的切点，为此我们定义一个Performance接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> concert;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Performance</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">perform</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Performance可以代表任何类型的现场表演，假设我们想编写Performance的perform()方法触发的通知，下面展示了一个切点表达式，这个表达式能够设置当perform()方法执行时触发通知的调用：<img src="/posts/5626/TIM%E6%88%AA%E5%9B%BE20191020153047.png" alt><strong>我们使用execution()指示器选择Preformance的perform（）方法。方法表达式以“*”号开始，表明我们不关心方法返回值的类型。然后我们指定了全限定类名和方法名。对于方法参数列表，我们使用两个点号（..）表明切点要选择任意的perform（）方法，无论该方法的入参是什么。假设我们需要配置的切点仅匹配concert包，可以使用within()指示器来限制匹配。使用“&amp;&amp;”来表示与的关系，“||”和“!”也同理：</strong><img src="/posts/5626/TIM%E6%88%AA%E5%9B%BE20191020153621.png" alt></p><h2 id="在切点中选择bean"><a href="#在切点中选择bean" class="headerlink" title="在切点中选择bean"></a>在切点中选择bean</h2><p>Spring引入一个新的bean（）指示器，允许我们在切点表达式中使用bean的ID来标识bean。bean（）使用bean ID或bean名称作为参数来限制切点只匹配特定的bean：<img src="/posts/5626/TIM%E6%88%AA%E5%9B%BE20191020153925.png" alt>在这里我们希望在执行Performance的perform（）方法时应用通知，但限定bean的ID为woodstock。</p><p><img src="/posts/5626/TIM%E6%88%AA%E5%9B%BE20191020154023.png" alt>在此场景下，切面的通知会被编织到所有ID不为woodstock的bean中。</p><h1 id="使用注解创建切面"><a href="#使用注解创建切面" class="headerlink" title="使用注解创建切面"></a>使用注解创建切面</h1><p>我们已经定义了Performance接口，他们是切面中切点的目标对象，现在使用AspectJ注解来定义切面。</p><h2 id="定义切面"><a href="#定义切面" class="headerlink" title="定义切面"></a>定义切面</h2><p>从演出的角度来看，观众是非常重要的，因此，将观众定义为一个切面，并将其应用到演出上：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> concert;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.AfterReturning;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.AfterThrowing;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.Aspect;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.Before;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Audience</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Before</span>(<span class="string">"execution(* concert.Performance.perform(..))"</span>)        <span class="comment">// 表演之前</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">silenceCellPhones</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Silencing cell phones"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Before</span>(<span class="string">"execution(* concert.Performance.perform(..))"</span>)        <span class="comment">// 表演之前</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">takeSeats</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Taking seats"</span>);</span><br><span class="line">    &#125;        </span><br><span class="line">    <span class="meta">@AfterReturning</span>(<span class="string">"execution(* concert.Performance.perform(..))"</span>)        <span class="comment">// 表演之后</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">applause</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"CLAP CLAP CLAP!!!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@AfterThrowing</span>(<span class="string">"execution(* concert.Performance.perform(..))"</span>)        <span class="comment">// 表演失败之后</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">demandRefound</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Demanding a refund"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Audience类使用@Aspect注解标注，该注解表明Audience不仅仅是一个POJO，还是一个切面。</strong></p><p>Audience四个方法定义了一个观众在观看演出时可能会做的事情：手机调至静音、就坐、喝彩鼓掌以及退款。可以看到这些方法都使用通知注解来表明它们应该在什么时候调用，注解都有如下：<img src="/posts/5626/TIM%E6%88%AA%E5%9B%BE20191020160119.png" alt><br>你可能注意到所有的这些注解都给定了一个切点表达式作为它的值，同时这四个方法的切点表达式都是相同的。所以我们可以改进一下，如果我们只定义这个切点一次，然后每次需要的时候引用它，那么这会是一个很好的方案。<strong>@Poincut注解能够在一个@AspectJ切面内定义可重用的切点</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> concert;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.AfterReturning;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.AfterThrowing;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.Aspect;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.Before;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.Pointcut;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Audience</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Pointcut</span>(<span class="string">"execution(* concert.Performance.perform(..))"</span>)        <span class="comment">//定义命名的切点</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">performance</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Before</span>(<span class="string">"performance()"</span>) </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">silenceCellPhones</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Silencing cell phones"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Before</span>(<span class="string">"performance()"</span>)        <span class="comment">// 表演之前</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">takeSeats</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Taking seats"</span>);</span><br><span class="line">    &#125;        </span><br><span class="line">    <span class="meta">@AfterReturning</span>(<span class="string">"performance()"</span>)        <span class="comment">// 表演之后</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">applause</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"CLAP CLAP CLAP!!!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@AfterThrowing</span>(<span class="string">"performance()"</span>)        <span class="comment">// 表演失败之后</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">demandRefound</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Demanding a refund"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要注意的是，除了注解和没有操作的performance（）方法，Audience类依然是一个独立的POJO，只不过它通过注解表明会作为切面使用，像其他类一样，它可以装配为Spring中的bean：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span> </span><br><span class="line"><span class="function"><span class="keyword">public</span> Audience <span class="title">audience</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Audience();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是到此为止的话，@Audience只会是Spring容器中的一个bean，并不会被视为切面，需要将这些注解启用配置到配置文件中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> concert;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.ComponentScan;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.EnableAspectJAutoProxy;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 启动AspectJ自动代理</span></span><br><span class="line"><span class="meta">@Configuration</span>                </span><br><span class="line"><span class="meta">@EnableAspectJAutoProxy</span></span><br><span class="line"><span class="meta">@ComponentScan</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcertConfig</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Audience <span class="title">audience</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Audience();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然使用XML文件配置也是完全可以的：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">/ 在XML中，通过Spring的aop命名空间启用AspectJ自动代理</span><br><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:context</span>=<span class="string">"http://www.springframework.org/schema/context"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:aop</span>=<span class="string">"http://www.springframework.org/schema/aop"</span>        // 声明<span class="attr">Spring</span>的<span class="attr">aop</span>命名空间</span></span><br><span class="line"><span class="tag">    <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/aop</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/context</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/context/spring-context.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/beans/spring-beans.xsd"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span> = <span class="string">"concert"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:aspectj-autoproxy</span> /&gt;</span>                // 启动AspectJ自动代理</span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>= <span class="string">"concert.Audience"</span> /&gt;</span>        // 声明Audience bean</span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="创建环绕通知"><a href="#创建环绕通知" class="headerlink" title="创建环绕通知"></a>创建环绕通知</h2><p>环绕通知是最为强大的通知类型，为了介绍它，我们重写Audiences切面：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用环绕通知重新实现Audience切面</span></span><br><span class="line"><span class="keyword">package</span> concert;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.ProceedingJoinPoint;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.Around;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.Aspect;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.Pointcut;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Audience</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="meta">@Pointcut</span>(<span class="string">"execution(** concert.Performance.perform(..))"</span>)        <span class="comment">//定义命名的切点</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">performance</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Around</span>(<span class="string">"performance()"</span>) </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">watchPerformance</span><span class="params">(ProceedingJoinPoint jp)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"Silencing cell phones"</span>);</span><br><span class="line">            System.out.println(<span class="string">"Taking seats"</span>);</span><br><span class="line">            jp.proceed();</span><br><span class="line">            System.out.println(<span class="string">"CLAP CLAP CLAP!!!"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span>(Throwable e)&#123;</span><br><span class="line">            System.out.println(<span class="string">"Demanding a refund"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，这个通知所达到的效果与之前的前置通知和后置通知是一样的，到那时现在它们处于同一个方法中。关于这个新的通知方法，你首先注意到的可能是它接受ProceedingJoinPoint作为参数，这个对象是必须要有的，因为你要在通知中通过它来调用被通知的方法。<strong>需要注意的是，别忘记调用proceed()方法，如果不调用这个方法，那么你的通知实际上会阻塞对被通知方法的调用。</strong></p><h2 id="处理通知中的参数"><a href="#处理通知中的参数" class="headerlink" title="处理通知中的参数"></a>处理通知中的参数</h2><p>之前的例子中都是没有参数的，但是如果切面所通知的方法有参数怎么办呢？有这样一个例子，play()方法会玄幻播放所有磁道并调用playTreck()方法，假设你想记录每个磁道被播放的次数，我们创建TrackCounter类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用参数化的通知来记录磁道播放的次数</span></span><br><span class="line"><span class="keyword">package</span> soundsystem;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.Aspect;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.Before;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.Pointcut;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TrackCounter</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Map&lt;Integer, Integer&gt; TrackCounts = <span class="keyword">new</span> HashMap&lt;Integer, Integer&gt;();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 通知playTrack()方法</span></span><br><span class="line">    <span class="meta">@Pointcut</span>(</span><br><span class="line">        <span class="string">"execution(* soundsystem.CompactDisc.playTrack(int))"</span> +</span><br><span class="line">        <span class="string">"&amp;&amp; args(trackNumber)"</span> )</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">trackPlayed</span><span class="params">(<span class="keyword">int</span> trackNumber)</span></span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Before</span>(<span class="string">"trackPlayed(trackNumber)"</span>)            <span class="comment">// 在播放前，为该磁道计数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">countTrack</span><span class="params">(<span class="keyword">int</span> trackNumber)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> currentCount = getPlayCount(trackNumber);</span><br><span class="line">        trackCounts.put(trackNumber, currentCount + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getPlayCount</span><span class="params">(<span class="keyword">int</span> trackNumber)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> trackCounts.containsKey(trackNumber) ? trackCounts.get(trackNumber) : <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>与之前不同的是，切点表达式中的args(trackNumber)限定符，它表明传递给playTrack方法的int类型参数也会传递到通知中去，参数的名称trackNumber也与切点方法签名中的参数相匹配。</strong><br><img src="/posts/5626/TIM%E6%88%AA%E5%9B%BE20191020162959.png" alt>现在我们可以在Spring配置中将BlankDisc和TrackCounter定义为bean，并启用AspectJ自动代理：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">/ 配置TrackCount记录每个磁道播放的次数</span><br><span class="line"><span class="keyword">package</span> soundsystem;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.List;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.EnableAspectJAutoProxy;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableAspectJAutoProxy</span>                    <span class="comment">// 启用AspectJ自动代理</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TrackCounterConfig</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> CompactDisc <span class="title">sgtPeppers</span><span class="params">()</span>        <span class="comment">// CompactDisc bean</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        BlankDisc cd = <span class="keyword">new</span> BlankDisc();</span><br><span class="line">        cd.setTitle(<span class="string">"Sgt. Pepper's Lonely Hearts Club Band"</span>);</span><br><span class="line">        cd.setArtist(<span class="string">"The Beales"</span>);</span><br><span class="line">        List&lt;String&gt; tracks = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">        tracks.add(<span class="string">"Sgt. Pepper's Lonely Hearts Club Band"</span>);</span><br><span class="line">        tracks.add(<span class="string">"With a Little Help from My Friends"</span>);</span><br><span class="line">        tracks.add(<span class="string">"Lucy in the Sky with Diamonds"</span>);</span><br><span class="line">        tracks.add(<span class="string">"Getting Better"</span>);</span><br><span class="line">        tracks.add(<span class="string">"Fixing a Hole"</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// ...other tracks omitted for brevity...</span></span><br><span class="line">        cd.setTracks(tracks);</span><br><span class="line">        <span class="keyword">return</span> cd;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TrackCounter <span class="title">trackCounter</span><span class="params">()</span>        <span class="comment">// TrackCounter bean</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> TrackCounter();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="通过注解引入新功能"><a href="#通过注解引入新功能" class="headerlink" title="通过注解引入新功能"></a>通过注解引入新功能</h2><p>静态语言的Java并不能像动态语言那样有开放类的理念，但是我们依旧可以使用切面为Spring bean添加新方法。在Spring中，切面只是实现了它们所包装bean相同接口的代理，如果除了实现这些接口，代理也能暴露新接口的话，会怎样呢？<img src="/posts/5626/TIM%E6%88%AA%E5%9B%BE20191020163646.png" alt>我们想办法使用AOP为示例中的所有Performance实现引入下面的Encoreable接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> concert;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Encoreable</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">performEncore</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为此我们需要创建一个新的切面：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> concert;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.Aspect;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.DeclareParents;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EncoreableIntroducer</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="meta">@DeclareParents</span>(value = <span class="string">"concert.Performance+"</span>, defaultImpl = DefaultEncoreable.class)</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Encoreable encoreable;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到EncoreableIntroducer是一个切面，但是他与我们之前的切面有所不同，使用了@DeclareParents注解，该注解由三部分组成：</p><ul><li><strong>value</strong>：<strong>该属性制定了哪种类型的bean要引入该接口</strong>，在本例中即Performance类型<strong>。标记后面的加号表示是Performance的所有子类型，而不是Performance本身。</strong></li><li><strong>defaultImpl</strong>：该属性指定了为引入功能提供实现的类。</li><li><strong>@DeclarationParents</strong>：该注解所标注的静态属性指明了要引入了接口。</li></ul><p>和其他切面一样，我们需要在Spring应用中将EncoreableIntroducer声明为一个bean：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span> = <span class="string">"concert.EncoreableIntroducer"</span> /&gt;</span></span><br></pre></td></tr></table></figure><h1 id="在XML中声明切面"><a href="#在XML中声明切面" class="headerlink" title="在XML中声明切面"></a>在XML中声明切面</h1><p>除了使用注解的方式，还可以考虑使用XML文件配置的方式。在Spring的aop命名空间中，提供了多个元素用来在XML中声明切面，如下表：<img src="/posts/5626/TIM%E6%88%AA%E5%9B%BE20191020170912.png" alt>在使用XML文件配置方式之前，先把之前在Audience类中的注解全部移除掉。</p><h2 id="声明前置和后置通知"><a href="#声明前置和后置通知" class="headerlink" title="声明前置和后置通知"></a>声明前置和后置通知</h2><p>接着我们在XML文件中配置将没有注解的Audience类转换为切面：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"> <span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">aop:aspect</span> <span class="attr">ref</span>=<span class="string">"audience"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">expression</span>=<span class="string">"execution(* XMLconcert.Performance.perform(..))"</span> <span class="attr">id</span>=<span class="string">"performance"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">aop:before</span> <span class="attr">pointcut-ref</span>=<span class="string">"performance"</span> <span class="attr">method</span>=<span class="string">"silenceCellPhones"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">aop:before</span> <span class="attr">pointcut-ref</span>=<span class="string">"performance"</span> <span class="attr">method</span>=<span class="string">"takeSeats"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">aop:after-returning</span> <span class="attr">pointcut-ref</span>=<span class="string">"performance"</span> <span class="attr">method</span>=<span class="string">"applause"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">aop:after-throwing</span> <span class="attr">pointcut-ref</span>=<span class="string">"performance"</span> <span class="attr">method</span>=<span class="string">"demandRefund"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">aop:aspect</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="声明环绕通知"><a href="#声明环绕通知" class="headerlink" title="声明环绕通知"></a>声明环绕通知</h2><p>将之前的watchPerformance()方法及其类中的注解都移除：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> concert;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.ProceedingJoinPoint;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Audience</span> </span>&#123;</span><br><span class="line">   </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">watchPerformance</span><span class="params">(ProceedingJoinPoint jp)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"手机静音"</span>);</span><br><span class="line">            System.out.println(<span class="string">"得到座位"</span>);</span><br><span class="line">            jp.proceed();</span><br><span class="line">            System.out.println(<span class="string">"鼓掌!!!"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">            System.out.println(<span class="string">"这演的啥啊！退票"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后在XML文件中配置：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">aop:aspect</span> <span class="attr">ref</span>=<span class="string">"audience"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">id</span>=<span class="string">"performance"</span> <span class="attr">expression</span>=<span class="string">"execution(* concert.Performance.perform(..))"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">aop:round</span> <span class="attr">pointcut-ref</span>=<span class="string">"preformance"</span> <span class="attr">method</span>=<span class="string">"watchPerformance"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">aop:aspect</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="为通知传递参数"><a href="#为通知传递参数" class="headerlink" title="为通知传递参数"></a>为通知传递参数</h2><p>将TrackCounter类中的注解都移除掉，然后在XML文件中配置如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">aop:aspect</span> <span class="attr">ref</span>=<span class="string">"trackCounter"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">id</span>=<span class="string">"trackPlayed"</span> <span class="attr">expression</span>=<span class="string">" execution(* com.springinaction.disc.CompactDisc.playTrack(int)) and args(trackNumber)"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">aop:before</span> <span class="attr">pointcut-ref</span>=<span class="string">"trackPlayed"</span> <span class="attr">method</span>=<span class="string">"countTrack"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">aop:aspect</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="通过切面引入新的功能"><a href="#通过切面引入新的功能" class="headerlink" title="通过切面引入新的功能"></a>通过切面引入新的功能</h2><p>依旧将原Encoreable的注解移除掉，然后配置为：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">aop:aspect</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">aop:declare-parents</span> <span class="attr">types-matching</span>=<span class="string">"com.springinaction.perf.Performance+"</span></span></span><br><span class="line"><span class="tag"><span class="attr">implement-interface</span>=<span class="string">"com.springinaction.perf.Encoreable"</span></span></span><br><span class="line"><span class="tag">                            <span class="attr">default-impl</span>=<span class="string">"com.springinaction.perf.DefaultEncoreable"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">aop:aspect</span>&gt;</span></span><br></pre></td></tr></table></figure><p>我们还可以使用delegate-ref属性来标识：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">aop:aspect</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">aop:declare-parents</span> <span class="attr">types-matching</span>=<span class="string">"com.springinaction.perf.Performance+"</span></span></span><br><span class="line"><span class="tag"><span class="attr">implement-interface</span>=<span class="string">"com.springinaction.perf.Encoreable"</span></span></span><br><span class="line"><span class="tag"><span class="attr">delegate-ref</span>=<span class="string">"defaultEncoreable"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">aop:aspect</span>&gt;</span></span><br></pre></td></tr></table></figure><p>delegate-ref属性引入了一个Spring的bean作为引入的委托：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"defaultEncoreable"</span> <span class="attr">class</span>=<span class="string">"com.springinaction.perf.DefaultEncoreable"</span> /&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      日志、安全和事务管理的确都很重要，但他们是否为应用程序对象主动参与的行为？AOP可以实现横切关注点与它们所影响的对象之间的解耦。
    
    </summary>
    
      <category term="Spring" scheme="http://yoursite.com/categories/Spring/"/>
    
    
  </entry>
  
  <entry>
    <title>@Autowired和@Resource</title>
    <link href="http://yoursite.com/posts/13512/"/>
    <id>http://yoursite.com/posts/13512/</id>
    <published>2019-10-19T06:32:32.000Z</published>
    <updated>2019-10-19T12:12:59.077Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Spring的-Autowired"><a href="#Spring的-Autowired" class="headerlink" title="Spring的@Autowired"></a>Spring的@Autowired</h1><h2 id="注解版的自动绑定（-Autowired）"><a href="#注解版的自动绑定（-Autowired）" class="headerlink" title="注解版的自动绑定（@Autowired）"></a>注解版的自动绑定（@Autowired）</h2><p>在之前的学习中，为了减少配置量，我们可以采用Spring的IoC容器提供的自动绑定功能：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">default-autowire</span>=<span class="string">"byType"</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"newsProvider"</span>    <span class="attr">class</span>=<span class="string">"..FXNewsProvider"</span> <span class="attr">autowire</span>=<span class="string">"byType"</span>/&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"djNewsListener"</span>  <span class="attr">class</span>=<span class="string">"..DowJonesNewsListener"</span>/&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"djNewsPersister"</span> <span class="attr">class</span>=<span class="string">"..DowJonesNewsPersister"</span>/&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>可以通过default-autowired或者autowired来指定每个bean定义的自动绑定方式，Spring2.5之后提供了一个更加方便的方式：@Autowired注解，它可以让容器知道需要为当前类注入哪些依赖。</strong>例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FXNewsProvider</span>  </span>&#123;  </span><br><span class="line"><span class="keyword">private</span> IFXNewsListener  newsListener; </span><br><span class="line"><span class="keyword">private</span> IFXNewsPersister newPersistener; </span><br><span class="line"></span><br><span class="line"><span class="meta">@Autowired</span>  </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">FXNewsProvider</span><span class="params">(IFXNewsListener newsListner,IFXNewsPersister newsPersister)</span>  </span>&#123;   </span><br><span class="line"><span class="keyword">this</span>.newsListener = newsListner;   </span><br><span class="line"><span class="keyword">this</span>.newPersistener = newsPersister;  </span><br><span class="line">&#125;  </span><br><span class="line">... </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>与原有的byType类型的自动绑定方式类似，@Autowired也是按照类型匹配进行依赖注入的,当按照类型找不到时，则会使用标注的属性名称，按byName的方式查找。</strong>但是@Autowired也更加灵活更加强大，它可以标注于类定义的多个位置。包括如下几个：</p><ul><li><strong>域或者说属性（Property）</strong>：<strong>不管它们声明的访问限制符是private还是public等等，只要标注@Autowired了，它们所需要的依赖注入需求就都能够被满足。</strong></li><li><strong>构造方法定义</strong>：<strong>标注于类的构造方法之上的@Autowired，相当于抢夺了原有自动绑定功能中“constructor”方式的权力，它将更具构造方法参数类型，来决定将什么样的依赖对象注入给当前对象，</strong>就如上面的代码演示一样。</li><li><strong>方法定义</strong>：<strong>@Autowired不光可以标注于传统的setter方法之上，而且还可以标注于任意名称的方法定义之上，只要该方法定义了需要被注入的参数。</strong></li></ul><p>接下来只需要在容器的配置文件中定义bean就行了：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span>&gt;</span>   </span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"newsProvider"</span>    <span class="attr">class</span>=<span class="string">"..FXNewsProvider"</span>/&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"djNewsListener"</span>  <span class="attr">class</span>=<span class="string">"..DowJonesNewsListener"</span>/&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"djNewsPersister"</span> <span class="attr">class</span>=<span class="string">"..DowJonesNewsPersister"</span>/&gt;</span> </span><br><span class="line"><span class="tag">&lt; /<span class="attr">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>为了给容器中定义的每个bean对应的实例注入依赖，可以遍历它们，然后通过反射，检查每个bean定义对应的类上各种可能位置上的@Autowired。如果存在的话，就可以从当前容器管理的对象中获取符合条件的对象，设置给@Autowired所标注的对象。</strong></p><p>那么如果仅仅只是一个注解，在Spring容器中并不能起作用，联想到之前的BeanPostProcessor自定义实现，让这个BeanPostProcessor在实例化bean定义的过程中，来检查当前对象是否有@Autowired标注的依赖需要注入，AutowiredAnnotationBeanPostProcessor就是Spring提供用于这一目的的BeanPostProcesser实现，所以只需要在配置文件中注册一下它就可以了：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor"</span>/&gt;</span>   </span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"newsProvider"</span>    <span class="attr">class</span>=<span class="string">"..FXNewsProvider"</span>/&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"djNewsListener"</span>  <span class="attr">class</span>=<span class="string">"..DowJonesNewsListener"</span>/&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"djNewsPersister"</span> <span class="attr">class</span>=<span class="string">"..DowJonesNewsPersister"</span>/&gt;</span> </span><br><span class="line"><span class="tag">&lt; /<span class="attr">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="Qualifier的陪伴"><a href="#Qualifier的陪伴" class="headerlink" title="@Qualifier的陪伴"></a>@Qualifier的陪伴</h2><p>@Autowired是按照类型进行匹配，如果当前@Autowired标注的依赖在容器中只能找到一个实例与之对应的话还好，可以是若能够同时找到多个同一类型的实例对象又该怎么办？这时候就可以使用@Qualifier对依赖注入的条件做进一步限定。</p><p><strong>@Qualifier实际上是byName自动绑定的注解版，既然IoC容器无法自己从多个同一类型的实例中选取我们真正想要的那个，那么我们就可以使用@Qualifier直接点名需要哪个。</strong>假设FXNewsProvider使用的IFNewsListener有两个实现类DowJonesNewsListener和ReutersNewsListener：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor"</span>/&gt;</span>    </span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"newsProvider"</span>    <span class="attr">class</span>=<span class="string">"..FXNewsProvider"</span>/&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"djNewsListener"</span>  <span class="attr">class</span>=<span class="string">"..DowJonesNewsListener"</span>/&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"reutersNewsListner"</span> <span class="attr">class</span>=<span class="string">"..ReutersNewsListener"</span>/&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"djNewsPersister"</span> <span class="attr">class</span>=<span class="string">"..DowJonesNewsPersister"</span>/&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><p>如果我们想让FXNewsProvider使用ReutersNewsListener，那么就可以使用@Qulifier指定选择：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FXNewsProvider</span>  </span>&#123;  </span><br><span class="line"><span class="meta">@Autowired</span>  </span><br><span class="line"><span class="meta">@Qualifier</span>(<span class="string">"reutersNewsListner"</span>)  </span><br><span class="line"><span class="keyword">private</span> IFXNewsListener  newsListener;  </span><br><span class="line"></span><br><span class="line"><span class="meta">@Autowired</span>  </span><br><span class="line"><span class="keyword">private</span> IFXNewsPersister newPersistener;  </span><br><span class="line"></span><br><span class="line">... </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="JavaEE的-Resource"><a href="#JavaEE的-Resource" class="headerlink" title="JavaEE的@Resource"></a>JavaEE的@Resource</h1><p>除了使用Spring提供的@Autowired和@Qulifier之外，还可以使用JavaEE提供的@Resource。<strong>@Resource与@Autowired不同，它遵循的是byName自动绑定的行为准则，也就是说，IoC容器将更具@Resource所指定的名称，到容器中查找beanName与之对应的实例，然后将查找到的对象实例注入给@Resource所标注的对象。</strong>如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FXNewsProvider</span>  </span>&#123;   </span><br><span class="line"><span class="meta">@Resource</span>(name=<span class="string">"djNewsListener"</span>)  </span><br><span class="line"><span class="keyword">private</span> IFXNewsListener  newsListener;  </span><br><span class="line"></span><br><span class="line"><span class="meta">@Resource</span>(name=<span class="string">"djNewsPersister"</span>) </span><br><span class="line"><span class="keyword">private</span> IFXNewsPersister newPersistener;  </span><br><span class="line">... </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>除了标注于属性之上外，还可以与@Autowired一样标注于方法或者构造方法之上，此处与@Autowired大致一样。</strong></p><h2 id="PostConstruct和-PreDestroy"><a href="#PostConstruct和-PreDestroy" class="headerlink" title="@PostConstruct和@PreDestroy"></a>@PostConstruct和@PreDestroy</h2><p><strong>确切的说，@PostConstruct和@PreDestroy不是服务于依赖注入的，他们主要用于标注对象生命周期管理相关方法，这与Spring的InitializingBean和DisposableBean接口，以及配置项中的init-method和destroy-method起到类似作用。</strong></p><p>如果想某个方法在对象实例化之后被调用，以做某些准备工作，或者想在对象销毁之前调用某个方法做清理工作，可以像如下这样：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LifecycleEnabledClass</span> </span>&#123; </span><br><span class="line"><span class="meta">@PostConstruct</span>  </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUp</span><span class="params">()</span>  </span>&#123;   </span><br><span class="line">...  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="meta">@PreDestroy</span>  </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span>  </span>&#123;   </span><br><span class="line">...  </span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="annotation-config"><a href="#annotation-config" class="headerlink" title="annotation-config"></a>annotation-config</h2><p>就像@AutoWired需要AutowiredAnnotationBeanPostProcessor为它与IoC容器牵线搭桥一样，JavaEE同样有这样的配置方法，可以帮助这些注解发挥它们的作用,那就是annotation-config，如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span> </span></span><br><span class="line"><span class="tag"><span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span> </span></span><br><span class="line"><span class="tag"><span class="attr">xmlns:context</span>=<span class="string">"http://www.springframework.org/schema/context"</span> </span></span><br><span class="line"><span class="tag"><span class="attr">xmlns:p</span>=<span class="string">"http://www.springframework.org/schema/p"</span> </span></span><br><span class="line"><span class="tag"><span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans </span></span></span><br><span class="line"><span class="tag"><span class="string">http://www.springframework.org/schema/beans/spring-beans-2.5.xsd </span></span></span><br><span class="line"><span class="tag"><span class="string">http://www.springframework.org/schema/context </span></span></span><br><span class="line"><span class="tag"><span class="string">http://www.springframework.org/schema/context/spring-context-2.5.xsd"</span>&gt;</span>     </span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">context:annotation-config</span>/&gt;</span>    </span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"newsProvider"</span>    <span class="attr">class</span>=<span class="string">"..FXNewsProvider"</span>/&gt;</span>  </span><br><span class="line"><span class="comment">&lt;!--其他bean定义--&gt;</span>  </span><br><span class="line">... </span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>&lt;context:annotation-config/&gt;不但帮我们把AutowiredAnnotationBeanPostProcessor和 CommonAnnotationBeanPostProcessor注册到容器，还把PersistenceAnnotationBeanPostProcessor和RequiredAnnotationBeanPostProcessor一并注册，可谓一举四得。</strong></p><h1 id="classpath-scanning介绍"><a href="#classpath-scanning介绍" class="headerlink" title="classpath-scanning介绍"></a>classpath-scanning介绍</h1><p>到现在为止，我们还是需要将相应对象的bean定义，一个个的添加到IoC容器的配置文件中，唯一与之前的区别就是，不用在配置文件中明确指定依赖关系了，那么既然注解做都做了，为了不做添加bean的注解呢》Spring的classpath-scanning就是因此而生的。</p><p><strong>使用相应的注解对组成应用程序的相关类进行标注后，classpath-scanning功能可以从某一顶层包开始扫描，当扫描到某个类标注了相应的注解之后，就会提取该类的相关信息，构建对应的BeanDefinition，然后把构建完成的BeanDefinition注册到容器，这之后的事情就不用多说了。</strong></p><p>classpath-scanning功能的触发是由&lt;context:component-scan&gt;决定的，只需要配置如下代码即可生效：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span>  </span></span><br><span class="line"><span class="tag"><span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span> </span></span><br><span class="line"><span class="tag"><span class="attr">xmlns:context</span>=<span class="string">"http://www.springframework.org/schema/context"</span> </span></span><br><span class="line"><span class="tag"><span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans </span></span></span><br><span class="line"><span class="tag"><span class="string">http://www.springframework.org/schema/beans/spring-beans-2.5.xsd </span></span></span><br><span class="line"><span class="tag"><span class="string">http://www.springframework.org/schema/context  </span></span></span><br><span class="line"><span class="tag"><span class="string">http://www.springframework.org/schema/context/spring-context-2.5.xsd"</span>&gt;</span> </span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">"org.spring21"</span>/&gt;</span> </span><br><span class="line"><span class="tag">&lt; /<span class="attr">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><p>现在&lt;context:component-scan&gt;将扫描org.spring21路径下的所有类型定义，寻找标注了相应注解的类，并添加到IoC容器。</p><p><strong>&lt;context:component-scan&gt;默认扫描的注解类型是@Component，不过在@Component语义基础上细化后的@Repository、@Service和@Controller也同样可以获得&lt;context:component-scan&gt;的青睐。</strong></p><p><strong>&lt;context:component-scan&gt;在扫描相关类定义并将它们添加到容器的时候，会使用一种默认的命名规则，来生成那些添加到容器的bean的名称（beanName）。比如DowJonesNewsPersister通过默认命名规则将获得dowJonesNewsPersister。如果想改变这种命名规则，就可以在@Component中制定一个自定义的名称。</strong></p><p>当在配置文件中添加&lt;context:component-scan&gt;之后，&lt;context:component-scan&gt;将多管闲事，同时会将AutowiredAnnotationBeanPostProcessor和CommonAnnotationBeanPostProcessor一并注入到容器中。</p><p>&lt;context:component-scan&gt;还会进一步定制扫描范围，默认情况下他只关系@Component、@Repository、@Service和@Controller四位大员。但是我们可以通过include-filtering和exclude-filtering定制扫描范围，例子如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span> </span></span><br><span class="line"><span class="tag"><span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span> </span></span><br><span class="line"><span class="tag"><span class="attr">xmlns:context</span>=<span class="string">"http://www.springframework.org/schema/context"</span> </span></span><br><span class="line"><span class="tag"><span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans </span></span></span><br><span class="line"><span class="tag"><span class="string">http://www.springframework.org/schema/beans/spring-beans-2.5.xsd </span></span></span><br><span class="line"><span class="tag"><span class="string">http://www.springframework.org/schema/context </span></span></span><br><span class="line"><span class="tag"><span class="string">http://www.springframework.org/ schema/context/spring-context-2.5.xsd"</span>&gt;</span> </span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">"org.spring21"</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">context:include-filter</span> <span class="attr">type</span>=<span class="string">"annotation"</span> <span class="attr">expression</span>=<span class="string">"cn.spring21.annotation.FXService"</span>/&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">context:exclude-filter</span> <span class="attr">type</span>=<span class="string">"aspectj"</span> <span class="attr">expression</span>=<span class="string">".."</span>/&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">context:component-scan</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt; /<span class="attr">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>include-filtering和exclude-filtering可以使用的type类型由annotation、assignable、regex和aspectj四种。</strong></p>]]></content>
    
    <summary type="html">
    
      在复杂的XML文件配置bean的方式之后，产生了@Autowired和@Resource这两个注解的，它们作用都是提供依赖注入、自动绑定的功能，那么它们之间的联系和区别又有什么呢？
    
    </summary>
    
      <category term="Spring" scheme="http://yoursite.com/categories/Spring/"/>
    
    
  </entry>
  
  <entry>
    <title>IoC容器之ApplicationContext</title>
    <link href="http://yoursite.com/posts/30205/"/>
    <id>http://yoursite.com/posts/30205/</id>
    <published>2019-10-19T05:33:24.000Z</published>
    <updated>2019-10-19T06:14:40.229Z</updated>
    
    <content type="html"><![CDATA[<h1 id="统一资源加载策略"><a href="#统一资源加载策略" class="headerlink" title="统一资源加载策略"></a>统一资源加载策略</h1><p>ApplicationContext既然要加载配置文件，就需要一个工具可以用来加载这些资源，因此而出现了ResourceLoader。ApplicationContext实则间接继承了ResourceLoader接口，可以用来对Spring内的资源做一个统一的加载。</p><p>在使用中最常用的两个加载器就是<strong>ClassPathXmlApplicationContext</strong>和<strong>FileSystemXmlApplicationContext</strong>。简单的使用代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ResourceLoader resourceLoader = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"配置文件路径"</span>); </span><br><span class="line"><span class="comment">// 或者 </span></span><br><span class="line"><span class="comment">// ResourceLoader resourceLoader = new FileSystemXmlApplicationContext("配置文件路径"); </span></span><br><span class="line">Resource fileResource = resourceLoader.getResource(<span class="string">"D:/spring21site/README"</span>);</span><br></pre></td></tr></table></figure><p><strong>ResourceLoader中增加了一种新的资源路径协议：classpath：和classpath<em>：，classpath</em>：与classpath：的唯一区别在于，如果能够在classpath中找到多个指定的资源，则返回多个。</strong></p><p><strong>ClassPathXmlApplicationContext和FileSystemXmlApplicationContext在处理资源在记得默认行为上有所不用。当ClassPathXmlApplicationContext在实例化的时候，即使没有执行classpath：或者classpath*：等前缀，它会默认从classpath中加载bean定义配置文件。而FileSystemXmlApplicationContext会默认从文件系统中加载bean定义文件。</strong></p><h1 id="其他特性"><a href="#其他特性" class="headerlink" title="其他特性"></a>其他特性</h1><p>ApplicationContext还提供了一些其他特性，这里就简单介绍一下，不过多描述。</p><ul><li><strong>国际化信息支持</strong>：ApplicationContext有两种国际化支持的方式，一个是Locale结合ResourceBundle，它可以绑定地区。另外一个就是MessageSource可以统一国际化信息的访问方式。</li><li><strong>容器内部事件发布</strong>：JavaSE提供了实现自定义时间发布功能的基础类，即EventListener和EventObject。</li><li><strong>多配置模块加载的简化</strong>：在配置应用的时候，为了更好的划分逻辑层次和分工，而延伸到个让容器同时读入划分到不同配置文件的信息。</li></ul>]]></content>
    
    <summary type="html">
    
      ApplicationContext作为较BeanFacory更先进的IoC容器实现，除了拥有BeanFactory支持的所有功能之外，还进一步扩展了基本容器的功能。下面就简单介绍一下这些新的特性吧。
    
    </summary>
    
      <category term="Spring" scheme="http://yoursite.com/categories/Spring/"/>
    
    
  </entry>
  
  <entry>
    <title>IoC容器之BeanFactory</title>
    <link href="http://yoursite.com/posts/37871/"/>
    <id>http://yoursite.com/posts/37871/</id>
    <published>2019-10-17T08:11:12.000Z</published>
    <updated>2019-10-18T14:36:48.377Z</updated>
    
    <content type="html"><![CDATA[<p>Spring提供了两种容器类型：<strong>BeanFactory</strong>和<strong>ApplicationContext</strong>。</p><ul><li><strong>BeanFactory</strong>：基础类型的Ioc容器，提供完整的IoC服务支持。<strong>如果没有特殊指定，默认采用延迟初始化策略。即只有当客户端对象需要访问容器中的某个受管对象时，才对该受管对象进行初始化以及依赖注入操作。</strong>所以相对来说，该容器启动初期速度较快，所需要的资源有限，因此BeanFactroy比较适合用于资源有限，并且功能要求不是很严格的场景。</li><li><strong>ApplicationContext</strong>：<strong>ApplicationContext是在BeanFactory的基础上构建的</strong>，是相对于高级的容器实现，因此ApplicationContext还提供了一些例如事件发布、国际化信息支持的高级特性。<strong>ApplicationContext所管理的对象，在该容器启动之后，默认全部初始化并绑定完成。</strong>所以相对BeanFactory来说，ApplicationContext要求更多的系统资源，同时启动时间也会长一些。因此ApplicationContext更适合于资源充足并且要求更多功能的场景中。</li></ul><p>通过下图可以对BeanFactory和ApplicationContext之间的关系有一个更清晰的认知。<img src="/posts/37871/TIM%E6%88%AA%E5%9B%BE20191017164208.png" alt></p><p>BeanFactory，顾名思义就是生产Bean的工厂，而Spring提倡使用POJO，所以可以把每个业务对象看作一个JavaBean对象。BeanFactory可以完成作为IoC Service Provider的所有职责，包括业务对象的注册和对象间依赖关系的绑定。</p><p>BeanFactory就像一个汽车生产厂。你从其他汽车零件厂商或者自己的零件生产部门取得汽车零件送入这个汽车生产厂，最后只需要从生产线的终点取得汽车成品就可以了。相似的，将应用程序所需的所有业务对象交给BeanFactory之后，剩下的就是直接从BeanFactory取得最终组装完成并且可用的对象。至于这个最终业务对象如何组装，你不需要担心，BeanFactory会帮你搞定。</p><h1 id="拥有BeanFactory之后的生活"><a href="#拥有BeanFactory之后的生活" class="headerlink" title="拥有BeanFactory之后的生活"></a>拥有BeanFactory之后的生活</h1><p>确切的说，拥有BeanFactory之后的生活没有太大的变化，有变化的也在只是一些拉拉扯扯的事情，客观一点就是对象之间依赖关系的解决方式改变了。之前系统业务对象需要自己去“拉”所依赖的业务对象，有了BeanFactory之类的IoC之后，需要依赖什么，让BeanFactory为我们推过来就行啦。以一个FX新闻系统的例子来说，FX新闻应用设计和实现框架代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>-设计FXNewsProvider类用于普遍的新闻处理 </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FXNewsProvider</span> </span>&#123;  ... &#125;   </span><br><span class="line"> </span><br><span class="line"><span class="number">2</span>-设计IFXNewsListener接口抽象各个新闻社不同的新闻获取方式，并给出相应实现类 </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IFXNewsListener</span> </span>&#123;  ... &#125; </span><br><span class="line">以及 </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DowJonesNewsListener</span> <span class="keyword">implements</span> <span class="title">IFXNewsListener</span></span>&#123;  ... &#125; </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="number">3</span>-设计IFXNewsPersister接口抽象不同数据访问方式，并实现相应的实现类 </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IFXNewsPersister</span> </span>&#123;  ...  &#125;   </span><br><span class="line">以及 </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DowJonesNewsPersister</span> <span class="keyword">implements</span> <span class="title">IFXNewsPersister</span> </span>&#123;  ... &#125;</span><br></pre></td></tr></table></figure><p>BeanFactory会说，这些都让我来干吧！此时BeanFactory说这些事情让他来做，但是它并不知道该怎么做，所以就需要你来教它怎么做。通常情况下，会使用XML文件配置的方式来教它，也就是告诉BeanFactory如何来注册并管理各个业务对象之间的依赖关系。下面是BeanFactory的XML配置方式实现业务对象间的依赖关系的一个例子代码：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span>&gt;</span>   </span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"djNewsProvider"</span> <span class="attr">class</span>=<span class="string">"..FXNewsProvider"</span>&gt;</span>   </span><br><span class="line"><span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">"0"</span>&gt;</span>    </span><br><span class="line"><span class="tag">&lt;<span class="name">ref</span> <span class="attr">bean</span>=<span class="string">"djNewsListener"</span>/&gt;</span>   </span><br><span class="line"><span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span>    </span><br><span class="line"><span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">"1"</span>&gt;</span>    </span><br><span class="line"><span class="tag">&lt;<span class="name">ref</span> <span class="attr">bean</span>=<span class="string">"djNewsPersister"</span>/&gt;</span>   </span><br><span class="line"><span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span>   </span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span>  </span><br><span class="line">... </span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在BeanFactory出现之前，我们通常会直接在应用程序的入口类的main方法中，自己动手实例化相应的对象并调用，如以下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">FXNewsProvider newsProvider = <span class="keyword">new</span> FXNewsProvider();  </span><br><span class="line">newsProvider.getAndPersistNews();</span><br></pre></td></tr></table></figure><p>不过现在有了BeanFactory，通过xml文件这张“图纸”告诉BeanFactory怎么做之后，让BeanFactory为我们生产一个FXNewsProvider，如以下代码所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">BeanFactory container = <span class="keyword">new</span> XmlBeanFactory(<span class="keyword">new</span> ClassPathResource(<span class="string">"配置文件路径"</span>)); </span><br><span class="line">FXNewsProvider newsProvider = (FXNewsProvider)container.getBean(<span class="string">"djNewsProvider"</span>); </span><br><span class="line">newsProvider.getAndPersistNews();</span><br><span class="line"></span><br><span class="line"><span class="comment">/*或者如以下代码所示*/</span> </span><br><span class="line">ApplicationContext container = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"配置文件路径"</span>); </span><br><span class="line">FXNewsProvider newsProvider = (FXNewsProvider)container.getBean(<span class="string">"djNewsProvider"</span>);  </span><br><span class="line">newsProvider.getAndPersistNews(); </span><br><span class="line"></span><br><span class="line"><span class="comment">/*也可以如以下代码所示*/</span></span><br><span class="line">ApplicationContext container = <span class="keyword">new</span> FileSystemXmlApplicationContext(<span class="string">"配置文件路径"</span>); </span><br><span class="line">FXNewsProvider newsProvider = (FXNewsProvider)container.getBean(<span class="string">"djNewsProvider"</span>); </span><br><span class="line">newsProvider.getAndPersistNews();</span><br></pre></td></tr></table></figure><h1 id="BeanFactory的对象注册与依赖绑定方式"><a href="#BeanFactory的对象注册与依赖绑定方式" class="headerlink" title="BeanFactory的对象注册与依赖绑定方式"></a>BeanFactory的对象注册与依赖绑定方式</h1><p>为了让BeanFactory能够明确管理各个业务对象以及业务对象之间的依赖绑定关系，同样需要需要某种途径来记录和管理这些信息。与上一章的IoC Service Provider提到的三种方式，BeanFactory几乎支持所有这些方式。</p><h2 id="直接编码方式"><a href="#直接编码方式" class="headerlink" title="直接编码方式"></a>直接编码方式</h2><p>先看一下使用直接编码方式FX新闻系统相关类是如何注册并绑定的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span>  </span>&#123;   </span><br><span class="line">DefaultListableBeanFactory beanRegistry = <span class="keyword">new</span> DefaultListableBeanFactory();  </span><br><span class="line">BeanFactory container = (BeanFactory)bindViaCode(beanRegistry);  </span><br><span class="line">FXNewsProvider newsProvider = (FXNewsProvider)container.getBean(<span class="string">"djNewsProvider"</span>);  </span><br><span class="line">newsProvider.getAndPersistNews(); </span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> BeanFactory <span class="title">bindViaCode</span><span class="params">(BeanDefinitionRegistry registry)</span> </span>&#123;     </span><br><span class="line">AbstractBeanDefinition newsProvider = <span class="keyword">new</span> RootBeanDefinition(FXNewsProvider.class,<span class="keyword">true</span>);     AbstractBeanDefinition newsListener = <span class="keyword">new</span> RootBeanDefinition(DowJonesNewsListener.class,<span class="keyword">true</span>);     AbstractBeanDefinition newsPersister = <span class="keyword">new</span> RootBeanDefinition(DowJonesNewsPersister.class,<span class="keyword">true</span>);     </span><br><span class="line"></span><br><span class="line"><span class="comment">// 将bean定义注册到容器中     </span></span><br><span class="line">registry.registerBeanDefinition(<span class="string">"djNewsProvider"</span>, newsProvider);     </span><br><span class="line">registry.registerBeanDefinition(<span class="string">"djListener"</span>, newsListener);     </span><br><span class="line">registry.registerBeanDefinition(<span class="string">"djPersister"</span>, newsPersister); </span><br><span class="line"></span><br><span class="line"><span class="comment">// 指定依赖关系     </span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. 可以通过构造方法注入方式     </span></span><br><span class="line">ConstructorArgumentValues argValues = <span class="keyword">new</span> ConstructorArgumentValues();   </span><br><span class="line">  argValues.addIndexedArgumentValue(<span class="number">0</span>, newsListener);     </span><br><span class="line">argValues.addIndexedArgumentValue(<span class="number">1</span>, newsPersister);     </span><br><span class="line">newsProvider.setConstructorArgumentValues(argValues);     </span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 或者通过setter方法注入方式</span></span><br><span class="line"> MutablePropertyValues propertyValues = <span class="keyword">new</span> MutablePropertyValues();     propertyValues.addPropertyValue(<span class="keyword">new</span> ropertyValue(<span class="string">"newsListener"</span>,newsListener));     propertyValues.addPropertyValue(<span class="keyword">new</span> PropertyValue(<span class="string">"newPersistener"</span>,newsPersister)); </span><br><span class="line">    newsProvider.setPropertyValues(propertyValues);    </span><br><span class="line"></span><br><span class="line"><span class="comment">// 绑定完成     </span></span><br><span class="line"><span class="keyword">return</span> (BeanFactory)registry; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>BeanFactory只是一个接口，我们最终需要一个该接口的实现来进行实际的Bean管理，DefaultListableBeanFactory就是这么一个比较通用的BeanFactory实现类。具体关系可以看下图：<img src="/posts/37871/TIM%E6%88%AA%E5%9B%BE20191017174425.png" alt>BeanDefaultListableBeanFactory除了间接的实现了BeanFactory接口，还实现了BeanDefinitionRegistry接口，该接口才是现在BeanFactory的实现中担当Bean注册管理的角色。打个比方说，BeanDefinitionRegistry就像图书馆的数加，所有的书是放在书架上的，虽然你还书借书都是跟图书馆（也就是BeanFactory）打交道，但书架才是图书馆存放各类图书的地方。</p><p>基本上BeanFactory接口只定义如何访问容器内管理Bean的方法，各个BeanFactory的实现类才负责具体Bean的注册以及管理工作。BeanDefinitionRegistry接口定义抽象了Bean的注册逻辑。通常情况下，具体的BeanFactory实现类会实现这个接口来管理Bean的注册。</p><p>每一个受管的对象，在容器中都会有一个BeanDefinition的实例与之相对应，该BeanDefinition的实例负责保存对象的所有必要信息，包括其对应的对象的class类型、是否是抽象类、构造方法参数以及其他属性等。当客户端向BeanFactory请求相对应对象的时候，BeanFactory会通过这些信息为客户端返回一个完备可用的对象实例。</p><p>所以现在可以回到上面的代码中了，上面代码大致可以分为三个步骤：</p><ol><li>在main方法中，首先构造一个DefaultListableBeanFactory作为BeanDefinitionRegistry，然后将其交给bindViaCode方式进行具体的对象注册和相关逻辑管理，然后就可以通过该方法返回的BeanFactory取得需要的对象。</li><li>在bindViaCode方法中，首先针对相应的业务对象构造与其相对应的BeanDefinition，使用了RootBeanDefinition作为BeanDefinition的实现类。构造完成后，将这些BeanDefinite注册到通过方法参数传进来的BeanDefinitionRegistry中。</li><li>之后我们可以通过构造方法，或者setter方法，为其注入相关依赖。最后以BeanFactory的形式返回已经注册并绑定了所有相关业务对象的BeanDefinitionRegistry实例。</li></ol><h2 id="外部配置文件方式"><a href="#外部配置文件方式" class="headerlink" title="外部配置文件方式"></a>外部配置文件方式</h2><p>Spring的IoC容器支持两种配置文件格式：<strong>Properties文件格式</strong>和<strong>XML文件格式</strong>。</p><p>采用外部配置文件时，Spring的IoC荣有一个统一的处理方式。通常情况下，需根据不同的外部配置文件格式，给出相应的BeanDefinitionReader实现类，由BeanDefinitionReader的相应实现类负责将相应的配置文件的内容读取并映射到BeanDefinition，然后将映射后的BeanDefinition注册到一个BeanDefinitionRegistry，之后BeanDefinitionRegistry即完成Bean的注册和加载。</p><h3 id="Properties配置格式的加载"><a href="#Properties配置格式的加载" class="headerlink" title="Properties配置格式的加载"></a>Properties配置格式的加载</h3><p>Spring提供了PropertiesBeanDefiniteReader类用于Properties格式配置文件的加载，只需要根据该类的读取规则，提供相应的配置文件即可，示例代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">djNewsProvider.(class)=..FXNewsProvider </span><br><span class="line">djListener.(class)=..impl.DowJonesNewsListener </span><br><span class="line">djPersister.(class)=..impl.DowJonesNewsPersister </span><br><span class="line"></span><br><span class="line"># ----------通过构造方法注入的时候------------- </span><br><span class="line">djNewsProvider.$0(ref)=djListener </span><br><span class="line">djNewsProvider.$1(ref)=djPersister </span><br><span class="line"></span><br><span class="line"># ----------通过setter方法注入的时候---------  </span><br><span class="line">djNewsProvider.newsListener(ref)=djListener  </span><br><span class="line">djNewsProvider.newPersistener(ref)=djPersister</span><br></pre></td></tr></table></figure><p>这些内容都是特定于Spring的PropertiesBeanDefinitionReader的，下面是简单的语法介绍：</p><ul><li>djNewsProvider作为beanName，后面通过（class）表明对应的实现类是什么，实际上使用djNewsProvider.class=…的形式也是可以的，但是不提倡。</li><li>通过在表示beanName的名称后添加.$[number]后缀的形式，来表示当前beanName对应的对象需要通过构造方法注入的方式注入相应依赖对象。$0和1$1后面的（ref）用来表示所依赖的是引用对象，而不是普通的类型。如果不加（ref），则会将djListener和djPersister作为简单的String类型进行注入，异常也是自然不可避免了。</li><li>setter方法注入与构造方法注入最大的区别就是，它不使用数字顺序来指定注入的位置，而使用相应的属性名称来指定注入，同样也不要忘掉（ref）。</li></ul><p>在使用Properties文件配置完后，就可以使用了，下面是一个使用演示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span>  </span>&#123;   </span><br><span class="line">DefaultListableBeanFactory beanRegistry = <span class="keyword">new</span> DefaultListableBeanFactory();  </span><br><span class="line">BeanFactory container = (BeanFactory)bindViaPropertiesFile(beanRegistry);  </span><br><span class="line">FXNewsProvider newsProvider = (FXNewsProvider)container.getBean(<span class="string">"djNewsProvider"</span>);  </span><br><span class="line">newsProvider.getAndPersistNews(); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> BeanFactory <span class="title">bindViaPropertiesFile</span><span class="params">(BeanDefinitionRegistry registry)</span> </span>&#123;  </span><br><span class="line">PropertiesBeanDefinitionReader reader =  <span class="keyword">new</span> PropertiesBeanDefinitionReader(registry);  </span><br><span class="line">reader.loadBeanDefinitions(<span class="string">"classpath:../../binding-config.properties"</span>);  </span><br><span class="line"><span class="keyword">return</span> (BeanFactory)registry; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="XML配置格式的加载"><a href="#XML配置格式的加载" class="headerlink" title="XML配置格式的加载"></a>XML配置格式的加载</h3><p>XML配置格式是Spring支持最完整，功能最强大，也是使用最频繁的表达方式。例子如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span> </span><br><span class="line"><span class="meta">&lt;!DOCTYPE beans PUBLIC "-//SPRING//DTD BEAN//EN" "http://www.springframework.org/dtd/spring-beans.dtd"&gt;</span> </span><br><span class="line"> </span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"djNewsProvider"</span> <span class="attr">class</span>=<span class="string">"..FXNewsProvider"</span>&gt;</span>   </span><br><span class="line"><span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">"0"</span>&gt;</span>    </span><br><span class="line"><span class="tag">&lt;<span class="name">ref</span> <span class="attr">bean</span>=<span class="string">"djNewsListener"</span>/&gt;</span>   </span><br><span class="line"><span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span>   </span><br><span class="line"><span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">"1"</span>&gt;</span>    </span><br><span class="line"><span class="tag">&lt;<span class="name">ref</span> <span class="attr">bean</span>=<span class="string">"djNewsPersister"</span>/&gt;</span>   </span><br><span class="line"><span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span>    </span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"djNewsListener"</span> <span class="attr">class</span>=<span class="string">"..impl.DowJonesNewsListener"</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span>  </span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"djNewsPersister"</span> <span class="attr">class</span>=<span class="string">"..impl.DowJonesNewsPersister"</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><p>相对应的加载XML配置文件的BeanFactory的使用演示如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span>  </span>&#123; </span><br><span class="line">DefaultListableBeanFactory beanRegistry = <span class="keyword">new</span> DefaultListableBeanFactory();  </span><br><span class="line">BeanFactory container = (BeanFactory)bindViaXMLFile(beanRegistry);  </span><br><span class="line">FXNewsProvider newsProvider = (FXNewsProvider)container.getBean(<span class="string">"djNewsProvider"</span>); </span><br><span class="line">newsProvider.getAndPersistNews(); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> BeanFactory <span class="title">bindViaXMLFile</span><span class="params">(BeanDefinitionRegistry registry)</span>  </span>&#123;  </span><br><span class="line">XmlBeanDefinitionReader reader = <span class="keyword">new</span> XmlBeanDefinitionReader(registry);  </span><br><span class="line">reader.loadBeanDefinitions(<span class="string">"classpath:../news-config.xml"</span>); </span><br><span class="line"><span class="keyword">return</span> (BeanFactory)registry;  </span><br><span class="line"><span class="comment">// 或者直接  </span></span><br><span class="line"><span class="comment">//return new XmlBeanFactory(new ClassPathResource("../news-config.xml")); </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>与Properties一样，XML同样有Spring提供的现成的BeanDefinitionReader实现，即XmlBeanDefinitionReader。</p><h2 id="注解方式"><a href="#注解方式" class="headerlink" title="注解方式"></a>注解方式</h2><p>注解是Java5之后才引入的，所以相对来说也更加简洁方便一些，使用注解的方式为FXNewsProvider注入所需要的依赖，现在可以使用@Autowired以及@Component对相关类进行标记。下面是FXNews使用注解标注后的情况。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FXNewsProvider</span>  </span>&#123;  </span><br><span class="line"><span class="meta">@Autowired</span>  </span><br><span class="line"><span class="keyword">private</span> IFXNewsListener  newsListener;  </span><br><span class="line"><span class="meta">@Autowired</span>  </span><br><span class="line"><span class="keyword">private</span> IFXNewsPersister newPersistener;    </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">FXNewsProvider</span><span class="params">(IFXNewsListener newsListner,IFXNewsPersister newsPersister)</span>  </span>&#123;   </span><br><span class="line"><span class="keyword">this</span>.newsListener   = newsListner;   </span><br><span class="line"><span class="keyword">this</span>.newPersistener = newsPersister;  </span><br><span class="line">&#125;  </span><br><span class="line">... </span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line"><span class="meta">@Component</span> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DowJonesNewsListener</span> <span class="keyword">implements</span> <span class="title">IFXNewsListener</span>  </span>&#123;  ... &#125; </span><br><span class="line"> </span><br><span class="line"><span class="meta">@Component</span> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DowJonesNewsPersister</span> <span class="keyword">implements</span> <span class="title">IFXNewsPersister</span>  </span>&#123;  ... &#125;</span><br></pre></td></tr></table></figure><p><strong>@Autowired是这里的主角，它的存在将告知Spring容器需要为当前对象注入哪些依赖对象。而@Component则是配合Spring中的classpath-scanning功能使用。现在我们只要再向Spring的配置文件中增加一个“触发器”，使用@Autowired和@Component标注的类就能获得依赖对象的注入了。</strong>下面是在配置文件中配置的方法：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span> </span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span> </span></span><br><span class="line"><span class="tag"><span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span> </span></span><br><span class="line"><span class="tag"><span class="attr">xmlns:context</span>=<span class="string">"http://www.springframework.org/schema/context"</span> </span></span><br><span class="line"><span class="tag"><span class="attr">xmlns:tx</span>=<span class="string">"http://www.springframework.org/schema/tx"</span> </span></span><br><span class="line"><span class="tag"><span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans </span></span></span><br><span class="line"><span class="tag"><span class="string">http://www.springframework.org/schema/beans/spring-beans-2.5.xsd </span></span></span><br><span class="line"><span class="tag"><span class="string">http://www.springframework.org/schema/context </span></span></span><br><span class="line"><span class="tag"><span class="string">http://www.springframework.org/schema/context/spring-context-2.5.xsd </span></span></span><br><span class="line"><span class="tag"><span class="string">http://www.springframework.org/schema/tx </span></span></span><br><span class="line"><span class="tag"><span class="string">http://www.springframework.org/schema/tx/spring-tx-2.5.xsd"</span>&gt;</span> </span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">"cn.spring21.project.base.package"</span>/&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong><a href="context:component-scan" target="_blank" rel="noopener">context:component-scan</a>会到指定的包下面扫描有@Component的类，如果找到，则将他们添加到容器进行管理，并根据它们所标注的@Autowired为这些类注入符合条件的依赖对象。</strong>所以在做完上面的工作之后，就可以使用了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;  </span><br><span class="line">ApplicationContext ctx = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"配置文件路径"</span>);  </span><br><span class="line">FXNewsProvider newsProvider = (FXNewsProvider)container.getBean(<span class="string">"FXNewsProvider"</span>); </span><br><span class="line">newsProvider.getAndPersistNews(); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="XML配置方法"><a href="#XML配置方法" class="headerlink" title="XML配置方法"></a>XML配置方法</h1><p>XML格式的容器信息管理方式是Spring提供的最为强大、支持最为全面的方式，因此在这里讲述一下XML文件的以标签和一些属性。</p><h2 id="lt-beans-gt-和-lt-bean-gt"><a href="#lt-beans-gt-和-lt-bean-gt" class="headerlink" title="&lt;beans&gt;和&lt;bean&gt;"></a>&lt;beans&gt;和&lt;bean&gt;</h2><p>所有的Spring容器加载的XML配置文件的头部，都需要基于文档声明，而DTD和XSD的声明方式不一样，下面是一个对比：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- DTD方式 --&gt;</span></span><br><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span>  </span><br><span class="line"><span class="meta">&lt;!DOCTYPE beans PUBLIC "-//SPRING//DTD BEAN//EN" ➥ "http://www.springframework.org/dtd/spring-beans.dtd"&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span>&gt;</span>  ... <span class="tag">&lt;/<span class="name">beans</span>&gt;</span> </span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- XSD方式 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span> </span></span><br><span class="line"><span class="tag"><span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span> </span></span><br><span class="line"><span class="tag"><span class="attr">xmlns:util</span>=<span class="string">"http://www.springframework.org/schema/util"</span> </span></span><br><span class="line"><span class="tag"><span class="attr">xmlns:jee</span>=<span class="string">"http://www.springframework.org/schema/jee"</span>  </span></span><br><span class="line"><span class="tag"><span class="attr">xmlns:lang</span>=<span class="string">"http://www.springframework.org/schema/lang"</span>  </span></span><br><span class="line"><span class="tag"><span class="attr">xmlns:aop</span>=<span class="string">"http://www.springframework.org/schema/aop"</span>  </span></span><br><span class="line"><span class="tag"><span class="attr">xmlns:tx</span>=<span class="string">"http://www.springframework.org/schema/tx"</span>  </span></span><br><span class="line"><span class="tag"><span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans  </span></span></span><br><span class="line"><span class="tag"><span class="string">http://www.springframework.org/schema/beans/spring-beans-2.0.xsd  </span></span></span><br><span class="line"><span class="tag"><span class="string">http://www.springframework.org/schema/util </span></span></span><br><span class="line"><span class="tag"><span class="string">http://www.springframework.org/schema/util/spring-util-2.0.xsd  </span></span></span><br><span class="line"><span class="tag"><span class="string">http://www.springframework.org/schema/jee </span></span></span><br><span class="line"><span class="tag"><span class="string">http://www.springframework.org/schema/jee/spring-jee-2.0.xsd </span></span></span><br><span class="line"><span class="tag"><span class="string">http://www.springframework.org/schema/lang </span></span></span><br><span class="line"><span class="tag"><span class="string">http://www.springframework.org/schema/lang/spring-lang-2.0.xsd </span></span></span><br><span class="line"><span class="tag"><span class="string">http://www.springframework.org/schema/aop </span></span></span><br><span class="line"><span class="tag"><span class="string">http://www.springframework.org/schema/aop/spring-aop-2.0.xsd  </span></span></span><br><span class="line"><span class="tag"><span class="string">http://www.springframework.org/schema/tx </span></span></span><br><span class="line"><span class="tag"><span class="string">http://www.springframework.org/schema/tx/spring-tx-2.0.xsd"</span>&gt;</span>   </span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><p>所有注册到容器的业务对象，在Spring中称之为Bean。所以，每一个对象在XML的映射中也自然而然的对应一个&lt;bean&gt;。既然容器最终可以管理所有的业务对象，那么XML中把这些叫做&lt;bean&gt;的元素组织起来，就叫做&lt;beans&gt;。</p><h3 id="lt-beans-gt-之唯我独尊"><a href="#lt-beans-gt-之唯我独尊" class="headerlink" title="&lt;beans&gt;之唯我独尊"></a>&lt;beans&gt;之唯我独尊</h3><p>&lt;beans&gt;是XML配置我呢见中最顶层的元素，它下面可以包含0或者1个&lt;description&gt;和多个&lt;bean&gt;以及&lt;import&gt;或者&lt;alias&gt;。&lt;beans&gt;作为所有<bean>的“统帅”，它拥有相应的属性对所辖的&lt;bean&gt;进行统一的默认行为设置，包括如下几个：</bean></p><ul><li><strong>default-lazy-init</strong>:其值可以指定为true或者false，默认值为false。用来标志是否对所有的&lt;bean&gt;进行延迟初始化，但是指定为true时并不一定会延迟初始化，如果某个非延迟的bean依赖于该bean，那么该bean就不会延迟初始化。</li><li><strong>default-autowire</strong>：可以取值为no-不采取任何形式的自动绑定，完全依赖于手工明确配置、byName-与XML文件中声明的bean定义的beanName的值进行匹配、byType-会根据当前bean定义类型，按类型匹配、constructor-同样是按类型绑定，但是是匹配构造放的参数类型，而不是实例属性的类型，以及autodetect-byTye和constructor的结合体，如果是无参构造方法则是由byType，否则使用constructor模式。默认为no。如果使用自动绑定的话，用来标志全体bean使用哪一种默认绑定方式。</li><li><strong>default-dependency-check</strong>：可以取值为none-不检查、objects-只对对象引用类型依赖进行检查、simple-对简单属性类型以及相关的collection进行依赖检查，对象引用类型的依赖除外，以及all-simple和objects的结合，默认为none，即不做检查。</li><li><strong>default-init-method</strong>：如果所管辖的所有&lt;bean&gt;都有同样名称的初始化方法，可以在这里统一指定这个初始化方法名，而不用每一个单独指定。</li><li><strong>default-destroy-method</strong>：与default-init-method相对应，如果所管辖的所有&lt;bean&gt;都有同样名称的销毁方法，可以在这里统一指定这个销毁方法名，而不用每一个单独指定。</li></ul><h3 id="lt-description-gt-、-lt-import-gt-和-lt-alias-gt"><a href="#lt-description-gt-、-lt-import-gt-和-lt-alias-gt" class="headerlink" title="&lt;description&gt;、&lt;import&gt;和&lt;alias&gt;"></a>&lt;description&gt;、&lt;import&gt;和&lt;alias&gt;</h3><p>这几个元素通常情况下不是必须的，这里只是了解一下。</p><ul><li><strong>&lt;description&gt;</strong>：在配置文件中指定一些描述性的信息。</li><li><strong>&lt;import&gt;</strong>：可以在主要的配置文件中通过这个标签元素对其所依赖的配置文件引用，例如在A文件中&lt;import resource=”B.xml”&gt;</li><li><strong>&lt;alias&gt;</strong>：为某些&lt;bean&gt;起一些别名，通常情况下是为了减少输入。</li></ul><h2 id="孤孤单单的id和class"><a href="#孤孤单单的id和class" class="headerlink" title="孤孤单单的id和class"></a>孤孤单单的id和class</h2><h3 id="id属性"><a href="#id属性" class="headerlink" title="id属性"></a>id属性</h3><p>通常，每个注册到容器的对象都需要一个唯一标志来将其与同处一室的bean兄弟们区分开来，通过id属性来指定当前注册对象的beanName是什么。实际上并非任何情况下都需要指定每个&lt;bean&gt;的id，有些情况下可以省略，会在后面提到。</p><p>除了使用id来指定&lt;bean&gt;在容器中的标志，还可以使用name属性来指定&lt;bean&gt;的别名。name比id灵活之处在于，name可以使用id不能使用的一些字符，比如、。而且还可以通过逗号、空格或者冒号分割指定多个name。name的作用和alias的作用基本相同。</p><h3 id="class属性"><a href="#class属性" class="headerlink" title="class属性"></a>class属性</h3><p>每个注册到容器的对象都需要通过&lt;bean&gt;元素的class属性指定其类型。在大部分情况下该属性都是必须的，仅在少数情况下不需要指定，后面会提到。</p><h2 id="XML中的继承"><a href="#XML中的继承" class="headerlink" title="XML中的继承"></a>XML中的继承</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"newsProviderTemplate"</span> <span class="attr">abstract</span>=<span class="string">"true"</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"newPersistener"</span>&gt;</span>    </span><br><span class="line"><span class="tag">&lt;<span class="name">ref</span> <span class="attr">bean</span>=<span class="string">"djNewsPersister"</span>/&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span>  </span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"superNewsProvider"</span> <span class="attr">parent</span>=<span class="string">"newsProviderTemplate"</span>   <span class="attr">class</span>=<span class="string">"..FXNewsProvider"</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"newsListener"</span>&gt;</span>   </span><br><span class="line"><span class="tag">&lt;<span class="name">ref</span> <span class="attr">bean</span>=<span class="string">"djNewsListener"</span>/&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"> </span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"subNewsProvider"</span> <span class="attr">parent</span>=<span class="string">"newsProviderTemplate"</span>   <span class="attr">class</span>=<span class="string">"..SpecificFXNewsProvider"</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"newsListener"</span>&gt;</span>   </span><br><span class="line"><span class="tag">&lt;<span class="name">ref</span> <span class="attr">bean</span>=<span class="string">"specificNewsListener"</span>/&gt;</span>   </span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt; /<span class="attr">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>根据上面的代码可以看出，我们在声明superNewsProvider和subNewsProvider的时候，使用了parent属性，将其值指定为newsProviderTemplate，这样我们就继承了newsProviderTemplate定义的默认值，只需要将指定的属性进行更改，而不要全部又重新定义一遍。</p><p>parent属性还可以与abstract属性结合使用，达到将相应bean定义模板化的目的。newsProviderTemplate的bean定义通过abstract属性声明为true，说明这个bean定义不需要实例化，<strong>这就是之前提到的可以不指定class属性的少数场景之一。</strong>该bean只是配置一个模板，不对应任何对象，superNewsProvider和subNewsProvider通过parent指向这个模板定义，就拥有了该模板定义的所有属性配置。</p><p><strong>容器在初始化对象实例的时候，不会关注abstract的bean。如果你不想容器在初始化对象实例的时候，那么可以将其abstract属性赋值为true，以避免容器将其实例化。同样对于ApplicationContext也是如此。</strong></p><h2 id="bean的scope（作用域）"><a href="#bean的scope（作用域）" class="headerlink" title="bean的scope（作用域）"></a>bean的scope（作用域）</h2><p>scope用来声明容器中的对象所应该处的限定场景或者说该对象的存活时间，即容器在对象进入相应的scope之前，生产并装配这些对象，在该对象不在处于这些scope的限定之后，容器通常会销毁这些对象。</p><p>Spring最初提供了两种bean的scope类型：singleton和prototype，但是2.0发布之后，又引入了另外三种scope类型，即request、session和globa session类型，对应这三种类型只能在Web应用中使用。</p><h3 id="singleton"><a href="#singleton" class="headerlink" title="singleton"></a>singleton</h3><p><strong>标记为拥有singleton scope的对象定义，在Spring的IoC容器中只存在一个实例，所有对该对象的引用将共享这个实例，也就是说它与IoC容器的寿命“几乎”相同。</strong></p><p><strong>不要将这里的singleton与设计模式中的singleton相混淆。二者的语义是不同的：标记为singleton的bean是由容器来保证这种类型的bean在同一个容器中只存在一个共享实例；而Singleton模式则是保证在同一个Classloader中只存在一个这种类型的实例。</strong></p><p>可以从两个方面看singleton的bean所具有的特性：</p><ul><li><strong>对象实例数量</strong>：singleton的bean定义，在一个容器中只存在一个共享实例，所有对该类型bean的依赖都引用这一单一实例。</li><li><strong>对象存活时间</strong>：singleton类型bean定义，从容器启动，到它第一次被请求而实例化开始，只要容器不销毁或者退出，该类型bean的单一实例就会一直存活。</li></ul><p><strong>通常情况下，如果你不指定bean的scope，singleton便是容器默认的scope。</strong></p><h3 id="prototype"><a href="#prototype" class="headerlink" title="prototype"></a>prototype</h3><p><strong>针对声明为拥有prototype scope的bean定义，容器在接到该类型对象的请求的时候，会每次都重新生成一个新的对象实例给请求方。虽然这种类型的对象的实例化以及属性设置等工作都是由容器负责的，但是只要准备完毕，并且对象实例返回给请求方之后，容器就不再拥有当前返回对象的引用，请求方需要自己负责当前返回对象的后继生命周期的管理工具，包括销毁。</strong></p><p>所以对于那些请求不能共享使用的对象类型，应该将其bean定义的scope设置为prototype，这样可以用它来保存一些用户的状态信息。</p><h3 id="request"><a href="#request" class="headerlink" title="request"></a>request</h3><p><strong>Spring容器，即XmlWebApplicationContext会为每一个HTTP请求创建一个全新的RequestProcessor对象供当前请求使用，当请求结束后，该对象实例的生命周期即告结束。</strong></p><h3 id="session"><a href="#session" class="headerlink" title="session"></a>session</h3><p>Spring容器会为每个独立的session创建属于它们自己的全新的UserPreferences对象实例。与request相比，除了可能有更长的存活时间，其它方面真是没什么区别。</p><h3 id="global-session"><a href="#global-session" class="headerlink" title="global session"></a>global session</h3><p>global session只应用于基于porlet的Web应用程序中才有意义，在普通的基于servlet的Web应用中使用了这个类型的scope，容器会将其作为普通的session类型对待。</p><h3 id="自定义scope"><a href="#自定义scope" class="headerlink" title="自定义scope"></a>自定义scope</h3><p>默认的singleton和prototype是硬编码到代码中的，而request、session和globa session，包括自定义scope类型，都实现了Scope接口，该接口定义如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Scope</span> </span>&#123;    </span><br><span class="line"><span class="function">Object <span class="title">get</span><span class="params">(String name, ObjectFactory objectFactory)</span></span>; </span><br><span class="line"></span><br><span class="line"><span class="function">Object <span class="title">remove</span><span class="params">(String name)</span></span>;  </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">registerDestructionCallback</span><span class="params">(String name, Runnable callback)</span></span>; </span><br><span class="line"> </span><br><span class="line"><span class="function">String <span class="title">getConversationId</span><span class="params">()</span></span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>要实现自己的scope类型，首先要给出一个Scope接口的实现类，并非4个方法都是必须的，<strong>但get和remove方法必须实现。</strong>下面是一个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadScope</span> <span class="keyword">implements</span> <span class="title">Scope</span> </span>&#123; </span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ThreadLocal threadScope = <span class="keyword">new</span> ThreadLocal() &#123;       </span><br><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">initialValue</span><span class="params">()</span> </span>&#123;         </span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> HashMap();       </span><br><span class="line">&#125;      </span><br><span class="line">&#125;;      </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">get</span><span class="params">(String name, ObjectFactory objectFactory)</span> </span>&#123;     </span><br><span class="line">Map scope = (Map) threadScope.get();     </span><br><span class="line">Object object = scope.get(name);     </span><br><span class="line"><span class="keyword">if</span>(object==<span class="keyword">null</span>) &#123;       </span><br><span class="line">object = objectFactory.getObject();        </span><br><span class="line">scope.put(name, object);     </span><br><span class="line">&#125;     </span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> object;    </span><br><span class="line">&#125; </span><br><span class="line">   </span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">remove</span><span class="params">(String name)</span> </span>&#123;     </span><br><span class="line">Map scope = (Map) threadScope.get();     </span><br><span class="line"><span class="keyword">return</span> scope.remove(name);   </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerDestructionCallback</span><span class="params">(String name, Runnable callback)</span> </span>&#123;   </span><br><span class="line">&#125;   </span><br><span class="line">... </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来就是把这个新定义的scope注册到容器中，才能供相应的bean使用。我们有两种方式可以注册。</p><p>一种就是我们可以使用ConfigurableBeanFactory的以下方法去注册：<code>void registerScope(String scopeName, Scope scope)</code>，其中参数scopeName就是使用的bean定义可以指定的名称，参数scope就是我们提供的scope实现类实例。注册例子如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Scope threadScope = <span class="keyword">new</span> ThreadScope(); </span><br><span class="line">beanFactory.registerScope(<span class="string">"thread"</span>,threadScope);</span><br></pre></td></tr></table></figure><p>另一种方式就是可以在xml文件中配置CustomScopeConfigurer来注册scope。例如“</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.springframework.beans.factory.config.CustomScopeConfigurer"</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"scopes"</span>&gt;</span>   </span><br><span class="line"><span class="tag">&lt;<span class="name">map</span>&gt;</span>    </span><br><span class="line"><span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">"thread"</span> <span class="attr">value</span>=<span class="string">"com.foo.ThreadScope"</span>/&gt;</span>   </span><br><span class="line"><span class="tag">&lt;/<span class="name">map</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>接下来就可以使用这个自定义的scope了，例如：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"beanName"</span> <span class="attr">class</span>=<span class="string">"..."</span> <span class="attr">scope</span>=<span class="string">"thread"</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">aop:scoped-proxy</span>/&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="工厂方法与FactoryBean"><a href="#工厂方法与FactoryBean" class="headerlink" title="工厂方法与FactoryBean"></a>工厂方法与FactoryBean</h2><p>工厂方法（Factory Method）模式，提供一个工厂类来实例化具体的接口实现类，这样主体对象只需要依赖工厂类，具体使用的实现类有变更的话，只是变更工厂类，而主体对象不需要做任何变动，这样就避免了接口与实现类的耦合性。</p><p>针对这种方式，Spring的IoC容器同样提供了对应的集成支持，我们要做的，只是将工厂类所返回的具体的接口实现类注入给主体对象。</p><h3 id="静态工厂方法"><a href="#静态工厂方法" class="headerlink" title="静态工厂方法"></a>静态工厂方法</h3><p>假设现在有一个接口BarInterface，为了向使用该接口的客户端对象屏蔽以后可能对BarInterface实现类的变动，因此还提供了一个静态的工厂方法实现类StaticBarInterfaceFactory，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticBarInterfaceFactory</span> </span>&#123;  </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> BarInterface <span class="title">getInstance</span><span class="params">()</span>  </span>&#123;  </span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> BarInterfaceImpl();  </span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了将该静态方法类返回的实现注入Foo，我们使用以下方式进行配置：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"foo"</span> <span class="attr">class</span>=<span class="string">"...Foo"</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"barInterface"</span>&gt;</span>   </span><br><span class="line"><span class="tag">&lt;<span class="name">ref</span> <span class="attr">bean</span>=<span class="string">"bar"</span>/&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span> </span><br><span class="line"> </span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"bar"</span> <span class="attr">class</span>=<span class="string">"...StaticBarInterfaceFactory"</span> <span class="attr">factory-method</span>=<span class="string">"getInstance"</span>/&gt;</span></span><br></pre></td></tr></table></figure><p><strong>class指定静态方法工厂类，factory-method指定工厂方法名称，然后，容器调用该静态方法工厂类的指定工厂方法，并返回方法调用后的结果，即BarInterfaceImpl的实例。</strong></p><p>某些时候，有的工厂类的工厂方法需要参数来返回相应实例，可以通过&lt;constructor-arg&gt;来指定工厂方法需要的参数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticBarInterfaceFactory</span> </span>&#123;  </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> BarInterface <span class="title">getInstance</span><span class="params">(Foobar foobar)</span>  </span>&#123;   </span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> BarInterfaceImpl(foobar);  </span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"foo"</span> <span class="attr">class</span>=<span class="string">"...Foo"</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"barInterface"</span>&gt;</span>   </span><br><span class="line"><span class="tag">&lt;<span class="name">ref</span> <span class="attr">bean</span>=<span class="string">"bar"</span>/&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span> </span><br><span class="line"> </span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"bar"</span> <span class="attr">class</span>=<span class="string">"...StaticBarInterfaceFactory"</span> <span class="attr">factory-method</span>=<span class="string">"getInstance"</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">constructor-arg</span>&gt;</span>   </span><br><span class="line"><span class="tag">&lt;<span class="name">ref</span> <span class="attr">bean</span>=<span class="string">"foobar"</span>/&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span> </span><br><span class="line"> </span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"foobar"</span> <span class="attr">class</span>=<span class="string">"...FooBar"</span>/&gt;</span></span><br></pre></td></tr></table></figure><p><strong>唯一需要注意的是，针对静态工厂方法实现类的bean定义，使用&lt;constructor-arg&gt;传入的是工厂方法的参数，而不是静态工厂方法的构造方法的参数，况且，静态工厂方法实现类也没有提供显式的构造方法。</strong></p><h3 id="非静态工厂方法"><a href="#非静态工厂方法" class="headerlink" title="非静态工厂方法"></a>非静态工厂方法</h3><p>针对非静态方法的调用方式也很简单，只是需要稍微该变一下代码即可：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NonStaticBarInterfaceFactory</span>  </span>&#123;  </span><br><span class="line"><span class="function"><span class="keyword">public</span> BarInterface <span class="title">getInstance</span><span class="params">()</span>  </span>&#123;   </span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> BarInterfaceImpl();   </span><br><span class="line">&#125;  </span><br><span class="line">... </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"foo"</span> <span class="attr">class</span>=<span class="string">"...Foo"</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"barInterface"</span>&gt;</span>   </span><br><span class="line"><span class="tag">&lt;<span class="name">ref</span> <span class="attr">bean</span>=<span class="string">"bar"</span>/&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span> </span><br><span class="line"> </span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"barFactory"</span> <span class="attr">class</span>=<span class="string">"...NonStaticBarInterfaceFactory"</span>/&gt;</span>   </span><br><span class="line"></span><br><span class="line"><span class="tag">&lt; <span class="attr">bean</span> <span class="attr">id</span>=<span class="string">"bar"</span> <span class="attr">factory-bean</span>=<span class="string">"barFactory"</span> <span class="attr">factory-method</span>=<span class="string">"getInstance"</span>/&gt;</span></span><br></pre></td></tr></table></figure><p><strong>现在的最主要不同就在于是使用factory-bean属性来指定工厂方法所在的工厂类实例，而不是通过class属性来指定工厂方法所在类的类型。</strong>如果需要参数的话，配置方法同静态工厂方法一样。</p><h3 id="FactoryBean"><a href="#FactoryBean" class="headerlink" title="FactoryBean"></a>FactoryBean</h3><p>当某些对象的实例化过程因为繁琐，使用XML配置过于复杂时，就可以考虑通过代码的方式来完成这个实例化过程，FactoryBean接口就是为此而生的。FactoryBean接口只定义了三个方法，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">FactoryBean</span> </span>&#123; </span><br><span class="line"><span class="function">Object <span class="title">getObject</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>;  </span><br><span class="line"><span class="function">Class <span class="title">getObjectType</span><span class="params">()</span></span>;  </span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isSingleton</span><span class="params">()</span></span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>getObject()方法会返回该FactoryBean生产的对象实例，我们需要实现该方法以给出自己的对象实例化逻辑；</strong></li><li><strong>getObjectType()方法仅返回getObject()方法所返回的对象的类型，如果预先无法确定，则返回null；</strong></li><li><strong>isSingleton()方法返回结果用于表明是否为单例实例。</strong></li></ul><p>这是一个例子，得到第二天的日期：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NextDayDateFactoryBean</span> <span class="keyword">implements</span> <span class="title">FactoryBean</span> </span>&#123; </span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getObject</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;   </span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> DateTime().plusDays(<span class="number">1</span>);  </span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">public</span> Class <span class="title">getObjectType</span><span class="params">()</span> </span>&#123;   </span><br><span class="line"><span class="keyword">return</span> DateTime.class;  </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSingleton</span><span class="params">()</span> </span>&#123;   </span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;  </span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来只需要将其注册到容器中即可：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"nextDayDateDisplayer"</span> <span class="attr">class</span>=<span class="string">"...NextDayDateDisplayer"</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"dateOfNextDay"</span>&gt;</span>   </span><br><span class="line"><span class="tag">&lt;<span class="name">ref</span> <span class="attr">bean</span>=<span class="string">"nextDayDate"</span>/&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span>         </span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"nextDayDate"</span> <span class="attr">class</span>=<span class="string">"...NextDayDateFactoryBean"</span>&gt;</span> <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>接下来就是最重要的地方，来看看NextDayDateDisplayer的定义：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NextDayDateDisplayer</span> </span>&#123;  </span><br><span class="line"><span class="keyword">private</span> DateTime dateOfNextDay;  </span><br><span class="line"><span class="comment">// 相应的setter方法  </span></span><br><span class="line"><span class="comment">// ... </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>NextDayDateDisplayer所声明的依赖dateOfNextDay的类型为DateTime，而不是NextDayDateFactoryBean，也就是说FactoryBean类型的bean定义，通过正常id引用，容器返回的时FactoryBean所生产的对象类型，而非其本身。当然如果一定要取得FactoryBean本身的话，可以通过bean定义的id之前加前缀“&amp;”来达到目的。</strong></p><h2 id="方法注入以及方法替换"><a href="#方法注入以及方法替换" class="headerlink" title="方法注入以及方法替换"></a>方法注入以及方法替换</h2><p>在引出标题内容之前，需要先提一下有关bean的scope的prototype属性的陷阱，我们知道，拥有prototype类型scope的bean，在请求方法每次向容器请求该类型对象的时候，容器都会返回一个全新的该对象实例，下面看看这个情况：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MockNewsPersister</span> <span class="keyword">implements</span> <span class="title">IFXNewsPersister</span> </span>&#123;  </span><br><span class="line"><span class="keyword">private</span> FXNewsBean newsBean;    </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">persistNews</span><span class="params">(FXNewsBean bean)</span> </span>&#123;   </span><br><span class="line">persistNewes();  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">persistNews</span><span class="params">()</span>  </span>&#123;   </span><br><span class="line">System.out.println(<span class="string">"persist bean:"</span>+getNewsBean());  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="function"><span class="keyword">public</span> FXNewsBean <span class="title">getNewsBean</span><span class="params">()</span> </span>&#123;  </span><br><span class="line"><span class="keyword">return</span> newsBean;  </span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setNewsBean</span><span class="params">(FXNewsBean newsBean)</span> </span>&#123;   </span><br><span class="line"><span class="keyword">this</span>.newsBean = newsBean;  </span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>配置为：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"newsBean"</span> <span class="attr">class</span>=<span class="string">"..domain.FXNewsBean"</span> <span class="attr">singleton</span>=<span class="string">"false"</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span> </span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"mockPersister"</span> <span class="attr">class</span>=<span class="string">"..impl.MockNewsPersister"</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"newsBean"</span>&gt;</span>   </span><br><span class="line"><span class="tag">&lt;<span class="name">ref</span> <span class="attr">bean</span>=<span class="string">"newsBean"</span>/&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>当我们多次调用MockNewsPersister的persistNews时，看看结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">BeanFactory container = <span class="keyword">new</span> XmlBeanFactory(<span class="keyword">new</span> ClassPathResource(<span class="string">".."</span>)); </span><br><span class="line">MockNewsPersister persister = (MockNewsPersister)container.getBean(<span class="string">"mockPersister"</span>); </span><br><span class="line">persister.persistNews(); persister.persistNews(); </span><br><span class="line"></span><br><span class="line">输出： </span><br><span class="line">persist bean:..domain.FXNewsBean@<span class="number">1662</span>dc8 </span><br><span class="line">persist bean:..domain.FXNewsBean@<span class="number">1662</span>dc8</span><br></pre></td></tr></table></figure><p>从输出看对象实例是相同的，而这与我们的初衷时相悖的。问题实际上不出在FXNewsBean的scope类型是否是prototype的，而是出在实例的取得方式上面。<strong>虽然FXNewsBean拥有prototype类型的scope，但当容器将一个FXNewsBean的实例注入MockNewsPersister之后，MockNewsPersister就会一直持有这个FXNewsBean实例的引用。虽然每次输出都调用了getNewBean()方法并返回一个FXNewsBean的实例，但实际上每次返回的都是MockNewsPersister持有的容器第一次注入的实例。这就是问题之所在</strong>。</p><p><strong>换句话说，第一个实例注入后，MockNewsPersister再也没有重新想容器申请新的实例，所以容器也不会重新为其注入新的FXNewsBean类型的实例。</strong></p><p>下面就是介绍解决这个问题的方法了。</p><h3 id="方法注入"><a href="#方法注入" class="headerlink" title="方法注入"></a>方法注入</h3><p><strong>若要使用方法注入的方式，该方法必须能够被子类实现或者覆写，因为容器会为我们要进行方法注入的对象使用Cglib动态生成一个子类实现，从而代替当前对象，</strong>既然我们的getNewsBean()方法已经满足以上方法声明要求，就只需要正确配置该类了：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"newsBean"</span> <span class="attr">class</span>=<span class="string">"..domain.FXNewsBean"</span> <span class="attr">singleton</span>=<span class="string">"false"</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span> </span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"mockPersister"</span> <span class="attr">class</span>=<span class="string">"..impl.MockNewsPersister"</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">lookup-method</span> <span class="attr">name</span>=<span class="string">"getNewsBean"</span> <span class="attr">bean</span>=<span class="string">"newsBean"</span>/&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>通过&lt;lookup-method&gt;的name属性指定需要注入的方法名，bean属性指定需要注入的对象，当getNewsBean方法被调用的时候，容器可以每次返回一个新的FXNewsBean类型的实例。所以这个时候再次检查执行结果，输出的实例引用就是不同的了。</strong></p><h3 id="殊途同归"><a href="#殊途同归" class="headerlink" title="殊途同归"></a>殊途同归</h3><p>除了使用方法注入来达到“每次调用都让容器返回新的对象实例”的目的，还可以使用其他方式达到相同的目的：</p><ul><li><strong>使用BeanFactoryAware</strong>：我们知道，即使没有方法注入，只要在实现getNewsBean()方法的时候，能够保证每次调用BeanFactory的getBean(“newsBean”)，就同样可以每次都取得新的FXNewsBean对象实例。BeanFactoryAware接口就可以帮我们完成这一步，其定义如下：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BeanFactoryAware</span> </span>&#123;   </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setBeanFactory</span><span class="params">(BeanFactory beanFactory)</span> <span class="keyword">throws</span> BeansException</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>实现BeanFactoryAware接口和配置的代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MockNewsPersister</span> <span class="keyword">implements</span> <span class="title">IFXNewsPersister</span>,<span class="title">BeanFactoryAware</span> </span>&#123;  </span><br><span class="line"><span class="keyword">private</span> BeanFactory beanFactory;    </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBeanFactory</span><span class="params">(BeanFactory bf)</span> <span class="keyword">throws</span> BeansException </span>&#123;   </span><br><span class="line"><span class="keyword">this</span>.beanFactory = bf;  </span><br><span class="line">&#125;   </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">persistNews</span><span class="params">(FXNewsBean bean)</span> </span>&#123;   </span><br><span class="line">persistNews();  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">persistNews</span><span class="params">()</span> </span>&#123;   </span><br><span class="line">System.out.println(<span class="string">"persist bean:"</span>+getNewsBean());  </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> FXNewsBean <span class="title">getNewsBean</span><span class="params">()</span> </span>&#123;   </span><br><span class="line"><span class="keyword">return</span> beanFactory.getBean(<span class="string">"newsBean"</span>);</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"newsBean"</span> <span class="attr">class</span>=<span class="string">"..domain.FXNewsBean"</span> <span class="attr">singleton</span>=<span class="string">"false"</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span> </span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"mockPersister"</span> <span class="attr">class</span>=<span class="string">"..impl.MockNewsPersister"</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li><strong>使用ObjectFatoryCreatingFatoryBean</strong>：实际上ObjectFatoryCreatingFatoryBean实现了BeanFactoryAware接口，它返回的ObjectFactory实例这是特定于与Spring容器进行交互的一个实现而已。<strong>使用它的好处就是，隔离了客户端对象对BeanFactory的直接引用。</strong><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MockNewsPersister</span> <span class="keyword">implements</span> <span class="title">IFXNewsPersister</span> </span>&#123;  </span><br><span class="line"><span class="keyword">private</span> ObjectFactory newsBeanFactory;     </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">persistNews</span><span class="params">(FXNewsBean bean)</span> </span>&#123;   </span><br><span class="line">persistNews();  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">persistNews</span><span class="params">()</span>  </span>&#123;   </span><br><span class="line">System.out.println(<span class="string">"persist bean:"</span>+getNewsBean());  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="function"><span class="keyword">public</span> FXNewsBean <span class="title">getNewsBean</span><span class="params">()</span> </span>&#123;   </span><br><span class="line"><span class="keyword">return</span> newsBeanFactory.getObject();  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setNewsBeanFactory</span><span class="params">(ObjectFactory newsBeanFactory)</span> </span>&#123;   </span><br><span class="line"><span class="keyword">this</span>.newsBeanFactory = newsBeanFactory;  </span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"newsBean"</span> <span class="attr">class</span>=<span class="string">"..domain.FXNewsBean"</span> <span class="attr">singleton</span>=<span class="string">"false"</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span> </span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"newsBeanFactory"</span> <span class="attr">class</span>=<span class="string">"org.springframework.beans.factory.config.ObjectFactoryCreatingFactoryBean"</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"targetBeanName"</span>&gt;</span>   </span><br><span class="line"><span class="tag">&lt;<span class="name">idref</span> <span class="attr">bean</span>=<span class="string">"newsBean"</span>/&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span> </span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"mockPersister"</span> <span class="attr">class</span>=<span class="string">"..impl.MockNewsPersister"</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"newsBeanFactory"</span>&gt;</span>   </span><br><span class="line"><span class="tag">&lt;<span class="name">ref</span> <span class="attr">bean</span>=<span class="string">"newsBeanFactory"</span>/&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="方法替换"><a href="#方法替换" class="headerlink" title="方法替换"></a>方法替换</h3><p>基本上可以认为，方法替换可以帮助我们实现简单的方法拦截功能。假设某天我看FXNewsProvider不爽，想替换掉它的getAndPersistNews方法默认逻辑，这是我就可以用方法替换将它的原有逻辑给替换掉。</p><p>替换的方法就是实现一个叫做MethodReplacer接口，简单的实现例子如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FXNewsProviderMethodReplacer</span> <span class="keyword">implements</span> <span class="title">MethodReplacer</span> </span>&#123; </span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">transient</span> Log logger = LogFactory.getLog(FXNewsProviderMethodReplacer.class);    </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">reimplement</span><span class="params">(Object target, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;   </span><br><span class="line">logger.info(<span class="string">"before executing method["</span>+method.getName()+ <span class="string">"] on Object["</span>+target.getClass().getName()+<span class="string">"]."</span>);      </span><br><span class="line">System.out.println(<span class="string">"sorry,We will do nothing this time."</span>);    </span><br><span class="line">logger.info(<span class="string">"end of executing method["</span>+method.getName()+ <span class="string">"] on Object["</span>+target.getClass().getName()+<span class="string">"]."</span>);   </span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;   </span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来把它配置到xml文件中就可以了：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"djNewsProvider"</span> <span class="attr">class</span>=<span class="string">"..FXNewsProvider"</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">"0"</span>&gt;</span>   </span><br><span class="line"><span class="tag">&lt;<span class="name">ref</span> <span class="attr">bean</span>=<span class="string">"djNewsListener"</span>/&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">"1"</span>&gt;</span>   </span><br><span class="line"><span class="tag">&lt;<span class="name">ref</span> <span class="attr">bean</span>=<span class="string">"djNewsPersister"</span>/&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span>  </span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">replaced-method</span> <span class="attr">name</span>=<span class="string">"getAndPersistNews"</span> <span class="attr">replacer</span>=<span class="string">"providerReplacer"</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">replaced-method</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span> </span><br><span class="line"> </span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"providerReplacer"</span> <span class="attr">class</span>=<span class="string">"..FXNewsProviderMethodReplacer"</span>&gt;</span> <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><h1 id="容器加载过程"><a href="#容器加载过程" class="headerlink" title="容器加载过程"></a>容器加载过程</h1><p>先看一张IoC容器的工作框图：<img src="/posts/37871/TIM%E6%88%AA%E5%9B%BE20191018205518.png" alt></p><h2 id="两大阶段"><a href="#两大阶段" class="headerlink" title="两大阶段"></a>两大阶段</h2><p>IoC容器所起的作用就如上图所展示的那样，<strong>他会以某种方式加载Configuration MetaData（通常为XML配置文件），然后根据这些信息绑定整个系统对象，最终组装成一个可用的基于轻量级容器的应用系统。</strong></p><p>Spring的IoC容器实现以上功能的过程，基本上分为两个阶段：<strong>容器启动阶段</strong>和<strong>Bean的实例化阶段</strong>。<br><img src="/posts/37871/TIM%E6%88%AA%E5%9B%BE20191018205833.png" alt></p><h3 id="容器启动阶段"><a href="#容器启动阶段" class="headerlink" title="容器启动阶段"></a>容器启动阶段</h3><p><strong>容器启动伊始，首先会通过某种途径加载Configuration MetaData。除了代码方式比较直接，大部分情况下都会依赖于工具类BeanDefinitionReader对加载的配置文件进行解析和分析，并将分析后的信息编组为相应的BeanDefinition，最后把这些保存了bean定义必要信息的BeanDefinition，注册到相应的BeanDefinitionRegistry，</strong>这样启动阶段就完成了。<br><img src="/posts/37871/TIM%E6%88%AA%E5%9B%BE20191018210226.png" alt></p><h3 id="Bean实例化阶段"><a href="#Bean实例化阶段" class="headerlink" title="Bean实例化阶段"></a>Bean实例化阶段</h3><p><strong>该阶段，容器会首先检查所请求的对象之前是否已经实例化。如果没有，则会根据注册的BeanDefinition所提供的信息实例化被请求对象，并为其注入依赖。如果该对象实现了某些回调接口，也会根据回调接口的要求来装配它。当该对象装配完毕后，容器会立即将其返回请求方使用。</strong></p><h2 id="插手两大阶段"><a href="#插手两大阶段" class="headerlink" title="插手两大阶段"></a>插手两大阶段</h2><p><strong>Spring提供了一种叫做BeanFactoryPostProcessor的容器扩展机制，该机制允许我们在容器实例化相应对象之前，对注册到容器的BeanDefinition所保存的信息做相应的修改。这就相当于在容器第一阶段结束之后，第二阶段开始之前，加入一道工序，让我们对最终的BeanDefinition做一些额外的操作，</strong>比如修改其中bean定义的某些属性，为bean定义增加其他信息等。</p><p>如果自定义实现BeanFactoryPostProcessor，通常实现接口BeanFactoryPostProcessor就可以了，如果有多个自定义实现的类，则实现Order接口来规定它们的顺序。</p><p>但是Spring为我们提供了三种常用的已经实现好的BeanFactoryPostProcessor实现类，它们分别是 PropertyPlaceholderConfigurer、PropertyOverrideConfigurer和CustomEditorConfigure。在介绍这三种实现类之前，先需要了解它们的配置方法是什么，很简单，只需要在XML配置文件中加入以下代码即可：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">... </span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.springframework.beans.factory.config.PropertyPlaceholderConfigurer"</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"locations"</span>&gt;</span>    </span><br><span class="line"><span class="tag">&lt;<span class="name">list</span>&gt;</span>     </span><br><span class="line"><span class="tag">&lt;<span class="name">value</span>&gt;</span>conf/jdbc.properties<span class="tag">&lt;/<span class="name">value</span>&gt;</span>     </span><br><span class="line"><span class="tag">&lt;<span class="name">value</span>&gt;</span>conf/mail.properties<span class="tag">&lt;/<span class="name">value</span>&gt;</span>    </span><br><span class="line"><span class="tag">&lt;/<span class="name">list</span>&gt;</span>   </span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span>   </span><br><span class="line">... </span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="PropertyPlaceholderConfigurer"><a href="#PropertyPlaceholderConfigurer" class="headerlink" title="PropertyPlaceholderConfigurer"></a>PropertyPlaceholderConfigurer</h3><p>通常情况下，对于MySQL数据库或者Redis数据库之类的配置，为了不将这些系统管理信息相关的信息与业务对象相关的信息混杂到XML文件中，会单独把这些信息配置到一个.properties文件中。<strong>PropertyPlaceholderConfigurer允许我们在XML配置文件中使用占位符，并将这些占位符所代表的资源单独配置到见简单的properties文件中来加载，</strong>例如最常见的：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"dataSource"</span> <span class="attr">class</span>=<span class="string">"org.apache.commons.dbcp.BasicDataSource"</span> <span class="attr">destroy-method</span>=<span class="string">"close"</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"url"</span>&gt;</span>   </span><br><span class="line"><span class="tag">&lt;<span class="name">value</span>&gt;</span>$&#123;jdbc.url&#125;<span class="tag">&lt;/<span class="name">value</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"driverClassName"</span>&gt;</span>   </span><br><span class="line"><span class="tag">&lt;<span class="name">value</span>&gt;</span>$&#123;jdbc.driver&#125;<span class="tag">&lt;/<span class="name">value</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"username"</span>&gt;</span>   </span><br><span class="line"><span class="tag">&lt;<span class="name">value</span>&gt;</span>$&#123;jdbc.username&#125;<span class="tag">&lt;/<span class="name">value</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"password"</span>&gt;</span>   </span><br><span class="line"><span class="tag">&lt;<span class="name">value</span>&gt;</span>$&#123;jdbc.password&#125;<span class="tag">&lt;/<span class="name">value</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"maxActive"</span>&gt;</span>   </span><br><span class="line"><span class="tag">&lt;<span class="name">value</span>&gt;</span>100<span class="tag">&lt;/<span class="name">value</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span> </span><br><span class="line">...</span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>对应的properties文件内容则为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">jdbc.url=jdbc:mysql://server/MAIN?useUnicode=true&amp;characterEncoding=ms932&amp;failOverReadOnly=false&amp;roundRobinLoadBalance=true </span><br><span class="line">jdbc.driver=com.mysql.jdbc.Driver </span><br><span class="line">jdbc.username=your username</span><br><span class="line">jdbc.password=your password</span><br></pre></td></tr></table></figure><p><strong>基本就如上面所说的那样，当BeanFactory完成第一阶段加载完成所有配置信息之后，BeanFactory中保存的对象的属性信息还只是以占位符的形式存在，如”${jdbc.url}”。当PropertyPlaceholderConfigurer被应用时，他会使用properties配置文件中的配置信息来替换相应的BeanDefintion中占位符所表示的属性值。</strong>PropertyPlaceholderConfigurer不单会从其配置的properties文件中加载配置项，同时还会检查Java的System类中的Properties。</p><h3 id="PropertyOverrideConfigurer"><a href="#PropertyOverrideConfigurer" class="headerlink" title="PropertyOverrideConfigurer"></a>PropertyOverrideConfigurer</h3><p><strong>PropertyOverrideConfigurer的作用就是，通过它可以对容器中篇日志的任何你想处理的bean定义的property信息进行覆盖替换。</strong>比如之前的dataSource定义中，maxActive的值为100，如果我们觉得不合适，那么可以通过PropertyOverrideConfigurer将其覆盖为200：<code>dataSource.maxActive=200</code>。</p><p>如果要对容器中的某些bean定义的property信息进行覆盖，我们需要按照如下规则提供一个PropertyOverrideConfigurer使用的配置文件：<code>beanName.propertyName=value</code>。然后通过以下方法将PropertyOverrideConfigurer注册到容器即可：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.springframework.beans.factory.config.PropertyOverrideConfigurer"</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"location"</span> <span class="attr">value</span>=<span class="string">"pool-adjustment.properties"</span>/&gt;</span> </span><br><span class="line"><span class="tag">&lt; /<span class="attr">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>当容器中配置的多个PropertyOverrideConfigurer对同一个bean定义的同一个property值进行处理的时候，最后一个会生效。</strong></p><h3 id="CustomEditorConfigure"><a href="#CustomEditorConfigure" class="headerlink" title="CustomEditorConfigure"></a>CustomEditorConfigure</h3><p><strong>因为我们配置XML文件都是String类型，即容器从XML格式的文件中读取的都是字符串形式，最终应用程序却是由各种类型的对象所构成的。要想完成这种由字符串到具体对象的转换，都需要这种转换规则相关的信息，而CustomEditorConfigure就是帮我们传达类似信息的。</strong></p><h2 id="bean的生命周期"><a href="#bean的生命周期" class="headerlink" title="bean的生命周期"></a>bean的生命周期</h2><p>接下来就是第二大阶段了，即bean实例化阶段的实现逻辑。这里还需要再提一次BeanFactory和ApplicationContext对于bean加载的区别：</p><ul><li><strong>BeanFactory对象实例化默认采用延迟初始化</strong>。</li><li><strong>ApplicationContext启动之后会实例化所有的bean定义</strong>。</li></ul><p>当调用getBean()方法时，内部发现该bean定义之前还没有被实例化之后，会通过createBean()方法来进行具体的对象实例化，实例化过程如图所示：<img src="/posts/37871/TIM%E6%88%AA%E5%9B%BE20191018215127.png" alt>下面就来详细看看其中的步骤。</p><h3 id="Bean的实例化与BeanWrapper"><a href="#Bean的实例化与BeanWrapper" class="headerlink" title="Bean的实例化与BeanWrapper"></a>Bean的实例化与BeanWrapper</h3><p>容器在内部实现的时候，采用“策略模式”来决定采用何种方式初始化bean实例。通常，可以通过反射或者CGLIB动态字节码生成来初始化相应的bean实例或者动态生成其子类。</p><h4 id="第一步"><a href="#第一步" class="headerlink" title="第一步"></a>第一步</h4><p><strong>容器只要根据相应的bean定义的BeanDefintion取得实例化信息，结合CglibSubclassingInstantiationStrategy通过反射的方式，以及不同的bean定义类型，就可以返回实例化完成的对象实例。但是，返回的不是构造完成的对象实例，而是以BeanWrapper对构造完成的对象实例进行包括，返回相应的BeanWrapper实例。</strong></p><h4 id="第二步"><a href="#第二步" class="headerlink" title="第二步"></a>第二步</h4><p><strong>第一步结束后返回BeanWrapper实例而不是原先的对象实例，就是为了第二步“设置对象属性”。</strong>使用BeanWrapper对bean实例操作很方便，可以免去直接使用Java反射API操作对象实力的反锁，看一段代码就知道Spring容器内部时如何设置对象属性的了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Object provider = Class.forName(<span class="string">"package.name.FXNewsProvider"</span>).newInstance(); </span><br><span class="line">Object listener = Class.forName(<span class="string">"package.name.DowJonesNewsListener"</span>).newInstance(); </span><br><span class="line">Object persister = Class.forName(<span class="string">"package.name.DowJonesNewsPersister"</span>).newInstance();  </span><br><span class="line"></span><br><span class="line">BeanWrapper newsProvider = <span class="keyword">new</span> BeanWrapperImpl(provider); </span><br><span class="line">newsProvider.setPropertyValue(<span class="string">"newsListener"</span>, listener); </span><br><span class="line">newsProvider.setPropertyValue(<span class="string">"newPersistener"</span>, persister);</span><br></pre></td></tr></table></figure><h3 id="各色的Aware接口"><a href="#各色的Aware接口" class="headerlink" title="各色的Aware接口"></a>各色的Aware接口</h3><p><strong>当对象实例化完成后并且相关属性以及依赖设置完成之后，Spring容器会检查当前对象实例是否实现了一系列的以Aware命名结尾的接口定义，如果是，则将这些Aware接口定义中规定的依赖注入给当前对象实例。</strong>下面介绍几个重要的Aware接口：</p><ul><li><strong>ApplicationContextAware</strong>: 获得ApplicationContext对象,可以用来获取所有Bean definition的名字。</li><li><strong>BeanFactoryAware</strong>:获得BeanFactory对象，可以用来检测Bean的作用域。</li><li><strong>BeanNameAware</strong>:获得Bean在配置文件中定义的名字。</li><li><strong>ResourceLoaderAware</strong>:获得ResourceLoader对象，可以获得classpath中某个文件。</li><li><strong>ServletContextAware</strong>:在一个MVC应用中可以获取ServletContext对象，可以读取context中的参数。</li><li><strong>ServletConfigAware</strong>： 在一个MVC应用中可以获取ServletConfig对象，可以读取config中的参数。</li></ul><h3 id="BeanPostProcessor"><a href="#BeanPostProcessor" class="headerlink" title="BeanPostProcessor"></a>BeanPostProcessor</h3><p>BeanPostProcessor会处理容器内所有符合条件的实例化后的对象实例，该接口声明了两个方法，分别在不同的时机执行：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BeanPostProcessor</span>  </span>&#123;  </span><br><span class="line"><span class="function">Object <span class="title">postProcessBeforeInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException</span>; </span><br><span class="line"><span class="function">Object <span class="title">postProcessAfterInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>postProcessBeforeInitialization()方法是上图中BeanPostProcessor前置处理这一步将会执行的方法，postProcessAfterInitialization()则是对应图中BeanPostProcessor后置处理那一步将会执行的方法。</strong>BeanPostProcessor的两个方法中都传入了原来的对象实例的引用，这位我们操作扩展容器的对象实例化过程中的行为提供了极大的便利。</p><h3 id="InitializingBean和init-method"><a href="#InitializingBean和init-method" class="headerlink" title="InitializingBean和init-method"></a>InitializingBean和init-method</h3><p>InitializingBean是容器内部广泛使用的一个对象生命周期表示接口，其定义如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">InitializingBean</span> </span>&#123;   </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">afterPropertiesSet</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>其作用在于，在对象实例化过程调用过“BeanPostProcessor”的前置处理之后，会接着检测当前对象是否实现了InitializingBean接口，如果是，则回到调用其afterPropertiesSet()方法进一步调整对象实例的状态。</strong></p><p><strong>通过init-method，系统中业务对象的自定义初始化操作可以以任何方式命名。而不再受制于InitializingBean的afterPropertiesSet()。</strong>在自己定义init方法后，只需要在XML文件中简单配置一下就好了：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"tradeDateCalculator"</span> <span class="attr">class</span>=<span class="string">"FXTradeDateCalculator"</span> <span class="attr">init-method</span>=<span class="string">"setupHolidays"</span> &gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">constructor-arg</span>&gt;</span>    </span><br><span class="line"><span class="tag">&lt;<span class="name">ref</span> <span class="attr">bean</span>=<span class="string">"sqlMapClientTemplate"</span>/&gt;</span>   </span><br><span class="line"><span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"sqlMapClientTemplate"</span> <span class="attr">class</span>=<span class="string">"org.springframework.orm.ibatis.SqlMapClientTemplate"</span>&gt;</span>   </span><br><span class="line">...  </span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span>    </span><br><span class="line">... </span><br><span class="line"><span class="tag">&lt; /<span class="attr">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这样FXTradeDateCalculator类中的setupHolidays方法就是会在该阶段执行的方法了。</p><h3 id="DisposableBean与destroy-method"><a href="#DisposableBean与destroy-method" class="headerlink" title="DisposableBean与destroy-method"></a>DisposableBean与destroy-method</h3><p><strong>当所有的一切，该设置的设置，该注入的注入，该调用的调用之后，容器将检查singleton类型的bean实例，看其是否实现了DisposableBean接口。或者其对应的bean定义是否通过&lt;bean&gt;的destroy-method属性制定了自定义的对象销毁方法，如果是，就会为该实例注册一个用于对象销毁的回调，以及在这些singleton类型的对象实例销毁之前，执行销毁逻辑。</strong></p><p><strong>不过这些自定义的对象销毁逻辑，在对象实例初始化完成并注册了相关的回调方法之后，并不会马上执行。回调方法注册后，在使用完成后，只有在执行回调方法之后，才会执行销毁操作。</strong></p><p>对于BeanFactory注册回调方法的方式为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">((ConfigurableListableBeanFactory)container).destroySingletons();</span><br></pre></td></tr></table></figure><p>对于ApplicationContext注册回调方法的方式为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">((AbstractApplicationContext)container).registerShutdownHook();</span><br></pre></td></tr></table></figure><p>至此为止，bean就算走完了它在容器中“光荣”的一生。</p>]]></content>
    
    <summary type="html">
    
      根据之前说过的，Spring的IoC容器是一个IoC Service Provider，但是我们只是知道了IoC Service Provider是什么，还不是知道其“庐山真面目”中的“容器”到底是什么，这里就介绍IoC容器之中一BeanFactory。
    
    </summary>
    
      <category term="Spring" scheme="http://yoursite.com/categories/Spring/"/>
    
    
  </entry>
  
</feed>
