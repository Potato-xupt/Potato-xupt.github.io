<!DOCTYPE html>












  


<html class="theme-next pisces use-motion" lang="zh-CN">
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">






















<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css?v=4.7.0">

<link rel="stylesheet" href="/css/main.css?v=7.2.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/favicon.ico?v=7.2.0">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.ico?v=7.2.0">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon.ico?v=7.2.0">


  <link rel="mask-icon" href="/images/logo.svg?v=7.2.0" color="#222">







<script id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '7.2.0',
    sidebar: {"position":"left","width":250,"display":"post","offset":12,"onmobile":true,"dimmer":true},
    back2top: true,
    back2top_sidebar: false,
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta name="description" content="索引（也叫做“键（key）”）是存储引擎用于快速找到记录的一种数据结构。这里介绍了索引的基础知识、基本功能和优化，还讨论索引其它一些方面有用的属性。">
<meta property="og:type" content="article">
<meta property="og:title" content="创建高性能索引">
<meta property="og:url" content="http://yoursite.com/posts/28327/index.html">
<meta property="og:site_name" content="Potato Blog">
<meta property="og:description" content="索引（也叫做“键（key）”）是存储引擎用于快速找到记录的一种数据结构。这里介绍了索引的基础知识、基本功能和优化，还讨论索引其它一些方面有用的属性。">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="http://yoursite.com/posts/28327/B-Tree%E7%BB%93%E6%9E%84.png">
<meta property="og:image" content="http://yoursite.com/posts/28327/B-Tree%E8%A1%A8%E4%BE%8B%E5%AD%90.png">
<meta property="og:image" content="http://yoursite.com/posts/28327/hashdata.png">
<meta property="og:image" content="http://yoursite.com/posts/28327/hashdata2.png">
<meta property="og:image" content="http://yoursite.com/posts/28327/%E8%81%9A%E7%B0%87%E7%B4%A2%E5%BC%95.png">
<meta property="og:image" content="http://yoursite.com/posts/28327/MyISAM%E8%81%9A%E7%B0%87%E7%B4%A2%E5%BC%95%E6%95%B0%E6%8D%AE%E5%88%86%E5%B8%83.png">
<meta property="og:image" content="http://yoursite.com/posts/28327/TIM%E6%88%AA%E5%9B%BE20190923193723.png">
<meta property="og:image" content="http://yoursite.com/posts/28327/InnoDB%E8%81%9A%E7%B0%87%E7%B4%A2%E5%BC%95%E4%B8%BB%E9%94%AE%E5%88%86%E5%B8%83.png">
<meta property="og:image" content="http://yoursite.com/posts/28327/InnoDB%E4%BA%8C%E7%BA%A7%E7%B4%A2%E5%BC%95%E5%88%86%E5%B8%83.png">
<meta property="og:image" content="http://yoursite.com/posts/28327/%E8%81%9A%E7%B0%87%E9%9D%9E%E8%81%9A%E7%B0%87%E5%AF%B9%E6%AF%94.png">
<meta property="og:image" content="http://yoursite.com/posts/28327/InnoDB%E6%8F%92%E5%85%A5.png">
<meta property="og:image" content="http://yoursite.com/posts/28327/%E5%90%91%E8%81%9A%E7%B0%87%E7%B4%A2%E5%BC%95%E6%8F%92%E5%85%A5%E9%A1%BA%E5%BA%8F%E7%9A%84%E7%B4%A2%E5%BC%95%E5%80%BC.png">
<meta property="og:image" content="http://yoursite.com/posts/28327/%E5%90%91%E8%81%9A%E7%B0%87%E7%B4%A2%E5%BC%95%E6%8F%92%E5%85%A5%E6%97%A0%E5%BA%8F%E5%80%BC.png">
<meta property="og:image" content="http://yoursite.com/posts/28327/beforesql.png">
<meta property="og:image" content="http://yoursite.com/posts/28327/aftersql.png">
<meta property="og:image" content="http://yoursite.com/posts/28327/%E8%A6%86%E7%9B%96%E6%B5%8B%E8%AF%95.png">
<meta property="og:updated_time" content="2019-09-26T11:54:57.160Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="创建高性能索引">
<meta name="twitter:description" content="索引（也叫做“键（key）”）是存储引擎用于快速找到记录的一种数据结构。这里介绍了索引的基础知识、基本功能和优化，还讨论索引其它一些方面有用的属性。">
<meta name="twitter:image" content="http://yoursite.com/posts/28327/B-Tree%E7%BB%93%E6%9E%84.png">



  <link rel="alternate" href="/atom.xml" title="Potato Blog" type="application/atom+xml">



  
  
  <link rel="canonical" href="http://yoursite.com/posts/28327/">



<script id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>创建高性能索引 | Potato Blog</title>
  












  <noscript>
  <style>
  .use-motion .motion-element,
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-title { opacity: initial; }

  .use-motion .logo,
  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Potato Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
      
        <p class="site-subtitle">李土豆的Blog</p>
      
    
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home">

    
    
      
    

    
      
    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br>首页</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-categories">

    
    
      
    

    
      
    

    <a href="/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i> <br>分类<span class="badge">9</span></a>

  </li>

      
      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br>搜索</a>
        </li>
      
    </ul>
  

  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off" placeholder="搜索..." spellcheck="false" type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



  



</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
            

          
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
    
  
  

  

  <article class="post post-type-normal true" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/posts/28327/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Potato">
      <meta itemprop="description" content="Although the road is endless and faraway, I still want to pursue the truth in the world.">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Potato Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">创建高性能索引

              
            
          </h1>
        

        <div class="post-meta">

          
          
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-09-18 19:58:01" itemprop="dateCreated datePublished" datetime="2019-09-18T19:58:01+08:00">2019-09-18</time>
            </span>
          

          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-09-26 19:54:57" itemprop="dateModified" datetime="2019-09-26T19:54:57+08:00">2019-09-26</time>
              </span>
            
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/MySQL数据库/" itemprop="url" rel="index"><span itemprop="name">MySQL数据库</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          
		  
		  

          <br>
          

          

          
            <div class="post-description">索引（也叫做“键（key）”）是存储引擎用于快速找到记录的一种数据结构。这里介绍了索引的基础知识、基本功能和优化，还讨论索引其它一些方面有用的属性。</div>
          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>索引（也叫做“键（key）”）是存储引擎用于快速找到记录的一种数据结构。索引对于良好的性能非常关键，尤其是当表中的数据量越来越大时，索引对性能的影响越发重要。其外索引优化也很重要，索引优化应该是对查询性能优化最有效的手段了，索引能轻易将查询性能提高几个数量级。</p>
<h1 id="索引基础"><a href="#索引基础" class="headerlink" title="索引基础"></a>索引基础</h1><p>要理解MySQL中索引时如何工作的，最简单的方法就是去看看一本书的“索引”部分：如果想在一本书中找到某个特定主题，一般会先看书的“索引”，找到对应的页码。</p>
<p>在MySQL中，存储引擎用类似的方法使用索引，<strong>其先在索引中找到对应值，然后根据匹配的索引记录找到对应的数据行。也就是说，MySQL先在索引上按值进行查找，然后返回所有包含该值的数据行。</strong></p>
<p>索引可以包含一个或多个列的值。如果索引包含多个列，那么列的顺序也十分重要，因为<strong>MySQL只能高效的使用索引的最左前缀列。</strong></p>
<h2 id="索引的类型"><a href="#索引的类型" class="headerlink" title="索引的类型"></a>索引的类型</h2><p>在MySQL中，<strong>索引是在存储引擎层</strong>而不是服务层<strong>实现的</strong>。索引不同存储引擎的索引的工作方式不一样，也不是所有的存储引擎都支持所有类型的索引。下面是MySQL支持的索引类型，以及它们的优点和缺点。</p>
<h3 id="B-Tree索引"><a href="#B-Tree索引" class="headerlink" title="B-Tree索引"></a>B-Tree索引</h3><p>如果没有特别说明索引类型，默认是B-Tree索引，它使用B-Tree数据结构来存储数据，大多数MySQL引擎都支持这种索引（Archive除外）。不过底层的存储引擎也可能使用不同的数据结构，例如<strong>InnoDB则使用的是B+Tree。</strong></p>
<p>存储引擎以不用的方式使用B-Tree索引，性能也各有不同，各有优势。例如：<strong>MyISAM使用前缀压缩技术使得索引更小，但InnoDB则按照原数据格式进行存储。再如MyISAM索引通过数据的物理位置引用被索引的行，而InnoDB则根据主键引用被索引的行。</strong></p>
<p><strong>B-Tree通常意味着所有的值都是按顺序存储的，并且每一个叶子页到根的距离相同。</strong>下图展示B-Tree索引的抽象表示：<br><img src="/posts/28327/B-Tree%E7%BB%93%E6%9E%84.png" alt></p>
<p><strong>B-Tree索引能加快访问数据的速度，因为存储引擎不再需要进行全表扫描来获取需要的数据，取而代之的是从索引的根节点开始进行搜索。根节点的槽中存放了指向子节点的指针，存储引擎根据这些指针向下层查找。通过比较节点页的值和要查找的值可以找到合适的指针进入下层子节点，这些指针实际上定义了子节点中值的上限和下限。最终存储引擎要么是找到对应的值，要么该记录不存在。</strong>叶子节点比较特别，它们的指针指向的是被索引的数据，而不是其他的节点页。</p>
<p><strong>B-Tree对索引列是顺序组织存储的，所以很适合查找范围数据。</strong>例如，在一个基于文本域的索引树上，按字母顺序传递连续的值进行查找是非常合适的，所以像“找出所有以I到K开头的名字”这样的查找效率会非常高。</p>
<p>建立如下表：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">CREATE TABLE <span class="title">people</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">	last_name varchar(<span class="number">50</span>)</span> not <span class="keyword">null</span>,</span></span><br><span class="line"><span class="function">	first_name <span class="title">varchar</span><span class="params">(<span class="number">50</span>)</span> not <span class="keyword">null</span>,</span></span><br><span class="line"><span class="function">	dob date not <span class="keyword">null</span>,</span></span><br><span class="line"><span class="function">	gender <span class="title">enum</span><span class="params">(<span class="string">'m'</span>,<span class="string">'f'</span>)</span> not <span class="keyword">null</span>,</span></span><br><span class="line"><span class="function">	<span class="title">key</span><span class="params">(last_name,first_name,dob)</span></span></span><br><span class="line"><span class="function">)</span>;</span><br></pre></td></tr></table></figure>

<p><img src="/posts/28327/B-Tree%E8%A1%A8%E4%BE%8B%E5%AD%90.png" alt><br><strong>索引对多个值进行排序的依据是CREATE TABLE语句中定义索引时列的顺序。</strong>例如上图中，最后两个条目中，两个人的姓和名都一样，则根据他们的出生日期来排序。</p>
<p>可以使用B-Tree索引的查询类型。<strong>B-Tree索引适用于全键值、键值范围或前缀查询。其中键前缀查找只适用于根据最左前缀的查找。</strong>故所述的索引对如下类型的查询有效：</p>
<ul>
<li><strong>全值匹配</strong>：<strong>全值匹配指的是和索引中的所有列进行匹配。</strong>例如上图中，索引可用于查找姓名为Cuba Allen、同时出生于1960-01-01的人。</li>
<li><strong>匹配最左前缀</strong>：索引可用于查询所有姓为Allen的人，<strong>即只使用索引的第一列。</strong></li>
<li><strong>匹配列前缀</strong>：也可以<strong>只匹配某一列的值的开头部分。</strong>例如可以查找所有以J开头的性的人，这里也只使用了索引的第一列。</li>
<li><strong>匹配范围值</strong>：例如索引可用于查找姓在Allen和Barrymore之间的人，这里也只使用了索引的第一列。</li>
<li><strong>精确匹配某一列并范围匹配另外一列</strong>：例如可以查找所有姓为Allen，并且名字是字母K开头的人。即第一列全匹配，第二列范围匹配。</li>
<li><strong>只访问索引的查询</strong>：B-Tree通常可以支持“只访问索引的查询”，<strong>即查询只需要访问索引，而无须访问数据行。</strong></li>
</ul>
<p>因为索引树中的节点是有序的，所以除了按值查找之外，<strong>索引还可以用于查询中的ORDER BY操作</strong>。一般来说，如果B-Tree可以按照这种方式用于排序。</p>
<p>但是B-Tree索引也有一些限制：</p>
<ul>
<li><strong>如果不是按照索引的最左列开始查找，则无法使用索引。</strong>即最左列不能跳过，例如上面例子中的索引无法用于查找名字为Bill的人，也无法查找某个特定生日的人，因为这两列都不是最左数据列。</li>
<li><strong>不能跳过索引中的列。</strong>也就是说不能查找姓名为Smith并且某个特定日期出生的人。如果不指定名，则MySQL只能使用索引的第一列。</li>
<li><strong>如果查询中有某个列的范围查找，则其右边所有列都无法使用索引优化查找。</strong></li>
</ul>
<p>总而言之这些限制都和索引列的顺序有关。在优化性能的时候，可能需要使用相同的列但顺序不同的索引来满足不同类型的查询需求。</p>
<h3 id="哈希索引"><a href="#哈希索引" class="headerlink" title="哈希索引"></a>哈希索引</h3><p><strong>哈希索引基于哈希表实现，只有精确匹配索引所有列的查询才有效。</strong>对于每一行数据，存储引擎哦都会对所有的索引列计算一个哈希码，哈希码是一个较小的值，并且不同键值的行计算出来的哈希码也不一样。<strong>哈希索引将所有的哈希码存储在索引中，同时在哈希表中保存指向每个数据行的指针。</strong></p>
<p>假设有如下表：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> testhash (  </span><br><span class="line">    fname <span class="built_in">VARCHAR</span>(<span class="number">50</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">    lname <span class="built_in">VARCHAR</span>(<span class="number">50</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">    <span class="keyword">KEY</span> <span class="keyword">USING</span> <span class="keyword">HASH</span>(fname)</span><br><span class="line">)<span class="keyword">ENGINE</span>= <span class="keyword">MEMORY</span>;</span><br></pre></td></tr></table></figure>

<p>表中包含数据：<img src="/posts/28327/hashdata.png" alt><br>假设索引使用假想的哈希函数f()，它返回下面的值（以下为实例数据）：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">f('Arjen') = 2323</span><br><span class="line">f('Baron') = 7437</span><br><span class="line">f('Peter') = 8784</span><br><span class="line">f('Vadim') = 2458</span><br></pre></td></tr></table></figure>

<p>则哈希索引的数据结构如下：<img src="/posts/28327/hashdata2.png" alt><br><strong>注意，每个槽的编号是顺序的，但是数据行不是。</strong></p>
<p>因为索引自身只需存储对应的哈希值，所以索引的结构十分紧凑，这也让哈希索引查找到速度非常快。但是哈希索引也有它的限制：</p>
<ul>
<li><strong>哈希索引只包含哈希值和行指针，而不存储字段值，所以不能使用索引中的值来避免读取行。</strong>不过访问内存中的行的速度很快，所以大部分情况下这一点对性能的影响并不明显。</li>
<li>哈希索引值并不是按照索引值顺序存储的，所以也就<strong>无法用于排序。</strong></li>
<li><strong>哈希索引也不支持部分索引列匹配查找，因为哈希索引始终是使用索引列的全部内存容来计算哈希值的。</strong></li>
<li><strong>哈希索引只支持等值比较查询</strong>，包括=、IN()、&lt;=&gt;，也不支持任何范围查询。</li>
<li>访问哈希索引的数据非常快，除非有很多哈希冲突。当出现哈希冲突的时候，存储引擎会遍历链表中所有的行指针，逐行进行比较查找。</li>
<li>如果哈希冲突很多的话，一些索引维护操作的代价也会很高，冲突越多，代价越高。</li>
</ul>
<p>因为这些限制，哈希索引只适用于某些特定的场合，而一旦适合哈希索引，则它带来的性能提升将非常明显。</p>
<p>InnoDB引擎有一个特殊的功能叫做“<strong>自适应哈希索引</strong>”。当InnoDB注意到某些索引值被使用的非常频繁时，它会在内存中基于B-Tree所以之上再创建一个哈希索引。这是一个完全自动的、内部的行为，用户无法控制或者配置，但是可以关闭。</p>
<p><strong>自定义哈希索引时，记住不要使用SHA1()和MD5()作为哈希函数</strong>，因为这两个函数计算出来的哈希值时非常长的字符出阿奴，会浪费大量空间，比较时也会更慢。使用简单哈希函数导致的冲突在一个可以接受的范围，同时又能提供更好的性能。<strong>自定义哈希函数要返回整数，而不是字符串，一个简单的方法可以使用MD5()函数返回值的一部分来作为哈希函数。</strong></p>
<p><strong>当使用哈希索引进行查找的时候，要避免冲突问题，必须在WHERE条件中带入哈希值和对应列值。</strong>例如<code>SELECT * FROM words WHERE crc = CRC32(&#39;gnu&#39;) AND word = &#39;gnu&#39;;</code>。如果只是统计记录数（不精确的），则可以不带入列值。</p>
<h3 id="其他索引"><a href="#其他索引" class="headerlink" title="其他索引"></a>其他索引</h3><ul>
<li><strong>空间数据索引（R-Tree）</strong>：MyISAM表支持空间索引，可以用作地理数据存储。不同于B-Tree索引，这类索引无须前缀查询。<strong>空间索引会从所有维度来索引数据。查询时，可以有效地使用任意维度来组合查询。</strong></li>
<li><strong>全文索引</strong>：<strong>全文索引是一种特殊类型的索引，它查找的时文本中的关键字，而不是直接比较索引中的值。</strong>全文索引更类似于搜索引擎做的事情。<strong>在相同的列上同时创建全文索引和基于值的B-Tree索引不会有冲突</strong>，全文索引适用于MATCH AGAINST操作，而不是普通的WHERE条件操作。</li>
</ul>
<h1 id="索引的优点"><a href="#索引的优点" class="headerlink" title="索引的优点"></a>索引的优点</h1><p>索引可以让服务器快速地定位到表的指定位置，但这不是索引的唯一作用，因为根据创建索引的数据结构不同，索引也有一些其他的附加作用。</p>
<p>最常见的B-Tree索引，按照顺序存储数据，所以MySQL可以用来做ORDER BY和GROUP BY操作；因为数据是有序的，所以B-Tree也就会将相关的列值都存储在一起；因为索引中存储了实际的列值，所以某些查询只使用索引就能完成全部查询。所以总结下来索引有如下三个优点：</p>
<ul>
<li><strong>索引大大减少了服务器需要描述的数据量</strong></li>
<li><strong>索引可以帮助服务器避免排序和临时表</strong></li>
<li><strong>索引可以将随机I/O变为顺序I/O</strong></li>
</ul>
<p>有一个简单评价一个索引是否适合某个查询的方法叫做“三星系统”：<strong>索引将相关的记录放在一起则获得一星；如果索引中的数据顺序和查找中的排列顺序一致则获得二星；如果索引的列包含了查询中需要的全部列则获得三星。</strong></p>
<h1 id="高性能的索引策略"><a href="#高性能的索引策略" class="headerlink" title="高性能的索引策略"></a>高性能的索引策略</h1><h2 id="独立的列"><a href="#独立的列" class="headerlink" title="独立的列"></a>独立的列</h2><p>如果查询时不当的使用索引，或使得MySQL无法使用已有的索引。<strong>如果查询中的列不是独立的，则MySQL就不会使用索引。“独立的列”是指索引列不能是表达式的一部分，也不能是函数的参数。</strong><br>例如：<code>SELECT actor_id FROM sakila.actor WHERE actor_id+1 = 5;</code>和<code>SELECT ... WHERE TO_DAYS(CURRENT_DATE) - TO_DAYS(data_col) &lt;= 10;</code></p>
<p>所以我们应该养成简化WHERE条件的习惯，<strong>始终将索引列单独放在符号的一侧。</strong></p>
<h2 id="前缀索引和索引选择性"><a href="#前缀索引和索引选择性" class="headerlink" title="前缀索引和索引选择性"></a>前缀索引和索引选择性</h2><p>通常可以索引开始的部分字符，这样可以大大节约索引空间，从而提高索引效率。但是这样也会降低索引的选择性。<strong>索引的选择性是指：不重复的索引值（也称为基数）和数据表的记录总数（#T）的比值，范围从 1/#T 到 1 之间。</strong>索引的选择性越高则查询效率越高，因为选择性高的索引可以让MySQL在查找时过滤掉更多的行，唯一索引的选择性是1，即选择性最好，性能也最好。</p>
<p>对于BLOB、TEXT或者很长的VARCHAR类型的列，必须使用前缀索引，因为MySQL不允许索引这些列的完整长度。</p>
<p>诀窍在于要选择足够长的前缀以保证较高的选择性，同时又不能太长，以便节约空间。</p>
<p>为了决定前缀的合适长度，需要找到最常见的值的列表，然后和最常见的前缀列表进行比较，<strong>适当增加前缀长度，直到这个前缀的选择性接近完整列的选择性。</strong>另外一个方法就是计算完整列的选择性，并使前缀的选择性接近于完整列的选择性，计算方法如下：<code>SELECT COUNT(DISTINCT city)/COUNT(*) FROM city_demo</code>。通常来说，如果前缀的选择性能够接近<strong>0.031</strong>，基本上就可用了。</p>
<p><strong>前缀索引是一种能使索引更小、更快的有效办法，但另一方面也有其缺点：MySQL无法使用前缀索引做ORDER BY和GROUP BY，也无法使用前缀索引做覆盖扫描。</strong></p>
<h2 id="多列索引"><a href="#多列索引" class="headerlink" title="多列索引"></a>多列索引</h2><p>很多人对多列索引的理解一个常见的错误就是：为每个列创建独立的索引，或者按照错误的顺序创建多列索引。在多个列上建立独立的单独索引大部分情况下并不能提高MySQL的查询性能。</p>
<p>MySQL5.0和最新版本引入了一种叫“<strong>索引合并</strong>”的策略，一定程度上可以使用表上的多个单列索引来定位指定的行。这种算法有三个变种：OR条件的联合（union），AND条件的相交，组合前两种情况的联合及相交。</p>
<p><strong>索引合并策略有时候是一种优化的结果，但实际上更多时候说明了表上的索引建的很差。</strong>如果使用EXPLAIN语句中看到有索引合并，应该好好检查一下查询和表的结构，有无优化的余地。</p>
<h2 id="选择合适的索引列顺序"><a href="#选择合适的索引列顺序" class="headerlink" title="选择合适的索引列顺序"></a>选择合适的索引列顺序</h2><p>正确的索引顺序依赖于使用该索引的查询，并且同时需要考虑如何更好地满足排序和分组的需要。</p>
<p>在一个多列的B-Tree索引中，<strong>索引列的顺序意味着索引首先按照最左列进行排序，其次是第二列，等等。所以索引可以按照升序或者降序进行扫描，以满足精确符合列顺序的ORDER BY、GROUP BY和DISTINCT等子句的查询需求。所以多列索引的列顺序至关重要。</strong></p>
<p><strong>对于如何选择索引的列顺序有一个经验法则：将选择性最高的列放在索引最前列。</strong>但不需要考虑排序和分组时，将选择性最高的列放在前面通常是很好的。这时候索引的作用只是用于优化WHERE条件的查找。</p>
<h2 id="聚簇索引"><a href="#聚簇索引" class="headerlink" title="聚簇索引"></a>聚簇索引</h2><p>聚簇索引并不是一种单独的索引类型，而是一种数据存储方式，具体的细节依赖于其实现方式，<strong>InnoDB的聚簇索引实际上在同一个结构中保存了B-Tree索引的数据行。**</strong>当表有聚簇索引时，它的数据行实际上存放在索引的叶子页中。<strong>“聚簇”表示数据行和相邻的键值紧凑的存储在一起。因为无法同时把数据行存放在两个不同的地方，所以</strong>一个表只能有一个聚簇索引。**</p>
<p>下图展示聚簇索引中的记录是如何存放的：<img src="/posts/28327/%E8%81%9A%E7%B0%87%E7%B4%A2%E5%BC%95.png" alt>注意到，叶子页中包含了行的全部数据，但是节点页只包含了索引列。<strong>InnoDB通过主键聚集数据，也就是说上图中的“被索引的列”就是主键列。</strong>如果没有定义主键，InnoDB会选择一个唯一非空索引代替。如果没有这样的索引，InnoDB会隐式定义一个主键来作为聚簇索引。下面讨论一些聚簇索引的优缺点。</p>
<p><strong>优点：</strong></p>
<blockquote>
<ul>
<li><strong>可以把相关的数据保存在一起。</strong></li>
<li><strong>数据访问更快。</strong>聚簇索引将索引和数据保存在同一个B-Tree中，因此从聚簇索引中获取数据通常比在非聚簇索引中查找更快。</li>
<li><strong>使用覆盖索引扫描的查询可以直接使用页节点的主键值。</strong></li>
</ul>
</blockquote>
<p><strong>缺点：</strong></p>
<blockquote>
<ul>
<li><strong>聚簇索引最大限度的提高了I/O密集型应用的性能</strong>，但如果全部数据都放在内存中，那么访问的顺序就没有关系了，因此也就无法体现出什么优势了。</li>
<li><strong>插入速度严重依赖于插入顺序。</strong>按照主键的顺序插入是数据加载到InnoDB表中最快速度的方式；但如果不是按照主键顺序加载数据，那么在加载完成后最好<strong>使用OPTIMIZE TABLE命令重新组织一下表。</strong></li>
<li><strong>更新聚簇索引列的代价很高，因为会强制InnoDB将每个被更新的行移动到新的位置。</strong></li>
<li><strong>基于聚簇索引的表在插入新行，或者主键被更新导致需要移动行的时候，可能面临“页分裂”的问题，页分裂会导致表占用更多的磁盘空间</strong>。当行的主键值要求必须将这一行插入到某个已满的页中时，存储引擎会将该页分裂成两个页面来容纳改行，这就是一次页分裂操作。</li>
<li><strong>聚簇索引可能导致全表扫描变慢，尤其是行比较稀疏，或者由于页分裂导致数据存储不连续的时候。</strong></li>
<li><strong>二级索引（非聚簇索引）可能比想象的要更大，因为在二级索引的叶子节点包含了引用行的主键列。</strong></li>
<li><strong>二级索引访问需要两次索引查找，而不是一次。</strong>导致这个问题的原因在于二级索引中保存的“行指针”的实质。<strong>二级索引叶子节点保存的不是指向行的物理位置的指针，而是行的主键值。</strong>这意味着<strong>通过二级索引查找行，存储引擎需要找到二级索引的叶子节点获得对应的主键值，然后根据这个值去聚簇索引中查找到对应的行。</strong>对于InnoDB自适应哈希索引可以减少这样的重复工作。</li>
</ul>
</blockquote>
<p>在InnoDB和MyISAM中，对于聚簇索引和非聚簇索引的实现有区别，所以就以下表为例对比二者的区别：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> layout_test(</span><br><span class="line">	col1 <span class="built_in">int</span> <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">	col2 <span class="built_in">int</span> <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">	PRIMARY <span class="keyword">KEY</span>(col1),</span><br><span class="line">	<span class="keyword">KEY</span>(col2)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>假设该表的主键取值为1<del>10000，并且数据在磁盘上的存储方式已经最优，但行的顺序是随机的；列col2的值是从1</del>100之间随机复制，可能有很多重复值。</p>
<h3 id="MyISAM的数据分布"><a href="#MyISAM的数据分布" class="headerlink" title="MyISAM的数据分布"></a>MyISAM的数据分布</h3><p>MyISAM的数据分布非常简单，<strong>它按照数据插入的顺序存储在磁盘上</strong>，如图所示：<img src="/posts/28327/MyISAM%E8%81%9A%E7%B0%87%E7%B4%A2%E5%BC%95%E6%95%B0%E6%8D%AE%E5%88%86%E5%B8%83.png" alt>在行的旁边显示了行号，从0开始递增。因为行是定长的，索引MyISAM可以从表的开头跳过所需的字节知道需要的行。这种分布方式很容易创建索引，如图：<img src="/posts/28327/TIM%E6%88%AA%E5%9B%BE20190923193723.png" alt></p>
<p><strong>MyISAM中主键索引和其他索引在结构上没什么不同</strong>，因此列col2的索引分布和col1一样。<strong>主键索引就是一个名为PRIMARY的唯一非空索引。</strong></p>
<h3 id="InnoDB的数据分布"><a href="#InnoDB的数据分布" class="headerlink" title="InnoDB的数据分布"></a>InnoDB的数据分布</h3><p><img src="/posts/28327/InnoDB%E8%81%9A%E7%B0%87%E7%B4%A2%E5%BC%95%E4%B8%BB%E9%94%AE%E5%88%86%E5%B8%83.png" alt><br>可以看到该图显示了整张表，而不只有索引，因为在InnoDB中，聚簇索引就是表，所以不需要像MyISAM那样需要独立的行存储。<strong>聚簇索引的每一个叶子节点都包含了主键值、事务ID、用于事务和MVCC的回滚指针以及所有的剩余列。</strong></p>
<p>还有一点与MyISAM不同的是，InnoDB的二级索引和聚簇索引很不相同。<strong>InnoDB二级索引的叶子节点中存储的不是“行指针”，而是主键值，并以此作为指向行的“指针”。这样的好处就是减少了当出现行移动或者数据页分裂时二级索引的维护工作，因此InnoDB在移动行时无需更新二级索引的这个“指针”。</strong>下图是InnoDB中的二级索引分布：<img src="/posts/28327/InnoDB%E4%BA%8C%E7%BA%A7%E7%B4%A2%E5%BC%95%E5%88%86%E5%B8%83.png" alt></p>
<p>聚簇和非聚簇对比如图：<img src="/posts/28327/%E8%81%9A%E7%B0%87%E9%9D%9E%E8%81%9A%E7%B0%87%E5%AF%B9%E6%AF%94.png" alt></p>
<h3 id="在InnoDB表中按主键顺序插入行"><a href="#在InnoDB表中按主键顺序插入行" class="headerlink" title="在InnoDB表中按主键顺序插入行"></a>在InnoDB表中按主键顺序插入行</h3><p>如果正在使用的InnoDB表没有什么数据需要聚集，那么可以定义一个与数据无关的代理键作为主键，<strong>最简单方法就是使用AUTO_INCREMENT自增列，这样可以保证数据行是按顺序写入，对于根据主键做关联的性能也会更好。</strong>最好避免随机的聚簇索引，下面对比以自增的整数ID作为主键和以随机字符串UUID作为主键的情况。<img src="/posts/28327/InnoDB%E6%8F%92%E5%85%A5.png" alt><strong>可以注意到UUID主键插入不仅花费时间更长，而且索引占用的空间也更大。这一方面是由于主键字段更长，另一方面毫无疑问是因为页分裂和碎片导致的。</strong><br><img src="/posts/28327/%E5%90%91%E8%81%9A%E7%B0%87%E7%B4%A2%E5%BC%95%E6%8F%92%E5%85%A5%E9%A1%BA%E5%BA%8F%E7%9A%84%E7%B4%A2%E5%BC%95%E5%80%BC.png" alt>如图所示，因为主键的值是顺序的，所以InnoDB把每一条记录都存储在上一条记录的后面。当达到页的最大填充因子时（InnoDB默认的最大填充因子是页大小的15/19，留出部分空间用于以后修改），下一条记录就会写入新的页中。一旦数据按照这种顺序的方式加载，主键页就会近似于被顺序的记录填满，这也正是所期望的结果。</p>
<p><img src="/posts/28327/%E5%90%91%E8%81%9A%E7%B0%87%E7%B4%A2%E5%BC%95%E6%8F%92%E5%85%A5%E6%97%A0%E5%BA%8F%E5%80%BC.png" alt><br>但是对比使用UUID聚簇索引的表插入数据，<strong>因为新行的主键值不一定比之前的插入大，所以InnoDB无法简单的总是把新行插入到索引的最后，而是需要为新的行寻找合适的位置————通常是已有数据的中间位置————并且分配空间。这会增加很多的额外工作，并导致数据分布不够优化，</strong>下面是总结的一些缺点：</p>
<blockquote>
<ul>
<li>写入到目标页可能已经刷到磁盘上并从缓存中移除，或者是还没有被加载到缓存中，InnoDB再插入之前不得不先找到并从磁盘读取目标页到内存中，这将<strong>导致大量的随机I/O。</strong></li>
<li><strong>因为写入是乱序的，InnoDB不得不频繁的做分页操作，以便为新的行分配空间。页分裂会导致移动大量数据，一次插入最少需要修改三个页面而不是一个页面。</strong></li>
<li>由于频繁的页分裂，页会变得稀疏并被不规则地填充，所以<strong>最终数据会有碎片。</strong></li>
</ul>
</blockquote>
<p>所以总结结论就是，<strong>使用InnoDB时应该尽可能的按主键顺序插入数据，并且尽可能地使用单调增加的聚簇键的值来插入新行。</strong></p>
<h2 id="索引覆盖"><a href="#索引覆盖" class="headerlink" title="索引覆盖"></a>索引覆盖</h2><p>索引确实是一种查找数据的高效方式，但是MySQL也可以使用索引来直接获取列的数据，这样就不再需要读取数据行。<strong>如果一个索引包含（或者说覆盖）所有需要的字段的值，我们就称之为“索引覆盖”。</strong>索引覆盖是非常有效的工具，能够极大地提高性能，如果查询只需要扫描索引而无需回表，会带来多少好处：</p>
<ul>
<li><strong>索引条目通常远小于数据行的大小，所以如果只需要读取索引，那MySQL就会极大的减少数据访问量。</strong>这对缓存的负载非常重要，因为这种情况下响应时间大部分花费在数据拷贝上。</li>
<li><strong>因为索引是按照列值的顺序存储的，所以对于I/O密集型的范围查找会比随机从磁盘读取每一行的I/O要少得多。</strong>对于MyISAM甚至可以通过OPTIMIZE命令使得索引完全顺序排列，这让简单的范围查询能完全顺序的索引访问。</li>
<li>一些存储引擎存储引擎入MyISAM在内存中只缓存索引，数据则依赖于操作系统来缓存，因此访问数据需要一次系统调用，所以这里<strong>减少了因调用系统导致的开销。</strong></li>
<li>由于InnoDB二级索引在叶子节点中保存了行的主键值，所以<strong>如果二级主键能够覆盖查询，则可以避免主键索引的二次查询。</strong></li>
</ul>
<p>不是所有类型的索引都可为成为覆盖索引，覆盖索引必须存储索引列的值，而哈希索引、空间索引和全文索引等都不存储索引列的值，所以<strong>MySQL只能使用B-Tree索引做覆盖索引。</strong>另外也不是所有的索引都支持覆盖索引。</p>
<p>当发起一个被索引覆盖的查询（也叫做索引覆盖查询）时，<strong>在EXPLAIN的Extra列可以看到“Using index”的信息。</strong>索引覆盖查询还有很多陷阱可能导致无法实现优化。<strong>MySQL查询优化器会在执行查询前判断是否有一个索引能进行覆盖。加入索引覆盖了WHERE条件中的字段，但是不是整个查询涉及的字段。如果条件为假，MySQL5.5及更早总是会回表获取数据行，尽管并不需要这一行且最终会被过滤掉。</strong></p>
<p>如下例子：<img src="/posts/28327/beforesql.png" alt><br>这里索引无法覆盖该查询，有两个原因：</p>
<blockquote>
<ul>
<li>没有任何索引能够覆盖这个查询，因为查询从表中选择了所有的列，而每一任何索引覆盖了所有列。</li>
<li>MySQL不能在索引中执行LIKE操作。这是底层存储引擎API的限制，MySQL5.5及更早版本只允许在索引中做简单比较操作。<strong>MySQL能在索引中做最左前缀匹配的LIKE比较，因为该操作可以转换为简单的比较操作，但是如果时通配符开头的LIKE查询，存储器引擎就无法做比较匹配。</strong></li>
</ul>
</blockquote>
<p>也有办法解决上面说的问题，需重写查询并巧妙的设计索引。先将索引拓展至覆盖三个数据列，然后按如下方式重写查询：<br><img src="/posts/28327/aftersql.png" alt><br><strong>这种方式叫做“延迟关联”，因为延迟了对列的访问。</strong>在查询的第一阶段MySQL可以使用覆盖索引，在FROM子句的子查询中找到匹配的prod_id，然后根据这些prod_id值在外层查询匹配获取需要的所有列值。虽无法完全使用覆盖查询，但总比不使用覆盖查询好。</p>
<p><strong>这样的优化效果取决于WHERE条件匹配返回的数据行。</strong><img src="/posts/28327/%E8%A6%86%E7%9B%96%E6%B5%8B%E8%AF%95.png" alt><br>在示例3中，因为索引过滤时符合第一个条件的结果集已经很小，所以子查询带来的成本反而比从表中直接提取完整行更高。</p>
<p>可以考虑更进一步优化InnoDB：InnoDB的二级索引的叶子节点都包含了主键的值，这意味着InnoDB的二级索引可以有效地利用这些“额外”的主键列来覆盖查询。</p>
<h2 id="使用索引扫描扫描来做排序"><a href="#使用索引扫描扫描来做排序" class="headerlink" title="使用索引扫描扫描来做排序"></a>使用索引扫描扫描来做排序</h2><p>MySQL有两种方式可以生成有序的结果：通过<strong>排序操作</strong>或者<strong>按索引顺序扫描</strong>。如果EXPLAIN出来的type列的值为“index”，则说明MySQL使用了索引扫描来做排序。扫描索引本身是很快的，但是如果索引不能覆盖所需的全部列，那就不得不每扫描一条索引记录都回表查询一次对应的行，这基本上都是随机I/O，因此按索引顺序读取数据的速度通常要比顺序地全表扫描。</p>
<p>MySQL可以使用同一个索引既满足排序又用于查找行，因此，如果可能，设计索引时应该尽可能地满足这两种任务。<strong>只有当索引的列顺序和ORDER BY子句的顺序完全一致，并且所有列的排序方向都一样时，MySQL才能使用索引来对结果做排序。**</strong>如果查询时需要关联多张表，则只有当ORDER BY子句引用的字段全部为第一个表时，才能使用索引来做排序<strong>，，ORDER BY子句和查找型查询的限制是一样的：</strong>需要满足索引的最左前缀的要求；否则MySQL都需要执行排序操作，而无法利用索引排序。<strong>有一种情况下ORDER BY子句可以不满足索引的最左前缀的要求：</strong>前导列为常量的时候。**如果WHERE子句或者JOIN子句种对这些列指定了常量，就可以弥补索引的不足。例如有如下表：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">(retal_date,inventory_id,customer_id):</span><br><span class="line"><span class="function">CREATE TABLE <span class="title">retal</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">	...</span></span></span><br><span class="line"><span class="function"><span class="params">	PRIMARY KEY (retal_id)</span>,</span></span><br><span class="line"><span class="function">	UNIQUE KEY <span class="title">retal_date</span><span class="params">(retal_date,inventory_id,customer_id)</span>,</span></span><br><span class="line"><span class="function">	KEY <span class="title">idx_fk_inverntory_id</span><span class="params">(inventory_id)</span>,</span></span><br><span class="line"><span class="function">	KEY <span class="title">idx_fk_customer_id</span><span class="params">(customer_id)</span>,</span></span><br><span class="line"><span class="function">	KEY <span class="title">idx_fk_staff_id</span><span class="params">(staff_id)</span>,</span></span><br><span class="line"><span class="function">	...</span></span><br><span class="line"><span class="function">)</span>;</span><br></pre></td></tr></table></figure>

<p>MySQL可以在使用retal_date索引为下面的查询做排序，从EXPLAIN中可以看到没有出现文件排序（filesort）操作：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">EXPLAIN</span> <span class="keyword">SELECT</span> retal_id,staff_id <span class="keyword">FROM</span> sakila.rental</span><br><span class="line">	<span class="keyword">WHERE</span> retal_date = <span class="string">'2005-05-25'</span></span><br><span class="line">	<span class="keyword">ORDER</span> <span class="keyword">BY</span> inventory_id,customer_id\G</span><br></pre></td></tr></table></figure>

<p>即使ORDER BY子句不满足索引的最左前缀要求，也可以用于查询查询排序，这是因为<strong>索引的第一列被指定为一个常数。</strong>还有更多可以使用索引做排序的查询示例。下面这个查询可以利用查询排序，是因为<strong>查询为索引的第一列提供了常量条件，而使用第二列进行排序，将两列组合在一起，就形成了索引的最左前缀</strong>：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">...WHERE retal_date = '2005-05-25' ORDER BY inventory_id DESC;</span><br></pre></td></tr></table></figure>

<p>下面这个查询也可以，<strong>因为ORDER BY使用的两列就是索引的最左前缀：</strong></p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">...WHERE retal_date &gt; '2005-05-25' ORDER BY retal_date,inventory_id;</span><br></pre></td></tr></table></figure>

<p>下面是一些不能使用索引做排序的查询：</p>
<ul>
<li>查询使用两种不同的排序方向，但是索引列都是正序排序的。</li>
<li>查询的ORDER BY子句中引用了一个不在索引中的列。</li>
<li>查询的WHERE 和ORDER BY中的列无法组合成索引的最左前缀。</li>
<li>查询在索引列的第一列上使范围条件，MySQL无法使用索引的其余列。</li>
<li>在某一列上有多个等于条件，对于排序来说，这也是一种范围查询。</li>
</ul>
<p>使用索引做排序的一个最重要的用法是当查询同时有ORDER BY和LIMIT子句的时候。</p>
<h2 id="压缩（前缀压缩）索引"><a href="#压缩（前缀压缩）索引" class="headerlink" title="压缩（前缀压缩）索引"></a>压缩（前缀压缩）索引</h2><p>MyISAM使用前缀压缩来减少索引的大小，从而让更多的索引可以放入内存中，这在某些情况下能极大的提高性能。<strong>默认只压缩字符串，也可以设置对整数压缩。</strong>MyISAM压缩每个索引块的方法是：<strong>先完全保存索引块中的第一个值，然后将其他值和第一个值进行比较得到相同前缀的字节数和剩余的不同后缀部分，把这部分存储起来即可。</strong>例如索引块中的第一个值是“perform”，第二个值是“performance”，那么这个值的前缀压缩后存储的是类似“7.ance”这样的形式，同样MyISAM对行指针也采用类似的前缀压缩方式。</p>
<p>压缩块使用更少的空间，代价是某些操作可能更慢。因为<strong>每个值的压缩前缀都依赖前面的值，所以MyISAM查找时无法在索引块使用二分查找而只能从头开始扫描</strong>。正序的扫描速度还不错，但是倒序就不是很好了。对于CPU密集型应用，因为扫描需要随机查找，压缩索引使得MyISAM在索引查找上要慢好几倍；但如果是I/O密集型应用，对某些查询带来的好处会比成本多很多。</p>
<h2 id="冗余和重复索引"><a href="#冗余和重复索引" class="headerlink" title="冗余和重复索引"></a>冗余和重复索引</h2><p>MySQL允许在相同列上创建多个索引，MySQL需要单独与维护重复的索引，并且优化器在优化查询的时候也需要逐个地进行考虑，这会影响性能。</p>
<p><strong>重复索引是指在相同的列上按照相同的顺序创建的相同类型的索引。</strong>应该避免这样创建重复索引。</p>
<p><strong>冗余索引和重复索引有一些不同。如果创建了索引（A，B），在创建索引（A）就是冗余索引，因为这是前一个索引的前缀索引。因此索引（A，B）也可以当作索引（A）来使用。但是如果再创建索引（B，A）则不是冗余索引，因为B不是索引（A，B）的最左前缀列。</strong></p>
<p>冗余索引通常发生在为表添加新索引的时候。例如，可能会增加一个新的索引（A,B）而不是扩展已有的索引（A），还有一种情况是将一个索引扩展为（A，ID），其中ID是主键，对于InnoDB来说主键列已经包含在二级索引中了，所以这也是冗余的。大多数情况下都不需要冗余索引，<strong>应该尽量扩展已有的索引而不是创建新索引。</strong>但也有时候出于性能方面考虑需要冗余索引，因为扩展已有的索引会太大导致影响性能。</p>
<p>有多个索引的缺点是索引成本更高，表中的索引越多插入速度会越慢，一般来说，增加新索引将导致INSERT、UPDATE、DELETE等操作速度变慢。解决冗余索引和重复索引的方法很简单，删除这些索引就可以。</p>
<h2 id="未使用的索引"><a href="#未使用的索引" class="headerlink" title="未使用的索引"></a>未使用的索引</h2><p>除了冗余索引和重复索引，可能还会有一些服务器永远不用的索引，这样的索引完全是累赘，建议考虑删除。</p>
<h2 id="索引和锁"><a href="#索引和锁" class="headerlink" title="索引和锁"></a>索引和锁</h2><p><strong>索引可以让查询锁定更少的行。</strong>InnoDB只有在访问行的时候才会对其进行加锁，而索引能够减少InnoDB访问的行数，从而减少锁的行数，但这只有当InnoDB在存储引擎层能够过滤掉索引不需要的行时才有效。</p>
<p>关于InnoDB、索引和锁有一些细节很少有人知道：<strong>InnoDB在二级索引上使用共享（读）锁，但访问主键索引需要排他（写）锁。这消除使用覆盖索引的可能性，并且使得SELECT FOR UPDATE比LOCK IN SHARE MODE或非锁定查询要慢的多。</strong></p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>在MySQL中，大多数情况下都会使用B-Tree索引。其他类型的索引大多只适用于特殊的目的。如果在合适的场景中，将大大提高查询的响应时间。在选择索引和编写利用这些索引的查询时有如下三个原则始终需要记住：</p>
<ul>
<li><strong>单行访问是很慢的。</strong>特别是在机械硬盘存储中，如果服务器从存储中读取一个数据块只是为了获取其中一行，那么就浪费了很多工作。最好读取的块中能包含尽可能多所需要的行。使用索引可以创建位置引用以提升效率。</li>
<li><strong>按顺序访问范围数据是很快的，</strong>这有两个原因：<strong>第一，I/O不需要多次磁盘寻道，所以比随机I/O要快很多；第二，如果服务器能够按需要顺序读取数据，那么就不再需要额外的排序操作，并且GROUP BY查询也无须再做排序和将行按组进行聚合计算了。</strong></li>
<li><strong>索引覆盖查询是很快的。</strong>如果一个索引包含了查询的所有列，那么存储引擎就不需要再回表查找行，这避免了大量的单行访问。</li>
</ul>

      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/posts/64582/" rel="next" title="Schema与数据类型优化">
                <i class="fa fa-chevron-left"></i> Schema与数据类型优化
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/posts/39035/" rel="prev" title="查询性能优化">
                查询性能优化 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>


  </div>


          </div>
          

  
    <div class="comments" id="gitalk-container">
    </div>

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/avatar.gif" alt="Potato">
            
              <p class="site-author-name" itemprop="name">Potato</p>
              <div class="site-description motion-element" itemprop="description">Although the road is endless and faraway, I still want to pursue the truth in the world.</div>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives">
                
                    <span class="site-state-item-count">36</span>
                    <span class="site-state-item-name">日志</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-categories">
                  
                    
                      <a href="/categories/">
                    
                  
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">9</span>
                    <span class="site-state-item-name">分类</span>
                  </a>
                </div>
              

              
            </nav>
          

          
            <div class="feed-link motion-element">
              <a href="/atom.xml" rel="alternate">
                <i class="fa fa-rss"></i>
                RSS
              </a>
            </div>
          

          

          
            <div class="links-of-author motion-element">
              
                <span class="links-of-author-item">
                  
                  
                    
                  
                  
                    
                  
                  <a href="https://github.com/Potato-xupt" title="GitHub &rarr; https://github.com/Potato-xupt" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
                </span>
              
                <span class="links-of-author-item">
                  
                  
                    
                  
                  
                    
                  
                  <a href="mailto:401242993@qq.com" title="E-Mail &rarr; mailto:401242993@qq.com" rel="noopener" target="_blank"><i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                </span>
              
            </div>
          

          

          
          

          
            
          
          

        </div>
      </div>

      
      <!--noindex-->
        <div class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
            
            
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#索引基础"><span class="nav-number">1.</span> <span class="nav-text">索引基础</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#索引的类型"><span class="nav-number">1.1.</span> <span class="nav-text">索引的类型</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#B-Tree索引"><span class="nav-number">1.1.1.</span> <span class="nav-text">B-Tree索引</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#哈希索引"><span class="nav-number">1.1.2.</span> <span class="nav-text">哈希索引</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#其他索引"><span class="nav-number">1.1.3.</span> <span class="nav-text">其他索引</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#索引的优点"><span class="nav-number">2.</span> <span class="nav-text">索引的优点</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#高性能的索引策略"><span class="nav-number">3.</span> <span class="nav-text">高性能的索引策略</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#独立的列"><span class="nav-number">3.1.</span> <span class="nav-text">独立的列</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#前缀索引和索引选择性"><span class="nav-number">3.2.</span> <span class="nav-text">前缀索引和索引选择性</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#多列索引"><span class="nav-number">3.3.</span> <span class="nav-text">多列索引</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#选择合适的索引列顺序"><span class="nav-number">3.4.</span> <span class="nav-text">选择合适的索引列顺序</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#聚簇索引"><span class="nav-number">3.5.</span> <span class="nav-text">聚簇索引</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#MyISAM的数据分布"><span class="nav-number">3.5.1.</span> <span class="nav-text">MyISAM的数据分布</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#InnoDB的数据分布"><span class="nav-number">3.5.2.</span> <span class="nav-text">InnoDB的数据分布</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#在InnoDB表中按主键顺序插入行"><span class="nav-number">3.5.3.</span> <span class="nav-text">在InnoDB表中按主键顺序插入行</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#索引覆盖"><span class="nav-number">3.6.</span> <span class="nav-text">索引覆盖</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#使用索引扫描扫描来做排序"><span class="nav-number">3.7.</span> <span class="nav-text">使用索引扫描扫描来做排序</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#压缩（前缀压缩）索引"><span class="nav-number">3.8.</span> <span class="nav-text">压缩（前缀压缩）索引</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#冗余和重复索引"><span class="nav-number">3.9.</span> <span class="nav-text">冗余和重复索引</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#未使用的索引"><span class="nav-number">3.10.</span> <span class="nav-text">未使用的索引</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#索引和锁"><span class="nav-number">3.11.</span> <span class="nav-text">索引和锁</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#总结"><span class="nav-number">4.</span> <span class="nav-text">总结</span></a></li></ol></div>
            

          </div>
        </div>
      <!--/noindex-->
      

      

    </div>
  </aside>
  
    <div id="sidebar-dimmer"></div>
  


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Potato</span>

  

  
</div>







<div>
<script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<span id="busuanzi_container_site_pv" style="display:none">
    本站总访问量 <span id="busuanzi_value_site_pv"></span> 次
    <span class="post-meta-divider">|</span>
</span>
<span id="busuanzi_container_site_uv" style="display:none">
    有<span id="busuanzi_value_site_uv"></span>人看过我的博客啦
</span>
</div>



        








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

    

    
  </div>

  

<script>
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


























  
  <script src="/lib/jquery/index.js?v=3.4.1"></script>

  
  <script src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>


  


  <script src="/js/utils.js?v=7.2.0"></script>

  <script src="/js/motion.js?v=7.2.0"></script>



  
  


  <script src="/js/affix.js?v=7.2.0"></script>

  <script src="/js/schemes/pisces.js?v=7.2.0"></script>



  
  <script src="/js/scrollspy.js?v=7.2.0"></script>
<script src="/js/post-details.js?v=7.2.0"></script>



  


  <script src="/js/next-boot.js?v=7.2.0"></script>


  
  <script src="/js/js.cookie.js?v=7.2.0"></script>
  <script src="/js/scroll-cookie.js?v=7.2.0"></script>


  

  

  


  
    

<script src="//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js"></script>



<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.css">



<script src="//cdn.jsdelivr.net/npm/js-md5@0.7.3/src/md5.min.js"></script>

<script>
  var gitalk = new Gitalk({
    clientID: '9b0c87d3c176c7c8ae2f',
    clientSecret: 'c1a521ad426a42ab0a65b5d65a33e27303274435',
    repo: 'comments',
    owner: 'Potato-xupt',
    admin: ['Potato-xupt'],
    id: md5(location.pathname),
    
      language: window.navigator.language || window.navigator.userLanguage,
    
    distractionFreeMode: 'true'
  });
  gitalk.render('gitalk-container');
</script>

  


  
  <script>
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url).replace(/\/{2,}/g, '/');
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x"></i></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x"></i></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  

  

  

  

  

  

  

  

  

  

  

  

</body>
</html>
