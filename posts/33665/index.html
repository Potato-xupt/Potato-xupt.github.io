<!DOCTYPE html>












  


<html class="theme-next pisces use-motion" lang="zh-CN">
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">






















<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css?v=4.7.0">

<link rel="stylesheet" href="/css/main.css?v=7.2.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/favicon.ico?v=7.2.0">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.ico?v=7.2.0">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon.ico?v=7.2.0">


  <link rel="mask-icon" href="/images/logo.svg?v=7.2.0" color="#222">







<script id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '7.2.0',
    sidebar: {"position":"left","width":250,"display":"post","offset":12,"onmobile":true,"dimmer":true},
    back2top: true,
    back2top_sidebar: false,
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta name="description" content="对Java集合中比较常用的一个容器：ArrayList的源码进行分析，相比来说ArrayList的源码还是比较容易阅读的。">
<meta name="keywords" content="java,容器,源码">
<meta property="og:type" content="article">
<meta property="og:title" content="ArrayList源码阅读">
<meta property="og:url" content="http://yoursite.com/posts/33665/index.html">
<meta property="og:site_name" content="Potato Blog">
<meta property="og:description" content="对Java集合中比较常用的一个容器：ArrayList的源码进行分析，相比来说ArrayList的源码还是比较容易阅读的。">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="http://yoursite.com/posts/33665/ArrayListDataStructure.jpg">
<meta property="og:updated_time" content="2019-08-24T17:48:25.911Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="ArrayList源码阅读">
<meta name="twitter:description" content="对Java集合中比较常用的一个容器：ArrayList的源码进行分析，相比来说ArrayList的源码还是比较容易阅读的。">
<meta name="twitter:image" content="http://yoursite.com/posts/33665/ArrayListDataStructure.jpg">



  <link rel="alternate" href="/atom.xml" title="Potato Blog" type="application/atom+xml">



  
  
  <link rel="canonical" href="http://yoursite.com/posts/33665/">



<script id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>ArrayList源码阅读 | Potato Blog</title>
  












  <noscript>
  <style>
  .use-motion .motion-element,
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-title { opacity: initial; }

  .use-motion .logo,
  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Potato Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
      
        <p class="site-subtitle">李土豆的Blog</p>
      
    
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home">

    
    
      
    

    
      
    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br>首页</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-categories">

    
    
      
    

    
      
    

    <a href="/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i> <br>分类<span class="badge">2</span></a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-tags">

    
    
      
    

    
      
    

    <a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i> <br>标签<span class="badge">4</span></a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-about">

    
    
      
    

    
      
    

    <a href="/about/" rel="section"><i class="menu-item-icon fa fa-fw fa-user"></i> <br>关于我</a>

  </li>

      
      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br>搜索</a>
        </li>
      
    </ul>
  

  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off" placeholder="搜索..." spellcheck="false" type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



  



</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
            

          
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
    
  
  

  

  <article class="post post-type-normal true" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/posts/33665/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Potato">
      <meta itemprop="description" content="Although the road is endless and faraway, I still want to pursue the truth in the world.">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Potato Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">ArrayList源码阅读

              
            
          </h1>
        

        <div class="post-meta">

          
          
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-08-06 19:57:45" itemprop="dateCreated datePublished" datetime="2019-08-06T19:57:45+08:00">2019-08-06</time>
            </span>
          

          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-08-25 01:48:25" itemprop="dateModified" datetime="2019-08-25T01:48:25+08:00">2019-08-25</time>
              </span>
            
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Java容器/" itemprop="url" rel="index"><span itemprop="name">Java容器</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          
		  
		  

          <br>
          

          

          
            <div class="post-description">对Java集合中比较常用的一个容器：ArrayList的源码进行分析，相比来说ArrayList的源码还是比较容易阅读的。</div>
          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="ArrayList的数据结构"><a href="#ArrayList的数据结构" class="headerlink" title="ArrayList的数据结构"></a>ArrayList的数据结构</h1><p>ArrayList往往被人用来与LinkedList对比，它们俩最重要的差异之一就是：ArrayList的底层是由数组组成的，而LinkedList的底层则是由链表组成，对于LinkedList不再多赘述，具体可以看一下LinkedList的文章。回到ArrayList中来，其实现的数据结构是一个名为elementData的Object数组，可以存放所有Object对象，因此我们对ArrayList类的实例的所有的操作底层都是基于这个数组的。<br><img src="/posts/33665/ArrayListDataStructure.jpg" alt></p>
<h1 id="顶部注释"><a href="#顶部注释" class="headerlink" title="顶部注释"></a>顶部注释</h1><blockquote>
<p>List接口的可调整大小的数组实现。 实现所有可选列表操作，并允许所有元素，包括null 。 除了实现List接口之外，该类还提供了一些方法来处理内部用于存储列表的数组的大小。 （这个类大致相当于Vector ，除了它是不同步的。）<br>该size ， isEmpty ， get ， set ， iterator ，并listIterator操作在固定时间内运行。 add操作以摊销的常数运行 ，即添加n个元素需要O（n）个时间。 所有其他操作都以线性时间运行（粗略地说）。 与LinkedList实现相比，常数因子较低。 </p>
<p>每个ArrayList实例都有一个容量 。 容量是用于存储列表中的元素的数组的大小。 它总是至少与列表大小一样大。 当元素添加到ArrayList时，其容量会自动增长。 没有规定增长政策的细节，除了添加元素具有不变的摊销时间成本。 </p>
<p>在使用ensureCapacity操作添加大量元素之前，应用程序可以增加ArrayList实例的容量。 这可能会减少增量重新分配的数量。 </p>
<p>请注意，此实现不同步。 如果多个线程同时访问ArrayList实例，并且至少有一个线程在结构上修改列表，则必须在外部进行同步。 （结构修改是添加或删除一个或多个元素的任何操作，或明确调整后台数组的大小;仅设置元素的值不是结构修改。）这通常是通过在一些自然地封装了名单。 如果没有这样的对象存在，列表应该使用Collections.synchronizedList方法“包装”。 这最好在创建时完成，以防止意外的不同步访问列表： </p>
<p>List list = Collections.synchronizedList(new ArrayList(…)); 由这个类的iterator和listIterator方法返回的迭代器是故障快速的 ：如果列表在迭代器创建之后的任何时间被结构地修改，除了通过迭代器自己的remove或add方法之外，迭代器将抛出一个ConcurrentModificationException 。 因此，面对并发修改，迭代器将快速而干净地失败，而不是在未来未确定的时间冒着任意的非确定性行为。 </p>
<p>请注意，迭代器的故障快速行为无法保证，因为一般来说，在不同步并发修改的情况下，无法做出任何硬性保证。 失败快速的迭代器ConcurrentModificationException扔出ConcurrentModificationException 。 因此，编写依赖于此异常的程序的正确性将是错误的： 迭代器的故障快速行为应仅用于检测错误。 </p>
<p>这个类是Java Collections Framework的成员。 </p>
</blockquote>
<p>总结上面的顶部注释可以得到以下几点：</p>
<ul>
<li><strong>底部实现</strong>：可调整大小的数组实现的。</li>
<li><strong>是否允许null值</strong>：允许所有元素，包括null。</li>
<li><strong>是否是线程安全的</strong>：不是线程安全的。</li>
<li><strong>迭代器</strong>： 迭代器是fast-fail，但是迭代器的快速失败行为不能得到保证。</li>
<li><strong>运行时间</strong>：在get，set，size等操作中，都是以常数时间运行，而add操作需要O(n)时间运行。</li>
</ul>
<h1 id="ArrayList的定义"><a href="#ArrayList的定义" class="headerlink" title="ArrayList的定义"></a>ArrayList的定义</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayList</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractList</span>&lt;<span class="title">E</span>&gt; <span class="keyword">implements</span> <span class="title">List</span>&lt;<span class="title">E</span>&gt;, <span class="title">RandomAccess</span>, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span></span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>ArrayList<e></e></strong>：支持泛型的存储模式。</li>
<li><strong>extends AbstractList<e></e></strong>：继承于AbstractList，继承了其中的方法，方便操作。</li>
<li><strong>implements List<e></e></strong>：实现了List接口，与继承AbstractList作用相同，实现该接口提供的方法，方便了实现。但是据开发这个collection 的作者Josh说：这其实是一个mistake，因为他写这代码的时候觉得这个会有用处，但是其实并没什么用，但因为没什么影响，就一直留到了现在。</li>
<li><strong>implements RandomAccess</strong>：实现了RandomAccess接口，表明支持固定时间的快速随机访问，这也是其在get和set方法时已固定时间运行的原因</li>
<li><strong>implements Cloneable</strong>：实现了Cloneable接口，内部可以调用clone()方法来返回实例的浅拷贝(shallow copy)。</li>
<li><strong>implements Serializable</strong>：实现了Serializable接口，表明该类时可以序列化的。</li>
</ul>
<h1 id="静态全局变量"><a href="#静态全局变量" class="headerlink" title="静态全局变量"></a>静态全局变量</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 	默认的初始容量</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_CAPACITY = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    *	  用于空实例的共享空数组实例。</span></span><br><span class="line"><span class="comment">    *	 也就是说当传入的指定容量为0的时候建立数组。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 	共享空数组实例，用于默认大小的空实例。</span></span><br><span class="line"><span class="comment">    * 	我们将其与EMPTY_ELEMENTDATA区分开来，以了解添加第一个元素时应该膨胀多少。</span></span><br><span class="line"><span class="comment">    * 	当无指定的容量传入时，返回的数组。其与EMPTY_ELEMENTDATA的区别在于：</span></span><br><span class="line"><span class="comment">    * 	EMPTY_ELEMENTDATA是当传入的指定容量为时候返回的</span></span><br><span class="line"><span class="comment">    * 	DEFAULTCAPACITY_EMPTY_ELEMENTDATA是为传入指定容量参数时候返回的。 </span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 	存储ArrayList元素的数组缓冲区。</span></span><br><span class="line"><span class="comment">    * 	ArrayList的容量是这个数组缓冲区的长度。</span></span><br><span class="line"><span class="comment">    * 	当添加第一个元素时，任何带有elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA的空ArrayList都将扩展为DEFAULT_CAPACITY。</span></span><br><span class="line"><span class="comment">    * 	也就是底层用来存储元素的数组</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">transient</span> Object[] elementData; <span class="comment">// 非私有以简化嵌套类访问,这里是用来为subList方法使用的。</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 	ArrayList的大小(它包含的元素的数量)。</span></span><br><span class="line"><span class="comment">    * 	ArrayList中实际包含的元素的数量</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@serial</span></span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">int</span> size;</span><br><span class="line"></span><br><span class="line">       <span class="comment">/**</span></span><br><span class="line"><span class="comment">   	* 	最大可分配的数组大小，减去8是为了一些vm在数组中保留一些头信息。</span></span><br><span class="line"><span class="comment">   	* 	试图分配更大的数组可能会导致OutOfMemoryError:请求的数组大小超过VM限制</span></span><br><span class="line"><span class="comment">   	*/</span></span><br><span class="line">  	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_ARRAY_SIZE = Integer.MAX_VALUE - <span class="number">8</span>;</span><br></pre></td></tr></table></figure>

<h1 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h1><h2 id="指定初始容量"><a href="#指定初始容量" class="headerlink" title="指定初始容量"></a>指定初始容量</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    *	构造具有指定初始容量的空列表。</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span>  initialCapacity  列表的初始容量</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@throws</span> IllegalArgumentException 如果指定初始容量是负的       </span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">   	<span class="comment">/**</span></span><br><span class="line"><span class="comment">   	 * 如果指定的初始容量大于零，则创建一个指定初始容量大小的数组</span></span><br><span class="line"><span class="comment">   	 */</span></span><br><span class="line">       <span class="keyword">if</span> (initialCapacity &gt; <span class="number">0</span>) &#123;</span><br><span class="line">           <span class="keyword">this</span>.elementData = <span class="keyword">new</span> Object[initialCapacity];</span><br><span class="line">       &#125; <span class="keyword">else</span> <span class="keyword">if</span> (initialCapacity == <span class="number">0</span>) &#123;</span><br><span class="line">       	<span class="comment">/**</span></span><br><span class="line"><span class="comment">       	 * 如果指定的初始等于零，则使用空数组EMPTY_ELEMENTDATA</span></span><br><span class="line"><span class="comment">       	 */</span></span><br><span class="line">           <span class="keyword">this</span>.elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">       	<span class="comment">/**</span></span><br><span class="line"><span class="comment">       	 * 如果指定的初始为负数，抛出异常</span></span><br><span class="line"><span class="comment">       	 */</span></span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal Capacity: "</span>+</span><br><span class="line">                                              initialCapacity);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>如果传入的指定初始容量大于零，那就创建一个指定初始容量大小的数组用来存放数据</li>
<li>如果指定的初始等于零，则使用静态全局变量中的空数组EMPTY_ELEMENTDATA</li>
<li>如果指定的初始为负数，抛出异常</li>
</ul>
<h2 id="无指定初始容量"><a href="#无指定初始容量" class="headerlink" title="无指定初始容量"></a>无指定初始容量</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 	当无指定初始容量参数时，使用默认容量，构造一个初始容量为10的空列表。</span></span><br><span class="line"><span class="comment"> * 	但是其实在初始化后，此时的数组容量为0，当第一次存入数据时，才对这个空数组进行扩容，变为长度为10的数组</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="传入集合初始化"><a href="#传入集合初始化" class="headerlink" title="传入集合初始化"></a>传入集合初始化</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *	构造包含指定集合的元素的列表，按集合的迭代器返回元素的顺序排列。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> c 要将其元素放入此列表的集合</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> NullPointerException 如果指定的集合为空</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 把传入的集合转化为数组</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">    elementData = c.toArray();</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 判断传入的集合是否为空，如果为空则初始化为EMPTY_ELEMENTDATA数组，也就是等于指定初始容量为0时的情况</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> ((size = elementData.length) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 为了防止传入集合转型后的数组的类型不是Object类型，所以在这里进行验证</span></span><br><span class="line">        <span class="comment">// 如果不是Object类型，则使用Arrays.copyOf()的方法重新拷贝成Object[].class类型</span></span><br><span class="line">        <span class="keyword">if</span> (elementData.getClass() != Object[].class)</span><br><span class="line">            elementData = Arrays.copyOf(elementData, size, Object[].class);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 用空数组替换。</span></span><br><span class="line">        <span class="keyword">this</span>.elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="核心方法"><a href="#核心方法" class="headerlink" title="核心方法"></a>核心方法</h1><h2 id="trimToSize-方法"><a href="#trimToSize-方法" class="headerlink" title="trimToSize 方法"></a>trimToSize 方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 修改此ArrayList实例的容量成为列表的当前大小。 应用程序可以使用此操作来最小化ArrayList实例的存储。 </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">trimToSize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 因为是对结构进行了修改，所以modCount加一次</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 如果当前数组中的元素数量小于数组长度，就对数组进行修改</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (size &lt; elementData.length) &#123;</span><br><span class="line">    	<span class="comment">/**</span></span><br><span class="line"><span class="comment">    	 * 如果数组中的元素数量为0，则把数组变为EMPTY_ELEMENTDATA</span></span><br><span class="line"><span class="comment">    	 * 如果数组中的元素数量不为0，则把当前数组中的所有元素拷贝到一个新的数组，数组长度为元素的数量</span></span><br><span class="line"><span class="comment">    	 */</span></span><br><span class="line">        elementData = (size == <span class="number">0</span>)</span><br><span class="line">          ? EMPTY_ELEMENTDATA</span><br><span class="line">          : Arrays.copyOf(elementData, size);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该方法用于回收多余的内存。也就是说一旦我们确定集合不在添加多余的元素之后，调用 trimToSize() 方法会将实现集合的数组大小刚好调整为集合元素的大小。<br>注意：该方法会花时间来复制数组元素，所以应该在确定不会添加元素之后在调用。</p>
<h2 id="ensureCapacity-方法"><a href="#ensureCapacity-方法" class="headerlink" title="ensureCapacity 方法"></a>ensureCapacity 方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 如果需要，增加此 ArrayList实例的容量，以确保它至少能够容纳最小容量参数指定的元素数。 </span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> minCapacity 所需的最小容量 </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ensureCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 先判断是否满足增加容量的条件：</span></span><br><span class="line"><span class="comment">	 * 1.新的容量大于当前数组的长度，不然没有必要扩容</span></span><br><span class="line"><span class="comment">	 * 2.数组中有数据，或者数组中没有数据并且新的容量大于默认的容量长度</span></span><br><span class="line"><span class="comment">	 * 满足上面的两个条件后，modCount加一，然后调用grow方法进行数组的扩容和复制</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">    <span class="keyword">if</span> (minCapacity &gt; elementData.length</span><br><span class="line">        &amp;&amp; !(elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA</span><br><span class="line">             &amp;&amp; minCapacity &lt;= DEFAULT_CAPACITY)) &#123;</span><br><span class="line">        modCount++;</span><br><span class="line">        grow(minCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="grow-方法"><a href="#grow-方法" class="headerlink" title="grow 方法"></a>grow 方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 增加容量，以确保它至少可以容纳由最小容量参数指定的元素数目。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> minCapacity 所需的最小容量</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> OutOfMemoryError 如果minCapacity小于零</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> Object[] grow(<span class="keyword">int</span> minCapacity) &#123;</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 使用newCapacity方法获得新的合适的容量大小，因为minCapacity不一定时最合适的扩容容量</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">    <span class="keyword">return</span> elementData = Arrays.copyOf(elementData,</span><br><span class="line">                                       newCapacity(minCapacity));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> Object[] grow() &#123;</span><br><span class="line">    <span class="keyword">return</span> grow(size + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="newCapacity-方法"><a href="#newCapacity-方法" class="headerlink" title="newCapacity 方法"></a>newCapacity 方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 返回至少与给定的最小容量相同大的容量。返回当前容量增加50%(如果足够的话)。</span></span><br><span class="line"><span class="comment"> * 除非给定的最小容量大于MAX_ARRAY_SIZE，否则不会返回大于MAX_ARRAY_SIZE的容量。</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> minCapacity 所需的最小容量</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> OutOfMemoryError 如果minCapacity小于零</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">newCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 旧的容量是现在数组的长度</span></span><br><span class="line"><span class="comment">     * 默认的新的容量是旧容量的1.5倍</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">int</span> oldCapacity = elementData.length;</span><br><span class="line">    <span class="keyword">int</span> newCapacity = oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 如果传入的要求的最小容量（newCapacity）大于等于默认的新的容量，就进入if做边界条件的判断</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (newCapacity - minCapacity &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">    	<span class="comment">/**</span></span><br><span class="line"><span class="comment">    	 * 如果当前数组是空数组，这种情况下就是数组进行了初始化，但是没有放入任何数据，还是一个空数组，所以上面得到的oldCapacity和newCapacity都是0</span></span><br><span class="line"><span class="comment">    	 * 那么就取要求的最小容量和默认容量（16）二者中较大的那个进行扩容。</span></span><br><span class="line"><span class="comment">    	 */</span></span><br><span class="line">        <span class="keyword">if</span> (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA)</span><br><span class="line">            <span class="keyword">return</span> Math.max(DEFAULT_CAPACITY, minCapacity);</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">    	 * 因为上面的if判断的是 &lt;= 的情况，所以有可能传入的 minCapacity是负数</span></span><br><span class="line"><span class="comment">    	 */</span></span><br><span class="line">        <span class="keyword">if</span> (minCapacity &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> OutOfMemoryError();</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 边界没有溢出的话，就扩大为minCapacity</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">return</span> minCapacity;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 如果传入的要求的最小容量（newCapacity）小于默认的新的容量，就不使用传入的minCapacity</span></span><br><span class="line"><span class="comment">     * 如果默认的新的容量小于数组最大容量Integer.MAX_VALUE-8，那么就使用它，也就是数组扩容1.5倍</span></span><br><span class="line"><span class="comment">     * 但是如果大于数组最大容量Integer.MAX_VALUE-8，就尝试使用minCapacity，进入hugeCapacity函数判断</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">return</span> (newCapacity - MAX_ARRAY_SIZE &lt;= <span class="number">0</span>)</span><br><span class="line">        ? newCapacity</span><br><span class="line">        : hugeCapacity(minCapacity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">hugeCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (minCapacity &lt; <span class="number">0</span>) <span class="comment">// 溢出</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> OutOfMemoryError();</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 如果newCapacity大于数组最大容量Integer.MAX_VALUE-8，但是minCapacity没有，就使用Integer.MAX_VALUE-8</span></span><br><span class="line"><span class="comment">     * 但是如果newCapacity和minCapacity都大于了Integer.MAX_VALUE-8的话，就把数组扩容为Integer.MAX_VALUE</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">return</span> (minCapacity &gt; MAX_ARRAY_SIZE)</span><br><span class="line">        ? Integer.MAX_VALUE</span><br><span class="line">        : MAX_ARRAY_SIZE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结来说，对于数组容量扩容过程如下：</p>
<ol>
<li>先确定三个变量：传入的所需的最小容量（minCapacity），旧容量（oldCapacity）也就是当前现在数组的长度，默认的新的容量（newCapacity）是旧容量的1.5倍。</li>
<li>对比minCapacity和newCapacity，如果对比minCapacity大于等于（&gt;=）newCapacity,那么进入3，否则进入5。</li>
<li>如果elementData是只进行初始化，但是还没有存入数据的数组，那么它的长度肯定是0，所以这种情况下上面得到的oldCapacity和newCapacity是0，因此取默认初始容量（16）和minCapacity中的较大值，作为扩容后的容量。否则进入4。</li>
<li>判断如果传入的minCapacity是负数，那么抛出异常。否则将其作为扩容后的容量。</li>
<li>如果newCapacity小于等于MAX_ARRAY_SIZE（Integer.MAX_VALUE-8），那么newCapacity就是扩容大小，也就是扩容1.5倍。否则进行6。</li>
<li>如果newCapacity大于minCapacity，但是minCapacity其实是负数，那么直接抛出异常。否则再次判断minCapacity与MAX_ARRAY_SIZE的大小关系，如果minCapacity也大于MAX_ARRAY_SIZE，那么newCapacity和minCapacity都大于了MAX_ARRAY_SIZE，就把数组扩容为Integer.MAX_VALUE。否则进行7。</li>
<li>否则就只有newCapacity大于MAX_ARRAY_SIZE，而minCapacity小于等于MAX_ARRAY_SIZE，则数组扩容为MAX_ARRAY_SIZE。</li>
</ol>
<h2 id="size-方法"><a href="#size-方法" class="headerlink" title="size 方法"></a>size 方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 以常数时间返回此列表中的元素数量。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 列表中元素的数量</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> size;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="isEmpty-方法"><a href="#isEmpty-方法" class="headerlink" title="isEmpty 方法"></a>isEmpty 方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 如果此列表不包含任何元素，则返回true。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; 如果此列表不包含任何元素</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> size == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="contains-方法"><a href="#contains-方法" class="headerlink" title="contains 方法"></a>contains 方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 如果此列表包含指定的元素，则返回true 。</span></span><br><span class="line"><span class="comment"> * 更正式地说，返回true当且仅当此列表包含至少一个元素e这样Objects.equals(o, e) 。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> o 其在此列表中的存在性将被测试</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; 如果此列表包含指定的元素</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 实则调用了indexOf方法得到其下标，只需判断得到的下标是否小于零即可</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">    <span class="keyword">return</span> indexOf(o) &gt;= <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="indexOf-于-lastIndexOf-方法"><a href="#indexOf-于-lastIndexOf-方法" class="headerlink" title="indexOf 于 lastIndexOf 方法"></a>indexOf 于 lastIndexOf 方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 以常数时间返回此列表中指定元素的第一次出现的索引，如果此列表不包含元素，则返回-1。</span></span><br><span class="line"><span class="comment"> * 更正式地，返回最低下标i ，使得Objects.equals(o, get(i)) ，如果没有这样的下标则返回-1。 </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 如果要寻找的对象是null，那么就遍历数组，找第一个null的下标</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">    <span class="keyword">if</span> (o == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">            <span class="keyword">if</span> (elementData[i]==<span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    	<span class="comment">/**</span></span><br><span class="line"><span class="comment">    	 * 如果要寻找的对象非null，那么就遍历数组，找第一个为o的元素的下标</span></span><br><span class="line"><span class="comment">    	 */</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">            <span class="keyword">if</span> (o.equals(elementData[i]))</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 如果找不到的话，就返回-1</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 返回此列表中指定元素的最后一次出现的索引，如果此列表不包含元素，则返回-1。</span></span><br><span class="line"><span class="comment"> * 更正式地说，返回满足i这样Objects.equals(o, get(i)) ，如果没有这样的索引则返回-1。 </span></span><br><span class="line"><span class="comment"> * 搜索方法与indexOf相似，同为遍历整个数组，区别就是该方法从后向前寻找。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lastIndexOf</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (o == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = size-<span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">            <span class="keyword">if</span> (elementData[i]==<span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = size-<span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">            <span class="keyword">if</span> (o.equals(elementData[i]))</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该方法需要遍历整个数组，寻找对应的元素的下标，所以时间复杂度为O(N)。</p>
<h2 id="clone​-方法"><a href="#clone​-方法" class="headerlink" title="clone​ 方法"></a>clone​ 方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 返回此ArrayList实例的浅拷贝。（元素本身不被复制。） </span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 这个 ArrayList实例的克隆 </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">clone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">    	<span class="comment">/**</span></span><br><span class="line"><span class="comment">    	 * 调用AbstractList的clone方法得到一个ArrayList</span></span><br><span class="line"><span class="comment">    	 * 然后给这个v的elementData数组复制为当前数组，同时modCount重置为0</span></span><br><span class="line"><span class="comment">    	 * 返回这个ArrayList。</span></span><br><span class="line"><span class="comment">    	 */</span></span><br><span class="line">        ArrayList&lt;?&gt; v = (ArrayList&lt;?&gt;) <span class="keyword">super</span>.clone();</span><br><span class="line">        v.elementData = Arrays.copyOf(elementData, size);</span><br><span class="line">        v.modCount = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> v;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (CloneNotSupportedException e) &#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 这不应该发生，因为我们是可克隆的</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InternalError(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该方法只返回此ArrayList实例的浅拷贝，元素本身不被复制。</p>
<h2 id="toArray-方法"><a href="#toArray-方法" class="headerlink" title="toArray 方法"></a>toArray 方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 以正确的顺序（从第一个到最后一个元素）返回一个包含此列表中所有元素的数组。 </span></span><br><span class="line"><span class="comment"> * 返回的数组将是“安全的”，因为该列表不保留对它的引用。 （换句话说，这个方法必须分配一个新的数组）。</span></span><br><span class="line"><span class="comment"> * 因此，调用者可以自由地修改返回的数组。 </span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 此方法充当基于阵列和基于集合的API之间的桥梁。 </span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 一个包含该列表中所有元素的数组</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> Object[] toArray() &#123;</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 使用Arrays的copyOf拷贝elementData，得到并且返回一个新的数组。</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">    <span class="keyword">return</span> Arrays.copyOf(elementData, size);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 以正确的顺序返回一个包含此列表中所有元素的数组（从第一个到最后一个元素）; 返回的数组的运行时类型是指定数组的运行时类型。 </span></span><br><span class="line"><span class="comment"> * 如果列表适合指定的数组，则返回其中。 否则，将为指定数组的运行时类型和此列表的大小分配一个新数</span></span><br><span class="line"><span class="comment"> * 如果列表符合指定的数组，则有剩余空间（即数组的列表数量较多），则紧跟在集合结束后的数组中的元素设置为null 。 </span></span><br><span class="line"><span class="comment"> * （这仅在调用者知道列表不包含任何空元素的情况下才能确定列表的长度。） </span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> a 要存储列表的元素的数组，如果它足够大; 否则，为此目的分配相同运行时类型的新数组。 </span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 包含列表元素的数组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> ArrayStoreException 如果指定数组的运行时类型不是此列表中每个元素的运行时类型的超类型 </span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> NullPointerException 如果指定的数组为空</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; T[] toArray(T[] a) &#123;</span><br><span class="line">    <span class="keyword">if</span> (a.length &lt; size)</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 如果传入的数组的长度小于当前的元素数量，则创建一个新的数组a的运行时类型的数组，把elementData数组中的元素复制到该数组中。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">return</span> (T[]) Arrays.copyOf(elementData, size, a.getClass());</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 否则直接把elementData数组中的元素复制到该数组中。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    System.arraycopy(elementData, <span class="number">0</span>, a, <span class="number">0</span>, size);</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 如果传入数组长度大于元素数量，那么就把最后一个元素的后面的元素设置为null。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (a.length &gt; size)</span><br><span class="line">        a[size] = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>toArray 方法主要有两种方式，一种是无参方法，直接返回包含此列表中所有元素的数组；另一种是传入一个数组，然后把此列表中所有元素复制到该数组中，然后返回该数组。</p>
<h2 id="get-方法"><a href="#get-方法" class="headerlink" title="get 方法"></a>get 方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 因为底层是数组，所以以常数时间返回此列表中指定位置的元素。 </span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>  index 要返回的元素的索下标</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 该列表中指定位置的元素 </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IndexOutOfBoundsException  如果下标超出范围（ index &lt; 0 || index &gt;= size() ） </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Objects.checkIndex方法调用了Preconditions.checkIndex(index, length, null)检查下标是否超出范围</span></span><br><span class="line"><span class="comment">	 * Preconditions.checkIndex() 方法判断如果index &lt; 0 || index &gt;= size()，就抛出异常，否则返回传出的index。</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">    Objects.checkIndex(index, size);</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 如果下标满足要求，返回elementData数组中对应下标处的元素。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">return</span> elementData(index);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="set-方法"><a href="#set-方法" class="headerlink" title="set 方法"></a>set 方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 用指定的元素替换此列表中指定位置的元素。 </span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> index 要替换的元素的下标</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> element 要存储在指定位置的元素 </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 该元素以前在指定的位置 </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IndexOutOfBoundsException  如果索引超出范围（ index &lt; 0 || index &gt;= size() ） </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">set</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 同get方法一样，先判断下表是否越界，如果越阶就抛出异常。</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">    Objects.checkIndex(index, size);</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 记录下elementData数组中指定位置处的旧元素，用于返回。</span></span><br><span class="line"><span class="comment">     * 将elementData数组中指定位置处的元素设置为传入的元素，然后返回旧的元素</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    E oldValue = elementData(index);</span><br><span class="line">    elementData[index] = element;</span><br><span class="line">    <span class="keyword">return</span> oldValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="add-方法"><a href="#add-方法" class="headerlink" title="add 方法"></a>add 方法</h2><h3 id="将指定的元素追加到此列表的末尾"><a href="#将指定的元素追加到此列表的末尾" class="headerlink" title="将指定的元素追加到此列表的末尾"></a>将指定的元素追加到此列表的末尾</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 以常数时间，将指定的元素追加到此列表的末尾。 </span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> e 要附加到此列表的元素 </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; (由 Collection.add(E)指定)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 因为往数组中添加元素，所以结构发生了改变，因此modCount加一</span></span><br><span class="line"><span class="comment">	 * 调用内部的add方法添加元素，add方法见下面。</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">    modCount++;</span><br><span class="line">    add(e, elementData, size);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="内部的add方法添加元素"><a href="#内部的add方法添加元素" class="headerlink" title="内部的add方法添加元素"></a>内部的add方法添加元素</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 这个helper方法从add(E)中分离出来，以将方法字节码大小保持在35以下(-XX:MaxInlineSize默认值)，这有助于在c1编译的循环中调用add(E)。</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(E e, Object[] elementData, <span class="keyword">int</span> s)</span> </span>&#123;</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 先判断数组中的元素数量是否达到了数组长度</span></span><br><span class="line"><span class="comment">	 * 如果达到，则对数组进行扩容，扩容大小是原数组长度的1.5倍</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">    <span class="keyword">if</span> (s == elementData.length)</span><br><span class="line">        elementData = grow();</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 然后将传入的元素添加到数组尾部，元素数量加一</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    elementData[s] = e;</span><br><span class="line">    size = s + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="在指定位置插入指定的元素"><a href="#在指定位置插入指定的元素" class="headerlink" title="在指定位置插入指定的元素"></a>在指定位置插入指定的元素</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 以O(N)的时间，在此列表中的指定位置插入指定的元素。 </span></span><br><span class="line"><span class="comment"> * 将当前位于该位置的元素（如果有）和任何后续元素（向其索引添加一个）移动。 </span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> index  要在其中插入指定元素的下标 </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> element 要插入的元素 </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IndexOutOfBoundsException  如果索引超出范围（ index &lt; 0 || index &gt; size() ） </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * rangeCheckForAdd方法见下面；</span></span><br><span class="line"><span class="comment">	 * 同样把数组修改次数加一；</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">    rangeCheckForAdd(index);</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> s;</span><br><span class="line">    Object[] elementData;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 如果数组中的元素数量是否达到了数组长度，对数组进行扩容，扩容大小是原数组长度的1.5倍</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> ((s = size) == (elementData = <span class="keyword">this</span>.elementData).length)</span><br><span class="line">        elementData = grow();</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 然后将该index位置的元素和它后面的所有元素后移一位</span></span><br><span class="line"><span class="comment">     * 把index的位置空出来，然后将其赋值为传入的元素</span></span><br><span class="line"><span class="comment">     * 元素数量加一。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    System.arraycopy(elementData, index,</span><br><span class="line">                     elementData, index + <span class="number">1</span>,</span><br><span class="line">                     s - index);</span><br><span class="line">    elementData[index] = element;</span><br><span class="line">    size = s + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 由add和addAll使用的rangeCheck的一个版本。同为对下标范围的判断，本质与之前的checkIndex方法没什么区别。</span></span><br><span class="line"><span class="comment"> * 只是自己自定义了抛出异常的语句而已</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">rangeCheckForAdd</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (index &gt; size || index &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException(outOfBoundsMsg(index));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结来说，如果在指定位置插入指定的元素，因为要移动指定位置后面的所有元素，那么O(N)的时间；如果将指定的元素追加到此列表的末尾，那么仅花费常数的时间，但是如果数组需要扩容的话，将花费时间对数组进行扩容，所以尽量在初始化该List时就指定好容量大小。</p>
<h2 id="remove-方法"><a href="#remove-方法" class="headerlink" title="remove 方法"></a>remove 方法</h2><h3 id="删除指定位置的元素"><a href="#删除指定位置的元素" class="headerlink" title="删除指定位置的元素"></a>删除指定位置的元素</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 删除该列表中指定位置的元素。 将任何后续元素移动到左侧（从其索引中减去一个元素）。  </span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> index 要删除的元素的下标</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 从列表中删除的元素 </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IndexOutOfBoundsException 如果索引超出范围（ index &lt; 0 || index &gt;= size() ） </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 依旧先对下标范围进行检查</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">    Objects.checkIndex(index, size);</span><br><span class="line">    <span class="keyword">final</span> Object[] es = elementData;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 把旧的元素暂存下来，调用fastRemove方法把指定位置的元素删除，等删除后返回。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    E oldValue = (E) es[index];</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * fastRemove方法见下面</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    fastRemove(es, index);</span><br><span class="line">    <span class="keyword">return</span> oldValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="删除第一个出现的指定元素"><a href="#删除第一个出现的指定元素" class="headerlink" title="删除第一个出现的指定元素"></a>删除第一个出现的指定元素</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 从列表中删除第一个出现的指定元素（如果存在）。 </span></span><br><span class="line"><span class="comment"> * 如果列表不包含该元素，则它不会更改。</span></span><br><span class="line"><span class="comment"> * 更正式地，删除具有最低索引i的元素，使得Objects.equals(o, get(i)) （如果这样的元素存在）。</span></span><br><span class="line"><span class="comment"> *  如果此列表包含指定的元素（或等效地，如果此列表作为调用的结果而更改），则返回true 。 </span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> o 要从此列表中删除的元素（如果存在） </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; 如果此列表包含指定的元素</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Object[] es = elementData;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> size = <span class="keyword">this</span>.size;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    found: &#123;</span><br><span class="line">    	<span class="comment">/**</span></span><br><span class="line"><span class="comment">    	 * 遍历整个数组，查找指定元素o的下标，如果数组中不存在该元素，就直接返回false</span></span><br><span class="line"><span class="comment">    	 */</span></span><br><span class="line">        <span class="keyword">if</span> (o == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (; i &lt; size; i++)</span><br><span class="line">                <span class="keyword">if</span> (es[i] == <span class="keyword">null</span>)</span><br><span class="line">                    <span class="keyword">break</span> found;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (; i &lt; size; i++)</span><br><span class="line">                <span class="keyword">if</span> (o.equals(es[i]))</span><br><span class="line">                    <span class="keyword">break</span> found;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 找到该元素的下标后，调用fastRemove方法进行删除。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    fastRemove(es, i);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="fastRemove-方法"><a href="#fastRemove-方法" class="headerlink" title="fastRemove 方法"></a>fastRemove 方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 私有的remove方法，该方法跳过边界检查，并且不返回已删除的值。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">fastRemove</span><span class="params">(Object[] es, <span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 数组修改次数加一</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> newSize;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将指定元素第一次出现的下标后面的元素全部左移一位，等于将指定元素覆盖掉</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> ((newSize = size - <span class="number">1</span>) &gt; i)</span><br><span class="line">        System.arraycopy(es, i + <span class="number">1</span>, es, i, newSize - i);</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 然后将最后那个空出来的元素变赋值为null，同时size减小1</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    es[size = newSize] = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="clear-方法"><a href="#clear-方法" class="headerlink" title="clear 方法"></a>clear 方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 从列表中删除所有元素。 此呼叫返回后，列表将为空。 </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 数组修改次数加一</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="keyword">final</span> Object[] es = elementData;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 遍历整个数组，把所有下标置为null，同时size设置为0</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> to = size, i = size = <span class="number">0</span>; i &lt; to; i++)</span><br><span class="line">        es[i] = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="addAll-方法"><a href="#addAll-方法" class="headerlink" title="addAll 方法"></a>addAll 方法</h2><h3 id="将指定集合中的所有元素追加到列表的末尾"><a href="#将指定集合中的所有元素追加到列表的末尾" class="headerlink" title="将指定集合中的所有元素追加到列表的末尾"></a>将指定集合中的所有元素追加到列表的末尾</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 按指定集合的Iterator返回的顺序	。</span></span><br><span class="line"><span class="comment"> * 如果在操作进行中修改了指定的集合，则此操作的行为是不确定的。（这意味着如果指定的集合是此列表，则此调用的行为是不确定的，并且此列表是非空的。） </span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> c 包含要添加到此列表的元素的集合 </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; 如果此列表因调用而更改 </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> NullPointerException  如果指定的集合为空 </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">addAll</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 把传入的集合转化为数组，方便进行拷贝，同时修改次数加一</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">    Object[] a = c.toArray();</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 如果传入的集合中没有元素，那么此列表没有更改，因此返回false </span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">int</span> numNew = a.length;</span><br><span class="line">    <span class="keyword">if</span> (numNew == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    Object[] elementData;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> s;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * elementData.length- size 得到数组剩余的空闲空间，</span></span><br><span class="line"><span class="comment">     * 如果传入的集合长度numNew大于数组剩余的空闲空间，因此当前数组放不下传入的元素，所以要对数组进行扩容</span></span><br><span class="line"><span class="comment">     * 扩容的后的大小最小值为：当前元素数量加将要添加的元素数量</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (numNew &gt; (elementData = <span class="keyword">this</span>.elementData).length - (s = size))</span><br><span class="line">        elementData = grow(s + numNew);</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将传入的集合元素数组拷贝到列表数组的后面</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    System.arraycopy(a, <span class="number">0</span>, elementData, s, numNew);</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 元素数量加上传入的元素数量</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    size = s + numNew;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="从指定的位置开始，将指定集合中的所有元素插入到此列表中。"><a href="#从指定的位置开始，将指定集合中的所有元素插入到此列表中。" class="headerlink" title="从指定的位置开始，将指定集合中的所有元素插入到此列表中。"></a>从指定的位置开始，将指定集合中的所有元素插入到此列表中。</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 将指定集合中的所有元素插入到此列表中，从指定的位置开始。</span></span><br><span class="line"><span class="comment">    * 将当前位于该位置（如果有的话）的元素和随后的任何元素移动到右边（增加其索引）。</span></span><br><span class="line"><span class="comment">    * 新元素将按照指定集合的迭代器返回的顺序显示在列表中。 </span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> index 从中指定集合插入第一个元素的索引 </span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> c 包含要添加到此列表的元素的集合 </span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; 如果此列表因呼叫而更改</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@throws</span> IndexOutOfBoundsException 如果索引超出范围（ index &lt; 0 || index &gt; size() ）</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@throws</span> NullPointerException 如果指定的集合为空 </span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">addAll</span><span class="params">(<span class="keyword">int</span> index, Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">   	<span class="comment">/**</span></span><br><span class="line"><span class="comment">   	 * 使用自定义的方法对下标是否越界进行检查</span></span><br><span class="line"><span class="comment">   	 */</span></span><br><span class="line">       rangeCheckForAdd(index);</span><br><span class="line">       <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * 将传入的集合转化为数组，方便拷贝</span></span><br><span class="line"><span class="comment">        * 同时修改次数加一</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">       Object[] a = c.toArray();</span><br><span class="line">       modCount++;</span><br><span class="line">       <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * 如果传入的集合中没有元素，那么此列表没有更改，因此返回false </span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">       <span class="keyword">int</span> numNew = a.length;</span><br><span class="line">       <span class="keyword">if</span> (numNew == <span class="number">0</span>)</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">       Object[] elementData;</span><br><span class="line">       <span class="keyword">final</span> <span class="keyword">int</span> s;</span><br><span class="line">       <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * elementData.length- size 得到数组剩余的空闲空间，</span></span><br><span class="line"><span class="comment">        * 如果传入的集合长度numNew大于数组剩余的空闲空间，因此当前数组放不下传入的元素，所以要对数组进行扩容</span></span><br><span class="line"><span class="comment">        * 扩容的后的大小最小值为：当前元素数量加将要添加的元素数量</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">       <span class="keyword">if</span> (numNew &gt; (elementData = <span class="keyword">this</span>.elementData).length - (s = size))</span><br><span class="line">           elementData = grow(s + numNew);</span><br><span class="line">       <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * s - index 计算得到需要向右移动的元素的长度</span></span><br><span class="line"><span class="comment">        * 然后将其向右移动该长度</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">       <span class="keyword">int</span> numMoved = s - index;</span><br><span class="line">       <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)</span><br><span class="line">           System.arraycopy(elementData, index,</span><br><span class="line">                            elementData, index + numNew,</span><br><span class="line">                            numMoved);</span><br><span class="line">       <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * 把传入的集合中的元素拷贝到指定的位置，也就是上面数组向右移动后空出来的位置</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">       System.arraycopy(a, <span class="number">0</span>, elementData, index, numNew);</span><br><span class="line">       <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * 元素数量加上传入的集合中的元素数量</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">       size = s + numNew;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h2 id="removeAll-与-retainAll-方法"><a href="#removeAll-与-retainAll-方法" class="headerlink" title="removeAll 与 retainAll 方法"></a>removeAll 与 retainAll 方法</h2><h3 id="removeAll-方法"><a href="#removeAll-方法" class="headerlink" title="removeAll 方法"></a>removeAll 方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 从此列表中删除指定集合中包含的所有元素。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> c 包含要从此列表中删除的元素的集合 </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; 如果此列表因调用而更改</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> ClassCastException 如果此列表的元素的类与指定的集合不兼容（ 可选 ） </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> NullPointerException 如果此列表包含空元素，并且指定的集合不允许空元素（ 可选 ），或者如果指定的集合为空</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">removeAll</span><span class="params">(Collection&lt;?&gt; c)</span> </span>&#123;</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * batchRemove 方法见下面</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">    <span class="keyword">return</span> batchRemove(c, <span class="keyword">false</span>, <span class="number">0</span>, size);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="retainAll-方法"><a href="#retainAll-方法" class="headerlink" title="retainAll 方法"></a>retainAll 方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 仅保留此列表中包含在指定集合中的元素。 </span></span><br><span class="line"><span class="comment"> * 换句话说，从此列表中删除其中不包含在指定集合中的所有元素。</span></span><br><span class="line"><span class="comment"> * 本质就是求交集。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> c 包含要保留在此列表中的元素的集合</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; 如果此列表因调用而更改</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> ClassCastException 如果此列表的元素的类与指定的集合不兼容（ 可选 ） </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> NullPointerException 如果此列表包含空元素，并且指定的集合不允许空元素（ 可选 ），或者如果指定的集合为空</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">retainAll</span><span class="params">(Collection&lt;?&gt; c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> batchRemove(c, <span class="keyword">true</span>, <span class="number">0</span>, size);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="batchRemove-方法"><a href="#batchRemove-方法" class="headerlink" title="batchRemove 方法"></a>batchRemove 方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 对比removeAll和retainAll方法，同样都是调用了batchRemove方法，唯一的区别就是传入的complement参数</span></span><br><span class="line"><span class="comment"> * removeAll的参数是false，而retainAll方法传入的是true，所导致的结果则截然不同，所以这个complement是决定结果的关键</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">batchRemove</span><span class="params">(Collection&lt;?&gt; c, <span class="keyword">boolean</span> complement,</span></span></span><br><span class="line"><span class="function"><span class="params">           <span class="keyword">final</span> <span class="keyword">int</span> from, <span class="keyword">final</span> <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 该方法判断传入的集合c是否为null，如果是null则抛出异常，代码见下方</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	Objects.requireNonNull(c);</span><br><span class="line">	<span class="keyword">final</span> Object[] es = elementData;</span><br><span class="line">	<span class="keyword">int</span> r;</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 从头开始遍历数组，它的作用就是找到数组中第一个在集合c包含或者不包含的元素的位置，具体看下面</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">for</span> (r = from;; r++) &#123;</span><br><span class="line">		<span class="comment">/**</span></span><br><span class="line"><span class="comment">		 * 如果r走到了最后依旧没找到任何一个集合c中包含或者不包含的元素</span></span><br><span class="line"><span class="comment">		 * 那么数组将不会发生任何变化，返回false</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">if</span> (r == end)</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">		<span class="comment">/**</span></span><br><span class="line"><span class="comment">		 * 如果complement是false，那么在找到数组中第一个存在于集合c中的元素时，结束循环</span></span><br><span class="line"><span class="comment">		 * 如果complement是true，那么在找到数组中第一个不存在于集合c中的元素时，结束循环</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">if</span> (c.contains(es[r]) != complement)</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 看到w和r，顾名思义，w是write，r是read，也就是写和读，具体作用看下面就知道了</span></span><br><span class="line"><span class="comment">	 * 这里把r赋给了w，r加一</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">int</span> w = r++;</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		<span class="keyword">for</span> (Object e; r &lt; end; r++)</span><br><span class="line">			<span class="comment">/**</span></span><br><span class="line"><span class="comment">			 * 从上一次循环中，扎到数组中第一个存在/不存在于集合c中的元素的下标开始遍历</span></span><br><span class="line"><span class="comment">			 * </span></span><br><span class="line"><span class="comment">			 * 如果complement是false，那么在找到数组中一个不存在于集合c中的元素时，把他覆盖到刚刚找到的第一个存在于集合c中的元素的位置处</span></span><br><span class="line"><span class="comment">			 * 这里可能难以理解一点，可以这样想：</span></span><br><span class="line"><span class="comment">			 * 因为complement是false的情况是删除重复的元素嘛，所以用数组后面不重复的元素覆盖前面的元素，以此代替了删除。</span></span><br><span class="line"><span class="comment">			 * </span></span><br><span class="line"><span class="comment">			 * 同样如果complement是true，那么在找到数组中一个存在于集合c中的元素时，把他覆盖到刚刚找到的第一个不存在于集合c中的元素的位置处</span></span><br><span class="line"><span class="comment">			 */</span></span><br><span class="line">			<span class="keyword">if</span> (c.contains(e = es[r]) == complement)</span><br><span class="line">				es[w++] = e;</span><br><span class="line">	&#125; <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">		<span class="comment">/**</span></span><br><span class="line"><span class="comment">		 * 即使c.contains()抛出异常，也可以保持与AbstractCollection的兼容性</span></span><br><span class="line"><span class="comment">		 * 将已经覆盖的元素后面重复出来的元素删除掉</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		System.arraycopy(es, r, es, w, end - r);</span><br><span class="line">		w += end - r;</span><br><span class="line">		<span class="keyword">throw</span> ex;</span><br><span class="line">	&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">		<span class="comment">/**</span></span><br><span class="line"><span class="comment">		 * 修改此处对应增加改变的数量</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		modCount += end - w;</span><br><span class="line">		shiftTailOverGap(es, w, end);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">T <span class="title">requireNonNull</span><span class="params">(T obj)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (obj == <span class="keyword">null</span>)</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">       <span class="keyword">return</span> obj;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="comment">/**通过以下元素向下滑动，消除从lo到hi的间隔。 */</span></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">shiftTailOverGap</span><span class="params">(Object[] es, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi)</span> </span>&#123;</span><br><span class="line">       System.arraycopy(es, hi, es, lo, size - hi);</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> to = size, i = (size -= hi - lo); i &lt; to; i++)</span><br><span class="line">           es[i] = <span class="keyword">null</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>这里总结一下removeAll，retainAll和addAll方法之间的关系吧：</p>
<ul>
<li>removeAll 方法就是把存在于指定的集合中的元素全部删除掉，也就是求补集。</li>
<li>retainAll 方法就是把不存在于指定的集合中的元素全部删除掉，也就是求交集。</li>
<li>addAll 方法就把不存在于指定的集合中的元素全部添加到列表中，也就是求并集。</li>
</ul>
<h2 id="subList-方法"><a href="#subList-方法" class="headerlink" title="subList 方法"></a>subList 方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 返回指定的fromIndex （含）和toIndex之间的列表部分的视图。 （如果fromIndex和toIndex相等，返回的列表为空。）</span></span><br><span class="line"><span class="comment"> * 返回的列表由此列表支持，因此返回列表中的非结构更改将反映在此列表中，反之亦然。 返回的列表支持所有可选列表操作。 </span></span><br><span class="line"><span class="comment"> * 该方法消除了对显式范围操作（对于数组通常存在的排序）的需要。 </span></span><br><span class="line"><span class="comment"> * 任何期望列表的操作都可以通过传递一个子列表视图而不是整个列表来用作范围操作。 例如，以下成语从列表中移除了一系列元素： list.subList(from, to).clear();</span></span><br><span class="line"><span class="comment"> * 可以为indexOf(Object)和lastIndexOf(Object)构造类似的成语，并且可以将Collections类中的所有算法应用于子列表。 </span></span><br><span class="line"><span class="comment"> * 如果支持列表（即，此列表）以除了通过返回的列表之外的任何方式进行结构修改 ，则此方法返回的列表的语义将变为不正确。 </span></span><br><span class="line"><span class="comment"> * （结构修改是那些改变此列表的大小，或以其他方式扰乱它，使得正在进行的迭代可能产生不正确的结果）。</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 简单的来说，就是返回整个列表中，指定范围那部分的列表的视图。</span></span><br><span class="line"><span class="comment"> * 但是！！如果对返回的这部分列表进行修改，那么同时原列表的对应位置也会发生修改</span></span><br><span class="line"><span class="comment"> * 所以本质就是返回了一部分引用而已。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IndexOutOfBoundsException 如果端点索引值超出范围 (fromIndex &lt; 0 || toIndex &gt; size) </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IllegalArgumentException 如果端点索引不正确 (fromIndex &gt; toIndex) </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;E&gt; <span class="title">subList</span><span class="params">(<span class="keyword">int</span> fromIndex, <span class="keyword">int</span> toIndex)</span> </span>&#123;</span><br><span class="line">    subListRangeCheck(fromIndex, toIndex, size);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> SubList&lt;&gt;(<span class="keyword">this</span>, fromIndex, toIndex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所以总结来说，尽量不要使用subList方法，如果要使用的话，一定要注意下面几点使用方法：</p>
<ol>
<li>千万不要再对原 List 进行任何改动的操作(例如: 增删改), 查询和遍历倒是可以. 因为如果对原 List 进行了改动, 那么后续只要是涉及到子 List 的操作就一定会出问题. 而至于会出现什么问题呢? 具体来说就是:<br>(1) 如果是对原 List 进行修改 (即: 调用 set() 方法) 而不是增删, 那么子 List 的元素也可能会被修改 (这种情况下不会抛出并发修改异常).<br>(2) 如果是对原 List 进行增删, 那么此后只要操作了子 List , 就一定会抛出并发修改异常.</li>
<li>千万不要直接对子 List 进行任何改动的操作(例如: 增删改), 但是查询和间接改动倒是可以. 不要对子 List 进行直接改动, 是因为如果在对子 List 进行直接改动之前, 原 List 已经被改动过, 那么此后在对子 List 进行直接改动的时候就会抛出并发修改异常.</li>
<li>如果要进行操作，则使用例如：List<integer> subList = new ArrayList&lt;&gt;(list.subList(2, list.size()));  的方法，把分割出来的数组转化为一个新的列表，在新的列表基础上操作就不会对原列表产生任何影响。</integer></li>
</ol>
<h1 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h1><p>考虑一点：elementData设置成了transient，那ArrayList是怎么把元素序列化的呢？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">writeObject</span><span class="params">(java.io.ObjectOutputStream s)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> java.io.IOException</span>&#123;</span><br><span class="line">    <span class="comment">// 防止序列化期间有修改</span></span><br><span class="line">    <span class="keyword">int</span> expectedModCount = modCount;</span><br><span class="line">    <span class="comment">// 写出非transient非static属性（会写出size属性）</span></span><br><span class="line">    s.defaultWriteObject();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 写出元素个数</span></span><br><span class="line">    s.writeInt(size);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 依次写出元素</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;size; i++) &#123;</span><br><span class="line">        s.writeObject(elementData[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果有修改，抛出异常</span></span><br><span class="line">    <span class="keyword">if</span> (modCount != expectedModCount) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readObject</span><span class="params">(java.io.ObjectInputStream s)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> java.io.IOException, ClassNotFoundException </span>&#123;</span><br><span class="line">    <span class="comment">// 声明为空数组</span></span><br><span class="line">    elementData = EMPTY_ELEMENTDATA;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读入非transient非static属性（会读取size属性）</span></span><br><span class="line">    s.defaultReadObject();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读入元素个数，没什么用，只是因为写出的时候写了size属性，读的时候也要按顺序来读</span></span><br><span class="line">    s.readInt();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (size &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 计算容量</span></span><br><span class="line">        <span class="keyword">int</span> capacity = calculateCapacity(elementData, size);</span><br><span class="line">        SharedSecrets.getJavaOISAccess().checkArray(s, Object[].class, capacity);</span><br><span class="line">        <span class="comment">// 检查是否需要扩容</span></span><br><span class="line">        ensureCapacityInternal(size);</span><br><span class="line"></span><br><span class="line">        Object[] a = elementData;</span><br><span class="line">        <span class="comment">// 依次读取元素到数组中</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;size; i++) &#123;</span><br><span class="line">            a[i] = s.readObject();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>查看writeObject()方法可知，先调用s.defaultWriteObject()方法，再把size写入到流中，再把元素一个一个的写入到流中。</p>
<p>一般地，只要实现了Serializable接口即可自动序列化，writeObject()和readObject()是为了自己控制序列化的方式，这两个方法必须声明为private，在java.io.ObjectStreamClass#getPrivateMethod()方法中通过反射获取到writeObject()这个方法。</p>
<p>在ArrayList的writeObject()方法中先调用了s.defaultWriteObject()方法，这个方法是写入非static非transient的属性，在ArrayList中也就是size属性。同样地，在readObject()方法中先调用了s.defaultReadObject()方法解析出了size属性。</p>
<p>elementData定义为transient的优势，自己根据size序列化真实的元素，而不是根据数组的长度序列化元素，减少了空间占用。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ol>
<li>ArrayList内部使用数组存储元素，当数组长度不够时进行扩容，每次加一半的空间，ArrayList不会进行缩容；</li>
<li>ArrayList支持随机访问，通过索引访问元素极快，时间复杂度为O(1)；</li>
<li>ArrayList添加元素到尾部极快，平均时间复杂度为O(1)；</li>
<li>ArrayList添加元素到中间比较慢，因为要搬移元素，平均时间复杂度为O(n)；</li>
<li>ArrayList从尾部删除元素极快，时间复杂度为O(1)；</li>
<li>ArrayList从中间删除元素比较慢，因为要搬移元素，平均时间复杂度为O(n)；</li>
<li>ArrayList支持求并集，调用addAll(Collection&lt;? extends E&gt; c)方法即可；</li>
<li>ArrayList支持求交集，调用retainAll(Collection&lt;? extends E&gt; c)方法即可；</li>
<li>ArrayList支持求单向差集，调用removeAll(Collection&lt;? extends E&gt; c)方法即可；</li>
</ol>

      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      
        
          
        
        <div class="post-tags">
          
		  <!--# -->
            <a href="/tags/java/" rel="tag"><i class="fa fa-tag"></i> java</a>
          
		  <!--# -->
            <a href="/tags/容器/" rel="tag"><i class="fa fa-tag"></i> 容器</a>
          
		  <!--# -->
            <a href="/tags/源码/" rel="tag"><i class="fa fa-tag"></i> 源码</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/posts/42557/" rel="next" title="HashMap源码阅读">
                <i class="fa fa-chevron-left"></i> HashMap源码阅读
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/posts/35314/" rel="prev" title="Java内存区域">
                Java内存区域 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>


  </div>


          </div>
          

  
    <div class="comments" id="gitalk-container">
    </div>

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/avatar.gif" alt="Potato">
            
              <p class="site-author-name" itemprop="name">Potato</p>
              <div class="site-description motion-element" itemprop="description">Although the road is endless and faraway, I still want to pursue the truth in the world.</div>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives">
                
                    <span class="site-state-item-count">3</span>
                    <span class="site-state-item-name">日志</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-categories">
                  
                    
                      <a href="/categories/">
                    
                  
                    
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">2</span>
                    <span class="site-state-item-name">分类</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-tags">
                  
                    
                      <a href="/tags/">
                    
                  
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">4</span>
                    <span class="site-state-item-name">标签</span>
                  </a>
                </div>
              
            </nav>
          

          
            <div class="feed-link motion-element">
              <a href="/atom.xml" rel="alternate">
                <i class="fa fa-rss"></i>
                RSS
              </a>
            </div>
          

          

          
            <div class="links-of-author motion-element">
              
                <span class="links-of-author-item">
                  
                  
                    
                  
                  
                    
                  
                  <a href="https://github.com/Potato-xupt" title="GitHub &rarr; https://github.com/Potato-xupt" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
                </span>
              
                <span class="links-of-author-item">
                  
                  
                    
                  
                  
                    
                  
                  <a href="mailto:401242993@qq.com" title="E-Mail &rarr; mailto:401242993@qq.com" rel="noopener" target="_blank"><i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                </span>
              
            </div>
          

          

          
          

          
            
          
          

        </div>
      </div>

      
      <!--noindex-->
        <div class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
            
            
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#ArrayList的数据结构"><span class="nav-number">1.</span> <span class="nav-text">ArrayList的数据结构</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#顶部注释"><span class="nav-number">2.</span> <span class="nav-text">顶部注释</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#ArrayList的定义"><span class="nav-number">3.</span> <span class="nav-text">ArrayList的定义</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#静态全局变量"><span class="nav-number">4.</span> <span class="nav-text">静态全局变量</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#构造方法"><span class="nav-number">5.</span> <span class="nav-text">构造方法</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#指定初始容量"><span class="nav-number">5.1.</span> <span class="nav-text">指定初始容量</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#无指定初始容量"><span class="nav-number">5.2.</span> <span class="nav-text">无指定初始容量</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#传入集合初始化"><span class="nav-number">5.3.</span> <span class="nav-text">传入集合初始化</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#核心方法"><span class="nav-number">6.</span> <span class="nav-text">核心方法</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#trimToSize-方法"><span class="nav-number">6.1.</span> <span class="nav-text">trimToSize 方法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ensureCapacity-方法"><span class="nav-number">6.2.</span> <span class="nav-text">ensureCapacity 方法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#grow-方法"><span class="nav-number">6.3.</span> <span class="nav-text">grow 方法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#newCapacity-方法"><span class="nav-number">6.4.</span> <span class="nav-text">newCapacity 方法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#size-方法"><span class="nav-number">6.5.</span> <span class="nav-text">size 方法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#isEmpty-方法"><span class="nav-number">6.6.</span> <span class="nav-text">isEmpty 方法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#contains-方法"><span class="nav-number">6.7.</span> <span class="nav-text">contains 方法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#indexOf-于-lastIndexOf-方法"><span class="nav-number">6.8.</span> <span class="nav-text">indexOf 于 lastIndexOf 方法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#clone​-方法"><span class="nav-number">6.9.</span> <span class="nav-text">clone​ 方法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#toArray-方法"><span class="nav-number">6.10.</span> <span class="nav-text">toArray 方法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#get-方法"><span class="nav-number">6.11.</span> <span class="nav-text">get 方法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#set-方法"><span class="nav-number">6.12.</span> <span class="nav-text">set 方法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#add-方法"><span class="nav-number">6.13.</span> <span class="nav-text">add 方法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#将指定的元素追加到此列表的末尾"><span class="nav-number">6.13.1.</span> <span class="nav-text">将指定的元素追加到此列表的末尾</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#内部的add方法添加元素"><span class="nav-number">6.13.2.</span> <span class="nav-text">内部的add方法添加元素</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#在指定位置插入指定的元素"><span class="nav-number">6.13.3.</span> <span class="nav-text">在指定位置插入指定的元素</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#remove-方法"><span class="nav-number">6.14.</span> <span class="nav-text">remove 方法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#删除指定位置的元素"><span class="nav-number">6.14.1.</span> <span class="nav-text">删除指定位置的元素</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#删除第一个出现的指定元素"><span class="nav-number">6.14.2.</span> <span class="nav-text">删除第一个出现的指定元素</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#fastRemove-方法"><span class="nav-number">6.14.3.</span> <span class="nav-text">fastRemove 方法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#clear-方法"><span class="nav-number">6.15.</span> <span class="nav-text">clear 方法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#addAll-方法"><span class="nav-number">6.16.</span> <span class="nav-text">addAll 方法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#将指定集合中的所有元素追加到列表的末尾"><span class="nav-number">6.16.1.</span> <span class="nav-text">将指定集合中的所有元素追加到列表的末尾</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#从指定的位置开始，将指定集合中的所有元素插入到此列表中。"><span class="nav-number">6.16.2.</span> <span class="nav-text">从指定的位置开始，将指定集合中的所有元素插入到此列表中。</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#removeAll-与-retainAll-方法"><span class="nav-number">6.17.</span> <span class="nav-text">removeAll 与 retainAll 方法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#removeAll-方法"><span class="nav-number">6.17.1.</span> <span class="nav-text">removeAll 方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#retainAll-方法"><span class="nav-number">6.17.2.</span> <span class="nav-text">retainAll 方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#batchRemove-方法"><span class="nav-number">6.17.3.</span> <span class="nav-text">batchRemove 方法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#subList-方法"><span class="nav-number">6.18.</span> <span class="nav-text">subList 方法</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#补充"><span class="nav-number">7.</span> <span class="nav-text">补充</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#总结"><span class="nav-number">8.</span> <span class="nav-text">总结</span></a></li></ol></div>
            

          </div>
        </div>
      <!--/noindex-->
      

      

    </div>
  </aside>
  
    <div id="sidebar-dimmer"></div>
  


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Potato</span>

  

  
</div>







<div>
<script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<span id="busuanzi_container_site_pv" style="display:none">
    本站总访问量 <span id="busuanzi_value_site_pv"></span> 次
    <span class="post-meta-divider">|</span>
</span>
<span id="busuanzi_container_site_uv" style="display:none">
    有<span id="busuanzi_value_site_uv"></span>人看过我的博客啦
</span>
</div>



        








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

    

    
  </div>

  

<script>
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


























  
  <script src="/lib/jquery/index.js?v=3.4.1"></script>

  
  <script src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>


  


  <script src="/js/utils.js?v=7.2.0"></script>

  <script src="/js/motion.js?v=7.2.0"></script>



  
  


  <script src="/js/affix.js?v=7.2.0"></script>

  <script src="/js/schemes/pisces.js?v=7.2.0"></script>



  
  <script src="/js/scrollspy.js?v=7.2.0"></script>
<script src="/js/post-details.js?v=7.2.0"></script>



  


  <script src="/js/next-boot.js?v=7.2.0"></script>


  
  <script src="/js/js.cookie.js?v=7.2.0"></script>
  <script src="/js/scroll-cookie.js?v=7.2.0"></script>


  

  

  


  
    

<script src="//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js"></script>



<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.css">



<script src="//cdn.jsdelivr.net/npm/js-md5@0.7.3/src/md5.min.js"></script>

<script>
  var gitalk = new Gitalk({
    clientID: '9b0c87d3c176c7c8ae2f',
    clientSecret: 'c1a521ad426a42ab0a65b5d65a33e27303274435',
    repo: 'comments',
    owner: 'Potato-xupt',
    admin: ['Potato-xupt'],
    id: md5(location.pathname),
    
      language: window.navigator.language || window.navigator.userLanguage,
    
    distractionFreeMode: 'true'
  });
  gitalk.render('gitalk-container');
</script>

  


  
  <script>
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url).replace(/\/{2,}/g, '/');
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x"></i></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x"></i></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  

  

  

  

  

  

  

  

  

  

  

  

</body>
</html>
